{
    "run.py": {
        "parse_args": {
            "type": "FunctionDef",
            "name": "parse_args",
            "md_content": "",
            "code_start_line": 9,
            "code_end_line": 38,
            "parent": null,
            "have_return": true,
            "code_content": "def parse_args() -> argparse.Namespace:\n    \"\"\"\n    Parse the command line arguments and return them as an argparse.Namespace object.\n\n    Returns:\n        argparse.Namespace: An object containing command line arguments and their values.\n    \"\"\"\n    parser = argparse.ArgumentParser()\n\n    parser.add_argument(\"--task\", type=str, required=True, help=\"The task description.\")\n    parser.add_argument(\"--upload-files\", nargs='+', dest=\"upload_files\", help=\"List of files to upload.\")\n    parser.add_argument(\"--model\", type=str, help=\"Model identifier for the task.\")\n    parser.add_argument(\"--record-dir\", type=str, dest=\"record_dir\", help=\"Directory to record task execution logs.\")\n    parser.add_argument(\"--mode\", type=str, default=\"auto\", help=\"Operational mode: 'auto' or 'manual'.\")\n    parser.add_argument(\"--quiet\", action=\"store_true\", default=False, help=\"Run in quiet mode; minimal output.\")\n    parser.add_argument(\"--max-subtask-chain-length\", type=int, dest=\"max_subtask_chain_length\",\n                        help=\"Maximum length of subtask chain.\")\n    parser.add_argument(\"--enable-ask-human-for-help\", action=\"store_true\", dest=\"enable_ask_human_for_help\",\n                        help=\"Flag to enable asking for human assistance.\")\n    parser.add_argument(\"--max-plan-refine-chain-length\", type=int, dest=\"max_plan_refine_chain_length\",\n                        help=\"Maximum length of plan refinement chain.\")\n    parser.add_argument(\"--max-plan-tree-depth\", type=int, dest=\"max_plan_tree_depth\",\n                        help=\"Maximum depth of the plan tree.\")\n    parser.add_argument(\"--max-plan-tree-width\", type=int, dest=\"max_plan_tree_width\",\n                        help=\"Maximum width of the plan tree.\")\n    parser.add_argument(\"--max-retry-times\", type=int, dest=\"max_retry_times\", help=\"Maximum number of retry attempts.\")\n    parser.add_argument(\"--config-file\", type=str, default=os.getenv('CONFIG_FILE', 'assets/config.yml'),\n                        dest=\"config_file\", help=\"Path to the configuration file.\")\n\n    return parser.parse_args()\n",
            "name_column": 4
        },
        "execute_command_line_process": {
            "type": "FunctionDef",
            "name": "execute_command_line_process",
            "md_content": "",
            "code_start_line": 41,
            "code_end_line": 66,
            "parent": null,
            "have_return": false,
            "code_content": "def execute_command_line_process(args: argparse.Namespace, quiet_mode: bool = False) -> None:\n    \"\"\"\n    Execute the command line process based on the parsed arguments. If quiet mode is enabled,\n    redirect stdout to a file specified by the recorder's record_root_dir.\n\n    Args:\n        args (argparse.Namespace): Parsed command line arguments.\n        quiet_mode (bool): Whether to run in quiet mode, outputting to a file instead of the terminal.\n    \"\"\"\n    args_dict = vars(args)\n    for key, value in args_dict.items():\n        if value is not None:\n            if key == 'model':\n                ARGS['default_completion_kwargs'] = deepcopy(CONFIG['default_completion_kwargs'])\n                ARGS['default_completion_kwargs']['model'] = value\n            else:\n                ARGS[key] = value\n\n    # Redirect stdout to a file if quiet mode is true\n    if quiet_mode:\n        from XAgent.running_recorder import recorder\n        record_file_path = os.path.join(recorder.record_root_dir, \"command_line.ansi\")\n        with open(record_file_path, \"w\", encoding=\"utf-8\") as file, redirect_stdout(file):\n            start_command_line(args_dict)\n    else:\n        start_command_line(args_dict)\n",
            "name_column": 4
        },
        "start_command_line": {
            "type": "FunctionDef",
            "name": "start_command_line",
            "md_content": "",
            "code_start_line": 69,
            "code_end_line": 83,
            "parent": null,
            "have_return": false,
            "code_content": "def start_command_line(args_dict: dict) -> None:\n    \"\"\"\n    Start the command line interface with the provided arguments.\n\n    Args:\n        args_dict (dict): A dictionary of command line arguments.\n    \"\"\"\n    param = CommandLineParam(\n        task=args_dict['task'],\n        upload_files=args_dict.get('upload_files'),\n        role=\"Assistant\",\n        mode=args_dict[\"mode\"],\n    )\n    cmd = CommandLine(param)\n    cmd.start()\n",
            "name_column": 4
        }
    },
    "command.py": {
        "get_db": {
            "type": "FunctionDef",
            "name": "get_db",
            "md_content": "",
            "code_start_line": 33,
            "code_end_line": 45,
            "parent": null,
            "have_return": false,
            "code_content": "def get_db():\n    \"\"\"\n    Provide a transactional scope around a series of operations.\n    \"\"\"\n    session = SessionLocal()\n    try:\n        yield session\n        session.commit()\n    except:\n        session.rollback()\n        raise\n    finally:\n        session.close()\n",
            "name_column": 4
        },
        "CommandLineParam": {
            "type": "ClassDef",
            "name": "CommandLineParam",
            "md_content": "",
            "code_start_line": 48,
            "code_end_line": 85,
            "parent": null,
            "have_return": false,
            "code_content": "class CommandLineParam:\n    \"\"\"Command line parameters.\n    \n    Attributes:\n            task: Task description.\n            role: Role name (default is \"Assistant\").\n            plan: List of steps to perform (default is empty list).\n            upload_files: List of files to upload (default is empty list).\n            download_files: List of files to download (default is empty list).\n            record_dir: Directory to store records (default is `None`).\n            mode: Run mode. Can be \"auto\" (default is \"auto\").\n            max_wait_seconds: Maximum wait time in seconds (default is 600).\n            description: Description of the interaction (default is \"XAgent-Test\").\n            agent: Agent name (default is \"XAgent\").\n    \"\"\"\n    def __init__(self,\n                 task,\n                role=\"Assistant\",\n                plan=[],\n                upload_files: List[str] = [],\n                download_files: List[str] = [],\n                record_dir: str = None,\n                mode: str = \"auto\",\n                max_wait_seconds: int = 600,\n                description: str = \"XAgent-Test\",\n                agent: str = \"XAgent\",\n                ):\n        self.task = task\n        self.plan = plan\n        self.role = role\n        self.upload_files = upload_files\n        self.download_files = download_files\n        self.record_dir = record_dir\n        # auto is supported only in cmd\n        self.mode = \"auto\"\n        self.max_wait_seconds = max_wait_seconds\n        self.description = description\n        self.agent = agent\n",
            "name_column": 6
        },
        "CommandLine": {
            "type": "ClassDef",
            "name": "CommandLine",
            "md_content": "",
            "code_start_line": 88,
            "code_end_line": 290,
            "parent": null,
            "have_return": false,
            "code_content": "class CommandLine():\n    \"\"\"\n    A command-line interface for interacting with XAgentServer.\n\n    Attributes:\n        env: An instance of the XAgentServer environment.\n        client_id: A unique identifier for the client, generated as a hexadecimal UUID.\n        date_str: The current date as a string in YYYY-MM-DD format.\n        log_dir: The directory where the logs are stored.\n        logger: An instance of the Logger used for logging interactions.\n        interactionDB: A database interface for interacting with either a persistent\n            database (SQLite, MySQL, PostgreSQL) or a local storage file, depending\n            on the configuration of `env`.\n    \"\"\"\n\n    def __init__(self, args: CommandLineParam = None):\n        \"\"\"\n        Initialize the CommandLine instance.\n\n        Args:\n            args (CommandLineParam) : parameters.\n            task is required,\n            mode options: [\"auto\"]\n        \"\"\"\n\n        self.args = args\n        self.client_id = uuid.uuid4().hex\n        self.date_str = datetime.now().strftime(\"%Y-%m-%d\")\n        self.log_dir = os.path.join(os.path.join(XAgentServerEnv.base_dir, \"localstorage\",\n                                    \"interact_records\"), self.date_str, self.client_id)\n        if not os.path.exists(self.log_dir):\n            os.makedirs(self.log_dir)\n\n        self.logger = Logger(log_dir=self.log_dir, log_file=f\"interact.log\")\n\n        self.logger.typewriter_log(\n            title=f\"XAgentServer is running on cmd mode\",\n            title_color=Fore.RED)\n        self.logger.info(title=f\"XAgentServer log:\",\n                         title_color=Fore.RED, message=f\"{self.log_dir}\")\n        self.interrupt = self.args.mode != \"auto\"\n        self.init_conv_env()\n        self.max_wait_seconds = self.args.max_wait_seconds\n        self.scheduler = AsyncIOScheduler()\n        self.input = None\n        if self.interrupt:\n            self.input = CommandLineInput(\n                do_interrupt=True,\n                max_wait_seconds=self.max_wait_seconds,\n                logger=self.logger)\n\n    def init_conv_env(self):\n        \"\"\"initialize the conversation environment, \n        Share the same database resource with webui.\n        If you have initiated a session on the front end but it has not been executed, \n        this ID will be shared.\n        \"\"\"\n        user_id = \"guest\"\n        token = \"xagent\"\n        description = self.args.description\n        upload_files = self.args.upload_files\n        record_dir = self.args.record_dir\n        agent = self.args.agent\n        goal = self.args.task\n        mode = self.args.mode\n        plan = self.args.plan\n\n        with get_db() as db:\n            interaction = InteractionCRUD.get_ready_interaction(\n                db=db, user_id=user_id)\n            self.continue_flag = True\n            upload_files = upload_files if upload_files else []\n            file_list = []\n            for file in upload_files:\n                file_list.append({\n                    \"uuid\": file,\n                    \"name\": file\n                })\n            if interaction is None:\n\n                base = InteractionBase(interaction_id=self.client_id,\n                                       user_id=user_id,\n                                       create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                                       description=description,\n                                       agent=agent,\n                                       mode=mode,\n                                       file_list=file_list,\n                                       recorder_root_dir=\"\",\n                                       status=\"ready\",\n                                       message=\"ready...\",\n                                       current_step=\"-1\",\n                                       update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                                       call_method=\"cmd\")\n                InteractionCRUD.create_interaction(db=db, base=base)\n            else:\n                self.client_id = interaction.interaction_id\n            \n            parameter = InteractionParameter(\n                interaction_id=self.client_id,\n                parameter_id=uuid.uuid4().hex,\n                args={\n                    \"goal\": goal,\n                    \"plan\": plan\n                    },\n            )\n            InteractionCRUD.add_parameter(db=db, parameter=parameter)\n\n\n    def run(self):\n        \"\"\"\n        Runs the interaction with the XAgentServer with the provided arguments.\n        \"\"\"\n\n        # Create a new raw data to record\n        with get_db() as db:\n            InteractionCRUD.insert_raw(db=db, process=XAgentRaw(\n                interaction_id=self.client_id,\n                node_id=uuid.uuid4().hex,\n                status=StatusEnum.RUNNING,\n                create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                current=\"\",\n                step=-1,\n                data=None,\n                file_list=[],\n                do_interrupt=self.interrupt,\n                wait_seconds=0,\n                ask_for_human_help=False,\n                is_human=True,\n                human_data={\"goal\": self.args.task, \"plan\": self.args.plan},\n                human_file_list=self.args.upload_files,\n                is_send=True,\n                is_receive=False,\n                is_deleted=False\n            ))\n            redis.set_key(f\"{self.client_id}_send\", 1)\n            \n            parameter = InteractionCRUD.get_init_parameter(\n                db=db, interaction_id=self.client_id)\n        \n        self.task_handler(parameter=parameter)\n\n    def task_handler(self, parameter: InteractionParameter):\n        \"\"\"\n        define a long task to run interaction\n\n        Args:\n            parameter (InteractionParameter): The parameter of interaction\n        \"\"\"\n\n        try:\n            current_step = uuid.uuid4().hex\n            with get_db() as db:\n                base = InteractionCRUD.get_interaction(db=db,\n                                                    interaction_id=self.client_id)\n                InteractionCRUD.update_interaction_status(db=db,\n                                                        interaction_id=base.interaction_id,\n                                                        status=\"running\",\n                                                        message=\"running\",\n                                                        current_step=current_step)\n\n            # if mode is not auto, we will interrupt the interaction\n            # and you can change the wait_seconds\n            # default 10 min.\n            interaction = XAgentInteraction(\n                base=base,\n                parameter=parameter,\n                interrupt=base.mode != \"auto\",\n                call_method=\"cmd\")\n\n            # Register logger, dbinto interaction\n            interaction.resister_logger(self.logger)\n            self.logger.info(\n                f\"Register logger into interaction of {base.interaction_id}, done!\")\n\n            interaction.register_db(db=db)\n            self.logger.info(\n                f\"Register db into interaction of {base.interaction_id}, done!\")\n            # Create XAgentServer\n            server = XAgentServer(logger=self.logger)\n            self.logger.info(\n                f\"Register logger into XAgentServer of {base.interaction_id}, done!\")\n            self.logger.info(\n                f\"Start a new thread to run interaction of {base.interaction_id}, done!\")\n            # await server.interact(interaction=interaction)\n            server.interact(interaction=interaction)\n        except XAgentError as e:\n            traceback.print_exc()\n            self.logger.error(\n                f\"Error in task_handler of {self.client_id}: {e}\")\n            with get_db() as db:\n                InteractionCRUD.insert_error(\n                    db=db, interaction_id=self.client_id, message=str(e))\n                redis.set_key(self.client_id + \"_send\", 1)\n                InteractionCRUD.update_interaction_status(db=db,\n                                                        interaction_id=self.client_id,\n                                                        status=\"failed\",\n                                                        message=str(e),\n                                                        current_step=current_step)\n        \n    def start(self):\n\n        self.run()\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 103,
            "code_end_line": 137,
            "parent": "CommandLine",
            "have_return": false,
            "code_content": "    def __init__(self, args: CommandLineParam = None):\n        \"\"\"\n        Initialize the CommandLine instance.\n\n        Args:\n            args (CommandLineParam) : parameters.\n            task is required,\n            mode options: [\"auto\"]\n        \"\"\"\n\n        self.args = args\n        self.client_id = uuid.uuid4().hex\n        self.date_str = datetime.now().strftime(\"%Y-%m-%d\")\n        self.log_dir = os.path.join(os.path.join(XAgentServerEnv.base_dir, \"localstorage\",\n                                    \"interact_records\"), self.date_str, self.client_id)\n        if not os.path.exists(self.log_dir):\n            os.makedirs(self.log_dir)\n\n        self.logger = Logger(log_dir=self.log_dir, log_file=f\"interact.log\")\n\n        self.logger.typewriter_log(\n            title=f\"XAgentServer is running on cmd mode\",\n            title_color=Fore.RED)\n        self.logger.info(title=f\"XAgentServer log:\",\n                         title_color=Fore.RED, message=f\"{self.log_dir}\")\n        self.interrupt = self.args.mode != \"auto\"\n        self.init_conv_env()\n        self.max_wait_seconds = self.args.max_wait_seconds\n        self.scheduler = AsyncIOScheduler()\n        self.input = None\n        if self.interrupt:\n            self.input = CommandLineInput(\n                do_interrupt=True,\n                max_wait_seconds=self.max_wait_seconds,\n                logger=self.logger)\n",
            "name_column": 8
        },
        "init_conv_env": {
            "type": "FunctionDef",
            "name": "init_conv_env",
            "md_content": "",
            "code_start_line": 139,
            "code_end_line": 193,
            "parent": "CommandLine",
            "have_return": false,
            "code_content": "    def init_conv_env(self):\n        \"\"\"initialize the conversation environment, \n        Share the same database resource with webui.\n        If you have initiated a session on the front end but it has not been executed, \n        this ID will be shared.\n        \"\"\"\n        user_id = \"guest\"\n        token = \"xagent\"\n        description = self.args.description\n        upload_files = self.args.upload_files\n        record_dir = self.args.record_dir\n        agent = self.args.agent\n        goal = self.args.task\n        mode = self.args.mode\n        plan = self.args.plan\n\n        with get_db() as db:\n            interaction = InteractionCRUD.get_ready_interaction(\n                db=db, user_id=user_id)\n            self.continue_flag = True\n            upload_files = upload_files if upload_files else []\n            file_list = []\n            for file in upload_files:\n                file_list.append({\n                    \"uuid\": file,\n                    \"name\": file\n                })\n            if interaction is None:\n\n                base = InteractionBase(interaction_id=self.client_id,\n                                       user_id=user_id,\n                                       create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                                       description=description,\n                                       agent=agent,\n                                       mode=mode,\n                                       file_list=file_list,\n                                       recorder_root_dir=\"\",\n                                       status=\"ready\",\n                                       message=\"ready...\",\n                                       current_step=\"-1\",\n                                       update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                                       call_method=\"cmd\")\n                InteractionCRUD.create_interaction(db=db, base=base)\n            else:\n                self.client_id = interaction.interaction_id\n            \n            parameter = InteractionParameter(\n                interaction_id=self.client_id,\n                parameter_id=uuid.uuid4().hex,\n                args={\n                    \"goal\": goal,\n                    \"plan\": plan\n                    },\n            )\n            InteractionCRUD.add_parameter(db=db, parameter=parameter)\n",
            "name_column": 8
        },
        "run": {
            "type": "FunctionDef",
            "name": "run",
            "md_content": "",
            "code_start_line": 196,
            "code_end_line": 228,
            "parent": "CommandLine",
            "have_return": false,
            "code_content": "    def run(self):\n        \"\"\"\n        Runs the interaction with the XAgentServer with the provided arguments.\n        \"\"\"\n\n        # Create a new raw data to record\n        with get_db() as db:\n            InteractionCRUD.insert_raw(db=db, process=XAgentRaw(\n                interaction_id=self.client_id,\n                node_id=uuid.uuid4().hex,\n                status=StatusEnum.RUNNING,\n                create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                current=\"\",\n                step=-1,\n                data=None,\n                file_list=[],\n                do_interrupt=self.interrupt,\n                wait_seconds=0,\n                ask_for_human_help=False,\n                is_human=True,\n                human_data={\"goal\": self.args.task, \"plan\": self.args.plan},\n                human_file_list=self.args.upload_files,\n                is_send=True,\n                is_receive=False,\n                is_deleted=False\n            ))\n            redis.set_key(f\"{self.client_id}_send\", 1)\n            \n            parameter = InteractionCRUD.get_init_parameter(\n                db=db, interaction_id=self.client_id)\n        \n        self.task_handler(parameter=parameter)\n",
            "name_column": 8
        },
        "task_handler": {
            "type": "FunctionDef",
            "name": "task_handler",
            "md_content": "",
            "code_start_line": 230,
            "code_end_line": 286,
            "parent": "CommandLine",
            "have_return": false,
            "code_content": "    def task_handler(self, parameter: InteractionParameter):\n        \"\"\"\n        define a long task to run interaction\n\n        Args:\n            parameter (InteractionParameter): The parameter of interaction\n        \"\"\"\n\n        try:\n            current_step = uuid.uuid4().hex\n            with get_db() as db:\n                base = InteractionCRUD.get_interaction(db=db,\n                                                    interaction_id=self.client_id)\n                InteractionCRUD.update_interaction_status(db=db,\n                                                        interaction_id=base.interaction_id,\n                                                        status=\"running\",\n                                                        message=\"running\",\n                                                        current_step=current_step)\n\n            # if mode is not auto, we will interrupt the interaction\n            # and you can change the wait_seconds\n            # default 10 min.\n            interaction = XAgentInteraction(\n                base=base,\n                parameter=parameter,\n                interrupt=base.mode != \"auto\",\n                call_method=\"cmd\")\n\n            # Register logger, dbinto interaction\n            interaction.resister_logger(self.logger)\n            self.logger.info(\n                f\"Register logger into interaction of {base.interaction_id}, done!\")\n\n            interaction.register_db(db=db)\n            self.logger.info(\n                f\"Register db into interaction of {base.interaction_id}, done!\")\n            # Create XAgentServer\n            server = XAgentServer(logger=self.logger)\n            self.logger.info(\n                f\"Register logger into XAgentServer of {base.interaction_id}, done!\")\n            self.logger.info(\n                f\"Start a new thread to run interaction of {base.interaction_id}, done!\")\n            # await server.interact(interaction=interaction)\n            server.interact(interaction=interaction)\n        except XAgentError as e:\n            traceback.print_exc()\n            self.logger.error(\n                f\"Error in task_handler of {self.client_id}: {e}\")\n            with get_db() as db:\n                InteractionCRUD.insert_error(\n                    db=db, interaction_id=self.client_id, message=str(e))\n                redis.set_key(self.client_id + \"_send\", 1)\n                InteractionCRUD.update_interaction_status(db=db,\n                                                        interaction_id=self.client_id,\n                                                        status=\"failed\",\n                                                        message=str(e),\n                                                        current_step=current_step)\n",
            "name_column": 8
        },
        "start": {
            "type": "FunctionDef",
            "name": "start",
            "md_content": "",
            "code_start_line": 288,
            "code_end_line": 290,
            "parent": "CommandLine",
            "have_return": false,
            "code_content": "    def start(self):\n\n        self.run()\n",
            "name_column": 8
        }
    },
    "command_input.py": {
        "timer": {
            "type": "FunctionDef",
            "name": "timer",
            "md_content": "",
            "code_start_line": 12,
            "code_end_line": 30,
            "parent": null,
            "have_return": true,
            "code_content": "def timer(func):\n    \"\"\"\n    Decorator function to time the execution of a function.\n\n    Args:\n        func (Function): The function to be timed.\n\n    Returns:\n        wrapper (Function): The wrapped function with added timing functionality.\n    \"\"\"\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        try:\n            start_time = time.time()\n            result = func(*args, **kwargs)\n            end_time = time.time()\n        except:\n            pass\n    return wrapper\n",
            "name_column": 4
        },
        "CommandLineInput": {
            "type": "ClassDef",
            "name": "CommandLineInput",
            "md_content": "",
            "code_start_line": 33,
            "code_end_line": 153,
            "parent": null,
            "have_return": true,
            "code_content": "class CommandLineInput:\n    \"\"\"\n    Class for handling command line input.\n\n    This child class extends from BaseInput and implements methods to handle and manage command line input data.\n\n    Attributes:\n        do_interrupt (bool): If True, input will be interrupted.\n        max_wait_seconds (int): Maximum wait time for input in seconds.\n    \"\"\"\n    def __init__(self,\n                 do_interrupt: bool = False,\n                 max_wait_seconds: int = 600,\n                 logger=None):\n        self.do_interrupt = do_interrupt\n        self.max_wait_seconds = max_wait_seconds\n        self.logger = logger\n\n    def run(self, input_data):\n        \"\"\"\n        Run the command line input method.\n\n        Args:\n            input_data (Any): The original input data to be processed.\n\n        Returns:\n            data (Any): The processed input data.\n        \"\"\"\n        if self.do_interrupt:\n            data = self.interrupt(input_data)\n        else:\n            data = input_data\n        return data\n    \n    def get_each_input(self, key, value, res, timeout):\n        \"\"\"\n        Returns the input from the command line for a single key-value pair.\n\n        Args:\n            key (str): The key for which to get input.\n            value (Any): The current value associated with the key.\n            res (dict): The result dictionary where inputs collected will be stored.\n            timeout (int): Timeout in seconds for the input.\n\n        Returns:\n            Any: The input data.\n        \"\"\"\n        self.logger.typewriter_log(\n            f\"Now, ASK For {key}, Origin Input: {value}\",\n            Fore.RED,\n            f\"\"\n        )\n        self.logger.typewriter_log(\n            f\"Now, you can modify the current field by entering some information, and then press 'Enter' to continue, if you want to keep the original input, please enter '-1' and then press 'Enter':\",\n            Fore.GREEN\n        )\n        temp = inputimeout(prompt=f'You have {timeout} seconds to input:\\n', timeout=timeout)\n        if temp == \"-1\":\n            return value\n        else:\n            return temp\n        \n    def get_input(self, origin_data):\n        \"\"\"\n        Get input for all fields of the original data from the command line.\n\n        Args:\n            origin_data (dict): The original data for which to get input.\n\n        Returns:\n            dict: The dictionary with updated inputs.\n        \"\"\"\n        self.logger.typewriter_log(\n                \"Next, you can start modifying the original input by typing 'Y/y/yes' or skip this step by typing 'N/n/no' and then press 'Enter' to continue the loop:\",\n                Fore.RED\n            )\n        update = inputimeout(prompt=f'You have to make a decision within 60 seconds:\\n', timeout=60)\n        res = {\"args\": {}}\n        if update in ['y', 'Y', 'yes']:\n            execute_time = self.max_wait_seconds\n            if isinstance(origin_data, dict):\n                args = origin_data.get(\"args\", \"\")\n                self.logger.typewriter_log(\n                    f\"Next, you will have a total of {self.max_wait_seconds} seconds to modify each option:\",\n                    Fore.RED,\n                )\n                for key, value in args.items():\n                    if key == \"done\":\n                        res[key] = False\n                        continue\n                    start_time = time.time()\n                    res[\"args\"][key] = self.get_each_input(key, value, res, execute_time)\n                    end_time = time.time()\n                    execute_time = math.floor(execute_time - (end_time - start_time))\n            self.logger.info(f\"modify the input, receive the data: {res}\")\n        else:\n            res = origin_data\n            self.logger.info(\"skip this step\")\n        self.logger.info(\"continue the loop\")\n        res[\"done\"] = True\n        return res\n    \n    def interrupt(self, input_data):\n        \"\"\"\n        Interrupts the current input process and returns the current data.\n\n        Args:\n            input_data (dict): The original input data.\n\n        Returns:\n            dict: The current data collected so far.\n\n        Raises:\n            XAgentIOTimeoutError: If the input times out.\n        \"\"\"\n        try:\n            data = self.get_input(input_data)\n            return data\n        except TimeoutOccurred:\n            self.logger.error(f\"Waiting timemout, close connection!\")\n            raise XAgentTimeoutError(\"timeout!\")",
            "name_column": 6
        },
        "wrapper": {
            "type": "FunctionDef",
            "name": "wrapper",
            "md_content": "",
            "code_start_line": 23,
            "code_end_line": 29,
            "parent": "timer",
            "have_return": false,
            "code_content": "    def wrapper(*args, **kwargs):\n        try:\n            start_time = time.time()\n            result = func(*args, **kwargs)\n            end_time = time.time()\n        except:\n            pass\n",
            "name_column": 8
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 43,
            "code_end_line": 49,
            "parent": "CommandLineInput",
            "have_return": false,
            "code_content": "    def __init__(self,\n                 do_interrupt: bool = False,\n                 max_wait_seconds: int = 600,\n                 logger=None):\n        self.do_interrupt = do_interrupt\n        self.max_wait_seconds = max_wait_seconds\n        self.logger = logger\n",
            "name_column": 8
        },
        "run": {
            "type": "FunctionDef",
            "name": "run",
            "md_content": "",
            "code_start_line": 51,
            "code_end_line": 65,
            "parent": "CommandLineInput",
            "have_return": true,
            "code_content": "    def run(self, input_data):\n        \"\"\"\n        Run the command line input method.\n\n        Args:\n            input_data (Any): The original input data to be processed.\n\n        Returns:\n            data (Any): The processed input data.\n        \"\"\"\n        if self.do_interrupt:\n            data = self.interrupt(input_data)\n        else:\n            data = input_data\n        return data\n",
            "name_column": 8
        },
        "get_each_input": {
            "type": "FunctionDef",
            "name": "get_each_input",
            "md_content": "",
            "code_start_line": 67,
            "code_end_line": 93,
            "parent": "CommandLineInput",
            "have_return": true,
            "code_content": "    def get_each_input(self, key, value, res, timeout):\n        \"\"\"\n        Returns the input from the command line for a single key-value pair.\n\n        Args:\n            key (str): The key for which to get input.\n            value (Any): The current value associated with the key.\n            res (dict): The result dictionary where inputs collected will be stored.\n            timeout (int): Timeout in seconds for the input.\n\n        Returns:\n            Any: The input data.\n        \"\"\"\n        self.logger.typewriter_log(\n            f\"Now, ASK For {key}, Origin Input: {value}\",\n            Fore.RED,\n            f\"\"\n        )\n        self.logger.typewriter_log(\n            f\"Now, you can modify the current field by entering some information, and then press 'Enter' to continue, if you want to keep the original input, please enter '-1' and then press 'Enter':\",\n            Fore.GREEN\n        )\n        temp = inputimeout(prompt=f'You have {timeout} seconds to input:\\n', timeout=timeout)\n        if temp == \"-1\":\n            return value\n        else:\n            return temp\n",
            "name_column": 8
        },
        "get_input": {
            "type": "FunctionDef",
            "name": "get_input",
            "md_content": "",
            "code_start_line": 95,
            "code_end_line": 133,
            "parent": "CommandLineInput",
            "have_return": true,
            "code_content": "    def get_input(self, origin_data):\n        \"\"\"\n        Get input for all fields of the original data from the command line.\n\n        Args:\n            origin_data (dict): The original data for which to get input.\n\n        Returns:\n            dict: The dictionary with updated inputs.\n        \"\"\"\n        self.logger.typewriter_log(\n                \"Next, you can start modifying the original input by typing 'Y/y/yes' or skip this step by typing 'N/n/no' and then press 'Enter' to continue the loop:\",\n                Fore.RED\n            )\n        update = inputimeout(prompt=f'You have to make a decision within 60 seconds:\\n', timeout=60)\n        res = {\"args\": {}}\n        if update in ['y', 'Y', 'yes']:\n            execute_time = self.max_wait_seconds\n            if isinstance(origin_data, dict):\n                args = origin_data.get(\"args\", \"\")\n                self.logger.typewriter_log(\n                    f\"Next, you will have a total of {self.max_wait_seconds} seconds to modify each option:\",\n                    Fore.RED,\n                )\n                for key, value in args.items():\n                    if key == \"done\":\n                        res[key] = False\n                        continue\n                    start_time = time.time()\n                    res[\"args\"][key] = self.get_each_input(key, value, res, execute_time)\n                    end_time = time.time()\n                    execute_time = math.floor(execute_time - (end_time - start_time))\n            self.logger.info(f\"modify the input, receive the data: {res}\")\n        else:\n            res = origin_data\n            self.logger.info(\"skip this step\")\n        self.logger.info(\"continue the loop\")\n        res[\"done\"] = True\n        return res\n",
            "name_column": 8
        },
        "interrupt": {
            "type": "FunctionDef",
            "name": "interrupt",
            "md_content": "",
            "code_start_line": 135,
            "code_end_line": 153,
            "parent": "CommandLineInput",
            "have_return": true,
            "code_content": "    def interrupt(self, input_data):\n        \"\"\"\n        Interrupts the current input process and returns the current data.\n\n        Args:\n            input_data (dict): The original input data.\n\n        Returns:\n            dict: The current data collected so far.\n\n        Raises:\n            XAgentIOTimeoutError: If the input times out.\n        \"\"\"\n        try:\n            data = self.get_input(input_data)\n            return data\n        except TimeoutOccurred:\n            self.logger.error(f\"Waiting timemout, close connection!\")\n            raise XAgentTimeoutError(\"timeout!\")",
            "name_column": 8
        }
    },
    "setup.py": {},
    "start_server.py": {},
    "ToolServer/ToolServerManager/config.py": {
        "ManagerConfig": {
            "type": "ClassDef",
            "name": "ManagerConfig",
            "md_content": "",
            "code_start_line": 8,
            "code_end_line": 63,
            "parent": null,
            "have_return": true,
            "code_content": "class ManagerConfig:\n    \"\"\"\n    This class manages configuration settings for the application.\n    Configuration settings are initially loaded from a yaml file. \n    However, if an environment variable exists with the same name as a configuration setting, \n    the value from the environment variable will be used instead.\n\n    Attributes:\n        cfg: A dictionary containing all configuration settings.\n    \"\"\"\n\n    def __init__(self, config_file_path=\"./assets/config/manager.yml\"):\n        \"\"\"\n        Initializes a new instance of the ManagerConfig class.\n\n        Args:\n            config_file_path (str, optional): The path to a yaml file containing configuration settings. \n            Defaults to \"./assets/config.yml\".\n        \"\"\"\n        self.cfg:Dict = yaml.load(open(config_file_path,\"r\",encoding=\"utf-8\").read(), Loader=yaml.FullLoader)\n        for k in os.environ.keys():\n            if k in self.cfg:\n                self.cfg[k] = os.environ[k]  # overwrite the config with environment variables\n\n    def __getitem__(self, key):\n        \"\"\"\n        Returns the value of a configuration setting.\n\n        Args:\n            key (str): The name of the configuration setting.\n\n        Returns:\n            The value of the configuration setting. \n        \"\"\"\n        return self.cfg[key]\n\n    def dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Returns all configuration settings.\n\n        Returns:\n            A dictionary containing all configuration settings.\n        \"\"\"\n        return self.cfg\n\n    def update(self, new_config: Dict) -> None:\n        \"\"\"\n        Updates configuration settings with the values from another dictionary.\n\n        Args:\n            new_config (Dict): A dictionary containing the configuration settings to be updated.\n\n        Returns:\n            None\n        \"\"\"\n        self.cfg.update(new_config)\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 19,
            "code_end_line": 30,
            "parent": "ManagerConfig",
            "have_return": false,
            "code_content": "    def __init__(self, config_file_path=\"./assets/config/manager.yml\"):\n        \"\"\"\n        Initializes a new instance of the ManagerConfig class.\n\n        Args:\n            config_file_path (str, optional): The path to a yaml file containing configuration settings. \n            Defaults to \"./assets/config.yml\".\n        \"\"\"\n        self.cfg:Dict = yaml.load(open(config_file_path,\"r\",encoding=\"utf-8\").read(), Loader=yaml.FullLoader)\n        for k in os.environ.keys():\n            if k in self.cfg:\n                self.cfg[k] = os.environ[k]  # overwrite the config with environment variables\n",
            "name_column": 8
        },
        "__getitem__": {
            "type": "FunctionDef",
            "name": "__getitem__",
            "md_content": "",
            "code_start_line": 32,
            "code_end_line": 42,
            "parent": "ManagerConfig",
            "have_return": true,
            "code_content": "    def __getitem__(self, key):\n        \"\"\"\n        Returns the value of a configuration setting.\n\n        Args:\n            key (str): The name of the configuration setting.\n\n        Returns:\n            The value of the configuration setting. \n        \"\"\"\n        return self.cfg[key]\n",
            "name_column": 8
        },
        "dict": {
            "type": "FunctionDef",
            "name": "dict",
            "md_content": "",
            "code_start_line": 44,
            "code_end_line": 51,
            "parent": "ManagerConfig",
            "have_return": true,
            "code_content": "    def dict(self) -> Dict[str, Any]:\n        \"\"\"\n        Returns all configuration settings.\n\n        Returns:\n            A dictionary containing all configuration settings.\n        \"\"\"\n        return self.cfg\n",
            "name_column": 8
        },
        "update": {
            "type": "FunctionDef",
            "name": "update",
            "md_content": "",
            "code_start_line": 53,
            "code_end_line": 63,
            "parent": "ManagerConfig",
            "have_return": false,
            "code_content": "    def update(self, new_config: Dict) -> None:\n        \"\"\"\n        Updates configuration settings with the values from another dictionary.\n\n        Args:\n            new_config (Dict): A dictionary containing the configuration settings to be updated.\n\n        Returns:\n            None\n        \"\"\"\n        self.cfg.update(new_config)\n",
            "name_column": 8
        }
    },
    "ToolServer/ToolServerManager/models.py": {
        "ToolServerNode": {
            "type": "ClassDef",
            "name": "ToolServerNode",
            "md_content": "",
            "code_start_line": 5,
            "code_end_line": 15,
            "parent": null,
            "have_return": false,
            "code_content": "class ToolServerNode(Document):\n    \"\"\"\n    A class that represents a node in the database. \n    \"\"\"\n    id: str\n    short_id: str\n    status: str\n    health: str\n    last_req_time: datetime\n    ip: str\n    port: int\n",
            "name_column": 6
        },
        "NodeChecker": {
            "type": "ClassDef",
            "name": "NodeChecker",
            "md_content": "",
            "code_start_line": 17,
            "code_end_line": 20,
            "parent": null,
            "have_return": false,
            "code_content": "class NodeChecker(Document):\n    manager_id: str\n    interval: float\n    pid: int",
            "name_column": 6
        }
    },
    "ToolServer/ToolServerManager/connections.py": {},
    "ToolServer/ToolServerManager/main.py": {
        "startup": {
            "type": "AsyncFunctionDef",
            "name": "startup",
            "md_content": "",
            "code_start_line": 19,
            "code_end_line": 53,
            "parent": null,
            "have_return": false,
            "code_content": "async def startup():\n    \"\"\"\n    Event handler triggered on startup of the app. Sets up necessary configurations \n    like checking and creating table nodes if not exists in databse, creating subprocess \n    to update node status, and registering path to node. \n    \"\"\"\n    \n    from beanie import init_beanie\n    await init_beanie(database=db,\n                      document_models=[ToolServerNode,NodeChecker],)\n    \n    # create subprocess to update node status\n    if CONFIG['builtin_monitor']:\n        from node_checker import check_nodes_status_loop\n        \n        async for checker in NodeChecker.find_all():\n            if not psutil.pid_exists(checker.pid):\n                checker.delete()\n\n        checker = NodeChecker(\n            manager_id=MANAGER_ID,\n            interval=float(CONFIG['node'].get('health_check_interval',1)),\n            pid=os.getpid()\n            )\n        await checker.save()\n\n        asyncio.create_task(check_nodes_status_loop())\n            \n\n    # register path to node\n    for path in CONFIG['redirect_to_node_path']['post']:\n        app.add_api_route(path, route_to_node, methods=[\"POST\"])\n        \n    for path in CONFIG['redirect_to_node_path']['get']:\n        app.add_api_route(path, route_to_node, methods=[\"GET\"])\n",
            "name_column": 10
        },
        "shutdown": {
            "type": "AsyncFunctionDef",
            "name": "shutdown",
            "md_content": "",
            "code_start_line": 56,
            "code_end_line": 63,
            "parent": null,
            "have_return": false,
            "code_content": "async def shutdown():\n    \"\"\"\n    Event handler on shutdown of the app. Specifically closes the database cursor if \n    the database type os sqlite3.\n    \"\"\"\n    async for checker in NodeChecker.find(NodeChecker.manager_id == MANAGER_ID):\n        await checker.delete()\n    db.client.close()\n",
            "name_column": 10
        },
        "alive": {
            "type": "AsyncFunctionDef",
            "name": "alive",
            "md_content": "",
            "code_start_line": 66,
            "code_end_line": 73,
            "parent": null,
            "have_return": true,
            "code_content": "async def alive():\n    \"\"\"\n    Endpoint to check if the service is running.\n\n    Returns:\n        str: \"alive\"\n    \"\"\"\n    return \"alive\"\n",
            "name_column": 10
        },
        "wait_for_node_startup": {
            "type": "AsyncFunctionDef",
            "name": "wait_for_node_startup",
            "md_content": "",
            "code_start_line": 75,
            "code_end_line": 106,
            "parent": null,
            "have_return": true,
            "code_content": "async def wait_for_node_startup(node_id:str):\n    \"\"\"\n    Wait for the startup of node with id node_id. It probes the node status every seconds until \n    creation_wait_seconds reached.\n    \n    Args:\n        node_id (str): The unique identifier of the node whose startup is to be waited for.\n\n    Returns:\n        bool: True if node has started successfully, False if time out occured before node startup.\n    \n    Raises:\n        HTTPException: If node is not found in the databse.\n    \"\"\"\n    MAX_PROBE_TIMES = CONFIG['node']['creation_wait_seconds']\n    probe_times = 0\n    while probe_times < MAX_PROBE_TIMES:\n        node = await ToolServerNode.find_one(ToolServerNode.id == node_id)\n            \n        if node is None:\n            raise HTTPException(status_code=503, detail=\"Failed to detect node status! Node not found in db!\")\n        \n        if CONFIG['node']['health_check']:\n            if node.health == 'healthy':\n                return True\n        else:\n            if node.status == \"running\":\n                return True\n            \n        probe_times += 1\n        await asyncio.sleep(1)\n    return False\n",
            "name_column": 10
        },
        "read_cookie_info": {
            "type": "AsyncFunctionDef",
            "name": "read_cookie_info",
            "md_content": "",
            "code_start_line": 109,
            "code_end_line": 150,
            "parent": null,
            "have_return": true,
            "code_content": "async def read_cookie_info():\n    \"\"\"\n    Fetch server version and node info, create docker container and set the response cookies \n    with the key \"node_id\" and value as the id of the created container. Also, adds the created \n    node's details to the databse and waits for the node to startup.\n\n    Returns:\n        JSONResponse: A response object with status, headers and cookies set accordingly.\n\n    Raises:\n        HTTPException: If node creation timeout occurs.\n    \"\"\"\n    # append server version info\n    content = {\"message\": \"add cookie\",\"version\":CONFIG['version']}\n    response = JSONResponse(content=content)\n    response.headers[\"Server\"] = \"ToolServerManager/\" + CONFIG['version']\n    \n    # create a docker container\n    container = docker_client.containers.run(\n        device_requests=[docker.types.DeviceRequest(**req) for req in CONFIG['node']['device_requests']] if CONFIG['node']['device_requests'] else None,\n        **(CONFIG['node']['creation_kwargs']),)\n    logger.info(\"Node created: \" + container.id)\n    response.set_cookie(key=\"node_id\", value=container.id)\n    container.reload()\n    \n    node = ToolServerNode(\n        id=container.id,\n        short_id=container.short_id,\n        status=container.attrs[\"State\"][\"Status\"],\n        ip=container.attrs[\"NetworkSettings\"][\"Networks\"][CONFIG['node']['creation_kwargs']['network']][\"IPAddress\"],\n        port=CONFIG['node'].get('port',31942),\n        last_req_time=datetime.datetime.utcnow(),\n        health=container.attrs['State']['Health']['Status'] if CONFIG['node']['health_check'] else None\n    )\n    await node.insert()\n\n    # probe node status every seconds until creation_wait_seconds reached\n    if await wait_for_node_startup(container.id):\n        return response\n    else:\n        logger.warning(\"Node status detection timeout: \" + container.id)\n        raise HTTPException(status_code=503, detail=\"Node creation timeout!\")\n",
            "name_column": 10
        },
        "reconnect_session": {
            "type": "AsyncFunctionDef",
            "name": "reconnect_session",
            "md_content": "",
            "code_start_line": 153,
            "code_end_line": 179,
            "parent": null,
            "have_return": true,
            "code_content": "async def reconnect_session(node_id:str = Cookie(None)):\n    \"\"\"\n    Reconnect session of a node. Fetches node info and restarts the node if it exists.\n\n    Args:\n        node_id (str, optional): The unique identifier of the node. Defaults to Cookie(None).\n\n    Returns:\n        str: Success message if node restarts successfully.\n    \n    Raises:\n        HTTPException: If node restart timeout occurs.\n    \"\"\"\n    node = await ToolServerNode.find_one(ToolServerNode.id == node_id)\n    if node is None:\n        return \"invalid node_id: \" + str(node_id)\n    # restart node\n    container = docker_client.containers.get(node_id)\n    if container is not None:\n        container.restart()\n        logger.info(\"Node restarted: \" + node_id)\n    \n    if await wait_for_node_startup(node_id):\n        return \"Reconnect session: \" + str(node_id)\n    else:\n        logger.warning(\"Node restart timeout: \" + node_id)\n        raise HTTPException(status_code=503, detail=\"Node restart timeout!\")\n",
            "name_column": 10
        },
        "close_session": {
            "type": "AsyncFunctionDef",
            "name": "close_session",
            "md_content": "",
            "code_start_line": 182,
            "code_end_line": 200,
            "parent": null,
            "have_return": true,
            "code_content": "async def close_session(node_id:str = Cookie(None)):\n    \"\"\"\n    Close session of a node. Fetches node info and stops the node if it exists and is not already exited.\n\n    Args:\n        node_id (str, optional): The unique identifier of the node. Defaults to Cookie(None).\n\n    Returns:\n        str: Success message if node stops successfully.\n    \"\"\"\n    node = await ToolServerNode.find_one(ToolServerNode.id == node_id)\n    if node is None:\n        return \"invalid node_id: \" + str(node_id)\n    # stop node\n    container = docker_client.containers.get(node_id)\n    if container is not None and container.attrs[\"State\"][\"Status\"] != \"exit\":\n        container.stop()\n        logger.info(\"Node stopped: \" + node_id)\n    return \"Close session: \" + str(node_id)\n",
            "name_column": 10
        },
        "release_session": {
            "type": "AsyncFunctionDef",
            "name": "release_session",
            "md_content": "",
            "code_start_line": 203,
            "code_end_line": 226,
            "parent": null,
            "have_return": true,
            "code_content": "async def release_session(node_id:str = Cookie(None)):\n    \"\"\"\n    Release session of a node. Fetches node info and kills the node if it exists and is not already exited. \n    Also, removes the node.\n\n    Args:\n        node_id (str, optional): The unique identifier of the node. Defaults to Cookie(None).\n\n    Returns:\n        str: Success message if node is successfully killed and removed.\n    \"\"\"\n    node = await ToolServerNode.find_one(ToolServerNode.id == node_id)\n    if node is None:\n        return \"invalid node_id: \" + str(node_id)\n    \n    # delete node in docker\n    container = docker_client.containers.get(node_id)\n    if container is not None:\n        if container.attrs[\"State\"][\"Status\"] != \"exited\":\n            container.kill()\n            logger.info(\"Node killed: \" + node_id)\n        container.remove()\n        logger.info(\"Node deleted: \" + node_id)\n    return \"Release session: \" + str(node_id)\n",
            "name_column": 10
        },
        "route_to_node": {
            "type": "AsyncFunctionDef",
            "name": "route_to_node",
            "md_content": "",
            "code_start_line": 228,
            "code_end_line": 269,
            "parent": null,
            "have_return": true,
            "code_content": "async def route_to_node(requset:Request,*,node_id:str = Cookie(None)):\n    \"\"\"\n    Routes a request to a specific node. Fetches the node info, checks if it is valid and running. Updates latest \n    request time in the database and then sends a post request to the node.\n    \n    Args:\n        request (Request): The request object containing all request information.\n\n    Returns:\n        Response: The response object containing all response information received from the node.\n\n    Raises:\n        HTTPException: If node_id is not valid or if the node is not running or not responding.\n    \"\"\"\n    # logger.info(\"accept node_id:\",node_id)\n    node = await ToolServerNode.find_one(ToolServerNode.id == node_id)\n    if node is None:\n        raise HTTPException(status_code=403,detail=\"invalid node_id: \" + str(node_id)) \n    \n    if node.status != \"running\":\n        raise HTTPException(status_code=503,detail=\"node is not running: \" + str(node_id)) \n\n    # update latest_req_time in db\n    node.last_req_time = datetime.datetime.utcnow()\n    await node.replace()\n        \n    #post request to node\n    method = requset.method\n    headers = dict(requset.headers)\n    body = await requset.body()\n    url = \"http://\" + node.ip +\":\"+str(node.port) + requset.url.path\n    logger.info(\"Request to node: \" + url)\n    \n    async with httpx.AsyncClient(timeout=None) as client:\n        try:\n            response = await client.request(method,url,headers=headers,data=body)\n        except httpx.RequestError:\n            traceback.print_exc()\n            raise HTTPException(status_code=503, detail=\"node is not responding\")\n    logger.info('Response from node: ' + str(response.status_code))\n    res = Response(content=response.content, status_code=response.status_code, headers=response.headers)\n    return res\n",
            "name_column": 10
        }
    },
    "ToolServer/ToolServerManager/node_checker.py": {
        "check_nodes_status": {
            "type": "AsyncFunctionDef",
            "name": "check_nodes_status",
            "md_content": "",
            "code_start_line": 11,
            "code_end_line": 54,
            "parent": null,
            "have_return": false,
            "code_content": "async def check_nodes_status():\n    \"\"\"\n    Check the status of all existing nodes from the selected database 'sqlite3' or 'mongodb'.\n    If a node doesn't exist in Docker, it will be deleted from the database. \n\n    Raises:\n        docker.errors.NotFound: Raised when a Node is not found in Docker\n        docker.errors.APIError: Raised when it fails to get Node info from Docker\n    \"\"\"\n    # Check if each node exists in Docker\n    async for node in ToolServerNode.find_all():\n        container = None\n        try:\n            container = docker_client.containers.get(node.id)\n        except docker.errors.NotFound:\n            # Delete from db if not found in Docker\n            await node.delete()\n            logger.info(\"Node deleted from db: \" + node.id + '(not in docker)')\n            continue\n        except docker.errors.APIError:\n            logger.warning(\"Failed to get node info from docker: \" + node['node_id'])\n            continue\n\n        if container is not None:\n            # Update the node state in db\n            node_status = container.attrs[\"State\"][\"Status\"]\n \n            if node_status != node.status:\n                logger.info(f\"Node {node.short_id} status updated: \" + node.status + \" -> \" + node_status)\n            node.status = node_status\n                \n            if CONFIG['node']['health_check']:\n                health = container.attrs['State']['Health']['Status']\n                if health != node.health:\n                    logger.info(f\"Node {node.short_id} health updated: \" + node.health + \" -> \" + health)\n                node.health = health\n                \n            await node.replace()\n\n            # Check if node is running\n            if node_status == \"running\":\n                if datetime.datetime.utcnow() - node.last_req_time >= datetime.timedelta(minutes=CONFIG['node']['idling_close_minutes']):\n                    container.stop()\n                    logger.info(\"Stopping node: \" + node.id + \" due to idling time used up\")\n",
            "name_column": 10
        },
        "check_nodes_status_loop": {
            "type": "AsyncFunctionDef",
            "name": "check_nodes_status_loop",
            "md_content": "",
            "code_start_line": 57,
            "code_end_line": 68,
            "parent": null,
            "have_return": false,
            "code_content": "async def check_nodes_status_loop():\n    \"\"\"\n    An infinite loop that checks the status of the nodes and waits 1 second before each iteration.\n    \"\"\"\n    logger.info(\"Nodes status checker started.\")\n    while True:\n        try:\n            await check_nodes_status()\n        except:\n            import traceback\n            traceback.print_exc()\n        await asyncio.sleep(CONFIG['node'].get('health_check_interval',1))\n",
            "name_column": 10
        }
    },
    "ToolServer/ToolServerNode/config.py": {
        "NodeConfig": {
            "type": "ClassDef",
            "name": "NodeConfig",
            "md_content": "",
            "code_start_line": 6,
            "code_end_line": 71,
            "parent": null,
            "have_return": true,
            "code_content": "class NodeConfig:\n    \"\"\"\n    A class used to load and manage the configurations defined in a specified configuration file and the environment variables.\n\n    Methods\n    -------\n    __getitem__(self, key):\n        Fetches a configuration value for a given key.\n    dict():\n        Returns the entire configuration dictionary.\n    update(new_config: Dict):\n        Updates the configuration dictionary with new configurations.\n    \"\"\"\n    def __init__(self,\n                 config_file_path=\"./assets/config/node.yml\",):\n        \"\"\"\n        The constructor for NodeConfig class that loads the configuration details.\n\n        Args:\n          config_file_path (str, optional): The path to the configuration file. Defaults to \"assets/config.yml\".\n\n        Raises:\n          FileNotFoundError: If specified configuration file path could not be located.\n          yaml.YAMLError: If there are syntax errors in the provided yaml configuration file.\n        \"\"\"\n        self.cfg:Dict = yaml.load(open(config_file_path, \"r\", encoding=\"utf-8\").read(), Loader=yaml.FullLoader)\n        \n        for k in os.environ.keys():\n            if k in self.cfg:\n                self.cfg[k] = os.environ[k] # overwrite the config with environment variables\n\n    def __getitem__(self, key):\n        \"\"\"\n        Fetches a configuration value for a given key.\n\n        Args:\n          key (str): The configuration key to fetch value for.\n        \n        Returns:\n          Any: The value of the requested configuration key.\n        \n        Raises:\n          KeyError: If the given key is not found in the configuration.\n        \"\"\"\n        return self.cfg[key]\n    \n    def dict(self)-> Dict[str, Any]:\n        \"\"\"\n        Returns the entire configuration dictionary.\n        \n        Returns:\n          Dict[str, Any]: The entire configuration dictionary.\n        \"\"\"\n        return self.cfg\n\n    def update(self, new_config: Dict)-> None:\n        \"\"\"\n        Updates the configuration dictionary with new configurations.\n\n        Args:\n          new_config (Dict): The new configurations dictionary to update the existing configurations.\n\n        Returns:\n          None\n        \"\"\"\n        self.cfg.update(new_config)\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 19,
            "code_end_line": 35,
            "parent": "NodeConfig",
            "have_return": false,
            "code_content": "    def __init__(self,\n                 config_file_path=\"./assets/config/node.yml\",):\n        \"\"\"\n        The constructor for NodeConfig class that loads the configuration details.\n\n        Args:\n          config_file_path (str, optional): The path to the configuration file. Defaults to \"assets/config.yml\".\n\n        Raises:\n          FileNotFoundError: If specified configuration file path could not be located.\n          yaml.YAMLError: If there are syntax errors in the provided yaml configuration file.\n        \"\"\"\n        self.cfg:Dict = yaml.load(open(config_file_path, \"r\", encoding=\"utf-8\").read(), Loader=yaml.FullLoader)\n        \n        for k in os.environ.keys():\n            if k in self.cfg:\n                self.cfg[k] = os.environ[k] # overwrite the config with environment variables\n",
            "name_column": 8
        },
        "__getitem__": {
            "type": "FunctionDef",
            "name": "__getitem__",
            "md_content": "",
            "code_start_line": 37,
            "code_end_line": 50,
            "parent": "NodeConfig",
            "have_return": true,
            "code_content": "    def __getitem__(self, key):\n        \"\"\"\n        Fetches a configuration value for a given key.\n\n        Args:\n          key (str): The configuration key to fetch value for.\n        \n        Returns:\n          Any: The value of the requested configuration key.\n        \n        Raises:\n          KeyError: If the given key is not found in the configuration.\n        \"\"\"\n        return self.cfg[key]\n",
            "name_column": 8
        },
        "dict": {
            "type": "FunctionDef",
            "name": "dict",
            "md_content": "",
            "code_start_line": 52,
            "code_end_line": 59,
            "parent": "NodeConfig",
            "have_return": true,
            "code_content": "    def dict(self)-> Dict[str, Any]:\n        \"\"\"\n        Returns the entire configuration dictionary.\n        \n        Returns:\n          Dict[str, Any]: The entire configuration dictionary.\n        \"\"\"\n        return self.cfg\n",
            "name_column": 8
        },
        "update": {
            "type": "FunctionDef",
            "name": "update",
            "md_content": "",
            "code_start_line": 61,
            "code_end_line": 71,
            "parent": "NodeConfig",
            "have_return": false,
            "code_content": "    def update(self, new_config: Dict)-> None:\n        \"\"\"\n        Updates the configuration dictionary with new configurations.\n\n        Args:\n          new_config (Dict): The new configurations dictionary to update the existing configurations.\n\n        Returns:\n          None\n        \"\"\"\n        self.cfg.update(new_config)\n",
            "name_column": 8
        }
    },
    "ToolServer/ToolServerNode/main.py": {
        "startup": {
            "type": "FunctionDef",
            "name": "startup",
            "md_content": "",
            "code_start_line": 23,
            "code_end_line": 33,
            "parent": null,
            "have_return": false,
            "code_content": "def startup():\n    \"\"\"\n    Startup function to initialize the required services and variables for the application.\n    \"\"\"\n    try:\n        # start docker service\n        os.system('service docker start')\n    except:\n        pass\n    app.tool_register = ToolRegister()\n    app.doc_embeddings, app.id2tool = build_tool_embeddings(app.tool_register.get_all_tools_dict(include_invisible=True))\n",
            "name_column": 4
        },
        "root": {
            "type": "AsyncFunctionDef",
            "name": "root",
            "md_content": "",
            "code_start_line": 37,
            "code_end_line": 44,
            "parent": null,
            "have_return": true,
            "code_content": "async def root():\n    \"\"\"\n    Root function that returns a message Hello World.\n    \n    Returns:\n        dict: A dictionary containing a welcoming message.\n    \"\"\"\n    return {\"message\": \"Hello World\"}\n",
            "name_column": 10
        },
        "upload_file": {
            "type": "AsyncFunctionDef",
            "name": "upload_file",
            "md_content": "",
            "code_start_line": 47,
            "code_end_line": 62,
            "parent": null,
            "have_return": true,
            "code_content": "async def upload_file(file:UploadFile):\n    \"\"\"\n    This function allows the user to upload a file to the work directory defined in configuration file.\n\n    Args:\n        file (fastapi.UploadFile): The file to be uploaded.\n    \n    Returns:\n        dict: A message denoting successful upload of the file.\n    \"\"\"\n    upload_file =  file.file.read()\n    file_name = file.filename\n    work_directory = CONFIG['filesystem']['work_directory']\n    with open(os.path.join(work_directory,file_name),'wb') as f:\n        f.write(upload_file)\n    return {\"message\": \"Upload Success!\"}\n",
            "name_column": 10
        },
        "download_file": {
            "type": "AsyncFunctionDef",
            "name": "download_file",
            "md_content": "",
            "code_start_line": 65,
            "code_end_line": 83,
            "parent": null,
            "have_return": true,
            "code_content": "async def download_file(file_path:str=Body(...),file_type:str=Body(default='text/plain')):\n    \"\"\"\n    This function downloads a file from the work directory.\n\n    Args:\n        file_path (str): The path of the file to be downloaded.\n        file_type (str, optional): Type of the file. Defaults to 'text/plain'.\n    \n    Returns:\n        starlette.responses.FileResponse: File response containing the requested file for user to download.\n    \"\"\"\n    work_directory = CONFIG['filesystem']['work_directory']\n    if file_path.startswith(os.path.basename(work_directory)):\n        file_path = file_path[len(os.path.basename(work_directory))+1:]\n    response = FileResponse(\n        path=os.path.join(work_directory,file_path),\n        filename=os.path.basename(file_path),\n        )\n    return response\n",
            "name_column": 10
        },
        "download_workspace": {
            "type": "AsyncFunctionDef",
            "name": "download_workspace",
            "md_content": "",
            "code_start_line": 86,
            "code_end_line": 105,
            "parent": null,
            "have_return": true,
            "code_content": "async def download_workspace():\n    \"\"\"\n    This function downloads the workspace which is a directory consisting of all the uploaded files. \n    \n    Returns:\n        starlette.responses.FileResponse: File response containing the workspace for the user to download. \n    \"\"\"\n    work_directory = CONFIG['filesystem']['work_directory']\n    zip = zipfile.ZipFile('/tmp/workspace.zip','w',zipfile.ZIP_DEFLATED)\n    for path,dirs,files in os.walk(work_directory):\n        fpath= path.replace(work_directory,'')\n        for file in files:\n            zip.write(os.path.join(path,file),os.path.join(fpath,file))\n    \n    zip.close()\n    response = FileResponse(\n        path=os.path.join(work_directory,'/tmp/workspace.zip'),\n        filename='workspace.zip',\n        )\n    return response\n",
            "name_column": 10
        },
        "get_workspace_structure": {
            "type": "AsyncFunctionDef",
            "name": "get_workspace_structure",
            "md_content": "",
            "code_start_line": 109,
            "code_end_line": 125,
            "parent": null,
            "have_return": true,
            "code_content": "async def get_workspace_structure():\n    \"\"\"\n    This function generates the structure of the workspace directory.\n    \n    Returns:\n        dict: A dictionary depicting the structure of the workspace directory.\n    \"\"\"\n    work_directory = CONFIG['filesystem']['work_directory']\n    def generate_directory_structure(path):\n        result = {'name':os.path.basename(path)}\n        if os.path.isdir(path):\n            result['type'] = 'directory'\n            result['children'] = [generate_directory_structure(os.path.join(path,child)) for child in os.listdir(path)]\n        else:\n            result['type'] = 'file'\n        return result\n    return generate_directory_structure(work_directory)\n",
            "name_column": 10
        },
        "get_available_tools": {
            "type": "AsyncFunctionDef",
            "name": "get_available_tools",
            "md_content": "",
            "code_start_line": 128,
            "code_end_line": 140,
            "parent": null,
            "have_return": true,
            "code_content": "async def get_available_tools():\n    \"\"\"\n    This function returns the available tools and environments registered in the ToolRegister.\n    \n    Returns:\n        dict: A dictionary of available tools, environments and the JSON representation of the tools.\n    \"\"\"\n    tool_register:ToolRegister = app.tool_register\n    return {\n        \"available_envs\": tool_register.get_all_envs(),\n        \"available_tools\": tool_register.get_all_tools(),\n        \"tools_json\": tool_register.get_all_tools_dict(),\n    }\n",
            "name_column": 10
        },
        "retrieving_tools": {
            "type": "AsyncFunctionDef",
            "name": "retrieving_tools",
            "md_content": "",
            "code_start_line": 143,
            "code_end_line": 173,
            "parent": null,
            "have_return": true,
            "code_content": "async def retrieving_tools(question:str=Body(...), top_k:int=Body(default=5)):\n    \"\"\"\n    This function retrieves the tool names based on a query question using the ADA retriever.\n\n    Args:\n        question (str): The query question for which tools are to be retrieved.\n        top_k (int, optional): The number of top similar tools to be retrieved. Defaults to 5.\n\n    Returns:\n        dict: A dictionary with the list of retrieved tools and JSON representations of the tools.\n\n    Raises:\n        HTTPException: If an error occurs during retrieving the tools.\n    \"\"\"\n    try:\n        retrieved_tools = ada_retriever(app.doc_embeddings, app.id2tool, question, top_k)\n    except Exception as e:\n        error_report =  traceback.format_exc()\n        logger.error(error_report)\n        raise HTTPException(status_code=500, detail=f\"Errorhappens when retrieving tools:\\n{e}\\n\\n\" + error_report)\n    \n    tool_register:ToolRegister = app.tool_register\n    tools_json = []\n    for tool_name in retrieved_tools:\n        if tool_name in tool_register.tools:\n            tools_json.append(tool_register.get_tool_dict(tool_name))\n    \n    return {\n        \"retrieved_tools\":retrieved_tools,\n        \"tools_json\":tools_json,\n    }\n",
            "name_column": 10
        },
        "get_json_schema_for_tool": {
            "type": "AsyncFunctionDef",
            "name": "get_json_schema_for_tool",
            "md_content": "",
            "code_start_line": 177,
            "code_end_line": 199,
            "parent": null,
            "have_return": true,
            "code_content": "async def get_json_schema_for_tool(tool_names:List[str]=Body(...)):\n    \"\"\"\n    This function returns the JSON schema for the given list of tools.\n\n    Args:\n        tool_names (List[str]): List of tool names for which JSON schema is required.\n\n    Returns:\n        dict: JSON schema dictionary for all the available tools and list of error names for missing tools. \n    \"\"\"\n    tool_register:ToolRegister = app.tool_register\n    \n    error_names = []\n    tools_json = []\n    for tool_name in tool_names:\n        if tool_name not in tool_register.tools:\n            error_names.append(tool_name)\n        else:\n            tools_json.append(tool_register.get_tool_dict(tool_name))\n    return {\n        \"tools_json\": tools_json,\n        \"missing_tools\": error_names,\n    }\n",
            "name_column": 10
        },
        "get_json_schema_for_env": {
            "type": "AsyncFunctionDef",
            "name": "get_json_schema_for_env",
            "md_content": "",
            "code_start_line": 202,
            "code_end_line": 224,
            "parent": null,
            "have_return": true,
            "code_content": "async def get_json_schema_for_env(env_names:List[str]=Body(...)):\n    \"\"\"\n    This function returns the JSON schema for the given list of tool environments.\n\n    Args:\n        env_names (List[str]): List of environment names for which JSON schema is required.\n\n    Returns:\n        dict: JSON schema dictionary for all the available environments and list of error names for missing environments. \n    \"\"\"\n    tool_register:ToolRegister = app.tool_register\n    \n    error_names = []\n    envs_json = []\n    for env_name in env_names:\n        if env_name not in tool_register.envs:\n            error_names.append(env_name)\n        else:\n            envs_json.append(tool_register.get_env_dict(env_name))\n    return {\n        \"envs_json\": envs_json,\n        \"missing_envs\": error_names,\n    }\n",
            "name_column": 10
        },
        "register_new_tool": {
            "type": "AsyncFunctionDef",
            "name": "register_new_tool",
            "md_content": "",
            "code_start_line": 227,
            "code_end_line": 249,
            "parent": null,
            "have_return": true,
            "code_content": "async def register_new_tool(tool_name:str=Body(...), code:str=Body(...)):\n    \"\"\"\n    This function allows the user to register a new tool by providing the tool name and code.\n\n    Args:\n        tool_name (str): The name of the new tool.\n        code (str): The code for the new tool.\n\n    Returns:\n        dict: A dictionary representing the registered tool.\n\n    Raises:\n        HTTPException: If an error occurs during registering the new tool.\n    \"\"\"\n    tool_register:ToolRegister = app.tool_register\n    try:\n        tool_dict = tool_register.register_tool(tool_name,code)\n    except Exception as e:\n        error_report =  traceback.format_exc()\n        logger.error(error_report)\n        raise HTTPException(status_code=406, detail=f\"Error happens when registering new tool:\\n{e}\\n\\n\" + error_report)\n    \n    return tool_dict\n",
            "name_column": 10
        },
        "execute_tool": {
            "type": "AsyncFunctionDef",
            "name": "execute_tool",
            "md_content": "",
            "code_start_line": 252,
            "code_end_line": 289,
            "parent": null,
            "have_return": true,
            "code_content": "async def execute_tool(tool_name:str=Body(...), arguments:dict=Body(...), env_name:str=Body(default=None)):\n    \"\"\"\n    This function executes a tool with the provided arguments and environment.\n\n    Args:\n        tool_name (str): The name of the tool to be executed.\n        arguments (dict): The arguments for executing the tool.\n        env_name (str, optional): The name of the tool environment in which tool is to be executed. Defaults to None.\n\n    Returns:\n        dict: The result of executing the tool is wrapped in a dictionary.\n\n    Raises:\n        HTTPException: If an error occurs during tool execution.\n    \"\"\"\n    tool_register:ToolRegister = app.tool_register\n    \n    try:\n        if env_name is not None:\n            tool = tool_register[env_name,tool_name]\n        else:\n            tool = tool_register[tool_name]\n        result = tool(**arguments)\n        if isinstance(result,Coroutine):\n            result = await result\n        result = wrap_tool_response(result)\n    except ToolNotFound as e:\n        raise HTTPException(status_code=404, detail=str(e))\n    except OutputNotReady as e:\n        raise HTTPException(status_code=450, detail=e.next_try())\n    except HTTPException as e:\n        raise e\n    except Exception as e:\n        trace_info = traceback.format_exc()\n        logger.error(f'Error happens when executing tool {tool_name}! Exception: {e}\\n{trace_info}')\n        raise HTTPException(status_code=500, detail=trace_info)\n    \n    return result\n",
            "name_column": 10
        },
        "generate_directory_structure": {
            "type": "FunctionDef",
            "name": "generate_directory_structure",
            "md_content": "",
            "code_start_line": 117,
            "code_end_line": 124,
            "parent": "get_workspace_structure",
            "have_return": true,
            "code_content": "    def generate_directory_structure(path):\n        result = {'name':os.path.basename(path)}\n        if os.path.isdir(path):\n            result['type'] = 'directory'\n            result['children'] = [generate_directory_structure(os.path.join(path,child)) for child in os.listdir(path)]\n        else:\n            result['type'] = 'file'\n        return result\n",
            "name_column": 8
        }
    },
    "ToolServer/ToolServerNode/core/labels.py": {
        "ToolLabels": {
            "type": "ClassDef",
            "name": "ToolLabels",
            "md_content": "",
            "code_start_line": 5,
            "code_end_line": 70,
            "parent": null,
            "have_return": true,
            "code_content": "class ToolLabels:\n    \"\"\"A class representing a tool.\n\n    When invoked, this object runs the associated method using parameters defined in the signature.\n\n    Attributes:\n        name (str): The name of the tool.\n        description (str): Description of the tool.\n        method (Callable): The function/method that the tool executes.\n        signature (dict): Argument keys and values needed by the method to execute.\n        required (list): List of required arguments for the method.\n        enabled (bool): Flag indicating whether the tool is enabled or not.\n        disabled_reason (str): Reason for disabling the tool, if applicable.\n        func_type (str): Type of function for the tool, defaults to 'function'.\n        visible (bool): Flag indicating whether the tool is visible or not.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        description: str,\n        method: Callable[..., Any],\n        signature: dict = {},\n        required: list = [],\n        enabled: bool = True,\n        disabled_reason: Optional[str] = None,\n        func_type: str = 'function',\n        visible: bool = True,\n    ):\n        self.name = name\n        self.description = description\n        self.method = method\n        self.signature = signature\n        self.required = required\n        self.enabled = enabled\n        self.disabled_reason = disabled_reason\n        self.func_type = func_type\n        self.visible = visible\n\n    def dict(self, name_overwrite: str = '') -> dict:\n        \"\"\"Returns the tool information as a dictionary.\n\n        Args:\n            name_overwrite (str): Replacement string for tool name, defaults to empty string.\n\n        Returns:\n            dict: Dictionary of tool attributes.\n        \"\"\"\n        \n        return {\n            \"name\": self.name if name_overwrite == '' else name_overwrite,\n            \"description\": self.description[:1024],\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": self.signature,\n                \"required\": self.required\n            }\n        }\n\n    def __str__(self) -> str:\n        \"\"\"Returns the tool information in a formatted string.\n\n        Returns:\n            str: Formatted string containing tool attributes.\n        \"\"\"\n        return f\"{self.name}: {self.description}, args: {self.signature}\"\n",
            "name_column": 6
        },
        "EnvLabels": {
            "type": "ClassDef",
            "name": "EnvLabels",
            "md_content": "",
            "code_start_line": 73,
            "code_end_line": 149,
            "parent": null,
            "have_return": true,
            "code_content": "class EnvLabels:\n    \"\"\"A class representing an environment.\n\n    Each environment has a set of subtools associated with it. This object manages the collection of tools.\n\n    Attributes:\n        name (str): Name of the environment.\n        description (str): Description of the environment.\n        subtools_labels (dict): Collection of tools associated to the environment.\n        defined_tools (list): List of tool names defined in the environment.\n        cls (Type): Class that the environment pertains to.\n        enabled (bool): Flag indicating whether the environment is enabled or not.\n        disabled_reason (str): Reason for disabling the environment, if applicable.\n        visible (bool): Flag indicating whether the environment is visible or not.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        description: str,\n        subtools_labels: dict[ToolLabels] = {},\n        defined_tools:list[str] = [],\n        cls: Type = None,\n        enabled: bool = True,\n        disabled_reason: Optional[str] = None,\n        visible: bool = True,\n    ):\n        self.name = name\n        self.description = description\n        self.subtools_labels = subtools_labels\n        self.defined_tools = defined_tools\n        self.cls = cls\n        self.enabled = enabled\n        self.disabled_reason = disabled_reason\n        self.visible = visible\n\n    def dict(self,\n             include_invisible=False,\n             max_show_tools: int = CONFIG['toolregister']['env_max_tools_display']) -> dict:\n        \"\"\"\n        Returns the environment's tools as a dictionary.\n\n        Args:\n            include_invisible (bool): If true, includes tools even if they're set as invisible.\n            max_show_tools (int): Maximum number of tools to display in the output.\n\n        Returns:\n            dict: Dictionary of environment attributes and associated tools.\n        \"\"\"\n        \n        if include_invisible:\n            tools_name = list(self.subtools_labels.keys())\n        else:\n            if CONFIG['toolregister']['parent_tools_visible']:\n                tools_name = [tool_name for tool_name in self.subtools_labels.keys() if self.subtools_labels[tool_name].visible]\n            else:\n                tools_name = self.defined_tools\n\n        if max_show_tools != -1 and len(tools_name) > max_show_tools:\n            # only show first max_show_tools tools\n            tools_name = tools_name[:max_show_tools]\n            tools_name.append('...')\n\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"total_tools\": len(self.subtools_labels),\n            \"tools\": tools_name,\n        }\n\n    def __str__(self) -> str:\n        \"\"\"Returns the environment information as a formatted string.\n\n        Returns:\n            str: Formatted string containing environment attributes.\n        \"\"\"\n        return f\"{self.name}: {self.description}\"",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 89,
            "code_end_line": 107,
            "parent": "EnvLabels",
            "have_return": false,
            "code_content": "    def __init__(\n        self,\n        name: str,\n        description: str,\n        subtools_labels: dict[ToolLabels] = {},\n        defined_tools:list[str] = [],\n        cls: Type = None,\n        enabled: bool = True,\n        disabled_reason: Optional[str] = None,\n        visible: bool = True,\n    ):\n        self.name = name\n        self.description = description\n        self.subtools_labels = subtools_labels\n        self.defined_tools = defined_tools\n        self.cls = cls\n        self.enabled = enabled\n        self.disabled_reason = disabled_reason\n        self.visible = visible\n",
            "name_column": 8
        },
        "dict": {
            "type": "FunctionDef",
            "name": "dict",
            "md_content": "",
            "code_start_line": 109,
            "code_end_line": 141,
            "parent": "EnvLabels",
            "have_return": true,
            "code_content": "    def dict(self,\n             include_invisible=False,\n             max_show_tools: int = CONFIG['toolregister']['env_max_tools_display']) -> dict:\n        \"\"\"\n        Returns the environment's tools as a dictionary.\n\n        Args:\n            include_invisible (bool): If true, includes tools even if they're set as invisible.\n            max_show_tools (int): Maximum number of tools to display in the output.\n\n        Returns:\n            dict: Dictionary of environment attributes and associated tools.\n        \"\"\"\n        \n        if include_invisible:\n            tools_name = list(self.subtools_labels.keys())\n        else:\n            if CONFIG['toolregister']['parent_tools_visible']:\n                tools_name = [tool_name for tool_name in self.subtools_labels.keys() if self.subtools_labels[tool_name].visible]\n            else:\n                tools_name = self.defined_tools\n\n        if max_show_tools != -1 and len(tools_name) > max_show_tools:\n            # only show first max_show_tools tools\n            tools_name = tools_name[:max_show_tools]\n            tools_name.append('...')\n\n        return {\n            \"name\": self.name,\n            \"description\": self.description,\n            \"total_tools\": len(self.subtools_labels),\n            \"tools\": tools_name,\n        }\n",
            "name_column": 8
        },
        "__str__": {
            "type": "FunctionDef",
            "name": "__str__",
            "md_content": "",
            "code_start_line": 143,
            "code_end_line": 149,
            "parent": "EnvLabels",
            "have_return": true,
            "code_content": "    def __str__(self) -> str:\n        \"\"\"Returns the environment information as a formatted string.\n\n        Returns:\n            str: Formatted string containing environment attributes.\n        \"\"\"\n        return f\"{self.name}: {self.description}\"",
            "name_column": 8
        }
    },
    "ToolServer/ToolServerNode/core/__init__.py": {},
    "ToolServer/ToolServerNode/core/exceptions.py": {
        "OutputNotReady": {
            "type": "ClassDef",
            "name": "OutputNotReady",
            "md_content": "",
            "code_start_line": 4,
            "code_end_line": 20,
            "parent": null,
            "have_return": true,
            "code_content": "class OutputNotReady(Exception):\n    \"\"\"The output is not ready.\n        \"\"\"\n    def __init__(self, *args: object,type:str='retry',next_calling:str=None,arguments:dict={}) -> None:\n        super().__init__(*args)\n        self.type = type\n        self.next_calling = next_calling\n        self.arguments = arguments\n        \n    def next_try(self):\n        \"\"\"Prepare the next try by returning a dictionary\n           containing type, next calling event and arguments.\"\"\"\n        return {\n            \"type\":self.type,\n            \"next_calling\":self.next_calling,\n            \"arguments\":self.arguments\n        }\n",
            "name_column": 6
        },
        "ToolNotFound": {
            "type": "ClassDef",
            "name": "ToolNotFound",
            "md_content": "",
            "code_start_line": 22,
            "code_end_line": 43,
            "parent": null,
            "have_return": true,
            "code_content": "class ToolNotFound(Exception):\n    \"\"\"Custom exception class that is raised when the tool is not found.\n    \n    Args:\n        *args (object): Variable length argument list.\n        tool_name (str): The name of the tool.\n\n    Attributes:\n        tool_name (str): The name of the tool.\n    \"\"\"\n    def __init__(self, *args: object,tool_name:str=None) -> None:\n        super().__init__(*args)\n        self.tool_name = tool_name\n        \n    def __str__(self) -> str:\n        \"\"\"Returns the formatted exception error message with the name of the tool\"\"\"\n        s = super().__str__()\n        if s != '':\n            s += f'\\nThe tool {self.tool_name} is not found!'\n        else:\n            s = f'The tool {self.tool_name} is not found!'\n        return s \n",
            "name_column": 6
        },
        "EnvNotFound": {
            "type": "ClassDef",
            "name": "EnvNotFound",
            "md_content": "",
            "code_start_line": 46,
            "code_end_line": 69,
            "parent": null,
            "have_return": true,
            "code_content": "class EnvNotFound(Exception):\n    \"\"\"Custom exception class that is raised when the environment variable is not found.\n    \n    Args:\n        *args (object): Variable length argument list.\n        env_name (str): The name of the environment variable.\n\n    Attributes:\n        addition_info (tuple): Additional information.\n        env_name (str): The name of the environment variable.\n    \"\"\"\n    def __init__(self, *args: object,env_name:str=None) -> None:\n        super().__init__(*args)\n        self.addition_info = args\n        self.env_name =  env_name\n        \n    def __str__(self)->str:\n        \"\"\"Returns the formatted exception error message with the name of the environment variable\"\"\"\n        s = super().__str__()\n        if s != '':\n            s += f'\\nThe env {self.env_name} is not found!'\n        else:\n            s = f'The tool {self.env_name} is not found!'\n        return s \n",
            "name_column": 6
        },
        "ToolRegisterError": {
            "type": "ClassDef",
            "name": "ToolRegisterError",
            "md_content": "",
            "code_start_line": 71,
            "code_end_line": 94,
            "parent": null,
            "have_return": true,
            "code_content": "class ToolRegisterError(Exception):\n    \"\"\"Custom exception class that is raised when registering a tool encounters an error.\n    \n    Args:\n        *args (object): Variable length argument list.\n        tool_name (str): The name of the tool.\n\n    Attributes:\n        addition_info (tuple): Additional information.\n        tool_name (str): The name of the tool.\n    \"\"\"\n    def __init__(self, *args: object,tool_name:str=None) -> None:\n        super().__init__(*args)\n        self.addition_info = args\n        self.tool_name = tool_name\n        \n    def __str__(self)->str:\n        \"\"\"Returns the formatted exception error message with the name of the tool\"\"\"\n        s = super().__str__()\n        if s != '':\n            s += f'\\nError happens when registering tool {self.tool_name}!'\n        else:\n            s = f'Error happens when registering tool {self.tool_name}!'\n        return s \n",
            "name_column": 6
        },
        "remove_color": {
            "type": "FunctionDef",
            "name": "remove_color",
            "md_content": "",
            "code_start_line": 97,
            "code_end_line": 107,
            "parent": null,
            "have_return": true,
            "code_content": "def remove_color(text):\n    \"\"\"Removes ANSI escape sequences i.e. colors, from the text.\n\n    Args:\n        text (str): The text from which color needs to be removed.\n\n    Returns:\n        str: The filtered text with no color.\n    \"\"\"\n\n    return ansi_escape.sub('', text)\n",
            "name_column": 4
        },
        "ToolExecutionError": {
            "type": "ClassDef",
            "name": "ToolExecutionError",
            "md_content": "",
            "code_start_line": 109,
            "code_end_line": 118,
            "parent": null,
            "have_return": false,
            "code_content": "class ToolExecutionError(HTTPException):\n    \"\"\"Custom exception class that is raised when the tool execution encounters an error.\n\n    Args:\n        error_msg (str): The error message during tool execution.\n    \"\"\"\n    def __init__(self,error_msg:str):\n        if isinstance(error_msg,str):\n            error_msg = remove_color(error_msg)\n        super().__init__(500,error_msg)",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 115,
            "code_end_line": 118,
            "parent": "ToolExecutionError",
            "have_return": false,
            "code_content": "    def __init__(self,error_msg:str):\n        if isinstance(error_msg,str):\n            error_msg = remove_color(error_msg)\n        super().__init__(500,error_msg)",
            "name_column": 8
        },
        "next_try": {
            "type": "FunctionDef",
            "name": "next_try",
            "md_content": "",
            "code_start_line": 13,
            "code_end_line": 20,
            "parent": "OutputNotReady",
            "have_return": true,
            "code_content": "    def next_try(self):\n        \"\"\"Prepare the next try by returning a dictionary\n           containing type, next calling event and arguments.\"\"\"\n        return {\n            \"type\":self.type,\n            \"next_calling\":self.next_calling,\n            \"arguments\":self.arguments\n        }\n",
            "name_column": 8
        },
        "__str__": {
            "type": "FunctionDef",
            "name": "__str__",
            "md_content": "",
            "code_start_line": 87,
            "code_end_line": 94,
            "parent": "ToolRegisterError",
            "have_return": true,
            "code_content": "    def __str__(self)->str:\n        \"\"\"Returns the formatted exception error message with the name of the tool\"\"\"\n        s = super().__str__()\n        if s != '':\n            s += f'\\nError happens when registering tool {self.tool_name}!'\n        else:\n            s = f'Error happens when registering tool {self.tool_name}!'\n        return s \n",
            "name_column": 8
        }
    },
    "ToolServer/ToolServerNode/core/base.py": {
        "BaseEnv": {
            "type": "ClassDef",
            "name": "BaseEnv",
            "md_content": "",
            "code_start_line": 5,
            "code_end_line": 76,
            "parent": null,
            "have_return": true,
            "code_content": "class BaseEnv:\n    \"\"\"\n    BaseEnv class. It helps to handle functions and function names of the classes and subclasses.\n    This class provides methods to get all functions, defined functions and their names.\n    It also ensures the configuration updates if necessary.\n\n    Attributes:\n        config(Dict[str, Any], optional): A dictionary containing the configuration. Defaults to an empty dictionary.\n    \"\"\"\n    def __init__(self, config: Dict[str, Any] = {}):\n        \"\"\"Initialize BaseEnv class with specified or default configuration.\n\n        Args:\n            config (Dict[str, Any], optional): A dictionary containing the configuration. Defaults to an empty dictionary.\n\n        Notes:\n            The configuration is deep copied to avoid modifications to the original object.\n        \"\"\"\n        self.config = deepcopy(CONFIG)\n        if isinstance(config, dict):\n            self.config.update(config)\n        \n    @classmethod\n    def __get_all_func_name__(cls) -> list[str]:\n        \"\"\"Get all the function names of the class, excluding methods starting with '_' character.\n\n        Returns:\n            list[str]: A list that contains function names.\n        \"\"\"\n        return [name for name in dir(cls) \n        if not str(name).startswith('_') and callable(getattr(cls, name))]\n\n\n    @classmethod\n    def __get_all_func__(cls) -> list[Callable]:\n        \"\"\"Get all functions of the class, excluding methods starting with '__' characters.\n\n        Returns:\n            list[Callable]: A list that contains functions.\n        \"\"\"\n        func_names = cls.__get_all_func_name__()\n        return list(map(getattr, [cls]*len(func_names), func_names))\n\n    @classmethod\n    def __get_defined_func__(cls) -> list[Callable]:\n        \"\"\"Get all the functions of the subclass, excluding methods starting with '_' character.\n\n        Returns:\n            list[Callable]: A list that contains defined functions of the subclass.\n\n        Notes:\n            This method removes the parent class's methods from the functions list to \n            provide only the functions that are newly defined in the subclass.\n        \"\"\"\n        functions = cls.__get_all_func__()\n        for parent_cls in cls.__bases__:\n            if not issubclass(parent_cls, BaseEnv):\n                continue\n            parent_functions = parent_cls.__get_all_func__()\n            functions = list(filter(lambda x: x not in parent_functions, functions))\n    \n        return functions\n\n    @classmethod\n    def __get_defined_func_name__(cls) -> list[str]:\n        \"\"\"Get all the function names of the subclass, excluding methods starting with '_' character.\n\n        Returns:\n            list[str]: A list that contains function names of the subclass.\n        \"\"\"\n        functions = cls.__get_defined_func__()\n        return list(map(lambda x: x.__name__, functions))",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 14,
            "code_end_line": 25,
            "parent": "BaseEnv",
            "have_return": false,
            "code_content": "    def __init__(self, config: Dict[str, Any] = {}):\n        \"\"\"Initialize BaseEnv class with specified or default configuration.\n\n        Args:\n            config (Dict[str, Any], optional): A dictionary containing the configuration. Defaults to an empty dictionary.\n\n        Notes:\n            The configuration is deep copied to avoid modifications to the original object.\n        \"\"\"\n        self.config = deepcopy(CONFIG)\n        if isinstance(config, dict):\n            self.config.update(config)\n",
            "name_column": 8
        },
        "__get_all_func_name__": {
            "type": "FunctionDef",
            "name": "__get_all_func_name__",
            "md_content": "",
            "code_start_line": 28,
            "code_end_line": 35,
            "parent": "BaseEnv",
            "have_return": true,
            "code_content": "    def __get_all_func_name__(cls) -> list[str]:\n        \"\"\"Get all the function names of the class, excluding methods starting with '_' character.\n\n        Returns:\n            list[str]: A list that contains function names.\n        \"\"\"\n        return [name for name in dir(cls) \n        if not str(name).startswith('_') and callable(getattr(cls, name))]\n",
            "name_column": 8
        },
        "__get_all_func__": {
            "type": "FunctionDef",
            "name": "__get_all_func__",
            "md_content": "",
            "code_start_line": 39,
            "code_end_line": 46,
            "parent": "BaseEnv",
            "have_return": true,
            "code_content": "    def __get_all_func__(cls) -> list[Callable]:\n        \"\"\"Get all functions of the class, excluding methods starting with '__' characters.\n\n        Returns:\n            list[Callable]: A list that contains functions.\n        \"\"\"\n        func_names = cls.__get_all_func_name__()\n        return list(map(getattr, [cls]*len(func_names), func_names))\n",
            "name_column": 8
        },
        "__get_defined_func__": {
            "type": "FunctionDef",
            "name": "__get_defined_func__",
            "md_content": "",
            "code_start_line": 49,
            "code_end_line": 66,
            "parent": "BaseEnv",
            "have_return": true,
            "code_content": "    def __get_defined_func__(cls) -> list[Callable]:\n        \"\"\"Get all the functions of the subclass, excluding methods starting with '_' character.\n\n        Returns:\n            list[Callable]: A list that contains defined functions of the subclass.\n\n        Notes:\n            This method removes the parent class's methods from the functions list to \n            provide only the functions that are newly defined in the subclass.\n        \"\"\"\n        functions = cls.__get_all_func__()\n        for parent_cls in cls.__bases__:\n            if not issubclass(parent_cls, BaseEnv):\n                continue\n            parent_functions = parent_cls.__get_all_func__()\n            functions = list(filter(lambda x: x not in parent_functions, functions))\n    \n        return functions\n",
            "name_column": 8
        },
        "__get_defined_func_name__": {
            "type": "FunctionDef",
            "name": "__get_defined_func_name__",
            "md_content": "",
            "code_start_line": 69,
            "code_end_line": 76,
            "parent": "BaseEnv",
            "have_return": true,
            "code_content": "    def __get_defined_func_name__(cls) -> list[str]:\n        \"\"\"Get all the function names of the subclass, excluding methods starting with '_' character.\n\n        Returns:\n            list[str]: A list that contains function names of the subclass.\n        \"\"\"\n        functions = cls.__get_defined_func__()\n        return list(map(lambda x: x.__name__, functions))",
            "name_column": 8
        }
    },
    "ToolServer/ToolServerNode/core/tools/shell.py": {
        "async_read_pipe": {
            "type": "AsyncFunctionDef",
            "name": "async_read_pipe",
            "md_content": "",
            "code_start_line": 10,
            "code_end_line": 16,
            "parent": null,
            "have_return": true,
            "code_content": "async def async_read_pipe(pipe: asyncio.StreamReader):\n    ret = b''\n    while True:\n        try:\n            ret += await asyncio.wait_for(pipe.readline(), timeout=0.01)\n        except asyncio.TimeoutError:\n            return ret\n",
            "name_column": 10
        },
        "read_exec_proc_display": {
            "type": "AsyncFunctionDef",
            "name": "read_exec_proc_display",
            "md_content": "",
            "code_start_line": 17,
            "code_end_line": 23,
            "parent": null,
            "have_return": true,
            "code_content": "async def read_exec_proc_display(exec_proc: asyncio.subprocess.Process):\n    display = \"\"\n    for pipe, name in zip([exec_proc.stderr,exec_proc.stdout], ['stderr','stdout']):\n        ret = await async_read_pipe(pipe)\n        if ret != b'':\n            display += f'\\n{name}:\\n'+ ret.decode()\n    return display\n",
            "name_column": 10
        },
        "shell_command_executor": {
            "type": "AsyncFunctionDef",
            "name": "shell_command_executor",
            "md_content": "",
            "code_start_line": 26,
            "code_end_line": 109,
            "parent": null,
            "have_return": true,
            "code_content": "async def shell_command_executor(command: str = '', run_async: bool = False, shell_id: int = None, kill:bool = False):\n    \"\"\"The shell tool that execute shell command in root privilege, return the output and error. \n    You can use this tool to install packages, download files, run programs, etc.\n    Set run_async=True to run the command in a new thread and return instantly if your command is time costly like install packages, host services. \n    Example:\n    ```\n    In: shell_command_executor(command='echo \"hello world\"')\n    Out: \"hello world\"\n    In: shell_command_executor(command='sleep 10', run_async=True)\n    Out: {'shell_id': 0} # You can use this id to read the output and error later.\n    In: shell_command_executor(shell_id=0, kill=True)\n    Out: \"\" # The shell 0 will be killed.\n    ```\n\n    :param string? command: The shell command to be executed, must avoid command requiring additional user input. Default is empty string.\n    :param boolean? run_async: Whether to run the command asynchronously, default is False. If True, call this tool again with shell_id to get the final output and error. \n    :param integer? shell_id: The id of shell to execute command, default is None, which means running in a new shell. Change this to execute command in the same shell.\n    :param boolean? kill: If True, kill the shell which runs the command after execution. Default is False. Don't use any other kill command!\n    \"\"\"\n    if shell_id is not None:\n        exec_proc = ALL_SHELLS.get(shell_id, None)\n        if exec_proc is None:\n            raise ToolExecutionError(\n                {'Error': 'Shell not found or has been closed.'})\n        if exec_proc.returncode is not None:\n            print(exec_proc.returncode)\n            ALL_SHELLS.pop(shell_id)\n            raise ToolExecutionError({'Error': 'Shell has been closed.'})\n\n    else:\n        exec_proc = await asyncio.create_subprocess_shell(\n            'bash',\n            stderr=asyncio.subprocess.PIPE,\n            stdout=asyncio.subprocess.PIPE,\n            stdin=asyncio.subprocess.PIPE,\n            cwd=CONFIG['filesystem']['work_directory'])\n        shell_id = max(ALL_SHELLS.keys(), default=-1) + 1\n        ALL_SHELLS[shell_id] = exec_proc\n\n    if not run_async:\n        try:\n            ret = await asyncio.wait_for(exec_proc.communicate(command.encode()), timeout=CONFIG['shell']['timeout'])\n        except asyncio.TimeoutError:\n            des = \"Timeout while executing command.\"\n            if kill:\n                des += \" Shell has been killed.\"\n                exec_proc.kill()\n            display = await read_exec_proc_display(exec_proc)\n            if display != \"\":\n                des += \" But get some response:\" + display\n                \n            raise ToolExecutionError(des)\n            \n        ALL_SHELLS.pop(shell_id)\n\n        result = {\n            'ReturnCode': exec_proc.returncode,\n            'display': ''\n        }\n        if ret[1] != b'':\n            result['display'] += f'\\nstderr:\\n'+ret[1].decode()\n        if ret[0] != b'':\n            result['display'] = f'\\nstdout:\\n'+ret[0].decode()\n            \n        if result['ReturnCode'] != 0 and not kill:\n            raise ToolExecutionError(result)\n        return result\n    else:\n        if command[-1] != '\\n':\n            command += '\\n'\n        exec_proc.stdin.write(command.encode())\n        await exec_proc.stdin.drain()\n        await asyncio.sleep(5)\n        result = {'shell_id': shell_id , 'display':await read_exec_proc_display(exec_proc)}\n        if result['display'] == \"\":\n            await asyncio.sleep(30)\n            result['display'] = await read_exec_proc_display(exec_proc)\n        if kill:\n            exec_proc.kill()\n            ALL_SHELLS.pop(shell_id)\n            result['status'] = 'shell thread has been killed'\n        else:\n            result['status'] = 'shell still running, no return code'\n        return result\n",
            "name_column": 10
        }
    },
    "ToolServer/ToolServerNode/core/tools/__init__.py": {},
    "ToolServer/ToolServerNode/core/register/wrapper.py": {
        "generate_tool_labels": {
            "type": "FunctionDef",
            "name": "generate_tool_labels",
            "md_content": "",
            "code_start_line": 14,
            "code_end_line": 83,
            "parent": null,
            "have_return": true,
            "code_content": "def generate_tool_labels(\n    name: str = None,\n    enabled: bool = True,\n    disabled_reason: Optional[str] = None,\n    func: Callable[..., Any] = None,\n    visible:bool = True,\n)->Union[ToolLabels,None]:\n    \"\"\"\n    Generate and return tool labels for the provided function. If the tool is not enabled,\n    then a debug log message is printed and None is returned.\n\n    Args:\n        name (str, optional): The name of the tool. If it's not specified, the function's name is used.\n        enabled (bool, optional): Determines if the tool is enabled or not. Defaults to True.\n        disabled_reason (Optional[str], optional): The reason why the tool is disabled. Defaults to None.\n        func (Callable[..., Any], optional): The function for which the tool labels are generated. Defaults to None.\n        visible(bool, optional): The visibility status of the tool. Defaults to True.\n\n    Returns:\n        Union[ToolLabels,None]: A ToolLabels object containing tool information or None if tool is not enabled. \n    \"\"\"\n\n    if not enabled:\n        if disabled_reason is not None:\n            logger.debug(f\"tool '{func.__name__}' is disabled: {disabled_reason}\")\n        return None\n\n    # check if the method have full annotations\n    auto_signature = {}\n    func_desc =  docstring_parser.parse(func.__doc__)\n    required = []\n    for arg in func_desc.params:\n        auto_signature[arg.arg_name] = {\n            'type':arg.type_name,           # TODO support self defined type\n            'description':arg.description,\n        }\n        if arg.default is not None:\n            auto_signature[arg.arg_name]['default'] = arg.default\n        if not arg.is_optional:\n            required.append(arg.arg_name)\n\n    # for arg in inspect.getargs(func.__code__).args:\n    #     if arg in auto_signature:\n    #         continue\n    #     if arg in ['self','cls','config','return']:\n    #         continue\n    #     # if arg not in func.__annotations__:\n    #     #     raise SyntaxError(f'Signature is None and the annotation of varable {arg} in func {func.__name__} is not found!')\n    #     auto_signature[arg] = {\n    #         'type':'string',\n    #         'description':''                # TODO try to generate description\n    #     }\n\n    tool_name = func.__name__ if name is None else name\n    description = ''\n    if func_desc.short_description is not None:\n        description = func_desc.short_description\n    if func_desc.long_description is not None:\n        description += '\\n' + func_desc.long_description\n\n    return ToolLabels(\n        name=tool_name,\n        description=description,\n        method=func,\n        signature=auto_signature,\n        required=required,\n        enabled=enabled,\n        disabled_reason=disabled_reason,\n        visible=visible,\n    )\n",
            "name_column": 4
        },
        "toolwrapper": {
            "type": "FunctionDef",
            "name": "toolwrapper",
            "md_content": "",
            "code_start_line": 85,
            "code_end_line": 167,
            "parent": null,
            "have_return": true,
            "code_content": "def toolwrapper(\n    name: str = None,\n    enabled: bool = True,\n    disabled_reason: Optional[str] = None,\n    parent_tools_visible: bool = CONFIG['toolregister']['parent_tools_visible'],\n    visible:bool = True,\n)->Union[Type,Callable[..., Any]]:\n    \"\"\"The tool decorator for class, used to create tool objects from ordinary class.\"\"\"\n\n    def decorator(obj:object)->Union[Type,Callable[..., Any]]:\n        if inspect.isclass(obj):\n            cls = obj\n            cls_name = name if name is not None else cls.__name__\n            if not issubclass(cls,BaseEnv):\n                raise Exception(f'The class {cls} is not a subclass of BaseEnv!')\n            \n            description = cls.__doc__ if cls.__doc__ is not None else ''\n            if not visible:\n                description = 'Note: All tools of this env are invisible during all tools display, please check this env\\'s defination to show all tools.\\n' + description\n            \n            \n            subtools_labels = {}\n            if BaseEnv not in cls.__bases__:\n                direct_parents = [parent.__name__ for parent in cls.__bases__]\n                if not parent_tools_visible:\n                    description = f'Note: This env is subclass of {direct_parents}, and all tools of parent envs are inherited and not visible. You can try call parent tools or check this env\\'s defination to show them.\\n' + description\n                else:\n                    description = f'Note: This env is subclass of {direct_parents}, and all tools of parent envs are inherited.\\n' + description\n                for parent in cls.__bases__:\n                    if hasattr(parent,'env_labels') and isinstance(parent.env_labels,EnvLabels):\n                        subtools_labels.update(parent.env_labels.subtools_labels)\n            \n            cls_func_names = cls.__get_defined_func_name__()            \n            for func_name in cls_func_names:\n                origin_func = getattr(cls,func_name)\n                tool_labels = generate_tool_labels(\n                    name=func_name,\n                    enabled=enabled,\n                    disabled_reason=disabled_reason,\n                    func=origin_func,\n                    visible=visible)\n                if tool_labels is None:\n                    continue\n                \n                # label classmethod, staticmethod and instance method\n                #check if the function is a classmethod\n                if inspect.ismethod(origin_func) and not inspect.isfunction(origin_func):\n                    tool_labels.func_type = 'classmethod'\n                # check if the function is a staticmethod\n                if 'self' in inspect.getargs(origin_func.__code__).args:\n                    tool_labels.func_type = 'instancemethod'\n                else:   \n                    tool_labels.func_type = 'staticmethod'\n                \n                # tool_labels.dependent_cls = cls\n                origin_func.tool_labels = tool_labels\n                subtools_labels[tool_labels.name] = tool_labels\n            \n\n            cls.env_labels = EnvLabels(\n                name=cls_name,\n                description=description,\n                subtools_labels=subtools_labels,\n                defined_tools=cls_func_names,\n                cls=cls,\n                enabled=enabled,\n                disabled_reason=disabled_reason,\n                visible=visible\n            )\n            return cls\n        elif inspect.isfunction(obj):\n            func = obj\n            tool_labels = generate_tool_labels(\n                name=name,\n                enabled=enabled, \n                disabled_reason=disabled_reason,\n                func=func,\n                visible=visible)\n            func.tool_labels = tool_labels\n            return func\n        else:\n            raise NotImplementedError(f'Object with type {type(obj)} not recognized!')\n    return decorator\n",
            "name_column": 4
        },
        "decorator": {
            "type": "FunctionDef",
            "name": "decorator",
            "md_content": "",
            "code_start_line": 94,
            "code_end_line": 166,
            "parent": "toolwrapper",
            "have_return": true,
            "code_content": "    def decorator(obj:object)->Union[Type,Callable[..., Any]]:\n        if inspect.isclass(obj):\n            cls = obj\n            cls_name = name if name is not None else cls.__name__\n            if not issubclass(cls,BaseEnv):\n                raise Exception(f'The class {cls} is not a subclass of BaseEnv!')\n            \n            description = cls.__doc__ if cls.__doc__ is not None else ''\n            if not visible:\n                description = 'Note: All tools of this env are invisible during all tools display, please check this env\\'s defination to show all tools.\\n' + description\n            \n            \n            subtools_labels = {}\n            if BaseEnv not in cls.__bases__:\n                direct_parents = [parent.__name__ for parent in cls.__bases__]\n                if not parent_tools_visible:\n                    description = f'Note: This env is subclass of {direct_parents}, and all tools of parent envs are inherited and not visible. You can try call parent tools or check this env\\'s defination to show them.\\n' + description\n                else:\n                    description = f'Note: This env is subclass of {direct_parents}, and all tools of parent envs are inherited.\\n' + description\n                for parent in cls.__bases__:\n                    if hasattr(parent,'env_labels') and isinstance(parent.env_labels,EnvLabels):\n                        subtools_labels.update(parent.env_labels.subtools_labels)\n            \n            cls_func_names = cls.__get_defined_func_name__()            \n            for func_name in cls_func_names:\n                origin_func = getattr(cls,func_name)\n                tool_labels = generate_tool_labels(\n                    name=func_name,\n                    enabled=enabled,\n                    disabled_reason=disabled_reason,\n                    func=origin_func,\n                    visible=visible)\n                if tool_labels is None:\n                    continue\n                \n                # label classmethod, staticmethod and instance method\n                #check if the function is a classmethod\n                if inspect.ismethod(origin_func) and not inspect.isfunction(origin_func):\n                    tool_labels.func_type = 'classmethod'\n                # check if the function is a staticmethod\n                if 'self' in inspect.getargs(origin_func.__code__).args:\n                    tool_labels.func_type = 'instancemethod'\n                else:   \n                    tool_labels.func_type = 'staticmethod'\n                \n                # tool_labels.dependent_cls = cls\n                origin_func.tool_labels = tool_labels\n                subtools_labels[tool_labels.name] = tool_labels\n            \n\n            cls.env_labels = EnvLabels(\n                name=cls_name,\n                description=description,\n                subtools_labels=subtools_labels,\n                defined_tools=cls_func_names,\n                cls=cls,\n                enabled=enabled,\n                disabled_reason=disabled_reason,\n                visible=visible\n            )\n            return cls\n        elif inspect.isfunction(obj):\n            func = obj\n            tool_labels = generate_tool_labels(\n                name=name,\n                enabled=enabled, \n                disabled_reason=disabled_reason,\n                func=func,\n                visible=visible)\n            func.tool_labels = tool_labels\n            return func\n        else:\n            raise NotImplementedError(f'Object with type {type(obj)} not recognized!')\n",
            "name_column": 8
        }
    },
    "ToolServer/ToolServerNode/core/register/register.py": {
        "get_func_name": {
            "type": "FunctionDef",
            "name": "get_func_name",
            "md_content": "",
            "code_start_line": 16,
            "code_end_line": 26,
            "parent": null,
            "have_return": true,
            "code_content": "def get_func_name(func:Callable,env:BaseEnv=None)->str:\n    if env is None or not hasattr(env,'env_labels'):\n        if hasattr(func,'tool_labels'):\n            return func.tool_labels.name\n        else:\n            return func.__name__\n    else:\n        if hasattr(func,'tool_labels'):\n            return env.env_labels.name + '_' + func.tool_labels.name\n        else:\n            return env.env_labels.name + '_' + func.__name__\n",
            "name_column": 4
        },
        "ToolRegister": {
            "type": "ClassDef",
            "name": "ToolRegister",
            "md_content": "",
            "code_start_line": 29,
            "code_end_line": 204,
            "parent": null,
            "have_return": true,
            "code_content": "class ToolRegister:\n    def __init__(self,\n                 config:dict = {},\n                 ):\n        self.config = deepcopy(CONFIG)\n        for k in config:\n            self.config[k] = config[k]\n        self.toolregister_cfg = self.config['toolregister']\n        self.tool_creation_doc = open(self.toolregister_cfg['tool_creation_doc']).read()\n        self.tool_creation_context = {}\n        self.tool_creation_context_load_code = []\n        for k in self.toolregister_cfg['tool_creation_context']:\n            # load\n            load_code = f\"from {self.toolregister_cfg['tool_creation_context'][k]} import {k}\"\n            exec(load_code)\n            self.tool_creation_context[k] = eval(k)\n            self.tool_creation_context_load_code.append(load_code)\n        # load modules\n        self.tools = {}\n        self.envs = {}\n        for module_name in ['core.envs','core.tools']:            \n            sub_modules = importlib.import_module(module_name).__all__\n            for module in sub_modules:\n                for attr_name in dir(module):\n                    attr = getattr(module,attr_name)\n                    self.check_and_register(attr)\n            \n        # load extensions\n        if 'enabled_extensions' in self.config.cfg and isinstance(self.config['enabled_extensions'],list):\n            for extension in self.config['enabled_extensions']:\n                self.dynamic_extension_load(extension)\n        \n        logger.info(f'Loaded {len(self.tools)} tools and {len(self.envs)} envs!')\n        # print(self.tools)\n    def check_and_register(self,attr:Any):\n        if hasattr(attr,'tool_labels') and isinstance(attr.tool_labels,ToolLabels):\n            tool_name = get_func_name(attr)\n            if tool_name in self.tools:\n                logger.warning(f'Tool {tool_name} is replicated! The new one will be replaced!')\n                return None\n            \n            self.tools[tool_name] = attr\n            logger.info(f'Register tool {tool_name}!')\n            return attr\n            \n        if hasattr(attr,'env_labels') and isinstance(attr.env_labels,EnvLabels):\n            # attr is a cls, need get instance\n            if attr.env_labels.name in self.envs:\n                return\n            if not issubclass(attr,BaseEnv):\n                raise Exception(f'The env {attr.env_labels.name} is not a subclass of BaseEnv!')\n            env = attr(config=self.config.dict())\n            env_tools = {}\n            \n            if self.toolregister_cfg['parent_tools_visible']:\n                func_names = env.__get_all_func_name__()\n            else:\n                func_names = env.__get_defined_func_name__()\n            \n            for func_name in func_names:\n                func = getattr(env,func_name)\n                if hasattr(func,'tool_labels'):\n                    env_tools[get_func_name(func,env)] = func\n            \n            env_keys = set(env_tools.keys())\n            tools_keys = set(self.tools.keys())\n            if env_keys & tools_keys:\n                logger.warning(f'Env {env.env_labels.name} has tools with same name as other tools! The new one will be ignored!')\n                for tool_name in env_keys & tools_keys:\n                    env_tools.pop(tool_name)\n\n            self.tools.update(env_tools)\n            \n            self.envs[attr.env_labels.name] = env\n            logger.info(f'Register env {env.env_labels.name} with {len(env_tools)} tools!')\n            \n            return env\n            \n        return None\n\n    def register_tool(self,tool_name:str,code:str)->str:\n        try:\n            exec(code,self.tool_creation_context)\n        except Exception as e:\n            error_report =  traceback.format_exc()\n            logger.error(error_report)\n            raise ToolRegisterError(f'Failed to execute new tool code: {e}\\n\\n' + error_report,tool_name=tool_name)\n        \n        try:\n            tool_func = eval(tool_name,self.tool_creation_context)\n        except:\n            raise ToolRegisterError(f'Failed to find tool, please verify the tool_name!',tool_name=tool_name)\n        \n        tool_func = self.check_and_register(tool_func)\n        if tool_func is None:\n            raise ToolRegisterError(f'Tool: {tool_name} has no labels or replicated! Ensuring wrap the tool with `@toolwrapper()`.',tool_name=tool_name)\n        \n        # write the tool into file under extensions/tools\n        code = '\\n'.join(self.tool_creation_context_load_code) +'\\n# Tool Creation Context Load Ended.\\n'+ code\n        tool_file = f'extensions/tools/{tool_name}.py'\n        with open(tool_file,'w') as f:\n            f.write(code)\n        \n        return self.get_tool_dict(tool_name)\n    \n    def dynamic_extension_load(self,extension:str)->bool:\n        '''Load extension dynamically.\n        \n        :param string extension: The load path of the extension.\n        :return boolean: True if success, False if failed.\n        '''\n        try:\n            module = importlib.import_module(extension)\n            for attr_name in dir(module):\n                attr = getattr(module,attr_name)\n                self.check_and_register(attr)\n        except Exception as e:\n            logger.error(f'Failed to load extension {extension}! Exception: {e}')\n            # logger.error(traceback.format_exc())\n            return False\n        \n        return True\n        \n    def get_tool_dict(self,tool_name:str)->dict:\n        return self[tool_name].tool_labels.dict(name_overwrite=tool_name)\n    \n    def get_env_dict(self,env_name:str)->dict:\n        if env_name not in self.envs:\n            raise EnvNotFound(env_name=env_name)\n        return self.envs[env_name].env_labels.dict(include_invisible=True,max_show_tools = -1)\n    \n    def get_all_envs(self)->list[dict]:\n        return [self.envs[env_name].env_labels.dict()  for env_name in self.envs]\n    \n    def get_all_tools(self,include_invisible=False)->list[str]:\n        if include_invisible:\n            return [tool_name  for tool_name in self.tools]\n        else:\n            return [tool_name  for tool_name in self.tools if self.tools[tool_name].tool_labels.visible]\n    \n    def get_all_tools_dict(self,include_invisible=False)->list[dict]:\n        return [self.tools[tool_name].tool_labels.dict(name_overwrite=tool_name)  for tool_name in self.get_all_tools(include_invisible)]\n    \n    def __getitem__(self, key)->Callable[..., Any]:\n        # two stage index, first find env, then find tool\n        if isinstance(key,str):\n            if key not in self.tools:\n                # check if the tool is a env subtool which not visible\n                try:\n                    tool_name = key.split('_')\n                    env_name = tool_name[0]\n                    tool_name = '_'.join(tool_name[1:])\n                    return self[env_name,tool_name]\n                except:\n                    if self.dynamic_extension_load(f'extensions.tools.{key}') and key in self.tools:\n                        # try to find tool in unloaded extensions\n                        return self.tools[key]\n                    else:\n                        raise ToolNotFound(tool_name=key)\n            return self.tools[key]\n        elif isinstance(key,tuple):\n            if len(key) != 2:\n                raise NotImplementedError(f'Key {key} is not valid!')\n            env_name,tool_name = key\n            if env_name not in self.envs:\n                # try to find env in unloaded extensions\n                if self.dynamic_extension_load(f'extensions.envs.{env_name}') and env_name in self.envs:\n                    env = self.envs[env_name]\n                raise EnvNotFound(env_name=env_name)\n            env = self.envs[env_name]\n            if tool_name not in env.env_labels.subtools_labels:\n                raise ToolNotFound(tool_name=env_name+'_'+tool_name)\n            else:\n                func = getattr(env,env.env_labels.subtools_labels[tool_name].method.__name__)\n                return func\n        raise NotImplementedError(f'Key {key} is not valid!')",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 30,
            "code_end_line": 61,
            "parent": "ToolRegister",
            "have_return": false,
            "code_content": "    def __init__(self,\n                 config:dict = {},\n                 ):\n        self.config = deepcopy(CONFIG)\n        for k in config:\n            self.config[k] = config[k]\n        self.toolregister_cfg = self.config['toolregister']\n        self.tool_creation_doc = open(self.toolregister_cfg['tool_creation_doc']).read()\n        self.tool_creation_context = {}\n        self.tool_creation_context_load_code = []\n        for k in self.toolregister_cfg['tool_creation_context']:\n            # load\n            load_code = f\"from {self.toolregister_cfg['tool_creation_context'][k]} import {k}\"\n            exec(load_code)\n            self.tool_creation_context[k] = eval(k)\n            self.tool_creation_context_load_code.append(load_code)\n        # load modules\n        self.tools = {}\n        self.envs = {}\n        for module_name in ['core.envs','core.tools']:            \n            sub_modules = importlib.import_module(module_name).__all__\n            for module in sub_modules:\n                for attr_name in dir(module):\n                    attr = getattr(module,attr_name)\n                    self.check_and_register(attr)\n            \n        # load extensions\n        if 'enabled_extensions' in self.config.cfg and isinstance(self.config['enabled_extensions'],list):\n            for extension in self.config['enabled_extensions']:\n                self.dynamic_extension_load(extension)\n        \n        logger.info(f'Loaded {len(self.tools)} tools and {len(self.envs)} envs!')\n",
            "name_column": 8
        },
        "check_and_register": {
            "type": "FunctionDef",
            "name": "check_and_register",
            "md_content": "",
            "code_start_line": 63,
            "code_end_line": 107,
            "parent": "ToolRegister",
            "have_return": true,
            "code_content": "    def check_and_register(self,attr:Any):\n        if hasattr(attr,'tool_labels') and isinstance(attr.tool_labels,ToolLabels):\n            tool_name = get_func_name(attr)\n            if tool_name in self.tools:\n                logger.warning(f'Tool {tool_name} is replicated! The new one will be replaced!')\n                return None\n            \n            self.tools[tool_name] = attr\n            logger.info(f'Register tool {tool_name}!')\n            return attr\n            \n        if hasattr(attr,'env_labels') and isinstance(attr.env_labels,EnvLabels):\n            # attr is a cls, need get instance\n            if attr.env_labels.name in self.envs:\n                return\n            if not issubclass(attr,BaseEnv):\n                raise Exception(f'The env {attr.env_labels.name} is not a subclass of BaseEnv!')\n            env = attr(config=self.config.dict())\n            env_tools = {}\n            \n            if self.toolregister_cfg['parent_tools_visible']:\n                func_names = env.__get_all_func_name__()\n            else:\n                func_names = env.__get_defined_func_name__()\n            \n            for func_name in func_names:\n                func = getattr(env,func_name)\n                if hasattr(func,'tool_labels'):\n                    env_tools[get_func_name(func,env)] = func\n            \n            env_keys = set(env_tools.keys())\n            tools_keys = set(self.tools.keys())\n            if env_keys & tools_keys:\n                logger.warning(f'Env {env.env_labels.name} has tools with same name as other tools! The new one will be ignored!')\n                for tool_name in env_keys & tools_keys:\n                    env_tools.pop(tool_name)\n\n            self.tools.update(env_tools)\n            \n            self.envs[attr.env_labels.name] = env\n            logger.info(f'Register env {env.env_labels.name} with {len(env_tools)} tools!')\n            \n            return env\n            \n        return None\n",
            "name_column": 8
        },
        "register_tool": {
            "type": "FunctionDef",
            "name": "register_tool",
            "md_content": "",
            "code_start_line": 109,
            "code_end_line": 132,
            "parent": "ToolRegister",
            "have_return": true,
            "code_content": "    def register_tool(self,tool_name:str,code:str)->str:\n        try:\n            exec(code,self.tool_creation_context)\n        except Exception as e:\n            error_report =  traceback.format_exc()\n            logger.error(error_report)\n            raise ToolRegisterError(f'Failed to execute new tool code: {e}\\n\\n' + error_report,tool_name=tool_name)\n        \n        try:\n            tool_func = eval(tool_name,self.tool_creation_context)\n        except:\n            raise ToolRegisterError(f'Failed to find tool, please verify the tool_name!',tool_name=tool_name)\n        \n        tool_func = self.check_and_register(tool_func)\n        if tool_func is None:\n            raise ToolRegisterError(f'Tool: {tool_name} has no labels or replicated! Ensuring wrap the tool with `@toolwrapper()`.',tool_name=tool_name)\n        \n        # write the tool into file under extensions/tools\n        code = '\\n'.join(self.tool_creation_context_load_code) +'\\n# Tool Creation Context Load Ended.\\n'+ code\n        tool_file = f'extensions/tools/{tool_name}.py'\n        with open(tool_file,'w') as f:\n            f.write(code)\n        \n        return self.get_tool_dict(tool_name)\n",
            "name_column": 8
        },
        "dynamic_extension_load": {
            "type": "FunctionDef",
            "name": "dynamic_extension_load",
            "md_content": "",
            "code_start_line": 134,
            "code_end_line": 150,
            "parent": "ToolRegister",
            "have_return": true,
            "code_content": "    def dynamic_extension_load(self,extension:str)->bool:\n        '''Load extension dynamically.\n        \n        :param string extension: The load path of the extension.\n        :return boolean: True if success, False if failed.\n        '''\n        try:\n            module = importlib.import_module(extension)\n            for attr_name in dir(module):\n                attr = getattr(module,attr_name)\n                self.check_and_register(attr)\n        except Exception as e:\n            logger.error(f'Failed to load extension {extension}! Exception: {e}')\n            # logger.error(traceback.format_exc())\n            return False\n        \n        return True\n",
            "name_column": 8
        },
        "get_tool_dict": {
            "type": "FunctionDef",
            "name": "get_tool_dict",
            "md_content": "",
            "code_start_line": 152,
            "code_end_line": 153,
            "parent": "ToolRegister",
            "have_return": true,
            "code_content": "    def get_tool_dict(self,tool_name:str)->dict:\n        return self[tool_name].tool_labels.dict(name_overwrite=tool_name)\n",
            "name_column": 8
        },
        "get_env_dict": {
            "type": "FunctionDef",
            "name": "get_env_dict",
            "md_content": "",
            "code_start_line": 155,
            "code_end_line": 158,
            "parent": "ToolRegister",
            "have_return": true,
            "code_content": "    def get_env_dict(self,env_name:str)->dict:\n        if env_name not in self.envs:\n            raise EnvNotFound(env_name=env_name)\n        return self.envs[env_name].env_labels.dict(include_invisible=True,max_show_tools = -1)\n",
            "name_column": 8
        },
        "get_all_envs": {
            "type": "FunctionDef",
            "name": "get_all_envs",
            "md_content": "",
            "code_start_line": 160,
            "code_end_line": 161,
            "parent": "ToolRegister",
            "have_return": true,
            "code_content": "    def get_all_envs(self)->list[dict]:\n        return [self.envs[env_name].env_labels.dict()  for env_name in self.envs]\n",
            "name_column": 8
        },
        "get_all_tools": {
            "type": "FunctionDef",
            "name": "get_all_tools",
            "md_content": "",
            "code_start_line": 163,
            "code_end_line": 167,
            "parent": "ToolRegister",
            "have_return": true,
            "code_content": "    def get_all_tools(self,include_invisible=False)->list[str]:\n        if include_invisible:\n            return [tool_name  for tool_name in self.tools]\n        else:\n            return [tool_name  for tool_name in self.tools if self.tools[tool_name].tool_labels.visible]\n",
            "name_column": 8
        },
        "get_all_tools_dict": {
            "type": "FunctionDef",
            "name": "get_all_tools_dict",
            "md_content": "",
            "code_start_line": 169,
            "code_end_line": 170,
            "parent": "ToolRegister",
            "have_return": true,
            "code_content": "    def get_all_tools_dict(self,include_invisible=False)->list[dict]:\n        return [self.tools[tool_name].tool_labels.dict(name_overwrite=tool_name)  for tool_name in self.get_all_tools(include_invisible)]\n",
            "name_column": 8
        },
        "__getitem__": {
            "type": "FunctionDef",
            "name": "__getitem__",
            "md_content": "",
            "code_start_line": 172,
            "code_end_line": 204,
            "parent": "ToolRegister",
            "have_return": true,
            "code_content": "    def __getitem__(self, key)->Callable[..., Any]:\n        # two stage index, first find env, then find tool\n        if isinstance(key,str):\n            if key not in self.tools:\n                # check if the tool is a env subtool which not visible\n                try:\n                    tool_name = key.split('_')\n                    env_name = tool_name[0]\n                    tool_name = '_'.join(tool_name[1:])\n                    return self[env_name,tool_name]\n                except:\n                    if self.dynamic_extension_load(f'extensions.tools.{key}') and key in self.tools:\n                        # try to find tool in unloaded extensions\n                        return self.tools[key]\n                    else:\n                        raise ToolNotFound(tool_name=key)\n            return self.tools[key]\n        elif isinstance(key,tuple):\n            if len(key) != 2:\n                raise NotImplementedError(f'Key {key} is not valid!')\n            env_name,tool_name = key\n            if env_name not in self.envs:\n                # try to find env in unloaded extensions\n                if self.dynamic_extension_load(f'extensions.envs.{env_name}') and env_name in self.envs:\n                    env = self.envs[env_name]\n                raise EnvNotFound(env_name=env_name)\n            env = self.envs[env_name]\n            if tool_name not in env.env_labels.subtools_labels:\n                raise ToolNotFound(tool_name=env_name+'_'+tool_name)\n            else:\n                func = getattr(env,env.env_labels.subtools_labels[tool_name].method.__name__)\n                return func\n        raise NotImplementedError(f'Key {key} is not valid!')",
            "name_column": 8
        }
    },
    "ToolServer/ToolServerNode/core/register/__init__.py": {},
    "ToolServer/ToolServerNode/core/envs/web.py": {
        "WebEnv": {
            "type": "ClassDef",
            "name": "WebEnv",
            "md_content": "",
            "code_start_line": 12,
            "code_end_line": 126,
            "parent": null,
            "have_return": true,
            "code_content": "class WebEnv(BaseEnv):\n    \"\"\"Web Environment providing web interface and browsering.\n    \"\"\"\n    def __init__(self,config:dict = {}):\n        super().__init__(config=config)\n        self.bing_cfg = self.config['bing']\n        if self.bing_cfg['api_key'] is None:\n            logger.warning(\"Bing API key is not provided, rollback to duckduckgo.\")\n        \n        self.web_cfg = self.config['web']\n        self.headers = {\n            \"User-Agent\":self.web_cfg['user_agent']\n        }\n        self.client = httpx.AsyncClient(headers=self.headers,verify=False,timeout=30.0,http2=True)\n\n    def _check_url_valid(self,url:str):\n        local_prefixes = [\n            \"file:///\",\n            \"file://127.0.0.1\",\n            \"file://localhost\",\n            \"http://localhost\",\n            \"https://localhost\",\n            \"http://2130706433\",\n            \"https://2130706433\",\n            \"http://127.0.0.1\",\n            \"https://127.0.0.1\",\n            \"https://0.0.0.0\",\n            \"http://0.0.0.0\",\n            \"http://0000\",\n            \"https://0000\",\n        ]\n        if any(url.startswith(prefix) for prefix in local_prefixes):\n            raise ValueError(f\"URL {url} is a local url, blocked!\")\n        if not (url.startswith(\"http\") or url.startswith(\"file\")):\n            raise ValueError(f\"URL {url} is not a http or https url, please give a valid url!\")\n        \n    async def search_and_browse(self, search_query:str,goals_to_browse:str,region:str=None,num_results = 3) -> List[str]:\n        \"\"\"Search with search tools and browse the website returned by search. Note some websites may not be accessable due to network error.\n    \n        :param string search_query: The search query.\n        :param string goals_to_browse: What's you want to find on the website returned by search. If you need more details, request it in here. Examples: 'What is latest news about deepmind?', 'What is the main idea of this article?'\n        :param string? region: The region code of the search, default to `en-US`. Available regions: `en-US`, `zh-CN`, `ja-JP`, `de-DE`, `fr-FR`, `en-GB`.\n        :return string: The results of the search.\n        \"\"\"\n        \n        api_key = self.bing_cfg[\"api_key\"]\n        endpoint = self.bing_cfg[\"endpoint\"]\n        if region is None:\n            region = 'en-US'\n        if api_key is None:\n            pages = [{\n                'name':ret['title'],\n                'snippet':ret['body'],\n                'url':ret['href']\n            } for ret in DDGS().text(search_query, region='wt-wt')]\n            \n        else:\n            result = await self.client.get(endpoint,\n                        headers={'Ocp-Apim-Subscription-Key': api_key},\n                        params={'q': search_query, 'mkt': region },\n                        timeout=10)\n            result.raise_for_status()\n            result = result.json()\n            pages = result[\"webPages\"][\"value\"]\n            \n        search_results = []\n\n        for idx in range(min(len(pages),num_results)):\n            try:\n                page = await self.browse_website(pages[idx]['url'],goals_to_browse)\n            except httpx.HTTPStatusError as e:\n                page = e.response.text\n            except Exception as e:\n                page = str(e)\n                \n            message = {\n                'name':pages[idx]['name'],\n                'snippet':pages[idx]['snippet'],\n                'page':page\n            }\n            search_results.append(message)\n\n        return search_results\n    \n    async def browse_website(self,url:str,goals_to_browse:str)->str:\n        \"\"\"Give a http or https url to browse a website and return the summarize text. Note some websites may not be accessable due to network error. This tool only return the content of give url and cannot provide any information need interaction with the website.\n        \n        :param string url: The realworld Uniform Resource Locator (web address) to scrape text from. Never provide something like \"<URL of the second news article>\", give real url!!! Example: 'https://www.deepmind.com/'\n        :param string goals_to_browse: The goals for browse the given `url` (e.g. what you want to find on webpage.). If you need more details, request it in here.\n        :return string: The content of the website, with formatted text.\n        \"\"\"\n        # self._check_url_valid(url)\n        res = await self.client.get(url)\n        if res.status_code in [301,302,307,308]:\n            res = await self.client.get(res.headers['location'])\n        else:\n            res.raise_for_status()\n        \n        soup = BeautifulSoup(res.text,\"html.parser\")\n        text = soup.get_text()\n        lines = (line.strip() for line in text.splitlines())\n        chunks = (phrase.strip() for line in lines for phrase in line.split(\"  \"))\n        text = \"\\n\".join(chunk for chunk in chunks if chunk)\n        \n        links = soup.find_all('a')\n        if len(links) > 0:\n            text += '\\n\\nLinks:\\n'\n            for link in links:\n                if link.string != None and link.get('href')!= None:\n                    # print(''.join(link.string.split()),link.get('href'))\n                    striped_link_string = link.string.strip()\n                    if striped_link_string != '' and  link.get('href').startswith('http'):\n                        text += f\"{striped_link_string} ({link.get('href')})\\n\"\n        \n        return text",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 15,
            "code_end_line": 25,
            "parent": "WebEnv",
            "have_return": false,
            "code_content": "    def __init__(self,config:dict = {}):\n        super().__init__(config=config)\n        self.bing_cfg = self.config['bing']\n        if self.bing_cfg['api_key'] is None:\n            logger.warning(\"Bing API key is not provided, rollback to duckduckgo.\")\n        \n        self.web_cfg = self.config['web']\n        self.headers = {\n            \"User-Agent\":self.web_cfg['user_agent']\n        }\n        self.client = httpx.AsyncClient(headers=self.headers,verify=False,timeout=30.0,http2=True)\n",
            "name_column": 8
        },
        "_check_url_valid": {
            "type": "FunctionDef",
            "name": "_check_url_valid",
            "md_content": "",
            "code_start_line": 27,
            "code_end_line": 46,
            "parent": "WebEnv",
            "have_return": false,
            "code_content": "    def _check_url_valid(self,url:str):\n        local_prefixes = [\n            \"file:///\",\n            \"file://127.0.0.1\",\n            \"file://localhost\",\n            \"http://localhost\",\n            \"https://localhost\",\n            \"http://2130706433\",\n            \"https://2130706433\",\n            \"http://127.0.0.1\",\n            \"https://127.0.0.1\",\n            \"https://0.0.0.0\",\n            \"http://0.0.0.0\",\n            \"http://0000\",\n            \"https://0000\",\n        ]\n        if any(url.startswith(prefix) for prefix in local_prefixes):\n            raise ValueError(f\"URL {url} is a local url, blocked!\")\n        if not (url.startswith(\"http\") or url.startswith(\"file\")):\n            raise ValueError(f\"URL {url} is not a http or https url, please give a valid url!\")\n",
            "name_column": 8
        },
        "search_and_browse": {
            "type": "AsyncFunctionDef",
            "name": "search_and_browse",
            "md_content": "",
            "code_start_line": 48,
            "code_end_line": 94,
            "parent": "WebEnv",
            "have_return": true,
            "code_content": "    async def search_and_browse(self, search_query:str,goals_to_browse:str,region:str=None,num_results = 3) -> List[str]:\n        \"\"\"Search with search tools and browse the website returned by search. Note some websites may not be accessable due to network error.\n    \n        :param string search_query: The search query.\n        :param string goals_to_browse: What's you want to find on the website returned by search. If you need more details, request it in here. Examples: 'What is latest news about deepmind?', 'What is the main idea of this article?'\n        :param string? region: The region code of the search, default to `en-US`. Available regions: `en-US`, `zh-CN`, `ja-JP`, `de-DE`, `fr-FR`, `en-GB`.\n        :return string: The results of the search.\n        \"\"\"\n        \n        api_key = self.bing_cfg[\"api_key\"]\n        endpoint = self.bing_cfg[\"endpoint\"]\n        if region is None:\n            region = 'en-US'\n        if api_key is None:\n            pages = [{\n                'name':ret['title'],\n                'snippet':ret['body'],\n                'url':ret['href']\n            } for ret in DDGS().text(search_query, region='wt-wt')]\n            \n        else:\n            result = await self.client.get(endpoint,\n                        headers={'Ocp-Apim-Subscription-Key': api_key},\n                        params={'q': search_query, 'mkt': region },\n                        timeout=10)\n            result.raise_for_status()\n            result = result.json()\n            pages = result[\"webPages\"][\"value\"]\n            \n        search_results = []\n\n        for idx in range(min(len(pages),num_results)):\n            try:\n                page = await self.browse_website(pages[idx]['url'],goals_to_browse)\n            except httpx.HTTPStatusError as e:\n                page = e.response.text\n            except Exception as e:\n                page = str(e)\n                \n            message = {\n                'name':pages[idx]['name'],\n                'snippet':pages[idx]['snippet'],\n                'page':page\n            }\n            search_results.append(message)\n\n        return search_results\n",
            "name_column": 14
        },
        "browse_website": {
            "type": "AsyncFunctionDef",
            "name": "browse_website",
            "md_content": "",
            "code_start_line": 96,
            "code_end_line": 126,
            "parent": "WebEnv",
            "have_return": true,
            "code_content": "    async def browse_website(self,url:str,goals_to_browse:str)->str:\n        \"\"\"Give a http or https url to browse a website and return the summarize text. Note some websites may not be accessable due to network error. This tool only return the content of give url and cannot provide any information need interaction with the website.\n        \n        :param string url: The realworld Uniform Resource Locator (web address) to scrape text from. Never provide something like \"<URL of the second news article>\", give real url!!! Example: 'https://www.deepmind.com/'\n        :param string goals_to_browse: The goals for browse the given `url` (e.g. what you want to find on webpage.). If you need more details, request it in here.\n        :return string: The content of the website, with formatted text.\n        \"\"\"\n        # self._check_url_valid(url)\n        res = await self.client.get(url)\n        if res.status_code in [301,302,307,308]:\n            res = await self.client.get(res.headers['location'])\n        else:\n            res.raise_for_status()\n        \n        soup = BeautifulSoup(res.text,\"html.parser\")\n        text = soup.get_text()\n        lines = (line.strip() for line in text.splitlines())\n        chunks = (phrase.strip() for line in lines for phrase in line.split(\"  \"))\n        text = \"\\n\".join(chunk for chunk in chunks if chunk)\n        \n        links = soup.find_all('a')\n        if len(links) > 0:\n            text += '\\n\\nLinks:\\n'\n            for link in links:\n                if link.string != None and link.get('href')!= None:\n                    # print(''.join(link.string.split()),link.get('href'))\n                    striped_link_string = link.string.strip()\n                    if striped_link_string != '' and  link.get('href').startswith('http'):\n                        text += f\"{striped_link_string} ({link.get('href')})\\n\"\n        \n        return text",
            "name_column": 14
        }
    },
    "ToolServer/ToolServerNode/core/envs/filesystem.py": {
        "FileSystemEnv": {
            "type": "ClassDef",
            "name": "FileSystemEnv",
            "md_content": "",
            "code_start_line": 10,
            "code_end_line": 206,
            "parent": null,
            "have_return": true,
            "code_content": "class FileSystemEnv(BaseEnv):\n    \"\"\"Provide a file system operation environment for Agent.\n    \"\"\"\n    def __init__(self, config: Dict[str, Any] = None):\n        super().__init__(config)\n        filesystem_config = self.config['filesystem']\n        \n        self.ignored_list = filesystem_config[\"ignored_list\"]\n        self.work_directory = filesystem_config[\"work_directory\"]\n        self.max_entry_nums_for_level = filesystem_config[\"max_entry_nums_for_level\"]\n        if not os.path.exists(self.work_directory):\n            os.mkdir(self.work_directory,mode=0o777)\n        \n    def _check_ignorement(self,path:str)->bool:\n        for pattern in self.ignored_list:\n            if fnmatch.fnmatch(path,pattern):\n                return True\n        return False\n    \n    def _is_path_within_workspace(self,path:str)->bool:\n        common_prefix = os.path.commonprefix([os.path.realpath(path),\n                                            os.path.realpath(self.work_directory)])\n        return common_prefix == os.path.realpath(self.work_directory)\n    \n    def _is_path_exist(self,path:str)->bool:\n        \"\"\"Check if the path exists in the workspace.\n        \n        :param string path: The path to be checked.\n        :return bool: `True` if the path exists, else `False`.\n        \"\"\"\n\n        full_path = os.path.join(self.work_directory, path)\n        if not self._is_path_within_workspace(full_path):\n            raise ValueError(f\"Path {path} is not within workspace.\")\n        return os.path.exists(full_path)\n\n    def print_filesys_struture(self,return_root=False)->str:\n        \"\"\"Return a tree-like structure for all files and folders in the workspace. Use this tool if you are not sure what files are in the workspace.\n\n        This function recursively walks through all the directories in the workspace\n        and return them in a tree-like structure, \n        displaying all the files under each directory.\n        \n        Example:\n        ```\n        - root/\n            - sub_directory1/\n                - file1.txt\n                - file2.txt\n            - sub_directory2/\n                - file3.txt\n        ```\n\n        :return string: The tree-like structure of the workspace.\n        \"\"\"\n        full_repr = ''\n        if return_root:\n            full_repr += f'Global Root Work Directory: {self.work_directory}\\n'\n\n        folder_counts =  defaultdict(lambda: 0)\n        for root, dirs, files in os.walk(self.work_directory):\n            if self._check_ignorement(root):\n                continue\n            level = root.replace(self.work_directory, '').count(os.sep)\n            indent = ' ' * 4 * (level)\n            \n            folder_counts[root] += 1\n            if folder_counts[root] > self.max_entry_nums_for_level:\n                full_repr += f'{indent}`wrapped`\\n'\n            \n            full_repr += f'{indent}- {os.path.basename(root)}/\\n'\n            \n            idx = 0\n            subindent = ' ' * 4 * (level + 1) + '- '\n            for f in files:\n                if self._check_ignorement(f):\n                    continue\n                \n                idx += 1\n                if idx > self.max_entry_nums_for_level:\n                    full_repr += f'{subindent}`wrapped`\\n'\n                    break\n                full_repr += f'{subindent}{f}\\n'\n\n\n        return full_repr\n    \n    def read_from_file(self,filepath:str,line_number:int = 1)->str:\n        \"\"\"Open and read the textual file content in the workspace, you will see the content of the target file.\n        Don't use this if the give `filepath` is writen or modified before, the content in `filepath` should be already returned.\n        \n        :param string filepath: The path to the file to be opened, always use relative path to the workspace root.\n        :param integer? line_number: The starting line number of the content to be opened. Defaults to 1.\n        :return string: The content of the file.\n        \"\"\"\n        if not filepath.startswith(self.work_directory):\n            filepath = filepath.strip('/')\n            full_path = os.path.join(self.work_directory, filepath)        \n        else:\n            full_path = filepath\n                \n        if self._check_ignorement(full_path) or not os.path.isfile(full_path):\n            raise FileNotFoundError(f\"File {filepath} not found in workspace.\")\n        if not self._is_path_within_workspace(full_path):\n            raise ValueError(f\"File {filepath} is not within workspace.\")\n        if not os.path.exists(full_path):\n            raise FileNotFoundError(f\"File {filepath} not found in workspace.\")\n\n        content = ''\n        with open(full_path, 'r') as f:\n            lines = f.readlines(int(1e5))\n            \n        read_count = 0\n        if not (abs(line_number) - 1 < len(lines)):\n            raise ValueError(f\"Line number {line_number} is out of range.\")\n        index = line_number if line_number >= 0 else len(lines) + line_number\n        if index == 0:\n            index = 1\n            \n        if line_number == 0:\n            indexed_lines = lines\n        elif line_number > 0:\n            indexed_lines = lines[line_number-1:]\n        else:\n            indexed_lines = lines[line_number:]\n            \n        for line in indexed_lines:\n            content += f'{index}'.rjust(5) + ': '\n            content += line\n            read_count += len(line)\n            index += 1\n        return content\n\n    def write_to_file(self, filepath:str,content:str,truncating:bool = False,line_number:int = None, overwrite:bool = False)->str:\n        \"\"\"Write or modify the textual file lines based on `content` provided. \n        Return updated content of the file after modification so no further need to call `read_from_file` for this file. Create file if not exists.\n        \n        Example:\n        ```\n        In[0]: write_to_file('test.txt', 'Hello World!\\\\nA new line!')\n        Out[0]: '1: Hello World!\\\\n2: A new line!'\n        In[1]: write_to_file('test.txt', 'Hello World 1!', 2)\n        Out[1]: '1: Hello World!\\\\n2: Hello World 1!\\\\n3: A new line!'\n        In[2]: write_to_file('test.txt', 'Hello World 2!', 2, overwrite=True)\n        Out[2]: '1: Hello World!\\\\n2: Hello World 2!\\\\n3: A new line!'\n        ```\n        \n        :param string filepath: The path to the file to be modified, always use relative path to the workspace root.\n        :param boolean? truncating: If `True`, the file will be truncated before writing, else will read current content before writing. Defaults to `False`.\n        :param integer? line_number: The start line to modified file. Defaults to `None`, which means insert the new content at the end of the file. So do not provide this if you want to append the new content to the file.\n        :param boolean? overwrite: If `True`, the new content will overwrite content started from `line_number` line. Defaults to `False`, which insert the new content at the `line_number` line.\n        :param string content: The new content to be replaced with the old content.\n        \"\"\"\n        if not filepath.startswith(self.work_directory):\n            filepath = filepath.strip('/')\n            full_path = os.path.join(self.work_directory, filepath)\n        else:\n            full_path = filepath\n        if not self._is_path_within_workspace(full_path) or  self._check_ignorement(full_path):\n            raise ValueError(f\"File {filepath} is not within workspace.\")\n        \n        if not os.path.exists(full_path):\n            if line_number is None or line_number==0 or line_number == 1:\n                os.makedirs(os.path.split(full_path)[0],exist_ok=True)\n                open(full_path, 'w+').close()\n            else:\n                raise FileNotFoundError(f\"File {filepath} not found in workspace.\")\n        elif not os.path.isfile(full_path):\n            raise ValueError(f\"File {filepath} is not a file.\")\n            \n        # protential overflow\n        if truncating:\n            lines = []\n        else:\n            with open(full_path, 'r') as f:\n                lines = f.readlines()\n        \n        \n        new_lines = content.splitlines(keepends=True)\n        if line_number is None:\n            lines.extend(new_lines)\n        else:\n            if line_number >= 1:\n                line_number -= 1\n            if overwrite:\n                lines[line_number: line_number+len(new_lines)] = new_lines\n            else:\n                lines[line_number: line_number] = new_lines \n\n        for idx, _ in enumerate(lines):\n            if not lines[idx].endswith('\\n'):\n                lines[idx] += '\\n'\n                \n        with open(full_path, 'w+') as f:\n            f.writelines(lines)\n            \n        return self.read_from_file(filepath)\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 13,
            "code_end_line": 21,
            "parent": "FileSystemEnv",
            "have_return": false,
            "code_content": "    def __init__(self, config: Dict[str, Any] = None):\n        super().__init__(config)\n        filesystem_config = self.config['filesystem']\n        \n        self.ignored_list = filesystem_config[\"ignored_list\"]\n        self.work_directory = filesystem_config[\"work_directory\"]\n        self.max_entry_nums_for_level = filesystem_config[\"max_entry_nums_for_level\"]\n        if not os.path.exists(self.work_directory):\n            os.mkdir(self.work_directory,mode=0o777)\n",
            "name_column": 8
        },
        "_check_ignorement": {
            "type": "FunctionDef",
            "name": "_check_ignorement",
            "md_content": "",
            "code_start_line": 23,
            "code_end_line": 27,
            "parent": "FileSystemEnv",
            "have_return": true,
            "code_content": "    def _check_ignorement(self,path:str)->bool:\n        for pattern in self.ignored_list:\n            if fnmatch.fnmatch(path,pattern):\n                return True\n        return False\n",
            "name_column": 8
        },
        "_is_path_within_workspace": {
            "type": "FunctionDef",
            "name": "_is_path_within_workspace",
            "md_content": "",
            "code_start_line": 29,
            "code_end_line": 32,
            "parent": "FileSystemEnv",
            "have_return": true,
            "code_content": "    def _is_path_within_workspace(self,path:str)->bool:\n        common_prefix = os.path.commonprefix([os.path.realpath(path),\n                                            os.path.realpath(self.work_directory)])\n        return common_prefix == os.path.realpath(self.work_directory)\n",
            "name_column": 8
        },
        "_is_path_exist": {
            "type": "FunctionDef",
            "name": "_is_path_exist",
            "md_content": "",
            "code_start_line": 34,
            "code_end_line": 44,
            "parent": "FileSystemEnv",
            "have_return": true,
            "code_content": "    def _is_path_exist(self,path:str)->bool:\n        \"\"\"Check if the path exists in the workspace.\n        \n        :param string path: The path to be checked.\n        :return bool: `True` if the path exists, else `False`.\n        \"\"\"\n\n        full_path = os.path.join(self.work_directory, path)\n        if not self._is_path_within_workspace(full_path):\n            raise ValueError(f\"Path {path} is not within workspace.\")\n        return os.path.exists(full_path)\n",
            "name_column": 8
        },
        "print_filesys_struture": {
            "type": "FunctionDef",
            "name": "print_filesys_struture",
            "md_content": "",
            "code_start_line": 46,
            "code_end_line": 95,
            "parent": "FileSystemEnv",
            "have_return": true,
            "code_content": "    def print_filesys_struture(self,return_root=False)->str:\n        \"\"\"Return a tree-like structure for all files and folders in the workspace. Use this tool if you are not sure what files are in the workspace.\n\n        This function recursively walks through all the directories in the workspace\n        and return them in a tree-like structure, \n        displaying all the files under each directory.\n        \n        Example:\n        ```\n        - root/\n            - sub_directory1/\n                - file1.txt\n                - file2.txt\n            - sub_directory2/\n                - file3.txt\n        ```\n\n        :return string: The tree-like structure of the workspace.\n        \"\"\"\n        full_repr = ''\n        if return_root:\n            full_repr += f'Global Root Work Directory: {self.work_directory}\\n'\n\n        folder_counts =  defaultdict(lambda: 0)\n        for root, dirs, files in os.walk(self.work_directory):\n            if self._check_ignorement(root):\n                continue\n            level = root.replace(self.work_directory, '').count(os.sep)\n            indent = ' ' * 4 * (level)\n            \n            folder_counts[root] += 1\n            if folder_counts[root] > self.max_entry_nums_for_level:\n                full_repr += f'{indent}`wrapped`\\n'\n            \n            full_repr += f'{indent}- {os.path.basename(root)}/\\n'\n            \n            idx = 0\n            subindent = ' ' * 4 * (level + 1) + '- '\n            for f in files:\n                if self._check_ignorement(f):\n                    continue\n                \n                idx += 1\n                if idx > self.max_entry_nums_for_level:\n                    full_repr += f'{subindent}`wrapped`\\n'\n                    break\n                full_repr += f'{subindent}{f}\\n'\n\n\n        return full_repr\n",
            "name_column": 8
        },
        "read_from_file": {
            "type": "FunctionDef",
            "name": "read_from_file",
            "md_content": "",
            "code_start_line": 97,
            "code_end_line": 141,
            "parent": "FileSystemEnv",
            "have_return": true,
            "code_content": "    def read_from_file(self,filepath:str,line_number:int = 1)->str:\n        \"\"\"Open and read the textual file content in the workspace, you will see the content of the target file.\n        Don't use this if the give `filepath` is writen or modified before, the content in `filepath` should be already returned.\n        \n        :param string filepath: The path to the file to be opened, always use relative path to the workspace root.\n        :param integer? line_number: The starting line number of the content to be opened. Defaults to 1.\n        :return string: The content of the file.\n        \"\"\"\n        if not filepath.startswith(self.work_directory):\n            filepath = filepath.strip('/')\n            full_path = os.path.join(self.work_directory, filepath)        \n        else:\n            full_path = filepath\n                \n        if self._check_ignorement(full_path) or not os.path.isfile(full_path):\n            raise FileNotFoundError(f\"File {filepath} not found in workspace.\")\n        if not self._is_path_within_workspace(full_path):\n            raise ValueError(f\"File {filepath} is not within workspace.\")\n        if not os.path.exists(full_path):\n            raise FileNotFoundError(f\"File {filepath} not found in workspace.\")\n\n        content = ''\n        with open(full_path, 'r') as f:\n            lines = f.readlines(int(1e5))\n            \n        read_count = 0\n        if not (abs(line_number) - 1 < len(lines)):\n            raise ValueError(f\"Line number {line_number} is out of range.\")\n        index = line_number if line_number >= 0 else len(lines) + line_number\n        if index == 0:\n            index = 1\n            \n        if line_number == 0:\n            indexed_lines = lines\n        elif line_number > 0:\n            indexed_lines = lines[line_number-1:]\n        else:\n            indexed_lines = lines[line_number:]\n            \n        for line in indexed_lines:\n            content += f'{index}'.rjust(5) + ': '\n            content += line\n            read_count += len(line)\n            index += 1\n        return content\n",
            "name_column": 8
        },
        "write_to_file": {
            "type": "FunctionDef",
            "name": "write_to_file",
            "md_content": "",
            "code_start_line": 143,
            "code_end_line": 206,
            "parent": "FileSystemEnv",
            "have_return": true,
            "code_content": "    def write_to_file(self, filepath:str,content:str,truncating:bool = False,line_number:int = None, overwrite:bool = False)->str:\n        \"\"\"Write or modify the textual file lines based on `content` provided. \n        Return updated content of the file after modification so no further need to call `read_from_file` for this file. Create file if not exists.\n        \n        Example:\n        ```\n        In[0]: write_to_file('test.txt', 'Hello World!\\\\nA new line!')\n        Out[0]: '1: Hello World!\\\\n2: A new line!'\n        In[1]: write_to_file('test.txt', 'Hello World 1!', 2)\n        Out[1]: '1: Hello World!\\\\n2: Hello World 1!\\\\n3: A new line!'\n        In[2]: write_to_file('test.txt', 'Hello World 2!', 2, overwrite=True)\n        Out[2]: '1: Hello World!\\\\n2: Hello World 2!\\\\n3: A new line!'\n        ```\n        \n        :param string filepath: The path to the file to be modified, always use relative path to the workspace root.\n        :param boolean? truncating: If `True`, the file will be truncated before writing, else will read current content before writing. Defaults to `False`.\n        :param integer? line_number: The start line to modified file. Defaults to `None`, which means insert the new content at the end of the file. So do not provide this if you want to append the new content to the file.\n        :param boolean? overwrite: If `True`, the new content will overwrite content started from `line_number` line. Defaults to `False`, which insert the new content at the `line_number` line.\n        :param string content: The new content to be replaced with the old content.\n        \"\"\"\n        if not filepath.startswith(self.work_directory):\n            filepath = filepath.strip('/')\n            full_path = os.path.join(self.work_directory, filepath)\n        else:\n            full_path = filepath\n        if not self._is_path_within_workspace(full_path) or  self._check_ignorement(full_path):\n            raise ValueError(f\"File {filepath} is not within workspace.\")\n        \n        if not os.path.exists(full_path):\n            if line_number is None or line_number==0 or line_number == 1:\n                os.makedirs(os.path.split(full_path)[0],exist_ok=True)\n                open(full_path, 'w+').close()\n            else:\n                raise FileNotFoundError(f\"File {filepath} not found in workspace.\")\n        elif not os.path.isfile(full_path):\n            raise ValueError(f\"File {filepath} is not a file.\")\n            \n        # protential overflow\n        if truncating:\n            lines = []\n        else:\n            with open(full_path, 'r') as f:\n                lines = f.readlines()\n        \n        \n        new_lines = content.splitlines(keepends=True)\n        if line_number is None:\n            lines.extend(new_lines)\n        else:\n            if line_number >= 1:\n                line_number -= 1\n            if overwrite:\n                lines[line_number: line_number+len(new_lines)] = new_lines\n            else:\n                lines[line_number: line_number] = new_lines \n\n        for idx, _ in enumerate(lines):\n            if not lines[idx].endswith('\\n'):\n                lines[idx] += '\\n'\n                \n        with open(full_path, 'w+') as f:\n            f.writelines(lines)\n            \n        return self.read_from_file(filepath)\n",
            "name_column": 8
        }
    },
    "ToolServer/ToolServerNode/core/envs/__init__.py": {},
    "ToolServer/ToolServerNode/core/envs/pycoding.py": {
        "PythonNotebook": {
            "type": "ClassDef",
            "name": "PythonNotebook",
            "md_content": "",
            "code_start_line": 16,
            "code_end_line": 178,
            "parent": null,
            "have_return": true,
            "code_content": "class PythonNotebook(BaseEnv):\n    \"\"\"Python Notebook Environment. Provide a notebook interface to run python code.\"\"\"\n    def __init__(self, config: Dict[str, Any] = None):\n        super().__init__(config)\n        filesystem_config = self.config['filesystem']\n        \n        self.work_directory = filesystem_config[\"work_directory\"]\n        \n        self.nb_cfg = self.config['notebook']\n        \n        if not os.path.exists(self.work_directory):\n            os.mkdir(self.work_directory,mode=0o777)\n\n        # make a new notebook\n        self.nb = nbformat.v4.new_notebook(\n            metadata = {'kernelspec': {'name': 'python', 'language': 'python', 'display_name': 'python'}})\n        self.nbc = NotebookClient(self.nb,timeout=self.nb_cfg['timeout'])\n    \n    async def _running(self):\n        if self.nbc.kc is not None:\n            return await ensure_async(self.nbc.kc.is_alive())\n        return False\n    \n    async def _reset(self):\n        if await self._running():\n            await self.nbc._async_cleanup_kernel()\n        self.nbc.create_kernel_manager()\n        await self.nbc.async_start_new_kernel(cwd=self.work_directory)\n        await self.nbc.async_start_new_kernel_client()\n\n    @staticmethod\n    def _fix_escape(problematic_code: str) -> str:\n        for str_sign in ['\"', \"'\", '\"\"\"', \"'''\"]:\n\n            pattern = rf'{str_sign}(.*?){str_sign}'\n            in_line_strs = re.findall(pattern, problematic_code, re.DOTALL)\n            replaced_in_line_strs = []\n            for in_line_str in in_line_strs:\n                replaced_in_line_strs.append(in_line_str.replace('\\n', '\\\\n').replace('\\r', '\\\\r').replace('\\t', '\\\\t'))\n            for original_str, modified_str in zip(in_line_strs, replaced_in_line_strs):\n                fixed_code = problematic_code.replace(f'{str_sign}' + original_str + f'{str_sign}',\n                                                            f'{str_sign}' + modified_str + f'{str_sign}')\n\n        return fixed_code\n\n        \n    async def execute_cell(self,code:str,cell_index:int=None,reset:bool=False) -> str:\n        \"\"\"Create or replace a notebook cell and execute it, return the output.\n        Use this tool to test your idea quickly. Carefully examine the output to make sure it is what you want.\n        \n        Example:\n        ```\n        In[0]: code='print(\"hello world\")' # This will create a new cell and execute it.\n        Out[0]: ['cell_index: 0', 'hello world']\n        In[1]: code='print(\"hello world\")',cell_index=0 # This will overwrite the first cell and execute it.\n        In[2]: code='print(\"hello world\")',cell_index=-1 # This will overwrite the last cell and execute it.\n        ```\n        \n        :param string code: python code to be executed, make sure it is valid python code with right format. don't provide shell command that started with '!' here.\n        :param integer? cell_index: the index of the cell to be insert and overwrite `code`, default to `None`, which means append new cell.\n        :param boolean? reset: whether to reset the kernel before executing the code. Default to `False`.\n        :return string: execution result.\n        \"\"\"\n        # code = self._fix_escape(code)\n        if reset or not await self._running():\n            await self._reset()\n        if cell_index is None or cell_index == len(self.nb.cells) or len(self.nb.cells) == 0:\n            self.nb.cells.append(nbformat.v4.new_code_cell(code))\n            cell_index = len(self.nb.cells)-1\n        else:\n            self.nb.cells[cell_index] = nbformat.v4.new_code_cell(code)\n        \n        try:\n            await self.nbc.async_execute_cell(self.nb.cells[-1],len(self.nb.cells)-1)\n        except CellExecutionError as e:\n            pass\n        except DeadKernelError as e:\n            await self._reset()\n            \n        nbformat.write(self.nb,os.path.join(self.work_directory,self.nb_cfg['save_name']))\n        \n        return self._format_outputs(self.nb.cells[cell_index].outputs,cell_index,reraise=True,return_binary=True)\n        \n    def print_notebook(self)->str:\n        \"\"\"print all notebook cells' content and output.\n        \n        :return string: all notebook cells description.\n        \"\"\"\n        ret = ''\n        for i,cell in enumerate(self.nb.cells):\n            ret += f'= Cell {i} =\\n'\n            if cell['cell_type'] == 'code':\n                ret += f'{cell[\"source\"]}\\n'\n                if len(cell['outputs']) != 0:\n                    ret += f'= Output {i} =\\n'\n                    ret += f'{self._format_outputs(cell[\"outputs\"])}\\n'\n        return ret\n    def _format_outputs(self,outputs,cell_index=None,reraise=False,return_binary=False):\n        ret = None\n        if len(outputs) == 0:\n            ret = '' if cell_index is None else f'cell_index: {cell_index}'\n        elif len(outputs) == 1:\n            if cell_index is not None:\n                ret = {\n                    'type':'composite',\n                    'data':[\n                        f'cell_index: {cell_index}',\n                        self._format_output(outputs[0],cell_index,reraise,return_binary)\n                    ]\n                }\n            else:\n                ret = self._format_output(outputs[0],cell_index,reraise,return_binary)\n        else:\n            ret = {\n                'type':'composite',\n                'data':[\n                    self._format_output(output,cell_index,reraise,return_binary) for output in outputs\n                ]\n            }\n            if cell_index is not None:\n                ret['data'].insert(0,f'cell_index: {cell_index}')\n        return ret\n        \n    def _format_output(self,output,cell_index=None,reraise=False,return_binary=False):\n        def format_single_data(data,data_type:str):\n            if data_type.startswith('image/'):\n                return {\n                    'type': 'binary',\n                    'media_type':data_type,\n                    'data': data if return_binary else '`Wrapped`'\n                }\n            elif data_type.startswith('text/'):\n                return ''.join(data)\n            elif data_type.startswith('application/'):\n                return data\n            return data\n            \n        ret = None\n        match output['output_type']:\n            case 'execute_result' | 'display_data':\n                keys = list(output['data'].keys())\n                if 'text/html' in keys and 'text/plain' in keys:\n                    keys.remove('text/html') # remove html\n                if len(keys) == 1:\n                    ret = format_single_data(output['data'][keys[0]],keys[0])\n                elif len(keys) > 1:\n                    ret = {\n                        'type': 'composite',\n                        'data':[]\n                    }\n                    for k in keys:\n                        ret['data'].append(format_single_data(output['data'][k],k))\n                    \n            case 'error':\n                if reraise:\n                    raise ToolExecutionError(f'cell_index: {cell_index}\\n'+'\\n'.join(output['traceback']))\n                else:\n                    return '\\n'.join(output['traceback'])\n            case 'stream':\n                ret = output['text']\n            case _:\n                ret = output\n        return ret\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 18,
            "code_end_line": 32,
            "parent": "PythonNotebook",
            "have_return": false,
            "code_content": "    def __init__(self, config: Dict[str, Any] = None):\n        super().__init__(config)\n        filesystem_config = self.config['filesystem']\n        \n        self.work_directory = filesystem_config[\"work_directory\"]\n        \n        self.nb_cfg = self.config['notebook']\n        \n        if not os.path.exists(self.work_directory):\n            os.mkdir(self.work_directory,mode=0o777)\n\n        # make a new notebook\n        self.nb = nbformat.v4.new_notebook(\n            metadata = {'kernelspec': {'name': 'python', 'language': 'python', 'display_name': 'python'}})\n        self.nbc = NotebookClient(self.nb,timeout=self.nb_cfg['timeout'])\n",
            "name_column": 8
        },
        "_running": {
            "type": "AsyncFunctionDef",
            "name": "_running",
            "md_content": "",
            "code_start_line": 34,
            "code_end_line": 37,
            "parent": "PythonNotebook",
            "have_return": true,
            "code_content": "    async def _running(self):\n        if self.nbc.kc is not None:\n            return await ensure_async(self.nbc.kc.is_alive())\n        return False\n",
            "name_column": 14
        },
        "_reset": {
            "type": "AsyncFunctionDef",
            "name": "_reset",
            "md_content": "",
            "code_start_line": 39,
            "code_end_line": 44,
            "parent": "PythonNotebook",
            "have_return": false,
            "code_content": "    async def _reset(self):\n        if await self._running():\n            await self.nbc._async_cleanup_kernel()\n        self.nbc.create_kernel_manager()\n        await self.nbc.async_start_new_kernel(cwd=self.work_directory)\n        await self.nbc.async_start_new_kernel_client()\n",
            "name_column": 14
        },
        "_fix_escape": {
            "type": "FunctionDef",
            "name": "_fix_escape",
            "md_content": "",
            "code_start_line": 47,
            "code_end_line": 59,
            "parent": "PythonNotebook",
            "have_return": true,
            "code_content": "    def _fix_escape(problematic_code: str) -> str:\n        for str_sign in ['\"', \"'\", '\"\"\"', \"'''\"]:\n\n            pattern = rf'{str_sign}(.*?){str_sign}'\n            in_line_strs = re.findall(pattern, problematic_code, re.DOTALL)\n            replaced_in_line_strs = []\n            for in_line_str in in_line_strs:\n                replaced_in_line_strs.append(in_line_str.replace('\\n', '\\\\n').replace('\\r', '\\\\r').replace('\\t', '\\\\t'))\n            for original_str, modified_str in zip(in_line_strs, replaced_in_line_strs):\n                fixed_code = problematic_code.replace(f'{str_sign}' + original_str + f'{str_sign}',\n                                                            f'{str_sign}' + modified_str + f'{str_sign}')\n\n        return fixed_code\n",
            "name_column": 8
        },
        "execute_cell": {
            "type": "AsyncFunctionDef",
            "name": "execute_cell",
            "md_content": "",
            "code_start_line": 62,
            "code_end_line": 97,
            "parent": "PythonNotebook",
            "have_return": true,
            "code_content": "    async def execute_cell(self,code:str,cell_index:int=None,reset:bool=False) -> str:\n        \"\"\"Create or replace a notebook cell and execute it, return the output.\n        Use this tool to test your idea quickly. Carefully examine the output to make sure it is what you want.\n        \n        Example:\n        ```\n        In[0]: code='print(\"hello world\")' # This will create a new cell and execute it.\n        Out[0]: ['cell_index: 0', 'hello world']\n        In[1]: code='print(\"hello world\")',cell_index=0 # This will overwrite the first cell and execute it.\n        In[2]: code='print(\"hello world\")',cell_index=-1 # This will overwrite the last cell and execute it.\n        ```\n        \n        :param string code: python code to be executed, make sure it is valid python code with right format. don't provide shell command that started with '!' here.\n        :param integer? cell_index: the index of the cell to be insert and overwrite `code`, default to `None`, which means append new cell.\n        :param boolean? reset: whether to reset the kernel before executing the code. Default to `False`.\n        :return string: execution result.\n        \"\"\"\n        # code = self._fix_escape(code)\n        if reset or not await self._running():\n            await self._reset()\n        if cell_index is None or cell_index == len(self.nb.cells) or len(self.nb.cells) == 0:\n            self.nb.cells.append(nbformat.v4.new_code_cell(code))\n            cell_index = len(self.nb.cells)-1\n        else:\n            self.nb.cells[cell_index] = nbformat.v4.new_code_cell(code)\n        \n        try:\n            await self.nbc.async_execute_cell(self.nb.cells[-1],len(self.nb.cells)-1)\n        except CellExecutionError as e:\n            pass\n        except DeadKernelError as e:\n            await self._reset()\n            \n        nbformat.write(self.nb,os.path.join(self.work_directory,self.nb_cfg['save_name']))\n        \n        return self._format_outputs(self.nb.cells[cell_index].outputs,cell_index,reraise=True,return_binary=True)\n",
            "name_column": 14
        },
        "print_notebook": {
            "type": "FunctionDef",
            "name": "print_notebook",
            "md_content": "",
            "code_start_line": 99,
            "code_end_line": 112,
            "parent": "PythonNotebook",
            "have_return": true,
            "code_content": "    def print_notebook(self)->str:\n        \"\"\"print all notebook cells' content and output.\n        \n        :return string: all notebook cells description.\n        \"\"\"\n        ret = ''\n        for i,cell in enumerate(self.nb.cells):\n            ret += f'= Cell {i} =\\n'\n            if cell['cell_type'] == 'code':\n                ret += f'{cell[\"source\"]}\\n'\n                if len(cell['outputs']) != 0:\n                    ret += f'= Output {i} =\\n'\n                    ret += f'{self._format_outputs(cell[\"outputs\"])}\\n'\n        return ret\n",
            "name_column": 8
        },
        "_format_outputs": {
            "type": "FunctionDef",
            "name": "_format_outputs",
            "md_content": "",
            "code_start_line": 113,
            "code_end_line": 137,
            "parent": "PythonNotebook",
            "have_return": true,
            "code_content": "    def _format_outputs(self,outputs,cell_index=None,reraise=False,return_binary=False):\n        ret = None\n        if len(outputs) == 0:\n            ret = '' if cell_index is None else f'cell_index: {cell_index}'\n        elif len(outputs) == 1:\n            if cell_index is not None:\n                ret = {\n                    'type':'composite',\n                    'data':[\n                        f'cell_index: {cell_index}',\n                        self._format_output(outputs[0],cell_index,reraise,return_binary)\n                    ]\n                }\n            else:\n                ret = self._format_output(outputs[0],cell_index,reraise,return_binary)\n        else:\n            ret = {\n                'type':'composite',\n                'data':[\n                    self._format_output(output,cell_index,reraise,return_binary) for output in outputs\n                ]\n            }\n            if cell_index is not None:\n                ret['data'].insert(0,f'cell_index: {cell_index}')\n        return ret\n",
            "name_column": 8
        },
        "_format_output": {
            "type": "FunctionDef",
            "name": "_format_output",
            "md_content": "",
            "code_start_line": 139,
            "code_end_line": 178,
            "parent": "PythonNotebook",
            "have_return": true,
            "code_content": "    def _format_output(self,output,cell_index=None,reraise=False,return_binary=False):\n        def format_single_data(data,data_type:str):\n            if data_type.startswith('image/'):\n                return {\n                    'type': 'binary',\n                    'media_type':data_type,\n                    'data': data if return_binary else '`Wrapped`'\n                }\n            elif data_type.startswith('text/'):\n                return ''.join(data)\n            elif data_type.startswith('application/'):\n                return data\n            return data\n            \n        ret = None\n        match output['output_type']:\n            case 'execute_result' | 'display_data':\n                keys = list(output['data'].keys())\n                if 'text/html' in keys and 'text/plain' in keys:\n                    keys.remove('text/html') # remove html\n                if len(keys) == 1:\n                    ret = format_single_data(output['data'][keys[0]],keys[0])\n                elif len(keys) > 1:\n                    ret = {\n                        'type': 'composite',\n                        'data':[]\n                    }\n                    for k in keys:\n                        ret['data'].append(format_single_data(output['data'][k],k))\n                    \n            case 'error':\n                if reraise:\n                    raise ToolExecutionError(f'cell_index: {cell_index}\\n'+'\\n'.join(output['traceback']))\n                else:\n                    return '\\n'.join(output['traceback'])\n            case 'stream':\n                ret = output['text']\n            case _:\n                ret = output\n        return ret\n",
            "name_column": 8
        },
        "format_single_data": {
            "type": "FunctionDef",
            "name": "format_single_data",
            "md_content": "",
            "code_start_line": 140,
            "code_end_line": 151,
            "parent": "_format_output",
            "have_return": true,
            "code_content": "        def format_single_data(data,data_type:str):\n            if data_type.startswith('image/'):\n                return {\n                    'type': 'binary',\n                    'media_type':data_type,\n                    'data': data if return_binary else '`Wrapped`'\n                }\n            elif data_type.startswith('text/'):\n                return ''.join(data)\n            elif data_type.startswith('application/'):\n                return data\n            return data\n",
            "name_column": 12
        }
    },
    "ToolServer/ToolServerNode/utils/retriever.py": {
        "standardizing": {
            "type": "FunctionDef",
            "name": "standardizing",
            "md_content": "",
            "code_start_line": 16,
            "code_end_line": 30,
            "parent": null,
            "have_return": true,
            "code_content": "def standardizing(string: str) -> str:\n    \"\"\"\n    Return a standardized string by replacing non-alphanumeric characters with underscores,\n    reducing multiple underscores to one, and converting all characters to lowercase.\n\n    Args:\n        string: The input string to be standardized.\n\n    Returns: \n        A standardized version of the input string.\n    \"\"\"\n    string = STANDARDIZING_PATTERN.sub(\"_\", string)\n    string = re.sub(r\"(_)\\1+\",\"_\", string)\n    string = string.strip(\"_\").lower()\n    return string\n",
            "name_column": 4
        },
        "ada_retriever": {
            "type": "FunctionDef",
            "name": "ada_retriever",
            "md_content": "",
            "code_start_line": 32,
            "code_end_line": 59,
            "parent": null,
            "have_return": true,
            "code_content": "def ada_retriever(doc_embeddings: list, id2tool:dict, question: str, top_k: int=5) -> list:\n    \"\"\"\n    Retrieve tools related to the provided question.\n\n    Args:\n        doc_embeddings: The list of document embeddings.\n        id2tool: A dictionary mapping tool id to tool name.\n        question: The question for the ADA retriever.\n        top_k: The number of top tools to return (default is 5).\n\n    Returns:\n        A list of retrieved tools.\n    \"\"\"\n    cfg = CONFIG['retriver']\n    url = cfg['endpoint']\n    headers = cfg['headers']\n    payload = {'input':question}\n    payload.update(cfg['payload'])\n    \n    response = requests.post(url, json=payload, headers=headers)\n    query_embedding = np.array(response.json()['data'][0]['embedding'])\n\n    similarities = cosine_similarity([query_embedding], doc_embeddings)\n\n    sorted_doc_indices = sorted(range(len(similarities[0])), key=lambda i: similarities[0][i], reverse=True)\n    retrieved_tools = list(map(lambda doc_id: id2tool[str(doc_id)],sorted_doc_indices[:top_k]))\n    \n    return retrieved_tools\n",
            "name_column": 4
        },
        "build_tool_embeddings": {
            "type": "FunctionDef",
            "name": "build_tool_embeddings",
            "md_content": "",
            "code_start_line": 61,
            "code_end_line": 147,
            "parent": null,
            "have_return": true,
            "code_content": "def build_tool_embeddings(tools_json: list[dict]) -> tuple:\n    \"\"\"\n    Build tool embeddings.\n\n    Args:\n        tools_json: The list of dictionaries containing tool data.\n\n    Returns:\n        A tuple containing a list of document embeddings and a dictionary\n        mapping tool id to tool name.\n    \"\"\"\n    cfg = CONFIG['retriver']\n    if os.path.exists(cfg['id2tool_file']) and os.path.exists(cfg['embedding_file']):\n        id2tool = json.load(open(cfg['id2tool_file'], \"r\"))\n        doc_embedings = np.load(cfg['embedding_file'])\n        if len(id2tool) != len(doc_embedings):\n            logger.error('Embedding file and id2tool file do not match! Rebuild embeddings!')\n            id2tool = {}\n            doc_embedings = []\n    else:\n        id2tool = {}\n        doc_embedings = []\n\n    # check embedding file whether need to be updated\n    # get all current tool names\n    # tool_names = set(map(lambda tool_json: tool_json['name'], tools_json))\n    # cached_tool_names = set(id2tool.values())\n    # if tool_names == cached_tool_names:\n    #     logger.info('No tools change, use cached embeddings!')\n    #     return doc_embedings, id2tool\n    return doc_embedings, id2tool\n    \n    # update embeddings\n    logger.info('Tools change detected, updating embeddings...')\n    url = cfg['endpoint']\n    headers = cfg['headers']\n    \n    new_id2tool = { str(i):tool_json['name'] for i,tool_json in enumerate(tools_json) }\n    json.dump(new_id2tool, open(cfg['id2tool_file'], \"w\"), indent=4)\n\n    def get_embedding(tool_json:dict) -> list:\n        \"\"\"\n        Get embedding for a certain tool.\n\n        Args:\n            tool_json: The dictionary containing tool data.\n\n        Returns:\n            A list of tool embeddings.\n        \"\"\"\n        payload = {'input':json.dumps(tool_json)}\n        payload.update(cfg['payload'])\n        try:\n            response = requests.post(url, json=payload, headers=headers)\n            response.raise_for_status()\n        except Exception as e:\n            logger.error(f'Failed to get embedding for tool {tool_json[\"name\"]}! Error: {e}')\n            return [-1.000001] * cfg['embedding_dim']\n        return response.json()['data'][0]['embedding']\n    \n    uncached_tools = list(filter(lambda tool_json: tool_json['name'] not in cached_tool_names, tools_json))\n    uncached_tools_name = list(map(lambda tool_json: tool_json['name'],uncached_tools))\n    uncached_doc_embedings = []\n    with ThreadPoolExecutor(16) as pool:\n        futures = [pool.submit(get_embedding, tool_json) for tool_json in uncached_tools]\n        \n        for future in tqdm.tqdm(futures,ncols=100):\n            uncached_doc_embedings.append(future.result())\n    \n    new_doc_embedings = []\n    for tool_json in tools_json:\n        if tool_json['name'] not in cached_tool_names:\n            new_doc_embedings.append(\n                uncached_doc_embedings[\n                    uncached_tools_name.index(tool_json['name'])\n                    ])\n        else:\n            for doc_id in id2tool.keys():\n                if id2tool[doc_id] == tool_json['name']:\n                    new_doc_embedings.append(doc_embedings[int(doc_id)])\n                    break\n\n    new_doc_embedings = np.array(new_doc_embedings)\n    np.save(cfg['embedding_file'], new_doc_embedings)\n\n    logger.info('Embeddings updated! New embeddings saved!')\n    return doc_embedings, new_id2tool",
            "name_column": 4
        },
        "get_embedding": {
            "type": "FunctionDef",
            "name": "get_embedding",
            "md_content": "",
            "code_start_line": 101,
            "code_end_line": 119,
            "parent": "build_tool_embeddings",
            "have_return": true,
            "code_content": "    def get_embedding(tool_json:dict) -> list:\n        \"\"\"\n        Get embedding for a certain tool.\n\n        Args:\n            tool_json: The dictionary containing tool data.\n\n        Returns:\n            A list of tool embeddings.\n        \"\"\"\n        payload = {'input':json.dumps(tool_json)}\n        payload.update(cfg['payload'])\n        try:\n            response = requests.post(url, json=payload, headers=headers)\n            response.raise_for_status()\n        except Exception as e:\n            logger.error(f'Failed to get embedding for tool {tool_json[\"name\"]}! Error: {e}')\n            return [-1.000001] * cfg['embedding_dim']\n        return response.json()['data'][0]['embedding']\n",
            "name_column": 8
        }
    },
    "ToolServer/ToolServerNode/utils/__init__.py": {},
    "ToolServer/ToolServerNode/utils/response.py": {
        "is_base64": {
            "type": "FunctionDef",
            "name": "is_base64",
            "md_content": "",
            "code_start_line": 6,
            "code_end_line": 20,
            "parent": null,
            "have_return": true,
            "code_content": "def is_base64(s:str) -> bool:\n    \"\"\"\n    Check if the given string is a base64 sting or not.\n\n    Args:\n        s (str): the string to be checked.\n\n    Returns:\n        bool: Returns True if the given string is a base64 string, False otherwise.\n    \"\"\"\n    try:\n        base64.b64decode(s)\n        return True\n    except:\n        return False\n",
            "name_column": 4
        },
        "is_wrapped_response": {
            "type": "FunctionDef",
            "name": "is_wrapped_response",
            "md_content": "",
            "code_start_line": 22,
            "code_end_line": 36,
            "parent": null,
            "have_return": true,
            "code_content": "def is_wrapped_response(obj:dict) -> bool:\n    \"\"\"\n    Check if the dictionary object is a wrapped response.\n    A dictionary is considered as wrapped response if it has 'type' and 'data' keys,\n    and value of 'type' key is one of ['simple','composite','binary'].\n\n    Args:\n        obj (dict): the dictionary object to be checked.\n\n    Returns:\n        bool: Returns True if the dictionary is a wrapped response, False otherwise.\n    \"\"\"\n    if 'type' in obj and obj['type'] in ['simple','composite','binary'] and 'data' in obj:\n        return True\n    return False\n",
            "name_column": 4
        },
        "wrap_tool_response": {
            "type": "FunctionDef",
            "name": "wrap_tool_response",
            "md_content": "",
            "code_start_line": 38,
            "code_end_line": 128,
            "parent": null,
            "have_return": true,
            "code_content": "def wrap_tool_response(obj:Any) -> dict|list|str|int|float|bool:\n    \"\"\"\n    Wrap the tool response in a standardized object structure (depending on its type) to allow decoding.\n    \n    Format\n    ======\n    ```\n    {\n        'type': 'simple',       # for single return value like python basic types\n        'data': obj\n    },\n    {\n        'type': 'binary',       # for single return value like python basic types\n        'media_type':'image/png',   # or other media types\n        'name': 'xxx',             # file name of the binary data\n        'data': obj             # base64 encoded binary data\n    },\n    str,int,float,bool,list is directly returned\n    or\n    {\n        'type': 'composite',    # for multiple return values\n        'data': [\n            {\n                'type': 'simple',\n                'data': obj1\n            },\n            {\n                'type': 'simple',\n                'data': obj2\n            }\n        ]\n    }\n    ```\n    Standardized Structures:\n    - For simple data types (str, int, float, bool), the object is directly returned.\n    - For composite types (tuples), data is wrapped in an object with a composite type.\n    - For binary data, data is base64 encoded and wrapped in an object with a binary type.\n     \n\n    Args:\n        obj (Any): any Python object that needs to be wrapped.\n\n    Returns:\n        Union[dict, list, str, int, float, bool]: the wrapped response.\n        \n    Raises:\n        logger.warning: raises warning if the type of 'obj' is unknown.\n    \"\"\"\n    if isinstance(obj,tuple):\n        if len(obj) == 0:\n            ret = {\n                'type': 'simple',\n                'data': None\n            }\n        elif len(obj) == 1:\n            ret = {\n                'type': 'simple',\n                'data': obj[0]\n            }\n        else:\n            ret = {\n                'type': 'composite',\n                'data': []\n            }\n            for o in obj:\n                ret['data'].append(wrap_tool_response(o))\n    elif isinstance(obj,bytes):\n        ret = {\n            'type': 'binary',\n            'media_type': 'bytes',\n            'name': None,\n            'data': base64.b64encode(obj).decode()\n        }\n    elif isinstance(obj,(str,int,float,bool,list)) or obj is None:\n        ret = obj\n    elif isinstance(obj,dict):\n        # check if already wrapped\n        if is_wrapped_response(obj):\n            ret = obj\n        else:\n            ret = {\n                'type': 'simple',\n                'data': obj\n            }\n    else:\n        logger.warning(f'Unknown type {type(obj)} in wrap_tool_response')\n        ret = {\n            'type': 'simple',\n            'data': obj\n        }\n    return ret",
            "name_column": 4
        }
    },
    "ToolServer/ToolServerNode/utils/import_helper.py": {
        "import_all_modules_in_folder": {
            "type": "FunctionDef",
            "name": "import_all_modules_in_folder",
            "md_content": "",
            "code_start_line": 3,
            "code_end_line": 20,
            "parent": null,
            "have_return": true,
            "code_content": "def import_all_modules_in_folder(file,name):\n    current_dir = os.path.dirname(file)\n    all_modules = []\n    for item in os.listdir(current_dir):\n        item_path = os.path.join(current_dir, item)\n        if os.path.isfile(item_path) and item != '__init__.py' and item.endswith('.py'):\n            module_name = item[:-3]\n        elif os.path.isdir(item_path) and item != '__pycache__' and os.path.exists(os.path.join(item_path, '__init__.py')) and os.path.isfile(os.path.join(item_path, '__init__.py')):\n            module_name = item\n        else:\n            continue\n\n        full_module_path = f\"{name}.{module_name}\"\n        # print(module_name,full_module_path)\n        imported_module = importlib.import_module(full_module_path)\n        globals()[module_name] = imported_module\n        all_modules.append(imported_module)\n    return all_modules",
            "name_column": 4
        }
    },
    "ToolServer/ToolServerNode/utils/openai.py": {
        "OpenaiPoolRequest": {
            "type": "ClassDef",
            "name": "OpenaiPoolRequest",
            "md_content": "",
            "code_start_line": 14,
            "code_end_line": 93,
            "parent": null,
            "have_return": true,
            "code_content": "class OpenaiPoolRequest:\n    \"\"\"\n    Handles all OpenAI requests by dispatching them to the API endpoints.\n\n    Attributes:\n        openai_cfg: Configuration dictionary containing OpenAI parameters.\n        pool: list of dictionaries, where each dictionary has all the required details of an endpoint.\n    \"\"\"\n    def __init__(self,):\n        \"\"\"\n        Initializes the OpenaiPoolRequest class by setting the configuration and loading the pool.\n        \"\"\"\n        self.openai_cfg = deepcopy(CONFIG['openai'])\n        \n        self.pool:List[Dict] = []\n        \n        __pool_file = self.openai_cfg['key_pool_json']\n        if os.environ.get('API_POOL_FILE',None) is not None:\n            __pool_file = os.environ.get('API_POOL_FILE')\n        \n        if os.path.exists(__pool_file):\n            self.pool = json.load(open(__pool_file))\n        \n        if os.environ.get('OPENAI_KEY',None) is not None:\n            self.pool.append({\n                'api_key':os.environ.get('OPENAI_KEY'),\n                'organization':os.environ.get('OPENAI_ORG',None),\n                'api_type':os.environ.get('OPENAI_TYPE',None),\n                'api_version':os.environ.get('OPENAI_VER',None)\n            })\n        if len(self.pool) == 0:\n            logger.warning('No openai api key found! Some functions will be disable!')\n\n    @retry(wait=wait_random_exponential(multiplier=1, max=10), stop=stop_after_attempt(5),reraise=True)\n    async def request(self,messages,**kwargs) -> Dict[str, Any]:\n        \"\"\"\n        Sends a request to the OpenAI and gets a response.\n\n        Args:\n            messages: Payload to be sent to OpenAI.\n            kwargs: Optional arguments that the function takes.\n\n        Returns:\n            A dictionary containing the response from the OpenAI.\n\n        Raises:\n            Exception: If the attempt to reach the endpoint exceed limit.\n        \"\"\"\n        \n        chat_args:dict = deepcopy(self.openai_cfg['chat_args'])\n        chat_args.update(kwargs)\n\n        item = random.choice(self.pool)\n        chat_args['api_key'] = item['api_key']\n        if 'organization' in item:\n            chat_args['organization'] = item['organization']\n        if 'api_type' in item:\n            chat_args['api_type'] = item['api_type']\n        if 'api_version' in item:\n            chat_args['api_version'] = item['api_version']\n\n        return await openai.ChatCompletion.acreate(messages=messages,**chat_args)\n    \n    async def __call__(self,messages,**kwargs) -> Dict[str, Any]:\n        \"\"\"\n        Makes a request to the OpenAI by calling the instance of the class.\n\n        Args:\n            messages: Payload to be sent to OpenAI.\n            kwargs: Optional arguments that the function takes.\n\n        Returns:\n            A dictionary containing the response from the OpenAI.\n\n        Raises:\n            Exception: If there are no API keys available in the pool.\n        \"\"\"\n        if len(self.pool)==0:\n            raise Exception('No openai api key found! OPENAI_PR Disabled!')\n        return await self.request(messages,**kwargs)\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 22,
            "code_end_line": 45,
            "parent": "OpenaiPoolRequest",
            "have_return": false,
            "code_content": "    def __init__(self,):\n        \"\"\"\n        Initializes the OpenaiPoolRequest class by setting the configuration and loading the pool.\n        \"\"\"\n        self.openai_cfg = deepcopy(CONFIG['openai'])\n        \n        self.pool:List[Dict] = []\n        \n        __pool_file = self.openai_cfg['key_pool_json']\n        if os.environ.get('API_POOL_FILE',None) is not None:\n            __pool_file = os.environ.get('API_POOL_FILE')\n        \n        if os.path.exists(__pool_file):\n            self.pool = json.load(open(__pool_file))\n        \n        if os.environ.get('OPENAI_KEY',None) is not None:\n            self.pool.append({\n                'api_key':os.environ.get('OPENAI_KEY'),\n                'organization':os.environ.get('OPENAI_ORG',None),\n                'api_type':os.environ.get('OPENAI_TYPE',None),\n                'api_version':os.environ.get('OPENAI_VER',None)\n            })\n        if len(self.pool) == 0:\n            logger.warning('No openai api key found! Some functions will be disable!')\n",
            "name_column": 8
        },
        "request": {
            "type": "AsyncFunctionDef",
            "name": "request",
            "md_content": "",
            "code_start_line": 48,
            "code_end_line": 75,
            "parent": "OpenaiPoolRequest",
            "have_return": true,
            "code_content": "    async def request(self,messages,**kwargs) -> Dict[str, Any]:\n        \"\"\"\n        Sends a request to the OpenAI and gets a response.\n\n        Args:\n            messages: Payload to be sent to OpenAI.\n            kwargs: Optional arguments that the function takes.\n\n        Returns:\n            A dictionary containing the response from the OpenAI.\n\n        Raises:\n            Exception: If the attempt to reach the endpoint exceed limit.\n        \"\"\"\n        \n        chat_args:dict = deepcopy(self.openai_cfg['chat_args'])\n        chat_args.update(kwargs)\n\n        item = random.choice(self.pool)\n        chat_args['api_key'] = item['api_key']\n        if 'organization' in item:\n            chat_args['organization'] = item['organization']\n        if 'api_type' in item:\n            chat_args['api_type'] = item['api_type']\n        if 'api_version' in item:\n            chat_args['api_version'] = item['api_version']\n\n        return await openai.ChatCompletion.acreate(messages=messages,**chat_args)\n",
            "name_column": 14
        },
        "__call__": {
            "type": "AsyncFunctionDef",
            "name": "__call__",
            "md_content": "",
            "code_start_line": 77,
            "code_end_line": 93,
            "parent": "OpenaiPoolRequest",
            "have_return": true,
            "code_content": "    async def __call__(self,messages,**kwargs) -> Dict[str, Any]:\n        \"\"\"\n        Makes a request to the OpenAI by calling the instance of the class.\n\n        Args:\n            messages: Payload to be sent to OpenAI.\n            kwargs: Optional arguments that the function takes.\n\n        Returns:\n            A dictionary containing the response from the OpenAI.\n\n        Raises:\n            Exception: If there are no API keys available in the pool.\n        \"\"\"\n        if len(self.pool)==0:\n            raise Exception('No openai api key found! OPENAI_PR Disabled!')\n        return await self.request(messages,**kwargs)\n",
            "name_column": 14
        }
    },
    "ToolServer/ToolServerNode/extensions/__init__.py": {},
    "ToolServer/ToolServerNode/extensions/tools/code_interpreter.py": {
        "run_interpreter": {
            "type": "AsyncFunctionDef",
            "name": "run_interpreter",
            "md_content": "",
            "code_start_line": 11,
            "code_end_line": 47,
            "parent": null,
            "have_return": true,
            "code_content": "async def run_interpreter(code:str=None,command:str=None,filename:str='code.py'):\n    \"\"\"The code interpreter tool that runs code and return the output.\n\n    The `code` will be written to file `filename` and the `command` will be executed in a shell.\n    Example:\n    ```\n    run_interpreter(code='print(\"hello world\")',command='python code.py')\n    ```\n\n    :param string? code: The code to be written, default to `None`, which means no code will be written to file.\n    :param string? command: The shell command to be executed should avoid requiring additional user input, default to `python {filename}`.\n    :param string? filename: The filename to be written in mode `w`, default to `code.py`.\n\n    \"\"\"\n    if code is not None and code != \"\" and filename != \"\":\n        CODE_FS.write_to_file(filename,code)\n\n    if command is None:\n        command = f'python {filename}'\n    exec_proc = await asyncio.create_subprocess_shell(\n        'bash',\n        stderr=asyncio.subprocess.PIPE,\n        stdout=asyncio.subprocess.PIPE,\n        stdin=asyncio.subprocess.PIPE,\n        cwd=CODE_FS.work_directory)\n    \n    ret = await asyncio.wait_for(exec_proc.communicate(command.encode()),timeout=CONFIG['shell']['timeout'])\n    \n    result = {\n        'ReturnCode':exec_proc.returncode,\n    }\n    if ret[1]!=b'':\n        result['Error'] = ret[1].decode()\n    if ret[0]!=b'':\n        result['Output'] = ret[0].decode()\n\n    return result\n",
            "name_column": 10
        }
    },
    "ToolServer/ToolServerNode/extensions/tools/__init__.py": {},
    "ToolServer/ToolServerNode/extensions/tools/calculator.py": {
        "calculator": {
            "type": "FunctionDef",
            "name": "calculator",
            "md_content": "",
            "code_start_line": 9,
            "code_end_line": 28,
            "parent": null,
            "have_return": true,
            "code_content": "def calculator(expression:str)->str:\n    \"\"\"It is a simple calculator, which can execute Python expressions: e.g., \"(123 + 234) / 23 * 1.5 - 8\".\n        \n    :param string expression: The python expression you requested.\n    :return string: The execution results of the expression.\n    \"\"\"\n    globals={}\n    locals={}\n    try:\n        # Wrap the code in an eval() call to return the result\n        wrapped_code = f\"__result__ = eval({repr(expression)}, globals(), locals())\"\n        exec(wrapped_code, globals, locals)\n        return locals.get('__result__', None)\n    except Exception as e:\n        try:\n        # If eval fails, attempt to exec the code without returning a result\n            exec(expression, globals, locals)\n            return \"Code executed successfully.\"\n        except Exception as e:\n            return f\"Error: {str(e)}\"\n",
            "name_column": 4
        }
    },
    "ToolServer/ToolServerNode/extensions/tools/search.py": {
        "bing_search": {
            "type": "FunctionDef",
            "name": "bing_search",
            "md_content": "",
            "code_start_line": 10,
            "code_end_line": 40,
            "parent": null,
            "have_return": true,
            "code_content": "def bing_search(query:str,region:str = None)->str|list[str]:\n    \"\"\"Return 3 most relevant results of a Bing search using the official Bing API. This tool does not provide website details, use other tools to browse website if you need.\n    \n    :param string query: The search query.\n    :param string? region: The region code of the search, default to `en-US`. Available regions: `en-US`, `zh-CN`, `ja-JP`, `en-AU`, `en-CA`, `en-GB`, `de-DE`, `en-IN`, `en-ID`, `es-ES`, `fr-FR`, `it-IT`, `en-MY`, `nl-NL`, `en-NZ`, `en-PH`, `en-SG`, `en-ZA`, `sv-SE`, `tr-TR`.\n    :return string: The results of the search.\n    \"\"\"\n    #     :param int num_results: The number of results to return.\n    \n    num_results = 3\n    endpoint = bing_cfg[\"endpoint\"]\n    api_key = bing_cfg[\"api_key\"]\n    if region is None:\n        region = 'en-US'\n    result = requests.get(endpoint, headers={'Ocp-Apim-Subscription-Key': api_key}, params={'q': query, 'mkt': region }, timeout=10)\n    result.raise_for_status()\n    result = result.json()\n\n    pages = result[\"webPages\"][\"value\"]\n    search_results = []\n\n    for idx in range(min(len(pages),num_results)):\n        message = {\n            'url':pages[idx]['url'],\n            'name':pages[idx]['name'],\n            'snippet':pages[idx]['snippet']\n        }\n        search_results.append(message)\n\n    # Return the list of search result\n    return search_results",
            "name_column": 4
        }
    },
    "ToolServer/ToolServerNode/extensions/envs/shell.py": {
        "read_pipe": {
            "type": "FunctionDef",
            "name": "read_pipe",
            "md_content": "",
            "code_start_line": 12,
            "code_end_line": 23,
            "parent": null,
            "have_return": true,
            "code_content": "def read_pipe(pipe:Union[io.StringIO,io.BytesIO],text=True)->Union[str,bytes]:\n    \"\"\"Reading the `subprocess.PIPE` when readable.\n    If `text` is `True`, return str, else return bytes.\n    \"\"\"\n    output = '' if text else b''\n    while True:\n        ready_fds,_,_ = select.select( [pipe.fileno()],[],[],0.01)\n        if len(ready_fds) == 0:\n            break\n        output += os.read(ready_fds[0],16384).decode() if text else os.read(ready_fds[0],16384)\n\n    return output\n",
            "name_column": 4
        },
        "ShellEnv": {
            "type": "ClassDef",
            "name": "ShellEnv",
            "md_content": "",
            "code_start_line": 26,
            "code_end_line": 129,
            "parent": null,
            "have_return": true,
            "code_content": "class ShellEnv(BaseEnv):\n    \"\"\"Provide and maintain an interactive shell environment.\n    \"\"\"\n    def __init__(self,\n                 config:Dict[str,Any]):\n        super().__init__(config)\n        \n        if sys.platform.startswith(\"linux\"):\n            self.shell_program = \"bash\"\n        elif sys.platform.startswith(\"darwin\"):\n            self.shell_program = \"zsh\"\n        else:\n            self.shell_program = \"powershell\"\n        self.work_directory = self.config['filesystem']['work_directory']\n        self._restart()\n\n    @property\n    def running(self)->bool:\n        \"\"\"`True` if shell is running, else `False`\n        \"\"\"\n        if hasattr(self,'running_proc') and isinstance(self.running_proc,subprocess.Popen):\n            if self.running_proc.poll() is None:\n                return True\n        return False\n    \n    def _restart(self,program:str=None,shell:bool=True):\n        f\"\"\"Restart the shell.\n        \n        :param string? program: The program to be executed in shell, the default is `{self.shell_program}`.\n        \"\"\"\n        self._kill()\n        if program is None:\n            program = self.shell_program\n        self.running_proc = subprocess.Popen(\n            program, # adding more shells support\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            cwd=self.work_directory,\n            shell=shell,\n            text=True\n        )\n        self.output_fileno = [self.running_proc.stdout.fileno(),self.running_proc.stderr.fileno()]\n    \n    def _terminate(self):\n        \"\"\"Terminate the shell.\n        \"\"\"\n        if self.running:\n            self.running_proc.terminate()\n\n    def _kill(self):\n        \"\"\"Kill the shell.\n        \"\"\"\n        if self.running:\n            self.running_proc.kill()\n\n    def read_stdout(self, probe: bool = False) -> str:\n        \"\"\"Read the stdout stream of the shell. If stderr is not empty, it will be returned instead.\n        \n        Empty string will be returned if both stdout and stderr are empty.\n        You can use this function to check if the shell has new content to be read for a running process takes a while.\n        \n        :param boolean? probe: If `True`, the function will return immediately if no output is ready, else it will raise `OutputNotReady` exception and request to call functions in `next_calling` to get result.\n        \"\"\"\n        if not self.running:\n            raise RuntimeError('Shell is not running!')\n        \n        ready_fds,_,_ = select.select(self.output_fileno,[],[],0.01)\n        if probe and len(ready_fds) == 0 :\n            raise OutputNotReady('Output is not ready!',next_calling=get_func_name(self.read_stdout,self),arguments={'probe':True})\n        \n        error = read_pipe(self.running_proc.stderr)\n        if error:\n            return error\n\n        return read_pipe(self.running_proc.stdout)\n    \n    \n    def write_stdin(self, content:str) -> str:\n        \"\"\"Write the stdin stream of the shell and get instant feedback from stderr or stdout.\n        \n        Example:\n        ```\n        write_stdin('echo \"hello world\"')\n        ```\n        This will execute the command `echo \"hello world\"` in shell and return the output `hello world`.\n        \n        :param string content: The content to be written.\n        \"\"\"\n\n        # removed temporarily, maybe put back later?\n        # You may need to call `read_stdout` to get further feedback for running process takes a while.\n        if not self.running:\n            raise RuntimeError('Shell is not running!')\n        if not content.endswith(\"\\n\"):\n            content += \"\\n\"\n        self.running_proc.stdin.write(content)\n        self.running_proc.stdin.flush()\n        \n        ready_fds,_,_ = select.select(self.output_fileno,[],[],0.01)\n        if len(ready_fds) == 0:\n            raise OutputNotReady('Output is not ready!',next_calling=get_func_name(self.read_stdout,self),arguments={'probe':True})\n        \n        return 'Instant shell output: ' + self.read_stdout()\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 29,
            "code_end_line": 40,
            "parent": "ShellEnv",
            "have_return": false,
            "code_content": "    def __init__(self,\n                 config:Dict[str,Any]):\n        super().__init__(config)\n        \n        if sys.platform.startswith(\"linux\"):\n            self.shell_program = \"bash\"\n        elif sys.platform.startswith(\"darwin\"):\n            self.shell_program = \"zsh\"\n        else:\n            self.shell_program = \"powershell\"\n        self.work_directory = self.config['filesystem']['work_directory']\n        self._restart()\n",
            "name_column": 8
        },
        "running": {
            "type": "FunctionDef",
            "name": "running",
            "md_content": "",
            "code_start_line": 43,
            "code_end_line": 49,
            "parent": "ShellEnv",
            "have_return": true,
            "code_content": "    def running(self)->bool:\n        \"\"\"`True` if shell is running, else `False`\n        \"\"\"\n        if hasattr(self,'running_proc') and isinstance(self.running_proc,subprocess.Popen):\n            if self.running_proc.poll() is None:\n                return True\n        return False\n",
            "name_column": 8
        },
        "_restart": {
            "type": "FunctionDef",
            "name": "_restart",
            "md_content": "",
            "code_start_line": 51,
            "code_end_line": 68,
            "parent": "ShellEnv",
            "have_return": false,
            "code_content": "    def _restart(self,program:str=None,shell:bool=True):\n        f\"\"\"Restart the shell.\n        \n        :param string? program: The program to be executed in shell, the default is `{self.shell_program}`.\n        \"\"\"\n        self._kill()\n        if program is None:\n            program = self.shell_program\n        self.running_proc = subprocess.Popen(\n            program, # adding more shells support\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            cwd=self.work_directory,\n            shell=shell,\n            text=True\n        )\n        self.output_fileno = [self.running_proc.stdout.fileno(),self.running_proc.stderr.fileno()]\n",
            "name_column": 8
        },
        "_terminate": {
            "type": "FunctionDef",
            "name": "_terminate",
            "md_content": "",
            "code_start_line": 70,
            "code_end_line": 74,
            "parent": "ShellEnv",
            "have_return": false,
            "code_content": "    def _terminate(self):\n        \"\"\"Terminate the shell.\n        \"\"\"\n        if self.running:\n            self.running_proc.terminate()\n",
            "name_column": 8
        },
        "_kill": {
            "type": "FunctionDef",
            "name": "_kill",
            "md_content": "",
            "code_start_line": 76,
            "code_end_line": 80,
            "parent": "ShellEnv",
            "have_return": false,
            "code_content": "    def _kill(self):\n        \"\"\"Kill the shell.\n        \"\"\"\n        if self.running:\n            self.running_proc.kill()\n",
            "name_column": 8
        },
        "read_stdout": {
            "type": "FunctionDef",
            "name": "read_stdout",
            "md_content": "",
            "code_start_line": 82,
            "code_end_line": 101,
            "parent": "ShellEnv",
            "have_return": true,
            "code_content": "    def read_stdout(self, probe: bool = False) -> str:\n        \"\"\"Read the stdout stream of the shell. If stderr is not empty, it will be returned instead.\n        \n        Empty string will be returned if both stdout and stderr are empty.\n        You can use this function to check if the shell has new content to be read for a running process takes a while.\n        \n        :param boolean? probe: If `True`, the function will return immediately if no output is ready, else it will raise `OutputNotReady` exception and request to call functions in `next_calling` to get result.\n        \"\"\"\n        if not self.running:\n            raise RuntimeError('Shell is not running!')\n        \n        ready_fds,_,_ = select.select(self.output_fileno,[],[],0.01)\n        if probe and len(ready_fds) == 0 :\n            raise OutputNotReady('Output is not ready!',next_calling=get_func_name(self.read_stdout,self),arguments={'probe':True})\n        \n        error = read_pipe(self.running_proc.stderr)\n        if error:\n            return error\n\n        return read_pipe(self.running_proc.stdout)\n",
            "name_column": 8
        },
        "write_stdin": {
            "type": "FunctionDef",
            "name": "write_stdin",
            "md_content": "",
            "code_start_line": 104,
            "code_end_line": 129,
            "parent": "ShellEnv",
            "have_return": true,
            "code_content": "    def write_stdin(self, content:str) -> str:\n        \"\"\"Write the stdin stream of the shell and get instant feedback from stderr or stdout.\n        \n        Example:\n        ```\n        write_stdin('echo \"hello world\"')\n        ```\n        This will execute the command `echo \"hello world\"` in shell and return the output `hello world`.\n        \n        :param string content: The content to be written.\n        \"\"\"\n\n        # removed temporarily, maybe put back later?\n        # You may need to call `read_stdout` to get further feedback for running process takes a while.\n        if not self.running:\n            raise RuntimeError('Shell is not running!')\n        if not content.endswith(\"\\n\"):\n            content += \"\\n\"\n        self.running_proc.stdin.write(content)\n        self.running_proc.stdin.flush()\n        \n        ready_fds,_,_ = select.select(self.output_fileno,[],[],0.01)\n        if len(ready_fds) == 0:\n            raise OutputNotReady('Output is not ready!',next_calling=get_func_name(self.read_stdout,self),arguments={'probe':True})\n        \n        return 'Instant shell output: ' + self.read_stdout()\n",
            "name_column": 8
        }
    },
    "ToolServer/ToolServerNode/extensions/envs/__init__.py": {},
    "ToolServer/ToolServerNode/extensions/envs/rapidapi.py": {
        "generate_arg_doc": {
            "type": "FunctionDef",
            "name": "generate_arg_doc",
            "md_content": "",
            "code_start_line": 14,
            "code_end_line": 32,
            "parent": null,
            "have_return": true,
            "code_content": "def generate_arg_doc(arg_name,arg_type,arg_desc,arg_default=None,arg_optional=None):\n    match arg_type:\n        case 'NUMBER':\n            arg_type = 'integer'\n        case 'STRING':\n            arg_type = 'string'\n        case 'BOOLEAN':\n            arg_type = 'boolean'\n        case 'ARRAY':\n            arg_type = 'array'\n        case 'OBJECT':\n            arg_type = 'object'\n\n    if arg_optional:\n        arg_type += '?'\n    if arg_default:\n        return f':param {arg_type} {arg_name}: {arg_desc} defaults to {arg_default}'\n    else:\n        return f':param {arg_type} {arg_name}: {arg_desc}'\n",
            "name_column": 4
        },
        "convert_rapidapi_desc_to_code": {
            "type": "FunctionDef",
            "name": "convert_rapidapi_desc_to_code",
            "md_content": "",
            "code_start_line": 34,
            "code_end_line": 81,
            "parent": null,
            "have_return": true,
            "code_content": "def convert_rapidapi_desc_to_code(rapidapi_desc:dict)->list[dict]:\n    tool_desc = {\n        'category':rapidapi_desc['category'],\n        'tool_name':standardizing(rapidapi_desc['tool_name']),\n    }\n    api_infos = {}\n    for api_desc in rapidapi_desc['api_list']:\n        api_name = standardizing(api_desc['name'])\n        if api_name in ['from','class','return','false','true','id','and']:\n            api_name = 'is_'+ api_name\n        api_info = {'api_name':api_name}\n        api_info.update(tool_desc)\n        \n        api_uri = '_'.join(['rapi',tool_desc['tool_name'],api_name])\n        \n        \n        args_doc = []\n        \n        for param in api_desc['required_parameters']:\n            args_doc.append(generate_arg_doc(\n                param['name'],\n                param['type'],\n                param['description'],\n                param['default'] if 'default' in param else None,\n                ))\n        \n        for param in api_desc['optional_parameters']:\n            args_doc.append(generate_arg_doc(\n                param['name'],\n                param['type'],\n                param['description'],\n                param['default'] if 'default' in param else None,\n                True))\n        \n        args_doc = '\\n    '.join(args_doc)\n        code = f\"\"\"async def {api_uri}(self,*args,**kwargs):\n    '''{rapidapi_desc['tool_description']}\n    {api_info['description'] if 'description' in api_info else ''}\n    \n\n    {args_doc}\n    '''\n    return await self._request_rapid_api('{api_uri}',kwargs)\n        \"\"\"\n        api_info['code'] = code\n        \n        api_infos[api_uri] = api_info\n    return api_infos\n",
            "name_column": 4
        },
        "rapid_api_mapper": {
            "type": "FunctionDef",
            "name": "rapid_api_mapper",
            "md_content": "",
            "code_start_line": 83,
            "code_end_line": 103,
            "parent": null,
            "have_return": true,
            "code_content": "def rapid_api_mapper(cls:Type):\n    \"\"\"Dynamic adding api functions to RapidAPIENnv.\"\"\"\n    #reading api list\n    if not os.path.exists(CONFIG['rapidapi']['api_infos_json']):\n        try:\n            api_list = json.load(open(CONFIG['rapidapi']['api_raw_json']))\n        except:\n            raise FileNotFoundError(f'Both api_infos_json and api_raw_json are not found! Failed to setup RapidAPIEnv!')\n        \n        for rapidapi_desc in api_list:\n            API_INFOS.update(convert_rapidapi_desc_to_code(rapidapi_desc))\n        \n        json.dump(API_INFOS,open(CONFIG['rapidapi']['api_infos_json'],'w'),indent=4)\n    else:\n        API_INFOS.update(json.load(open(CONFIG['rapidapi']['api_infos_json'])))\n    \n    for api_uri,api_info in API_INFOS.items():\n        exec(api_info['code'])\n        setattr(cls,api_uri,eval(api_uri))\n    \n    return cls\n",
            "name_column": 4
        },
        "RapidAPIEnv": {
            "type": "ClassDef",
            "name": "RapidAPIEnv",
            "md_content": "",
            "code_start_line": 108,
            "code_end_line": 135,
            "parent": null,
            "have_return": true,
            "code_content": "class RapidAPIEnv(BaseEnv):\n    \"\"\"RapidAPI Env delivers rapid api for tool server.\"\"\"\n    \n    def __init__(self,config:dict={}):\n        super().__init__(config=config)\n        \n        self.rapidapi_cfg = self.config['rapidapi']\n        self.api_key = self.rapidapi_cfg['api_key']\n        self.endpoint = self.rapidapi_cfg['endpoint']\n        \n        self.api_infos = deepcopy(API_INFOS)\n        \n    async def _request_rapid_api(self,api_uri:str,arguments:dict={}):\n        api_info = self.api_infos[api_uri]\n        payload = {\n            'category':api_info['category'],\n            'tool_name':api_info['tool_name'],\n            'api_name':api_info['api_name'],\n            'tool_input':arguments,\n            'strip':'truncate',\n            'toolbench_key':self.api_key\n        }\n        async with httpx.AsyncClient() as client:\n            response = await client.post(self.endpoint,json=payload,headers={'toolbench_key':self.api_key})\n        \n        response.raise_for_status()\n        \n        return response.json()\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 111,
            "code_end_line": 118,
            "parent": "RapidAPIEnv",
            "have_return": false,
            "code_content": "    def __init__(self,config:dict={}):\n        super().__init__(config=config)\n        \n        self.rapidapi_cfg = self.config['rapidapi']\n        self.api_key = self.rapidapi_cfg['api_key']\n        self.endpoint = self.rapidapi_cfg['endpoint']\n        \n        self.api_infos = deepcopy(API_INFOS)\n",
            "name_column": 8
        },
        "_request_rapid_api": {
            "type": "AsyncFunctionDef",
            "name": "_request_rapid_api",
            "md_content": "",
            "code_start_line": 120,
            "code_end_line": 135,
            "parent": "RapidAPIEnv",
            "have_return": true,
            "code_content": "    async def _request_rapid_api(self,api_uri:str,arguments:dict={}):\n        api_info = self.api_infos[api_uri]\n        payload = {\n            'category':api_info['category'],\n            'tool_name':api_info['tool_name'],\n            'api_name':api_info['api_name'],\n            'tool_input':arguments,\n            'strip':'truncate',\n            'toolbench_key':self.api_key\n        }\n        async with httpx.AsyncClient() as client:\n            response = await client.post(self.endpoint,json=payload,headers={'toolbench_key':self.api_key})\n        \n        response.raise_for_status()\n        \n        return response.json()\n",
            "name_column": 14
        }
    },
    "tests/test_run.py": {
        "mock_argv": {
            "type": "FunctionDef",
            "name": "mock_argv",
            "md_content": "**mock_argv函数**：该函数的功能是模拟命令行参数。它将sys.argv设置为模拟命令行输入，以便进行测试。\n\n该函数使用了pytest的fixture装饰器，用于在测试中模拟命令行参数。它接受一个monkeypatch参数，用于修改sys.argv的值。在函数内部，首先定义了一个包含测试参数的列表test_args，其中包括了\"--task\", \"example_task\", \"--upload-files\", \"file1\", \"file2\", \"--model\", \"model1\"等参数。然后使用monkeypatch.setattr()方法将sys.argv设置为包含了'test_script.py'和test_args的列表，以模拟命令行输入。\n\n使用该函数可以方便地在测试中模拟命令行参数，以验证代码在不同参数下的行为。\n\n**注意**：在使用该函数时，需要注意以下几点：\n- 需要安装pytest库，并使用pytest.fixture装饰器来使用该函数。\n- 需要在测试代码中导入mock_argv函数，并将其作为参数传递给测试函数。\n- 在测试函数中，可以直接使用模拟的命令行参数进行测试。",
            "code_start_line": 7,
            "code_end_line": 13,
            "parent": null,
            "have_return": false,
            "code_content": "def mock_argv(monkeypatch):\n    \"\"\"\n    A pytest fixture to mock the command line arguments.\n    It sets the sys.argv to mimic command line input for testing.\n    \"\"\"\n    test_args = [\"--task\", \"example_task\", \"--upload-files\", \"file1\", \"file2\", \"--model\", \"model1\"]\n    monkeypatch.setattr(sys, 'argv', ['test_script.py'] + test_args)\n",
            "name_column": 4
        },
        "test_parse_args": {
            "type": "FunctionDef",
            "name": "test_parse_args",
            "md_content": "**test_parse_args函数**：该函数的功能是确保parse_args函数正确解析命令行参数。\n\n在这个函数中，首先调用parse_args函数获取命令行参数，并将结果保存在args变量中。然后，使用断言语句对args中的各个参数进行验证，确保它们的值与预期相符。\n\n具体来说，使用断言语句验证args.task的值是否为\"example_task\"，如果不相符则抛出异常并输出错误信息。接着，使用断言语句验证args.upload_files的值是否为[\"file1\", \"file2\"]，如果不相符则抛出异常并输出错误信息。最后，使用断言语句验证args.model的值是否为\"model1\"，如果不相符则抛出异常并输出错误信息。\n\n**注意**：使用该函数时需要注意以下几点：\n- 确保在调用该函数之前，已经正确设置了命令行参数。\n- 如果断言失败，将会抛出异常并输出错误信息，需要根据错误信息进行相应的调试和修复。",
            "code_start_line": 15,
            "code_end_line": 22,
            "parent": null,
            "have_return": false,
            "code_content": "def test_parse_args(mock_argv):\n    \"\"\"\n    Test to ensure that the parse_args function correctly parses command line arguments.\n    \"\"\"\n    args = parse_args()\n    assert args.task == \"example_task\", \"Task argument did not match.\"\n    assert args.upload_files == [\"file1\", \"file2\"], \"Upload files argument did not match.\"\n    assert args.model == \"model1\", \"Model argument did not match.\"\n",
            "name_column": 4
        },
        "test_execute_command_line_process_quiet_mode": {
            "type": "FunctionDef",
            "name": "test_execute_command_line_process_quiet_mode",
            "md_content": "**test_execute_command_line_process_quiet_mode函数**：该函数的功能是测试execute_command_line_process函数是否正确处理'quiet_mode'参数。\n\n该函数的代码逻辑如下：\n1. 首先，通过调用parse_args函数获取命令行参数，并将结果赋值给args变量。\n2. 然后，调用execute_command_line_process函数，并将args作为参数传入，同时设置quiet_mode为True。\n3. 接下来，使用assert_called_once断言函数mock_start_command_line被调用了一次。\n4. 最后，打印\"execute_command_line_process called start_command_line in quiet mode.\"。\n\n**注意**：关于代码使用的一些注意事项：\n- 该函数主要用于测试execute_command_line_process函数在quiet_mode模式下的行为。\n- 在测试中，使用了mock_start_command_line函数来模拟start_command_line函数的调用，以便进行断言。\n- 通过设置quiet_mode为True，测试了execute_command_line_process函数在quiet_mode模式下的正确性。",
            "code_start_line": 25,
            "code_end_line": 32,
            "parent": null,
            "have_return": false,
            "code_content": "def test_execute_command_line_process_quiet_mode(mock_start_command_line, mock_argv):\n    \"\"\"\n    Test to verify if the execute_command_line_process function correctly handles the 'quiet_mode' argument.\n    \"\"\"\n    args = parse_args()\n    execute_command_line_process(args, quiet_mode=True)\n    mock_start_command_line.assert_called_once()\n    print(\"execute_command_line_process called start_command_line in quiet mode.\")\n",
            "name_column": 4
        },
        "test_execute_command_line_process_normal_mode": {
            "type": "FunctionDef",
            "name": "test_execute_command_line_process_normal_mode",
            "md_content": "**test_execute_command_line_process_normal_mode函数**: 这个函数的功能是测试execute_command_line_process函数在没有'quiet_mode'参数的情况下是否正确工作。\n\n这个函数的作用是测试execute_command_line_process函数在没有'quiet_mode'参数的情况下是否正确工作。首先，它调用parse_args函数来解析命令行参数，并将结果保存在args变量中。然后，它调用execute_command_line_process函数，并将args和quiet_mode=False作为参数传递进去。接下来，它使用mock_start_command_line.assert_called_once()来断言mock_start_command_line函数被调用了一次。最后，它打印出\"execute_command_line_process called start_command_line in normal mode.\"。\n\n**注意**: 关于代码使用的一些注意事项：\n- 这个函数主要用于测试execute_command_line_process函数在没有'quiet_mode'参数的情况下的行为。\n- 在调用execute_command_line_process函数之前，需要先调用parse_args函数来解析命令行参数。\n- 断言mock_start_command_line函数被调用了一次，以确保execute_command_line_process函数正确地调用了start_command_line函数。\n- 打印出\"execute_command_line_process called start_command_line in normal mode.\"，用于验证execute_command_line_process函数以正常模式调用了start_command_line函数。",
            "code_start_line": 35,
            "code_end_line": 42,
            "parent": null,
            "have_return": false,
            "code_content": "def test_execute_command_line_process_normal_mode(mock_start_command_line, mock_argv):\n    \"\"\"\n    Test to verify if the execute_command_line_process function behaves correctly without the 'quiet_mode' argument.\n    \"\"\"\n    args = parse_args()\n    execute_command_line_process(args, quiet_mode=False)\n    mock_start_command_line.assert_called_once()\n    print(\"execute_command_line_process called start_command_line in normal mode.\")\n",
            "name_column": 4
        },
        "test_start_command_line": {
            "type": "FunctionDef",
            "name": "test_start_command_line",
            "md_content": "**test_start_command_line函数**：该函数的功能是确保start_command_line函数根据解析的参数正确初始化CommandLine类，并使用预期的CommandLineParam实例。\n\n该函数首先解析参数args，然后调用start_command_line函数，并将args的变量作为参数传递给start_command_line函数。\n\n接下来，函数使用mock_command_line和mock_argv作为参数调用mock_command_line函数，并将返回值赋给called_args和_。\n\n然后，函数从called_args中获取第一个元素，并将其赋给called_param。\n\n最后，函数使用断言语句来检查called_param的task属性是否与args的task属性相匹配，以及upload_files属性和mode属性是否与args的upload_files属性和mode属性相匹配。如果断言失败，则会抛出异常。\n\n最后，函数打印一条消息，表示start_command_line函数被正确调用，并传递了正确的CommandLineParam参数。\n\n**注意**：关于代码使用的注意事项：\n- 该函数依赖于parse_args函数和start_command_line函数的正确实现。\n- 该函数使用了mock_command_line和mock_argv作为参数，这些参数可能需要根据具体情况进行修改。\n- 该函数使用了断言语句来检查函数的输出是否符合预期，如果断言失败，则会抛出异常。",
            "code_start_line": 45,
            "code_end_line": 58,
            "parent": null,
            "have_return": false,
            "code_content": "def test_start_command_line(mock_command_line, mock_argv):\n    \"\"\"\n    Test to ensure the start_command_line function correctly initializes the CommandLine class\n    with the expected CommandLineParam instance based on the parsed arguments.\n    \"\"\"\n    args = parse_args()\n    start_command_line(vars(args))\n\n    called_args, _ = mock_command_line.call_args\n    called_param = called_args[0]\n    assert called_param.task == args.task, \"CommandLineParam task attribute did not match.\"\n    assert called_param.upload_files == args.upload_files, \"CommandLineParam upload_files attribute did not match.\"\n    assert called_param.mode == args.mode, \"CommandLineParam mode attribute did not match.\"\n    print(\"start_command_line function called with correct CommandLineParam.\")\n",
            "name_column": 4
        }
    },
    "tests/__init__.py": {},
    "tests/test_1106_model_openai.py": {
        "test_1106_model_openai": {
            "type": "FunctionDef",
            "name": "test_1106_model_openai",
            "md_content": "**test_1106_model_openai函数**: 这个函数的功能是测试1106模型的OpenAI。\n\n在这个函数中，首先会检查openai_version的值是否大于等于\"1.0.0\"。如果是，则会进行OpenAI客户端和响应的模拟。使用mock.patch方法来模拟OpenAI客户端，并返回模拟的客户端和响应。然后，模拟响应的model_dump()方法，将其返回值设置为一个包含一个字典的字典，其中choices列表中包含一个字典，字典中包含了\"finish_reason\"、\"index\"和\"message\"等键值对。接下来，调用chatcompletion_request函数，传入model和prompt参数，获取响应结果。最后，使用assert语句来断言响应结果是否符合预期。\n\n如果openai_version的值小于\"1.0.0\"，则会使用mock.patch方法来模拟ChatCompletion类，并返回模拟的响应数据。然后，调用chatcompletion_request函数，传入model和prompt参数，获取响应结果。最后，使用assert语句来断言响应结果是否符合预期。\n\n最后，打印出openai_version的值和测试成功的提示信息。\n\n**注意**: \n- 在测试过程中，使用了mock.patch方法来模拟OpenAI客户端和响应，以及ChatCompletion类和响应数据，以确保测试的独立性和可靠性。\n- 在测试过程中，使用了assert语句来断言响应结果是否符合预期，以确保测试的准确性。\n\n**输出示例**:\nYour OpenAI version is 1.0.0, Successful test",
            "code_start_line": 8,
            "code_end_line": 48,
            "parent": null,
            "have_return": true,
            "code_content": "def test_1106_model_openai():\n    if openai_version >= \"1.0.0\":\n        # Mock the OpenAI client and response\n        with mock.patch(\"openai.OpenAI\") as mock_openai:\n            mock_client = mock_openai.return_value\n            mock_response = mock_client.chat.completions.create.return_value\n\n            # Mock the model_dump() method\n            mock_model_dump = mock_response.model_dump\n            mock_model_dump.return_value = {\n                \"choices\": [\n                    {\n                        \"finish_reason\": \"stop\",\n                        \"index\": 0,\n                        \"message\": {\"content\": \"Hello, World!\"},\n                    }\n                ]\n            }\n\n            # Call the function\n            response = chatcompletion_request(\n                model=\"gpt-4-1106-preview\", prompt=\"Hello, world\"\n            )\n\n            # Assert that the response is as expected\n            assert response[\"choices\"][0][\"finish_reason\"] == \"stop\"\n            assert response[\"choices\"][0][\"index\"] == 0\n            assert response[\"choices\"][0][\"message\"][\"content\"] == \"Hello, World!\"\n\n    else:\n        with mock.patch(\"openai.ChatCompletion\") as mock_create:\n            mock_response_data = \"\"\"{\"choices\": [{\"finish_reason\": \"stop\", \"index\": 0, \"message\": {\"content\": \"Hello, World!\"}}]}\"\"\"\n\n            mock_create.create.return_value = mock_response_data\n\n            response = chatcompletion_request(\n                model=\"gpt-4-1106-preview\", prompt=\"Hello, world\"\n            )\n            assert response[\"choices\"][0][\"message\"][\"content\"] == \"Hello, World!\"\n\n    print(f\"Your OpenAI version is {openai_version}, Successful test\")\n",
            "name_column": 4
        }
    },
    "tests/test_model_alias.py": {
        "test_model_alias": {
            "type": "FunctionDef",
            "name": "test_model_alias",
            "md_content": "**test_model_alias函数**：该函数的功能是进行模型别名测试。\n\n该函数首先判断openai_version是否大于等于\"1.0.0\"，如果是，则进入第一个分支。在该分支中，使用mock.patch函数模拟OpenAI客户端和响应。然后，通过mock_response.model_dump.return_value模拟model_dump()方法的返回值，该返回值是一个包含一个字典的字典，其中包含一个choices列表，列表中包含一个字典，字典中包含了finish_reason、index和message等字段。接下来，调用chatcompletion_request函数，并传入model和prompt参数，将返回值赋给response变量。最后，使用assert语句对response进行断言，确保其与预期结果一致。\n\n如果openai_version小于\"1.0.0\"，则进入第二个分支。在该分支中，同样使用mock.patch函数模拟ChatCompletion类的实例化，并通过mock_response_data模拟create方法的返回值。然后，调用chatcompletion_request函数，并传入model和prompt参数，将返回值赋给response变量。最后，使用assert语句对response进行断言，确保其与预期结果一致。\n\n最后，打印出openai_version的值以及测试成功的提示信息。\n\n**注意**：在使用该函数时需要注意以下几点：\n- 需要安装mock库来模拟OpenAI客户端和响应。\n- 需要确保openai_version的值与预期一致，以便进入正确的分支。\n\n**输出示例**：模拟代码返回值的可能外观。\n```\nYour OpenAI version is 1.0.0, Successful test\n```",
            "code_start_line": 8,
            "code_end_line": 48,
            "parent": null,
            "have_return": true,
            "code_content": "def test_model_alias():\n    if openai_version >= \"1.0.0\":\n        # Mock the OpenAI client and response\n        with mock.patch(\"openai.OpenAI\") as mock_openai:\n            mock_client = mock_openai.return_value\n            mock_response = mock_client.chat.completions.create.return_value\n\n            # Mock the model_dump() method\n            mock_model_dump = mock_response.model_dump\n            mock_model_dump.return_value = {\n                \"choices\": [\n                    {\n                        \"finish_reason\": \"stop\",\n                        \"index\": 0,\n                        \"message\": {\"content\": \"Hello, World!\"},\n                    }\n                ]\n            }\n\n            # Call the function\n            response = chatcompletion_request(\n                model=\"gpt-4-turbo\", prompt=\"Hello, world\"\n            )\n\n            # Assert that the response is as expected\n            assert response[\"choices\"][0][\"finish_reason\"] == \"stop\"\n            assert response[\"choices\"][0][\"index\"] == 0\n            assert response[\"choices\"][0][\"message\"][\"content\"] == \"Hello, World!\"\n\n    else:\n        with mock.patch(\"openai.ChatCompletion\") as mock_create:\n            mock_response_data = \"\"\"{\"choices\": [{\"finish_reason\": \"stop\", \"index\": 0, \"message\": {\"content\": \"Hello, World!\"}}]}\"\"\"\n\n            mock_create.create.return_value = mock_response_data\n\n            response = chatcompletion_request(\n                model=\"gpt-4-turbo\", prompt=\"Hello, world\"\n            )\n            assert response[\"choices\"][0][\"message\"][\"content\"] == \"Hello, World!\"\n\n    print(f\"Your OpenAI version is {openai_version}, Successful test\")\n",
            "name_column": 4
        }
    },
    "XAgentServer/server.py": {
        "XAgentServer": {
            "type": "ClassDef",
            "name": "XAgentServer",
            "md_content": "",
            "code_start_line": 20,
            "code_end_line": 109,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentServer:\n    \"\"\"XAgent Server Start Class\n    \"\"\"\n\n    def __init__(self, logger: Logger) -> None:\n        self.logger: Logger = logger\n\n    def interact(self, interaction: XAgentInteraction):\n        # query = message\n        \"\"\"\n        XAgent Server Start Function\n        \"\"\"\n        from XAgent.config import CONFIG as config\n        xagent_core = None\n        try:\n            config.reload()\n            args = {}\n            # args\n            args = interaction.parameter.args\n\n            self.logger.info(\n                f\"server is running, the start query is {args.get('goal', '')}\")\n            xagent_param = XAgentParam()\n\n            # build query\n            xagent_param.build_query({\n                \"role_name\": \"Assistant\",\n                \"task\": args.get(\"goal\", \"\"),\n                \"plan\": args.get(\"plan\", [\"Pay attention to the language in initial goal, always answer with the same language of the initial goal given.\"]),\n            })\n            xagent_param.build_config(config)\n            xagent_core = XAgentCoreComponents()\n            # build XAgent Core Components\n            xagent_core.build(xagent_param, interaction=interaction)\n            json_str = json.dumps(\n                xagent_param.config.to_dict(), indent=2)\n            json_str=re.sub(r'\"api_key\": \"(.+?)\"', r'\"api_key\": \"**\"', json_str)\n            self.logger.info(json_str)\n            self.logger.typewriter_log(\n                \"Human-In-The-Loop\",\n                Fore.RED,\n                str(xagent_param.config.enable_ask_human_for_help),\n            )\n\n            file_list = interaction.base.file_list\n            for file in file_list:\n                file_uuid = file.get(\"uuid\", \"\")\n                file_name = file.get(\"name\", \"\")\n                if file_uuid.startswith(\"/\"):\n                    file_path = file_uuid\n                else:\n                    file_path = os.path.join(XAgentServerEnv.Upload.upload_dir,\n                                         interaction.base.user_id, file_uuid)\n\n                upload_dir = os.path.join(\n                    xagent_core.base_dir, \"upload\")\n                if not os.path.exists(upload_dir):\n                    os.makedirs(upload_dir)\n                # 拷贝到workspace\n                if interaction.call_method == \"web\":\n                    shutil.copy(file_path, os.path.join(upload_dir, file_name))\n                else:\n                    if os.path.exists(file_path):\n                        if os.path.samefile(file_path, os.path.join(upload_dir, file_name)):\n                            # 文件路径相同,跳过复制\n                            pass\n                        else:\n                            shutil.copy(file_path, os.path.join(upload_dir, file_name))\n                        # shutil.copy(file_path, os.path.join(upload_dir, file_name))\n\n                new_file = os.path.join(upload_dir, file_name)\n                try:\n                    xagent_core.toolserver_interface.upload_file(new_file)\n                except Exception as e:\n                    self.logger.typewriter_log(\n                        \"Error happens when uploading file\",\n                        Fore.RED,\n                        f\"{new_file}\\n{e}\",\n                    )\n                    raise XAgentUploadFileError(str(e)) from e\n\n            task_handler = TaskHandler(xagent_core=xagent_core,\n                                       xagent_param=xagent_param)\n            self.logger.info(\"Start outer loop async\")\n            task_handler.outer_loop()\n        except Exception as e:\n            raise XAgentRunningError(str(e)) from e\n        finally:\n            if xagent_core is not None:\n                xagent_core.close()\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 24,
            "code_end_line": 25,
            "parent": "XAgentServer",
            "have_return": false,
            "code_content": "    def __init__(self, logger: Logger) -> None:\n        self.logger: Logger = logger\n",
            "name_column": 8
        },
        "interact": {
            "type": "FunctionDef",
            "name": "interact",
            "md_content": "",
            "code_start_line": 27,
            "code_end_line": 109,
            "parent": "XAgentServer",
            "have_return": false,
            "code_content": "    def interact(self, interaction: XAgentInteraction):\n        # query = message\n        \"\"\"\n        XAgent Server Start Function\n        \"\"\"\n        from XAgent.config import CONFIG as config\n        xagent_core = None\n        try:\n            config.reload()\n            args = {}\n            # args\n            args = interaction.parameter.args\n\n            self.logger.info(\n                f\"server is running, the start query is {args.get('goal', '')}\")\n            xagent_param = XAgentParam()\n\n            # build query\n            xagent_param.build_query({\n                \"role_name\": \"Assistant\",\n                \"task\": args.get(\"goal\", \"\"),\n                \"plan\": args.get(\"plan\", [\"Pay attention to the language in initial goal, always answer with the same language of the initial goal given.\"]),\n            })\n            xagent_param.build_config(config)\n            xagent_core = XAgentCoreComponents()\n            # build XAgent Core Components\n            xagent_core.build(xagent_param, interaction=interaction)\n            json_str = json.dumps(\n                xagent_param.config.to_dict(), indent=2)\n            json_str=re.sub(r'\"api_key\": \"(.+?)\"', r'\"api_key\": \"**\"', json_str)\n            self.logger.info(json_str)\n            self.logger.typewriter_log(\n                \"Human-In-The-Loop\",\n                Fore.RED,\n                str(xagent_param.config.enable_ask_human_for_help),\n            )\n\n            file_list = interaction.base.file_list\n            for file in file_list:\n                file_uuid = file.get(\"uuid\", \"\")\n                file_name = file.get(\"name\", \"\")\n                if file_uuid.startswith(\"/\"):\n                    file_path = file_uuid\n                else:\n                    file_path = os.path.join(XAgentServerEnv.Upload.upload_dir,\n                                         interaction.base.user_id, file_uuid)\n\n                upload_dir = os.path.join(\n                    xagent_core.base_dir, \"upload\")\n                if not os.path.exists(upload_dir):\n                    os.makedirs(upload_dir)\n                # 拷贝到workspace\n                if interaction.call_method == \"web\":\n                    shutil.copy(file_path, os.path.join(upload_dir, file_name))\n                else:\n                    if os.path.exists(file_path):\n                        if os.path.samefile(file_path, os.path.join(upload_dir, file_name)):\n                            # 文件路径相同,跳过复制\n                            pass\n                        else:\n                            shutil.copy(file_path, os.path.join(upload_dir, file_name))\n                        # shutil.copy(file_path, os.path.join(upload_dir, file_name))\n\n                new_file = os.path.join(upload_dir, file_name)\n                try:\n                    xagent_core.toolserver_interface.upload_file(new_file)\n                except Exception as e:\n                    self.logger.typewriter_log(\n                        \"Error happens when uploading file\",\n                        Fore.RED,\n                        f\"{new_file}\\n{e}\",\n                    )\n                    raise XAgentUploadFileError(str(e)) from e\n\n            task_handler = TaskHandler(xagent_core=xagent_core,\n                                       xagent_param=xagent_param)\n            self.logger.info(\"Start outer loop async\")\n            task_handler.outer_loop()\n        except Exception as e:\n            raise XAgentRunningError(str(e)) from e\n        finally:\n            if xagent_core is not None:\n                xagent_core.close()\n",
            "name_column": 8
        }
    },
    "XAgentServer/interaction.py": {
        "XAgentInteraction": {
            "type": "ClassDef",
            "name": "XAgentInteraction",
            "md_content": "",
            "code_start_line": 27,
            "code_end_line": 302,
            "parent": null,
            "have_return": true,
            "code_content": "class XAgentInteraction(metaclass=abc.ABCMeta):\n    \"\"\"\n    XAgent 核心交互组件集, 引用: XAgentCE\n    Attributes:\n        base: 交互基本信息\n        parameter: 交互参数\n        interrupt: 是否包含中断\n        toolserver: 工具服务\n        call_method: 调用方式\n        wait_seconds: 等待时间\n        \n    Components:\n        logger: 日志\n        db: 数据库\n        recorder: 运行记录\n        toolserver_interface: 工具服务接口\n        \n    组件集中的所有组件全局唯一\n\n    \"\"\"\n\n    def __init__(\n        self,\n        base: InteractionBase,\n        parameter: InteractionParameter,\n        interrupt: bool = False,\n        call_method: str = \"web\",\n        wait_seconds: int = 600,\n    ) -> None:\n        self.base = base\n        self.parameter = parameter\n        # 唯一标识当前的执行步骤\n        self.current_step = uuid.uuid4().hex\n        self.logger = None\n        self.interrupt = interrupt\n        self.call_method = call_method\n        self.wait_seconds = wait_seconds\n        self.log_dir = os.path.join(\n            os.path.join(XAgentServerEnv.base_dir,\n                         \"localstorage\",\n                         \"interact_records\"),\n            datetime.now().strftime(\"%Y-%m-%d\"),\n            self.base.interaction_id)\n        self.human_data = None\n        if not os.path.exists(self.log_dir):\n            os.makedirs(self.log_dir)\n\n        self.extract_dir = os.path.join(self.log_dir, \"workspace\")\n        if not os.path.exists(self.extract_dir):\n            os.makedirs(self.extract_dir)\n\n        self.db: Session = None\n        self.toolserver_interface = None\n\n    def register_toolserver_interface(self, toolserver_interface: ToolServerInterface):\n        \"\"\"register tool server interface\"\"\"\n        self.toolserver_interface = toolserver_interface\n\n    def resister_logger(self, logger: Logger):\n        \"\"\"\n        注册logger, 根据会话id创建日志文件夹, 并创建日志文件\n        \"\"\"\n\n        self.logger = logger\n        self.logger.info(f\"init interaction: {self.base.interaction_id}\")\n\n    def register_db(self, db: Session):\n        \"\"\"\n        注册db\n\n        Args:\n            db: Session对象\n        \"\"\"\n        self.db = db\n\n    def insert_data(self,\n                    data: dict,\n                    status=\"\",\n                    current: str = None,\n                    is_include_pictures: bool = False,):\n        \"\"\"\n        更新缓存, 推送数据\n        \"\"\"\n        # check alive\n        alive = redis.get_key(self.base.interaction_id)\n        if alive == \"close\":\n            self.logger.info(\"The user terminated this action and exited.\")\n            exit(0)\n        self.current_step = uuid.uuid4().hex\n\n        if status == \"inner\":\n            tool_name = data.get(\"using_tools\", {}).get(\n                \"tool_name\", \"\") if isinstance(data, dict) else \"\"\n\n            if tool_name == \"subtask_submit\":\n                status = StatusEnum.SUBMIT\n\n        # download workspace files\n        self.download_files()\n\n        file_list = os.listdir(self.extract_dir)\n\n        # insert raw\n        process = XAgentRaw(\n            node_id=self.current_step,\n            interaction_id=self.base.interaction_id,\n            current=current,\n            step=0,\n            data=data,\n            file_list=file_list,\n            status=status,\n            do_interrupt=self.interrupt,\n            wait_seconds=0,\n            ask_for_human_help=False,\n            create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            is_deleted=False,\n            is_human=False,\n            human_data=None,\n            human_file_list=[],\n            is_send=self.call_method != 'web',\n            is_receive=False,\n            include_pictures=is_include_pictures,\n        )\n        if status == StatusEnum.FINISHED:\n            InteractionCRUD.update_interaction_status(\n                db=self.db,\n                interaction_id=self.base.interaction_id,\n                status=StatusEnum.FINISHED,\n                message=\"finished\",\n                current_step=self.current_step)\n        else:\n            InteractionCRUD.update_interaction_status(\n                db=self.db,\n                interaction_id=self.base.interaction_id,\n                status=\"running\",\n                message=\"running\",\n                current_step=self.current_step)\n        InteractionCRUD.insert_raw(db=self.db, process=process)\n        if self.call_method == \"web\":\n            redis.set_key(self.base.interaction_id + \"_send\", 1)\n        elif self.call_method == \"cmd\":\n            # print workspace file list\n            file_list_str = \", \".join(file_list) \n            self.logger.typewriter_log(\n                title=f\"-=-=-=-=-=-=-= {self.base.interaction_id}, {self.current_step}, WORKSPACE FILE LIST -=-=-=-=-=-=-=\\n\",\n                title_color=Fore.GREEN,\n                content=f\"[{file_list_str}] in {self.extract_dir}\"\n            )\n\n    def download_files(self):\n        \"\"\"download files\n\n        Returns:\n            Boolean: True or False\n        \"\"\"\n        try:\n            save_path = self.toolserver_interface.download_all_files()\n\n            if os.path.exists(save_path):\n                zip_file = zipfile.ZipFile(save_path)\n                zip_list = zip_file.namelist()  # 得到压缩包里所有文件\n                for f in zip_list:\n                    zip_file.extract(f, self.extract_dir)  # 循环解压文件到指定目录\n\n                zip_file.close()\n            return True\n        except zipfile.BadZipFile:\n            return False\n\n    def receive(self, can_modify=None):\n        \"\"\"\n        接收数据\n        \"\"\"\n\n        if self.call_method == \"web\":\n            wait = 0\n            while wait < self.wait_seconds:\n                human_data = self.get_human_data()\n                if human_data is not None:\n                    return human_data\n                else:\n                    wait += 2\n                    time.sleep(2)\n\n            raise XAgentTimeoutError(\"等待数据超时，关闭连接\")\n        else:\n            print(can_modify)\n\n    def get_human_data(self):\n        \"\"\"\n        获取人类数据\n        \"\"\"\n        # check alive, ensure the interaction is alive\n        # if The user terminated this action and exited\n        alive = redis.get_key(self.base.interaction_id)\n        if alive == \"close\":\n            self.logger.info(\"The user terminated this action and exited!\")\n            exit(0)\n        receive_key = self.base.interaction_id + \"_\" + self.current_step + \"_receive\"\n        is_receive = redis.get_key(receive_key)\n\n        if is_receive:\n            raw = InteractionCRUD.get_raw(\n                db=self.db, interaction_id=self.base.interaction_id, node_id=self.current_step)\n\n            if raw and raw.is_human and raw.is_receive:\n                redis.delete_key(receive_key)\n                return raw.human_data\n\n        return None\n\n    def ask_for_human_help(self, data):\n        \"\"\"调用工具时，请求人类帮助\n        Execute the tool and ask for human help\n        \"\"\"\n\n        self.current_step = uuid.uuid4().hex\n        self.download_files()\n        file_list = os.listdir(self.extract_dir)\n        # special: ask for human help and do interrupt\n        # send data\n        process = XAgentRaw(\n            node_id=self.current_step,\n            interaction_id=self.base.interaction_id,\n            current=self.current_step,\n            step=0,\n            data=data,\n            file_list=file_list,\n            status=StatusEnum.ASK_FOR_HUMAN_HELP,\n            do_interrupt=True,\n            wait_seconds=0,\n            ask_for_human_help=True,\n            create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            is_deleted=False,\n            is_human=False,\n            human_data=None,\n            human_file_list=[],\n            is_send=False,\n            is_receive=False,\n            include_pictures=False,\n        )\n\n        # insert into mysql\n        InteractionCRUD.insert_raw(db=self.db, process=process)\n\n        # set redis\n        redis.set_key(self.base.interaction_id + \"_send\", 1)\n\n        # set status\n\n        InteractionCRUD.update_interaction_status(\n            db=self.db,\n            interaction_id=self.base.interaction_id,\n            status=StatusEnum.ASK_FOR_HUMAN_HELP,\n            message=\"ask for human help\",\n            current_step=self.current_step)\n\n        # check alive\n        alive = redis.get_key(self.base.interaction_id)\n        if alive == \"close\":\n            self.logger.info(\"The user terminated this action and exited!\")\n            exit(0)\n\n        # wait for human data\n        wait = 0\n        while wait < self.wait_seconds:\n            human_data = self.get_human_data()\n            if human_data is not None:\n                return human_data\n            else:\n                wait += 2\n                time.sleep(2)\n\n        raise XAgentTimeoutError(\"ASK-For-Human-Data: 等待数据超时，关闭连接\")\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 48,
            "code_end_line": 79,
            "parent": "XAgentInteraction",
            "have_return": false,
            "code_content": "    def __init__(\n        self,\n        base: InteractionBase,\n        parameter: InteractionParameter,\n        interrupt: bool = False,\n        call_method: str = \"web\",\n        wait_seconds: int = 600,\n    ) -> None:\n        self.base = base\n        self.parameter = parameter\n        # 唯一标识当前的执行步骤\n        self.current_step = uuid.uuid4().hex\n        self.logger = None\n        self.interrupt = interrupt\n        self.call_method = call_method\n        self.wait_seconds = wait_seconds\n        self.log_dir = os.path.join(\n            os.path.join(XAgentServerEnv.base_dir,\n                         \"localstorage\",\n                         \"interact_records\"),\n            datetime.now().strftime(\"%Y-%m-%d\"),\n            self.base.interaction_id)\n        self.human_data = None\n        if not os.path.exists(self.log_dir):\n            os.makedirs(self.log_dir)\n\n        self.extract_dir = os.path.join(self.log_dir, \"workspace\")\n        if not os.path.exists(self.extract_dir):\n            os.makedirs(self.extract_dir)\n\n        self.db: Session = None\n        self.toolserver_interface = None\n",
            "name_column": 8
        },
        "register_toolserver_interface": {
            "type": "FunctionDef",
            "name": "register_toolserver_interface",
            "md_content": "",
            "code_start_line": 81,
            "code_end_line": 83,
            "parent": "XAgentInteraction",
            "have_return": false,
            "code_content": "    def register_toolserver_interface(self, toolserver_interface: ToolServerInterface):\n        \"\"\"register tool server interface\"\"\"\n        self.toolserver_interface = toolserver_interface\n",
            "name_column": 8
        },
        "resister_logger": {
            "type": "FunctionDef",
            "name": "resister_logger",
            "md_content": "",
            "code_start_line": 85,
            "code_end_line": 91,
            "parent": "XAgentInteraction",
            "have_return": false,
            "code_content": "    def resister_logger(self, logger: Logger):\n        \"\"\"\n        注册logger, 根据会话id创建日志文件夹, 并创建日志文件\n        \"\"\"\n\n        self.logger = logger\n        self.logger.info(f\"init interaction: {self.base.interaction_id}\")\n",
            "name_column": 8
        },
        "register_db": {
            "type": "FunctionDef",
            "name": "register_db",
            "md_content": "",
            "code_start_line": 93,
            "code_end_line": 100,
            "parent": "XAgentInteraction",
            "have_return": false,
            "code_content": "    def register_db(self, db: Session):\n        \"\"\"\n        注册db\n\n        Args:\n            db: Session对象\n        \"\"\"\n        self.db = db\n",
            "name_column": 8
        },
        "insert_data": {
            "type": "FunctionDef",
            "name": "insert_data",
            "md_content": "",
            "code_start_line": 102,
            "code_end_line": 175,
            "parent": "XAgentInteraction",
            "have_return": false,
            "code_content": "    def insert_data(self,\n                    data: dict,\n                    status=\"\",\n                    current: str = None,\n                    is_include_pictures: bool = False,):\n        \"\"\"\n        更新缓存, 推送数据\n        \"\"\"\n        # check alive\n        alive = redis.get_key(self.base.interaction_id)\n        if alive == \"close\":\n            self.logger.info(\"The user terminated this action and exited.\")\n            exit(0)\n        self.current_step = uuid.uuid4().hex\n\n        if status == \"inner\":\n            tool_name = data.get(\"using_tools\", {}).get(\n                \"tool_name\", \"\") if isinstance(data, dict) else \"\"\n\n            if tool_name == \"subtask_submit\":\n                status = StatusEnum.SUBMIT\n\n        # download workspace files\n        self.download_files()\n\n        file_list = os.listdir(self.extract_dir)\n\n        # insert raw\n        process = XAgentRaw(\n            node_id=self.current_step,\n            interaction_id=self.base.interaction_id,\n            current=current,\n            step=0,\n            data=data,\n            file_list=file_list,\n            status=status,\n            do_interrupt=self.interrupt,\n            wait_seconds=0,\n            ask_for_human_help=False,\n            create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            is_deleted=False,\n            is_human=False,\n            human_data=None,\n            human_file_list=[],\n            is_send=self.call_method != 'web',\n            is_receive=False,\n            include_pictures=is_include_pictures,\n        )\n        if status == StatusEnum.FINISHED:\n            InteractionCRUD.update_interaction_status(\n                db=self.db,\n                interaction_id=self.base.interaction_id,\n                status=StatusEnum.FINISHED,\n                message=\"finished\",\n                current_step=self.current_step)\n        else:\n            InteractionCRUD.update_interaction_status(\n                db=self.db,\n                interaction_id=self.base.interaction_id,\n                status=\"running\",\n                message=\"running\",\n                current_step=self.current_step)\n        InteractionCRUD.insert_raw(db=self.db, process=process)\n        if self.call_method == \"web\":\n            redis.set_key(self.base.interaction_id + \"_send\", 1)\n        elif self.call_method == \"cmd\":\n            # print workspace file list\n            file_list_str = \", \".join(file_list) \n            self.logger.typewriter_log(\n                title=f\"-=-=-=-=-=-=-= {self.base.interaction_id}, {self.current_step}, WORKSPACE FILE LIST -=-=-=-=-=-=-=\\n\",\n                title_color=Fore.GREEN,\n                content=f\"[{file_list_str}] in {self.extract_dir}\"\n            )\n",
            "name_column": 8
        },
        "download_files": {
            "type": "FunctionDef",
            "name": "download_files",
            "md_content": "",
            "code_start_line": 177,
            "code_end_line": 195,
            "parent": "XAgentInteraction",
            "have_return": true,
            "code_content": "    def download_files(self):\n        \"\"\"download files\n\n        Returns:\n            Boolean: True or False\n        \"\"\"\n        try:\n            save_path = self.toolserver_interface.download_all_files()\n\n            if os.path.exists(save_path):\n                zip_file = zipfile.ZipFile(save_path)\n                zip_list = zip_file.namelist()  # 得到压缩包里所有文件\n                for f in zip_list:\n                    zip_file.extract(f, self.extract_dir)  # 循环解压文件到指定目录\n\n                zip_file.close()\n            return True\n        except zipfile.BadZipFile:\n            return False\n",
            "name_column": 8
        },
        "receive": {
            "type": "FunctionDef",
            "name": "receive",
            "md_content": "",
            "code_start_line": 197,
            "code_end_line": 214,
            "parent": "XAgentInteraction",
            "have_return": true,
            "code_content": "    def receive(self, can_modify=None):\n        \"\"\"\n        接收数据\n        \"\"\"\n\n        if self.call_method == \"web\":\n            wait = 0\n            while wait < self.wait_seconds:\n                human_data = self.get_human_data()\n                if human_data is not None:\n                    return human_data\n                else:\n                    wait += 2\n                    time.sleep(2)\n\n            raise XAgentTimeoutError(\"等待数据超时，关闭连接\")\n        else:\n            print(can_modify)\n",
            "name_column": 8
        },
        "get_human_data": {
            "type": "FunctionDef",
            "name": "get_human_data",
            "md_content": "",
            "code_start_line": 216,
            "code_end_line": 237,
            "parent": "XAgentInteraction",
            "have_return": true,
            "code_content": "    def get_human_data(self):\n        \"\"\"\n        获取人类数据\n        \"\"\"\n        # check alive, ensure the interaction is alive\n        # if The user terminated this action and exited\n        alive = redis.get_key(self.base.interaction_id)\n        if alive == \"close\":\n            self.logger.info(\"The user terminated this action and exited!\")\n            exit(0)\n        receive_key = self.base.interaction_id + \"_\" + self.current_step + \"_receive\"\n        is_receive = redis.get_key(receive_key)\n\n        if is_receive:\n            raw = InteractionCRUD.get_raw(\n                db=self.db, interaction_id=self.base.interaction_id, node_id=self.current_step)\n\n            if raw and raw.is_human and raw.is_receive:\n                redis.delete_key(receive_key)\n                return raw.human_data\n\n        return None\n",
            "name_column": 8
        },
        "ask_for_human_help": {
            "type": "FunctionDef",
            "name": "ask_for_human_help",
            "md_content": "",
            "code_start_line": 239,
            "code_end_line": 302,
            "parent": "XAgentInteraction",
            "have_return": true,
            "code_content": "    def ask_for_human_help(self, data):\n        \"\"\"调用工具时，请求人类帮助\n        Execute the tool and ask for human help\n        \"\"\"\n\n        self.current_step = uuid.uuid4().hex\n        self.download_files()\n        file_list = os.listdir(self.extract_dir)\n        # special: ask for human help and do interrupt\n        # send data\n        process = XAgentRaw(\n            node_id=self.current_step,\n            interaction_id=self.base.interaction_id,\n            current=self.current_step,\n            step=0,\n            data=data,\n            file_list=file_list,\n            status=StatusEnum.ASK_FOR_HUMAN_HELP,\n            do_interrupt=True,\n            wait_seconds=0,\n            ask_for_human_help=True,\n            create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            is_deleted=False,\n            is_human=False,\n            human_data=None,\n            human_file_list=[],\n            is_send=False,\n            is_receive=False,\n            include_pictures=False,\n        )\n\n        # insert into mysql\n        InteractionCRUD.insert_raw(db=self.db, process=process)\n\n        # set redis\n        redis.set_key(self.base.interaction_id + \"_send\", 1)\n\n        # set status\n\n        InteractionCRUD.update_interaction_status(\n            db=self.db,\n            interaction_id=self.base.interaction_id,\n            status=StatusEnum.ASK_FOR_HUMAN_HELP,\n            message=\"ask for human help\",\n            current_step=self.current_step)\n\n        # check alive\n        alive = redis.get_key(self.base.interaction_id)\n        if alive == \"close\":\n            self.logger.info(\"The user terminated this action and exited!\")\n            exit(0)\n\n        # wait for human data\n        wait = 0\n        while wait < self.wait_seconds:\n            human_data = self.get_human_data()\n            if human_data is not None:\n                return human_data\n            else:\n                wait += 2\n                time.sleep(2)\n\n        raise XAgentTimeoutError(\"ASK-For-Human-Data: 等待数据超时，关闭连接\")\n",
            "name_column": 8
        }
    },
    "XAgentServer/exts/redis_ext.py": {
        "RedisClient": {
            "type": "ClassDef",
            "name": "RedisClient",
            "md_content": "",
            "code_start_line": 8,
            "code_end_line": 135,
            "parent": null,
            "have_return": true,
            "code_content": "class RedisClient:\n    \"\"\"\n    RedisClient\n    \"\"\"\n\n    def __init__(self):\n        self.client = Redis(host=os.getenv('REDIS_HOST', XAgentServerEnv.Redis.redis_host),\n                            port=XAgentServerEnv.Redis.redis_port,\n                            db=XAgentServerEnv.Redis.redis_db,\n                            password=XAgentServerEnv.Redis.redis_password)\n\n    def set_key(self, key, value, ex=None, px=None, nx=False, xx=False):\n        \"\"\"redis set key\n\n        Args:\n            key (_type_): _description_\n            value (_type_): _description_\n            ex (_type_, optional): _description_. Defaults to None.\n            px (_type_, optional): _description_. Defaults to None.\n            nx (bool, optional): _description_. Defaults to False.\n            xx (bool, optional): _description_. Defaults to False.\n        \"\"\"\n        self.client.set(key, value, ex, px, nx, xx)\n\n    def get_key(self, key):\n        \"\"\"redis get key\n\n        Args:\n            key (_type_): _description_\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        value = self.client.get(key)\n        if value:\n            return value.decode(\"utf-8\")\n        else:\n            return None\n\n    def delete_key(self, key):\n        \"\"\"redis delete key\n\n        Args:\n            key (_type_): _description_\n        \"\"\"\n        self.client.delete(key)\n\n    def get_all_keys(self):\n        \"\"\"redis get all keys\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        return self.client.keys()\n\n    def delete_all_keys(self):\n        \"\"\"redis delete all keys\n        \"\"\"\n        self.client.flushdb()\n\n    def set_parent_key(self, key, value):\n        \"\"\"redis set parent key\n\n        Args:\n            key (_type_): _description_\n            value (_type_): _description_\n        \"\"\"\n        self.client.set(key, value)\n\n    def get_parent_key(self, key):\n        \"\"\"redis get parent key\n\n        Args:\n            key (_type_): _description_\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        return self.client.get(key)\n\n    def delete_parent_key(self, key):\n        \"\"\"redis delete parent key\n\n        Args:\n            key (_type_): _description_\n        \"\"\"\n        self.client.delete(key)\n\n    def set_child_key(self, parent_key, key, value):\n        \"\"\"redis set child key\n\n        Args:\n            key (_type_): _description_\n            value (_type_): _description_\n        \"\"\"\n        parent = self.client.get(parent_key)\n        if parent:\n            parent[key] = value\n        else:\n            parent = {key: value}\n        self.set_key(parent_key, parent)\n        \n    def get_child_key(self, key):\n        \"\"\"redis get child key\n\n        Args:\n            key (_type_): _description_\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        return self.client.get(key)\n\n    def delete_child_key(self, key):\n        \"\"\"redis delete child key\n\n        Args:\n            key (_type_): _description_\n        \"\"\"\n        self.client.delete(key)\n\n    def get_child_keys(self, parent_key):\n        \"\"\"\n\n        Args:\n            parent_key (_type_): _description_\n        \"\"\"\n        return self.client.keys(parent_key)\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 13,
            "code_end_line": 17,
            "parent": "RedisClient",
            "have_return": false,
            "code_content": "    def __init__(self):\n        self.client = Redis(host=os.getenv('REDIS_HOST', XAgentServerEnv.Redis.redis_host),\n                            port=XAgentServerEnv.Redis.redis_port,\n                            db=XAgentServerEnv.Redis.redis_db,\n                            password=XAgentServerEnv.Redis.redis_password)\n",
            "name_column": 8
        },
        "set_key": {
            "type": "FunctionDef",
            "name": "set_key",
            "md_content": "",
            "code_start_line": 19,
            "code_end_line": 30,
            "parent": "RedisClient",
            "have_return": false,
            "code_content": "    def set_key(self, key, value, ex=None, px=None, nx=False, xx=False):\n        \"\"\"redis set key\n\n        Args:\n            key (_type_): _description_\n            value (_type_): _description_\n            ex (_type_, optional): _description_. Defaults to None.\n            px (_type_, optional): _description_. Defaults to None.\n            nx (bool, optional): _description_. Defaults to False.\n            xx (bool, optional): _description_. Defaults to False.\n        \"\"\"\n        self.client.set(key, value, ex, px, nx, xx)\n",
            "name_column": 8
        },
        "get_key": {
            "type": "FunctionDef",
            "name": "get_key",
            "md_content": "",
            "code_start_line": 32,
            "code_end_line": 45,
            "parent": "RedisClient",
            "have_return": true,
            "code_content": "    def get_key(self, key):\n        \"\"\"redis get key\n\n        Args:\n            key (_type_): _description_\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        value = self.client.get(key)\n        if value:\n            return value.decode(\"utf-8\")\n        else:\n            return None\n",
            "name_column": 8
        },
        "delete_key": {
            "type": "FunctionDef",
            "name": "delete_key",
            "md_content": "",
            "code_start_line": 47,
            "code_end_line": 53,
            "parent": "RedisClient",
            "have_return": false,
            "code_content": "    def delete_key(self, key):\n        \"\"\"redis delete key\n\n        Args:\n            key (_type_): _description_\n        \"\"\"\n        self.client.delete(key)\n",
            "name_column": 8
        },
        "get_all_keys": {
            "type": "FunctionDef",
            "name": "get_all_keys",
            "md_content": "",
            "code_start_line": 55,
            "code_end_line": 61,
            "parent": "RedisClient",
            "have_return": true,
            "code_content": "    def get_all_keys(self):\n        \"\"\"redis get all keys\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        return self.client.keys()\n",
            "name_column": 8
        },
        "delete_all_keys": {
            "type": "FunctionDef",
            "name": "delete_all_keys",
            "md_content": "",
            "code_start_line": 63,
            "code_end_line": 66,
            "parent": "RedisClient",
            "have_return": false,
            "code_content": "    def delete_all_keys(self):\n        \"\"\"redis delete all keys\n        \"\"\"\n        self.client.flushdb()\n",
            "name_column": 8
        },
        "set_parent_key": {
            "type": "FunctionDef",
            "name": "set_parent_key",
            "md_content": "",
            "code_start_line": 68,
            "code_end_line": 75,
            "parent": "RedisClient",
            "have_return": false,
            "code_content": "    def set_parent_key(self, key, value):\n        \"\"\"redis set parent key\n\n        Args:\n            key (_type_): _description_\n            value (_type_): _description_\n        \"\"\"\n        self.client.set(key, value)\n",
            "name_column": 8
        },
        "get_parent_key": {
            "type": "FunctionDef",
            "name": "get_parent_key",
            "md_content": "",
            "code_start_line": 77,
            "code_end_line": 86,
            "parent": "RedisClient",
            "have_return": true,
            "code_content": "    def get_parent_key(self, key):\n        \"\"\"redis get parent key\n\n        Args:\n            key (_type_): _description_\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        return self.client.get(key)\n",
            "name_column": 8
        },
        "delete_parent_key": {
            "type": "FunctionDef",
            "name": "delete_parent_key",
            "md_content": "",
            "code_start_line": 88,
            "code_end_line": 94,
            "parent": "RedisClient",
            "have_return": false,
            "code_content": "    def delete_parent_key(self, key):\n        \"\"\"redis delete parent key\n\n        Args:\n            key (_type_): _description_\n        \"\"\"\n        self.client.delete(key)\n",
            "name_column": 8
        },
        "set_child_key": {
            "type": "FunctionDef",
            "name": "set_child_key",
            "md_content": "",
            "code_start_line": 96,
            "code_end_line": 108,
            "parent": "RedisClient",
            "have_return": false,
            "code_content": "    def set_child_key(self, parent_key, key, value):\n        \"\"\"redis set child key\n\n        Args:\n            key (_type_): _description_\n            value (_type_): _description_\n        \"\"\"\n        parent = self.client.get(parent_key)\n        if parent:\n            parent[key] = value\n        else:\n            parent = {key: value}\n        self.set_key(parent_key, parent)\n",
            "name_column": 8
        },
        "get_child_key": {
            "type": "FunctionDef",
            "name": "get_child_key",
            "md_content": "",
            "code_start_line": 110,
            "code_end_line": 119,
            "parent": "RedisClient",
            "have_return": true,
            "code_content": "    def get_child_key(self, key):\n        \"\"\"redis get child key\n\n        Args:\n            key (_type_): _description_\n\n        Returns:\n            _type_: _description_\n        \"\"\"\n        return self.client.get(key)\n",
            "name_column": 8
        },
        "delete_child_key": {
            "type": "FunctionDef",
            "name": "delete_child_key",
            "md_content": "",
            "code_start_line": 121,
            "code_end_line": 127,
            "parent": "RedisClient",
            "have_return": false,
            "code_content": "    def delete_child_key(self, key):\n        \"\"\"redis delete child key\n\n        Args:\n            key (_type_): _description_\n        \"\"\"\n        self.client.delete(key)\n",
            "name_column": 8
        },
        "get_child_keys": {
            "type": "FunctionDef",
            "name": "get_child_keys",
            "md_content": "",
            "code_start_line": 129,
            "code_end_line": 135,
            "parent": "RedisClient",
            "have_return": true,
            "code_content": "    def get_child_keys(self, parent_key):\n        \"\"\"\n\n        Args:\n            parent_key (_type_): _description_\n        \"\"\"\n        return self.client.keys(parent_key)\n",
            "name_column": 8
        }
    },
    "XAgentServer/exts/mail_ext.py": {
        "email_content": {
            "type": "FunctionDef",
            "name": "email_content",
            "md_content": "",
            "code_start_line": 5,
            "code_end_line": 22,
            "parent": null,
            "have_return": true,
            "code_content": "def email_content(user):\n    html_body = f\"\"\"\n<body style=\"font-family: Arial, sans-serif;background-color: #f5f5f5;margin: 0; padding: 0;\">\n    <div style=\"background-color: #ffffff;margin: 0 auto;padding: 20px;border-radius: 10px;box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);\">\n        <h1 style=\"font-size: 28px;margin-bottom: 20px;\">Hello {user['name']},</h1>\n        <p style=\"font-size: 16px;line-height: 1.5;color: #333333;text-indent:2em;\">Welcome to XAgent, your personal assistant! Thanks for signing up for XAgent. There are some information about your account:</p>\n        <p style=\"font-size: 16px;line-height: 1.5;color: #333333;text-indent:2em;\">Your XAgent Account: <b>{user[\"email\"]}</b></p>\n        <p style=\"font-size: 16px;line-height: 1.5;color: #333333;text-indent:2em;\">You need to use this token for authentication on subsequent logins: </p>\n        <p style=\"font-size: 16px;line-height: 1.5;color: #333333;text-indent:2em;\">You need to use this token for authentication on subsequent logins: </p>\n        <p style=\"font-size: 16px;line-height: 1.5;color: #333333;text-indent:2em;\">Token: <b>{user[\"token\"]}</b></p>\n        \n        <p style=\"font-size: 16px;line-height: 1.5;color: #333333;text-indent:2em;\">Next is an activation link. You need to click on this link to activate your account. After that, you will be able to use XAgent happily:<a href=\"{XAgentServerEnv.Email.auth_server}/auth?user_id={user[\"user_id\"]}&token={user[\"token\"]}\">{XAgentServerEnv.Email.auth_server}/auth?user_id={user[\"user_id\"]}&token={user[\"token\"]}</a>! This Verification link will expire in 7 days.</p>\n        <p>If you have any questions, please contact us at yourxagent@gmail.com .</p>\n        <p style=\"margin-top: 20px;font-size: 14px;color: #999999;text-indent:2em;\">Best wishes!</p>\n        <p style=\"margin-top: 20px;font-size: 14px;color: #999999;\">XAgent Team</p>\n    </div>\n</body>\"\"\"\n    return html_body\n",
            "name_column": 4
        }
    },
    "XAgentServer/exts/exception_ext.py": {
        "XAgentError": {
            "type": "ClassDef",
            "name": "XAgentError",
            "md_content": "",
            "code_start_line": 4,
            "code_end_line": 8,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentError(Exception):\n    \"\"\"Base class for exceptions in this module.\"\"\"\n    def __init__(self, message=\"XAgent Error!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentTimeoutError": {
            "type": "ClassDef",
            "name": "XAgentTimeoutError",
            "md_content": "",
            "code_start_line": 11,
            "code_end_line": 20,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentTimeoutError(XAgentError):\n    \"\"\"Exception raised for errors in the input.\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgentTimeout!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentCloseError": {
            "type": "ClassDef",
            "name": "XAgentCloseError",
            "md_content": "",
            "code_start_line": 23,
            "code_end_line": 32,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentCloseError(XAgentError):\n    \"\"\"Exception raised for errors in the input.\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgentClose!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentWebSocketError": {
            "type": "ClassDef",
            "name": "XAgentWebSocketError",
            "md_content": "",
            "code_start_line": 34,
            "code_end_line": 43,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentWebSocketError(XAgentError):\n    \"\"\"Exception raised for errors in the input.\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgentWebSocket Error!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentWebSocketTimeoutError": {
            "type": "ClassDef",
            "name": "XAgentWebSocketTimeoutError",
            "md_content": "",
            "code_start_line": 45,
            "code_end_line": 54,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentWebSocketTimeoutError(XAgentWebSocketError):\n    \"\"\"Exception raised for errors in the input.\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgentWebSocket Timeout!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentWebSocketDisconnectError": {
            "type": "ClassDef",
            "name": "XAgentWebSocketDisconnectError",
            "md_content": "",
            "code_start_line": 57,
            "code_end_line": 66,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentWebSocketDisconnectError(XAgentWebSocketError):\n    \"\"\"Exception raised for errors in the input.\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgentWebSocket Disconnect!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentWebSocketConnectError": {
            "type": "ClassDef",
            "name": "XAgentWebSocketConnectError",
            "md_content": "",
            "code_start_line": 69,
            "code_end_line": 78,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentWebSocketConnectError(XAgentWebSocketError):\n    \"\"\"Exception raised for errors in the input.\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgentWebSocket Connect Error!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentWebSocketCloseError": {
            "type": "ClassDef",
            "name": "XAgentWebSocketCloseError",
            "md_content": "",
            "code_start_line": 81,
            "code_end_line": 90,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentWebSocketCloseError(XAgentWebSocketError):\n    \"\"\"Exception raised for errors in the input.\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgentWebSocket Close!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentWebSocketSendError": {
            "type": "ClassDef",
            "name": "XAgentWebSocketSendError",
            "md_content": "",
            "code_start_line": 93,
            "code_end_line": 102,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentWebSocketSendError(XAgentWebSocketError):\n    \"\"\"Exception raised for errors in the input.\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgentWebSocket Send Error!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentWebSocketReceiveError": {
            "type": "ClassDef",
            "name": "XAgentWebSocketReceiveError",
            "md_content": "",
            "code_start_line": 105,
            "code_end_line": 114,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentWebSocketReceiveError(XAgentWebSocketError):\n    \"\"\"Exception raised for errors in the input.\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgentWebSocket Receive Error!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentFileError": {
            "type": "ClassDef",
            "name": "XAgentFileError",
            "md_content": "",
            "code_start_line": 117,
            "code_end_line": 126,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentFileError(XAgentError):\n    \"\"\"Exception raised for errors in the input.\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgent File Error!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentDownloadFileError": {
            "type": "ClassDef",
            "name": "XAgentDownloadFileError",
            "md_content": "",
            "code_start_line": 129,
            "code_end_line": 138,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentDownloadFileError(XAgentFileError):\n    \"\"\"Exception raised for errors in the input.\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"Download File Error!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentWorkspaceFileError": {
            "type": "ClassDef",
            "name": "XAgentWorkspaceFileError",
            "md_content": "",
            "code_start_line": 141,
            "code_end_line": 150,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentWorkspaceFileError(XAgentFileError):\n    \"\"\"Exception raised for errors in the input.\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgent Workspace File Error!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentUploadFileError": {
            "type": "ClassDef",
            "name": "XAgentUploadFileError",
            "md_content": "",
            "code_start_line": 153,
            "code_end_line": 162,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentUploadFileError(XAgentFileError):\n    \"\"\"Exception raised for errors in the input.\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgent Workspace Upload File Error!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentDBError": {
            "type": "ClassDef",
            "name": "XAgentDBError",
            "md_content": "",
            "code_start_line": 165,
            "code_end_line": 174,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentDBError(XAgentError):\n    \"\"\"Exception raised because of DB error\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgent DB Error!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentAuthError": {
            "type": "ClassDef",
            "name": "XAgentAuthError",
            "md_content": "",
            "code_start_line": 177,
            "code_end_line": 186,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentAuthError(XAgentError):\n    \"\"\"Exception raised because of auth error\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgent Auth Error!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentRunningError": {
            "type": "ClassDef",
            "name": "XAgentRunningError",
            "md_content": "",
            "code_start_line": 189,
            "code_end_line": 198,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentRunningError(XAgentError):\n    \"\"\"Exception raised because of Running error\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgent Running Error!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "XAgentWebError": {
            "type": "ClassDef",
            "name": "XAgentWebError",
            "md_content": "",
            "code_start_line": 201,
            "code_end_line": 210,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentWebError(XAgentError):\n    \"\"\"Exception raised because of Running error\n\n    Attributes:\n        message -- explanation of the error\n    \"\"\"\n\n    def __init__(self, message=\"XAgent WEB Error!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 208,
            "code_end_line": 210,
            "parent": "XAgentWebError",
            "have_return": false,
            "code_content": "    def __init__(self, message=\"XAgent WEB Error!\"):\n        self.message = message\n        super().__init__(self.message)\n",
            "name_column": 8
        }
    },
    "XAgentServer/database/models.py": {
        "User": {
            "type": "ClassDef",
            "name": "User",
            "md_content": "",
            "code_start_line": 6,
            "code_end_line": 22,
            "parent": null,
            "have_return": false,
            "code_content": "class User(Base):\n    \"\"\"XAgent Users\"\"\"\n    __tablename__=\"users\"\n\n    id=Column(Integer,primary_key=True,index=True)\n    user_id = Column(String(32), unique=True, index=True)\n    email = Column(String(255), unique=True)\n    name = Column(String(255))\n    token = Column(String(255))\n    available = Column(Boolean, default=True)\n    is_beta = Column(Boolean, default=False)\n    deleted = Column(Boolean, default=False)\n    corporation = Column(Text)\n    industry = Column(Text)\n    position = Column(String(255))\n    create_time = Column(String(255))\n    update_time = Column(String(255))\n",
            "name_column": 6
        },
        "Interaction": {
            "type": "ClassDef",
            "name": "Interaction",
            "md_content": "",
            "code_start_line": 25,
            "code_end_line": 43,
            "parent": null,
            "have_return": false,
            "code_content": "class Interaction(Base):\n    \"\"\"XAgent Interactions\"\"\"\n    __tablename__ = \"interactions\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    interaction_id = Column(String(255))\n    user_id = Column(String(255))\n    create_time = Column(String(255))\n    update_time = Column(String(255))\n    description = Column(Text)\n    agent = Column(String(255))\n    mode = Column(String(255))\n    recorder_root_dir = Column(Text)\n    file_list = Column(JSON)\n    status = Column(String(255))\n    message = Column(Text)\n    current_step = Column(String(255))\n    is_deleted = Column(Boolean, default=False)\n    call_method = Column(String(255), default=\"web\")\n",
            "name_column": 6
        },
        "Parameter": {
            "type": "ClassDef",
            "name": "Parameter",
            "md_content": "",
            "code_start_line": 46,
            "code_end_line": 53,
            "parent": null,
            "have_return": false,
            "code_content": "class Parameter(Base):\n    \"\"\"XAgent Parameters\"\"\"\n    __tablename__ = \"interaction_parameters\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    interaction_id = Column(String(32), unique=True, index=True)\n    parameter_id = Column(String(32))\n    args = Column(JSON)\n",
            "name_column": 6
        },
        "SharedInteraction": {
            "type": "ClassDef",
            "name": "SharedInteraction",
            "md_content": "",
            "code_start_line": 56,
            "code_end_line": 70,
            "parent": null,
            "have_return": false,
            "code_content": "class SharedInteraction(Base):\n    \"\"\"Commnunity Shared Interactions\"\"\"\n    __tablename__ = \"shared_interactions\"\n\n    id = Column(Integer, primary_key=True, index=True)\n    interaction_id = Column(String(255))\n    user_name = Column(String(255))\n    create_time = Column(String(255))\n    update_time = Column(String(255))\n    description = Column(Text)\n    agent = Column(String(255))\n    mode = Column(String(255))\n    is_deleted = Column(Boolean, default=False)\n    star = Column(Integer, default=0)\n    is_audit = Column(Boolean, default=False)\n",
            "name_column": 6
        },
        "Raw": {
            "type": "ClassDef",
            "name": "Raw",
            "md_content": "",
            "code_start_line": 73,
            "code_end_line": 115,
            "parent": null,
            "have_return": false,
            "code_content": "class Raw(Base):\n    \"\"\"Raw Data\"\"\"\n    __tablename__ = \"raw\"\n    # id/id\n    id = Column(Integer, primary_key=True, index=True)\n    # node_id\n    node_id = Column(String(255))\n    # 交互id/interaction_id\n    interaction_id = Column(String(255))\n    # 当前节点/current\n    current = Column(String(128))\n    # step/step\n    step = Column(Integer, default=0)\n    # 数据/agent data\n    data = Column(JSON)\n    # workspace文件列表/workspace file list\n    file_list = Column(JSON)\n    # 状态/status\n    status = Column(String(20))\n    # 是否中断/interrupt or not\n    do_interrupt = Column(Boolean, default=False)\n    # 已等待时间/wait seconds\n    wait_seconds = Column(Integer, default=0)\n    # 是否需要人工干预/ask for human help or not\n    ask_for_human_help = Column(Boolean, default=False)\n    # 创建时间/create time\n    create_time = Column(String(255))\n    # 更新时间/update time\n    update_time = Column(String(255))\n    # 是否删除/is deleted or not\n    is_deleted = Column(Boolean, default=False)\n    # 是否人工已经输入/has human input or not\n    is_human = Column(Boolean, default=False)\n    # 人工输入数据/human data\n    human_data = Column(JSON)\n    # 人工文件列表/agent file list\n    human_file_list = Column(JSON)\n    # 是否推送前端/has send to frontend or not\n    is_send = Column(Boolean, default=False)\n    # 是否接收前端消息/has receive message from frontend or not\n    is_receive = Column(Boolean, default=False)\n    # 是否包含png/has png or not\n    include_pictures = Column(Boolean, default=False)\n",
            "name_column": 6
        },
        "RunningRecord": {
            "type": "ClassDef",
            "name": "RunningRecord",
            "md_content": "",
            "code_start_line": 118,
            "code_end_line": 138,
            "parent": null,
            "have_return": false,
            "code_content": "class RunningRecord(Base):\n    \"\"\"Running Record\"\"\"\n    __tablename__ = \"running_record\"\n    # id/id\n    id = Column(Integer, primary_key=True, index=True)\n    # record_id/record_id\n    record_id = Column(String(255))\n    # 当前节点/current\n    current = Column(String(255))\n    # 节点id/node_id\n    node_id = Column(String(255))\n    # 节点类型/node_type, options: [now_subtask_id, llm_input_pair, tool_server_pair, query, config]\n    node_type = Column(String(255))\n    # data/agent data\n    data = Column(JSON)\n    # 创建时间/create time\n    create_time = Column(String(255))\n    # 更新时间/update time\n    update_time = Column(String(255))\n    # 是否删除/is deleted or not\n    is_deleted = Column(Boolean, default=False)\n",
            "name_column": 6
        }
    },
    "XAgentServer/database/connect.py": {},
    "XAgentServer/database/__init__.py": {},
    "XAgentServer/database/interface/user.py": {
        "UserDBInterface": {
            "type": "ClassDef",
            "name": "UserDBInterface",
            "md_content": "",
            "code_start_line": 13,
            "code_end_line": 160,
            "parent": null,
            "have_return": true,
            "code_content": "class UserDBInterface(metaclass=abc.ABCMeta):\n    \"\"\"User DB Interface\n\n    Args:\n        UserBaseInterface (_type_): _description_\n        metaclass (_type_, optional): _description_. Defaults to abc.ABCMeta.\n    \"\"\"\n\n    @classmethod\n    def get_user_list(cls, db: Session) -> list[XAgentUser]:\n        \"\"\"get all users\n\n        Args:\n            db (Session): db\n\n        Returns:\n            list[XAgentUser]: user list\n        \"\"\"\n        users = db.query(User).all()\n        return [XAgentUser.from_db(user) for user in users]\n\n    @classmethod\n    def get_user(cls,\n                 db: Session,\n                 user_id: str | None = None,\n                 email: str | None = None) -> XAgentUser | None:\n        \"\"\"get user by user_id or email\n\n        Args:\n            db (Session): db\n            user_id (str | None, optional): user id. Defaults to None.\n            email (str | None, optional): email. Defaults to None.\n\n        Returns:\n            XAgentUser | None: user, if user is not exist, return None\n        \"\"\"\n        if email is not None:\n            user = db.query(User).filter(User.email == email,\n                                         User.deleted.is_(False)).first()\n        else:\n            user = db.query(User).filter(\n                User.user_id == user_id, User.deleted.is_(False)).first()\n\n        return XAgentUser.from_db(user) if user else None\n\n    @classmethod\n    def is_exist(cls,\n                db: Session,\n                user_id: str | None = None,\n                email: str | None = None):\n        \"\"\"user is exist?\n\n        Args:\n            db (Session): db session\n            user_id (str | None, optional): user id. Defaults to None.\n            email (str | None, optional): email. Defaults to None.\n\n        Returns:\n            Boolean: True or False\n        \"\"\"\n        if not email and not user_id:\n            return False\n        if email:\n            user = db.query(User).filter(User.email == email,\n                                         User.deleted.is_(False)).first()\n        else:\n            user = db.query(User).filter(\n                User.user_id == user_id, User.deleted.is_(False)).first()\n        return user is not None\n\n    @classmethod\n    def token_is_exist(cls,\n                       db: Session,\n                       user_id: str,\n                       token: str | None = None):\n        \"\"\"token is exist?\n        \n        Args:\n            db (Session): db session\n            user_id (str): user id\n            token (str | None, optional): token. Defaults to None.\n            \n        Returns:\n            Boolean: True or False\n        \"\"\"\n        if not token:\n            return False\n\n        user = db.query(User).filter(User.user_id == user_id,\n                                     User.token == token, User.deleted.is_(False)).first()\n        return user is not None\n\n    @classmethod\n    def user_is_valid(cls, db: Session,\n                      user_id: str | None = None,\n                      email: str | None = None,\n                      token: str | None = None):\n        \"\"\"\n        user is valid?\n        \n        Args:\n            db (Session): db session\n            user_id (str | None, optional): user id. Defaults to None.\n            email (str | None, optional): email. Defaults to None.\n            token (str | None, optional): token. Defaults to None.\n            \n        Returns:\n            Boolean: True or False\n        \"\"\"\n        if email == \"\":\n            return False\n        user = db.query(User).filter(User.user_id == user_id,\n                                     User.token == token, User.deleted.is_(False)).first()\n        if user is None:\n            return False\n        if token is None:\n            if user.email == email and user.available:\n                return True\n        if user_id is not None:\n            if user.user_id == user_id and user.token == token and user.available:\n                return True\n        if email is not None:\n            if user.email == email and user.token == token and user.available:\n                return True\n        return False\n\n    @classmethod\n    def add_user(cls, db: Session, user_dict: dict):\n        \"\"\"\n        add user\n        \"\"\"\n        db.add(User(**user_dict))\n        db.commit()\n\n    @classmethod\n    def update_user(cls, db: Session, user: XAgentUser):\n        \"\"\"\n        update user\n        \"\"\"\n        db_user = db.query(User).filter(\n            User.user_id == user.user_id, User.deleted.is_(False)).first()\n\n        db_user.available = user.available\n        db_user.email = user.email\n        db_user.name = user.name\n        db_user.token = user.token\n        db_user.update_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        db.commit()\n",
            "name_column": 6
        },
        "get_user_list": {
            "type": "FunctionDef",
            "name": "get_user_list",
            "md_content": "",
            "code_start_line": 22,
            "code_end_line": 32,
            "parent": "UserDBInterface",
            "have_return": true,
            "code_content": "    def get_user_list(cls, db: Session) -> list[XAgentUser]:\n        \"\"\"get all users\n\n        Args:\n            db (Session): db\n\n        Returns:\n            list[XAgentUser]: user list\n        \"\"\"\n        users = db.query(User).all()\n        return [XAgentUser.from_db(user) for user in users]\n",
            "name_column": 8
        },
        "get_user": {
            "type": "FunctionDef",
            "name": "get_user",
            "md_content": "",
            "code_start_line": 35,
            "code_end_line": 56,
            "parent": "UserDBInterface",
            "have_return": true,
            "code_content": "    def get_user(cls,\n                 db: Session,\n                 user_id: str | None = None,\n                 email: str | None = None) -> XAgentUser | None:\n        \"\"\"get user by user_id or email\n\n        Args:\n            db (Session): db\n            user_id (str | None, optional): user id. Defaults to None.\n            email (str | None, optional): email. Defaults to None.\n\n        Returns:\n            XAgentUser | None: user, if user is not exist, return None\n        \"\"\"\n        if email is not None:\n            user = db.query(User).filter(User.email == email,\n                                         User.deleted.is_(False)).first()\n        else:\n            user = db.query(User).filter(\n                User.user_id == user_id, User.deleted.is_(False)).first()\n\n        return XAgentUser.from_db(user) if user else None\n",
            "name_column": 8
        },
        "is_exist": {
            "type": "FunctionDef",
            "name": "is_exist",
            "md_content": "",
            "code_start_line": 59,
            "code_end_line": 81,
            "parent": "UserDBInterface",
            "have_return": true,
            "code_content": "    def is_exist(cls,\n                db: Session,\n                user_id: str | None = None,\n                email: str | None = None):\n        \"\"\"user is exist?\n\n        Args:\n            db (Session): db session\n            user_id (str | None, optional): user id. Defaults to None.\n            email (str | None, optional): email. Defaults to None.\n\n        Returns:\n            Boolean: True or False\n        \"\"\"\n        if not email and not user_id:\n            return False\n        if email:\n            user = db.query(User).filter(User.email == email,\n                                         User.deleted.is_(False)).first()\n        else:\n            user = db.query(User).filter(\n                User.user_id == user_id, User.deleted.is_(False)).first()\n        return user is not None\n",
            "name_column": 8
        },
        "token_is_exist": {
            "type": "FunctionDef",
            "name": "token_is_exist",
            "md_content": "",
            "code_start_line": 84,
            "code_end_line": 103,
            "parent": "UserDBInterface",
            "have_return": true,
            "code_content": "    def token_is_exist(cls,\n                       db: Session,\n                       user_id: str,\n                       token: str | None = None):\n        \"\"\"token is exist?\n        \n        Args:\n            db (Session): db session\n            user_id (str): user id\n            token (str | None, optional): token. Defaults to None.\n            \n        Returns:\n            Boolean: True or False\n        \"\"\"\n        if not token:\n            return False\n\n        user = db.query(User).filter(User.user_id == user_id,\n                                     User.token == token, User.deleted.is_(False)).first()\n        return user is not None\n",
            "name_column": 8
        },
        "user_is_valid": {
            "type": "FunctionDef",
            "name": "user_is_valid",
            "md_content": "",
            "code_start_line": 106,
            "code_end_line": 137,
            "parent": "UserDBInterface",
            "have_return": true,
            "code_content": "    def user_is_valid(cls, db: Session,\n                      user_id: str | None = None,\n                      email: str | None = None,\n                      token: str | None = None):\n        \"\"\"\n        user is valid?\n        \n        Args:\n            db (Session): db session\n            user_id (str | None, optional): user id. Defaults to None.\n            email (str | None, optional): email. Defaults to None.\n            token (str | None, optional): token. Defaults to None.\n            \n        Returns:\n            Boolean: True or False\n        \"\"\"\n        if email == \"\":\n            return False\n        user = db.query(User).filter(User.user_id == user_id,\n                                     User.token == token, User.deleted.is_(False)).first()\n        if user is None:\n            return False\n        if token is None:\n            if user.email == email and user.available:\n                return True\n        if user_id is not None:\n            if user.user_id == user_id and user.token == token and user.available:\n                return True\n        if email is not None:\n            if user.email == email and user.token == token and user.available:\n                return True\n        return False\n",
            "name_column": 8
        },
        "add_user": {
            "type": "FunctionDef",
            "name": "add_user",
            "md_content": "",
            "code_start_line": 140,
            "code_end_line": 145,
            "parent": "UserDBInterface",
            "have_return": false,
            "code_content": "    def add_user(cls, db: Session, user_dict: dict):\n        \"\"\"\n        add user\n        \"\"\"\n        db.add(User(**user_dict))\n        db.commit()\n",
            "name_column": 8
        },
        "update_user": {
            "type": "FunctionDef",
            "name": "update_user",
            "md_content": "",
            "code_start_line": 148,
            "code_end_line": 160,
            "parent": "UserDBInterface",
            "have_return": false,
            "code_content": "    def update_user(cls, db: Session, user: XAgentUser):\n        \"\"\"\n        update user\n        \"\"\"\n        db_user = db.query(User).filter(\n            User.user_id == user.user_id, User.deleted.is_(False)).first()\n\n        db_user.available = user.available\n        db_user.email = user.email\n        db_user.name = user.name\n        db_user.token = user.token\n        db_user.update_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        db.commit()\n",
            "name_column": 8
        }
    },
    "XAgentServer/database/interface/interaction.py": {
        "InteractionDBInterface": {
            "type": "ClassDef",
            "name": "InteractionDBInterface",
            "md_content": "",
            "code_start_line": 19,
            "code_end_line": 559,
            "parent": null,
            "have_return": true,
            "code_content": "class InteractionDBInterface(metaclass=abc.ABCMeta):\n    \"\"\"Interaction DB Interface\n    \"\"\"\n\n    @classmethod\n    def search_many_interaction(cls, db: Session) -> list[InteractionBase]:\n        \"\"\"search many interactions\n\n        Args:\n            db (Session): db session\n\n        Returns:\n            list[InteractionBase]: interaction list\n        \"\"\"\n        interactions = db.query(Interaction).all()\n        return [InteractionBase.from_db(interaction) for interaction in interactions]\n\n    @classmethod\n    def get_interaction(cls,\n                        db: Session,\n                        interaction_id: str) -> InteractionBase | None:\n        \"\"\"get interaction by interaction_id\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n            InteractionBase | None: _description_\n        \"\"\"\n        interaction = db.query(Interaction).filter(\n            Interaction.interaction_id == interaction_id,\n            Interaction.is_deleted.is_not(True)).first()\n        return InteractionBase.from_db(interaction) if interaction else None\n\n    @classmethod\n    def get_ready_interaction(cls,\n                              db: Session,\n                              user_id: str) -> InteractionBase | None:\n        \"\"\"get interaction by user_id\n\n        Args:\n            db (Session): db session\n            user_id (str): user id\n\n        Returns:\n            InteractionBase | None: _description_\n        \"\"\"\n        interaction = db.query(Interaction).filter(\n            Interaction.user_id == user_id,\n            Interaction.status == 'ready').first()\n        return InteractionBase.from_db(interaction) if interaction else None\n\n    @classmethod\n    def create_interaction(cls,\n                           db: Session,\n                           base: InteractionBase) -> InteractionBase:\n        \"\"\"\n        create interaction\n\n        Args:\n            db (Session): db session\n            base (InteractionBase): interaction base\n\n        Returns:\n            None\n        \"\"\"\n        db.add(Interaction(**base.to_dict()))\n        db.commit()\n        return None\n\n    @classmethod\n    def add_parameter(cls,\n                      db: Session,\n                      parameter: InteractionParameter):\n        \"\"\"\n        add parameter for interaction\n        \"\"\"\n        db.add(Parameter(**parameter.to_dict()))\n        db.commit()\n\n        return None\n\n    @classmethod\n    def search_interaction_by_user_id(cls,\n                                      db: Session,\n                                      user_id: str,\n                                      page_size: int = 20,\n                                      page_num: int = 1) -> list[dict]:\n        \"\"\"\n        search interaction by user id\n\n        Args:\n            db (Session): db session\n            user_id (str): user id\n            page_size (int, optional): page size. Defaults to 20.\n            page_num (int, optional): page num. Defaults to 1.\n\n        Returns:\n            list[dict]: interaction list\n        \"\"\"\n        total = db.query(func.count(Interaction.id)).filter(\n            Interaction.user_id == user_id, Interaction.is_deleted.is_(False)).scalar()\n\n        interaction_list = db.query(Interaction).filter(\n            Interaction.user_id == user_id,\n            Interaction.is_deleted.is_(False),\n            Interaction.status.in_([StatusEnum.FINISHED])).limit(\n            page_size).offset((page_num - 1) * page_size).all()\n        data = []\n        for interaction in interaction_list:\n            d_ = InteractionBase.from_db(interaction).to_dict(\n                exclude=[\"recorder_root_dir\", \"is_deleted\"])\n            parameter = cls.get_parameter(\n                db=db, interaction_id=d_[\"interaction_id\"])\n            d_[\"parameters\"] = [parameter[0]]\n            data.append(d_)\n        return {\n            \"total\": total,\n            \"rows\": data\n        }\n\n    @classmethod\n    def search_many_shared(cls,\n                           db: Session,\n                           page_size: int = 20,\n                           page_index: int = 1) -> list[dict]:\n        \"\"\"\n        search many shared interactions from community\n\n        Args:\n            db (Session): db session\n            page_size (int, optional): page size. Defaults to 20.\n            page_index (int, optional): page index. Defaults to 1.\n\n        Returns:\n            list[dict]: interaction list\n        \"\"\"\n        total = db.query(func.count(SharedInteraction.id)).filter(\n            SharedInteraction.is_deleted.is_(False),\n            SharedInteraction.is_audit.is_(True)).scalar()\n        interaction_list = db.query(SharedInteraction).filter(\n            SharedInteraction.is_deleted.is_(False),\n            SharedInteraction.is_audit.is_(True)).order_by(\n            SharedInteraction.star.desc()).limit(page_size).offset(\n                (page_index - 1) * page_size).all()\n        data = []\n        for interaction in interaction_list:\n            d_ = SharedInteractionBase.from_db(interaction).to_dict(\n                exclude=[\"record_dir\", \"is_deleted\"])\n            parameter = cls.get_parameter(\n                db=db, interaction_id=d_[\"interaction_id\"])\n            d_[\"parameters\"] = parameter\n            data.append(d_)\n        return {\n            \"total\": total,\n            \"rows\": data\n        }\n\n    @classmethod\n    def get_shared_interaction(cls,\n                               db: Session,\n                               interaction_id: str) -> SharedInteractionBase | None:\n        \"\"\"\n        get shared interaction by interaction id\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n\n            SharedInteractionBase | None: shared interaction\n        \"\"\"\n        interaction = db.query(SharedInteraction).filter(\n            SharedInteraction.interaction_id == interaction_id, SharedInteraction.is_deleted.is_(False)).first()\n        return SharedInteractionBase.from_db(interaction) if interaction else None\n\n    @classmethod\n    def is_exist(cls,\n                 db: Session,\n                 interaction_id: str) -> bool:\n        \"\"\"\n        check interaction is exist or not\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n            bool: True or False\n        \"\"\"\n        interaction = db.query(Interaction).filter(\n            Interaction.interaction_id == interaction_id,\n            Interaction.is_deleted.is_(False)).first()\n        return interaction is not None\n\n    @classmethod\n    def update_interaction(cls, db: Session, base_data: dict):\n        \"\"\"\n        update interaction\n\n        Args:\n            db (Session): db session\n            base_data (dict): interaction data\n\n        Returns:\n            None\n        \"\"\"\n        if \"interaction_id\" not in base_data:\n            raise XAgentError(\"interaction_id is required\")\n        interaction = db.query(Interaction).filter(\n            Interaction.interaction_id == base_data[\"interaction_id\"]).first()\n        if interaction is None:\n            raise XAgentError(\"interaction is not exist\")\n        for k, v in base_data.items():\n            if k == \"interaction_id\":\n                continue\n            setattr(interaction, k, v)\n        interaction.update_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        db.commit()\n\n    @classmethod\n    def update_interaction_status(cls,\n                                  db: Session,\n                                  interaction_id: str,\n                                  status: str,\n                                  message: str,\n                                  current_step: int):\n        \"\"\"\n        update interaction status\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n            status (str): status\n            message (str): message\n            current_step (int): current step\n\n        Returns:\n            None\n        \"\"\"\n        db_interaction = db.query(Interaction).filter(\n            Interaction.interaction_id == interaction_id).first()\n        if db_interaction is None:\n            raise XAgentError(\"interaction is not exist\")\n\n        db_interaction.status = status\n        db_interaction.message = message\n        db_interaction.current_step = current_step\n        db_interaction.update_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        db.commit()\n\n    @classmethod\n    def update_interaction_parameter(cls,\n                                     db: Session,\n                                     interaction_id: str,\n                                     parameter: InteractionParameter):\n        \"\"\"\n        update interaction parameter\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n            parameter (InteractionParameter): parameter\n\n        Returns:\n            None\n        \"\"\"\n        db_parameter = db.query(Parameter).filter(\n            Parameter.interaction_id == interaction_id,\n            Parameter.parameter_id == parameter.parameter_id).first()\n\n        if db_parameter is None:\n            db.add(Parameter(**parameter.to_dict()))\n        db.commit()\n\n    @classmethod\n    def is_running(cls, db: Session, user_id: str):\n        \"\"\"\n        check user is only running one interaction\n\n        Args:\n            db (Session): db session\n            user_id (str): user id\n\n        Returns:    \n            bool: True or False\n        \"\"\"\n        interaction = db.query(Interaction).filter(\n            Interaction.user_id == user_id,\n            Interaction.status.in_((\"running\", \"waiting\"))).first()\n        return interaction is not None\n\n    @classmethod\n    def get_parameter(cls, db: Session, interaction_id: str) -> list:\n        \"\"\"\n        get interaction running parameter\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n            list: parameter list\n        \"\"\"\n        raws = db.query(Raw).filter(\n            Raw.interaction_id == interaction_id,\n            Raw.is_human.is_(True),\n            Raw.human_data.is_not(None)).order_by(Raw.step.asc()).all()\n        return [raw.human_data for raw in raws]\n\n    @classmethod\n    def delete_interaction(cls, db: Session, interaction_id: str):\n        \"\"\"\n        delete interaction\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n            None\n\n        Raises:\n            XAgentError: interaction is not exist\n        \"\"\"\n        interaction = db.query(Interaction).filter(\n            Interaction.interaction_id == interaction_id).first()\n        if interaction is None:\n            raise XAgentError(\"interaction is not exist\")\n        interaction.is_deleted = True\n        db.commit()\n\n    @classmethod\n    def add_share(cls, db: Session, shared: SharedInteractionBase):\n        \"\"\"add share interaction\n\n        Args:\n            db (Session): db session\n            shared (SharedInteractionBase): shared interaction from community\n        \"\"\"\n        db.add(SharedInteraction(**shared.to_dict()))\n\n    @classmethod\n    def insert_raw(cls, db: Session, process: XAgentRaw):\n        \"\"\"\n        insert an interaction process for recording\n\n        Args:\n            db (Session): db session\n            process (XAgentRaw): interaction process\n\n        Returns:\n            None\n\n        Raises:\n            XAgentError: interaction is not exist\n        \"\"\"\n        interaction = db.query(Interaction).filter(\n            process.interaction_id == process.interaction_id).first()\n        exist_process = db.query(Raw).filter(\n            Raw.interaction_id == process.interaction_id, Raw.is_deleted.is_(False)).order_by(Raw.step.desc()).first()\n        if interaction is None:\n            raise XAgentError(\"interaction is not exist\")\n\n        if exist_process is not None:\n            process.step = exist_process.step + 1\n        else:\n            process.step = 0\n\n        db.add(Raw(**process.to_dict()))\n        db.commit()\n\n    @classmethod\n    def search_many_raws(cls, db: Session, interaction_id: str):\n        \"\"\"search many raws\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n            list[XAgentRaw]: interaction process list\n        \"\"\"\n        processes = db.query(Raw).filter(\n            Raw.interaction_id == interaction_id, Raw.is_deleted.is_(False)).order_by(Raw.step.asc()).all()\n        return processes\n\n    @classmethod\n    def get_raw(cls, db: Session, interaction_id: str, node_id: str):\n        \"\"\"\n        get raw by interaction id and node id\n        \"\"\"\n        process = db.query(Raw).filter(\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id, Raw.is_deleted.is_(False)).first()\n        return process\n\n    @classmethod\n    def get_next_send(cls, db: Session, interaction_id: str):\n        \"\"\"\n        get next send process\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n            XAgentRaw: interaction process\n        \"\"\"\n        processes = db.query(Raw).filter(Raw.interaction_id == interaction_id,\n                                         Raw.is_send.is_(False),\n                                         Raw.is_deleted.is_(False)).order_by(Raw.step.desc()).all()\n        return processes\n\n    @classmethod\n    def update_send_flag(cls, db: Session, interaction_id: str, node_id: str):\n        \"\"\"\n        update send flag, if send success, update flag\n        if send flag is True, it means that the process has been sent\n        and no longer needs to be sent\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n            node_id (str): node id\n\n        Returns:\n            None\n\n        Raises:\n            XAgentError: process is not exist\n        \"\"\"\n        process = db.query(Raw).filter(\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id).first()\n        if process is None:\n            raise XAgentError(\"process is not exist\")\n        process.is_send = True\n        process.update_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        db.commit()\n\n    @classmethod\n    def update_receive_flag(cls, db: Session, interaction_id: str, node_id: str):\n        \"\"\"\n        update receive flag, if receive success, update flag\n        if this flag is True, it means that the process has been received from human\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n            node_id (str): node id\n\n        Returns:\n            None\n\n        Raises:\n            XAgentError: process is not exist\n        \"\"\"\n        process = db.query(Raw).filter(\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id).first()\n        if process is None:\n            raise XAgentError(\"process is not exist\")\n        process.is_receive = True\n        process.update_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        db.commit()\n\n    @classmethod\n    def update_human_data(cls, db: Session, interaction_id: str, node_id: str, human_data: dict):\n        \"\"\"\n        update human data\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n            node_id (str): node id\n            human_data (dict): human data\n\n        Returns:\n            None\n\n        Raises:\n            XAgentError: process is not exist\n        \"\"\"\n        process = db.query(Raw).filter(\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id, Raw.is_deleted.is_(False)).first()\n        if process is None:\n            raise XAgentError(\"process is not exist\")\n        process.is_receive = True\n        process.is_human = True\n        process.human_data = human_data\n        db.commit()\n\n    @classmethod\n    def insert_error(cls, db: Session, interaction_id: str, message: str):\n        \"\"\"\n        if interaction is failed, insert error message\n        this message will be displayed in the interaction list\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n            message (str): error message\n\n        Returns:\n            None\n\n        Raises:\n            None\n\n        \"\"\"\n        process = Raw(\n            node_id=uuid.uuid4().hex,\n            interaction_id=interaction_id,\n            current=\"\",\n            step=0,\n            data=message,\n            file_list=[],\n            status=StatusEnum.FAILED,\n            create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        )\n        db.add(process)\n        db.commit()\n\n    @classmethod\n    def get_finish_status(cls, db: Session, interaction_id: str):\n        \"\"\"\n        get interaction finish status\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n            Boolean: True or False\n        \"\"\"\n        process = db.query(Raw).filter(\n            Raw.interaction_id == interaction_id,\n            Raw.is_deleted.is_(False),\n            Raw.status == \"finished\").first()\n        return process is not None\n",
            "name_column": 6
        },
        "search_many_interaction": {
            "type": "FunctionDef",
            "name": "search_many_interaction",
            "md_content": "",
            "code_start_line": 24,
            "code_end_line": 34,
            "parent": "InteractionDBInterface",
            "have_return": true,
            "code_content": "    def search_many_interaction(cls, db: Session) -> list[InteractionBase]:\n        \"\"\"search many interactions\n\n        Args:\n            db (Session): db session\n\n        Returns:\n            list[InteractionBase]: interaction list\n        \"\"\"\n        interactions = db.query(Interaction).all()\n        return [InteractionBase.from_db(interaction) for interaction in interactions]\n",
            "name_column": 8
        },
        "get_interaction": {
            "type": "FunctionDef",
            "name": "get_interaction",
            "md_content": "",
            "code_start_line": 37,
            "code_end_line": 52,
            "parent": "InteractionDBInterface",
            "have_return": true,
            "code_content": "    def get_interaction(cls,\n                        db: Session,\n                        interaction_id: str) -> InteractionBase | None:\n        \"\"\"get interaction by interaction_id\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n            InteractionBase | None: _description_\n        \"\"\"\n        interaction = db.query(Interaction).filter(\n            Interaction.interaction_id == interaction_id,\n            Interaction.is_deleted.is_not(True)).first()\n        return InteractionBase.from_db(interaction) if interaction else None\n",
            "name_column": 8
        },
        "get_ready_interaction": {
            "type": "FunctionDef",
            "name": "get_ready_interaction",
            "md_content": "",
            "code_start_line": 55,
            "code_end_line": 70,
            "parent": "InteractionDBInterface",
            "have_return": true,
            "code_content": "    def get_ready_interaction(cls,\n                              db: Session,\n                              user_id: str) -> InteractionBase | None:\n        \"\"\"get interaction by user_id\n\n        Args:\n            db (Session): db session\n            user_id (str): user id\n\n        Returns:\n            InteractionBase | None: _description_\n        \"\"\"\n        interaction = db.query(Interaction).filter(\n            Interaction.user_id == user_id,\n            Interaction.status == 'ready').first()\n        return InteractionBase.from_db(interaction) if interaction else None\n",
            "name_column": 8
        },
        "create_interaction": {
            "type": "FunctionDef",
            "name": "create_interaction",
            "md_content": "",
            "code_start_line": 73,
            "code_end_line": 88,
            "parent": "InteractionDBInterface",
            "have_return": true,
            "code_content": "    def create_interaction(cls,\n                           db: Session,\n                           base: InteractionBase) -> InteractionBase:\n        \"\"\"\n        create interaction\n\n        Args:\n            db (Session): db session\n            base (InteractionBase): interaction base\n\n        Returns:\n            None\n        \"\"\"\n        db.add(Interaction(**base.to_dict()))\n        db.commit()\n        return None\n",
            "name_column": 8
        },
        "add_parameter": {
            "type": "FunctionDef",
            "name": "add_parameter",
            "md_content": "",
            "code_start_line": 91,
            "code_end_line": 100,
            "parent": "InteractionDBInterface",
            "have_return": true,
            "code_content": "    def add_parameter(cls,\n                      db: Session,\n                      parameter: InteractionParameter):\n        \"\"\"\n        add parameter for interaction\n        \"\"\"\n        db.add(Parameter(**parameter.to_dict()))\n        db.commit()\n\n        return None\n",
            "name_column": 8
        },
        "search_interaction_by_user_id": {
            "type": "FunctionDef",
            "name": "search_interaction_by_user_id",
            "md_content": "",
            "code_start_line": 103,
            "code_end_line": 139,
            "parent": "InteractionDBInterface",
            "have_return": true,
            "code_content": "    def search_interaction_by_user_id(cls,\n                                      db: Session,\n                                      user_id: str,\n                                      page_size: int = 20,\n                                      page_num: int = 1) -> list[dict]:\n        \"\"\"\n        search interaction by user id\n\n        Args:\n            db (Session): db session\n            user_id (str): user id\n            page_size (int, optional): page size. Defaults to 20.\n            page_num (int, optional): page num. Defaults to 1.\n\n        Returns:\n            list[dict]: interaction list\n        \"\"\"\n        total = db.query(func.count(Interaction.id)).filter(\n            Interaction.user_id == user_id, Interaction.is_deleted.is_(False)).scalar()\n\n        interaction_list = db.query(Interaction).filter(\n            Interaction.user_id == user_id,\n            Interaction.is_deleted.is_(False),\n            Interaction.status.in_([StatusEnum.FINISHED])).limit(\n            page_size).offset((page_num - 1) * page_size).all()\n        data = []\n        for interaction in interaction_list:\n            d_ = InteractionBase.from_db(interaction).to_dict(\n                exclude=[\"recorder_root_dir\", \"is_deleted\"])\n            parameter = cls.get_parameter(\n                db=db, interaction_id=d_[\"interaction_id\"])\n            d_[\"parameters\"] = [parameter[0]]\n            data.append(d_)\n        return {\n            \"total\": total,\n            \"rows\": data\n        }\n",
            "name_column": 8
        },
        "search_many_shared": {
            "type": "FunctionDef",
            "name": "search_many_shared",
            "md_content": "",
            "code_start_line": 142,
            "code_end_line": 176,
            "parent": "InteractionDBInterface",
            "have_return": true,
            "code_content": "    def search_many_shared(cls,\n                           db: Session,\n                           page_size: int = 20,\n                           page_index: int = 1) -> list[dict]:\n        \"\"\"\n        search many shared interactions from community\n\n        Args:\n            db (Session): db session\n            page_size (int, optional): page size. Defaults to 20.\n            page_index (int, optional): page index. Defaults to 1.\n\n        Returns:\n            list[dict]: interaction list\n        \"\"\"\n        total = db.query(func.count(SharedInteraction.id)).filter(\n            SharedInteraction.is_deleted.is_(False),\n            SharedInteraction.is_audit.is_(True)).scalar()\n        interaction_list = db.query(SharedInteraction).filter(\n            SharedInteraction.is_deleted.is_(False),\n            SharedInteraction.is_audit.is_(True)).order_by(\n            SharedInteraction.star.desc()).limit(page_size).offset(\n                (page_index - 1) * page_size).all()\n        data = []\n        for interaction in interaction_list:\n            d_ = SharedInteractionBase.from_db(interaction).to_dict(\n                exclude=[\"record_dir\", \"is_deleted\"])\n            parameter = cls.get_parameter(\n                db=db, interaction_id=d_[\"interaction_id\"])\n            d_[\"parameters\"] = parameter\n            data.append(d_)\n        return {\n            \"total\": total,\n            \"rows\": data\n        }\n",
            "name_column": 8
        },
        "get_shared_interaction": {
            "type": "FunctionDef",
            "name": "get_shared_interaction",
            "md_content": "",
            "code_start_line": 179,
            "code_end_line": 195,
            "parent": "InteractionDBInterface",
            "have_return": true,
            "code_content": "    def get_shared_interaction(cls,\n                               db: Session,\n                               interaction_id: str) -> SharedInteractionBase | None:\n        \"\"\"\n        get shared interaction by interaction id\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n\n            SharedInteractionBase | None: shared interaction\n        \"\"\"\n        interaction = db.query(SharedInteraction).filter(\n            SharedInteraction.interaction_id == interaction_id, SharedInteraction.is_deleted.is_(False)).first()\n        return SharedInteractionBase.from_db(interaction) if interaction else None\n",
            "name_column": 8
        },
        "is_exist": {
            "type": "FunctionDef",
            "name": "is_exist",
            "md_content": "",
            "code_start_line": 198,
            "code_end_line": 214,
            "parent": "InteractionDBInterface",
            "have_return": true,
            "code_content": "    def is_exist(cls,\n                 db: Session,\n                 interaction_id: str) -> bool:\n        \"\"\"\n        check interaction is exist or not\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n            bool: True or False\n        \"\"\"\n        interaction = db.query(Interaction).filter(\n            Interaction.interaction_id == interaction_id,\n            Interaction.is_deleted.is_(False)).first()\n        return interaction is not None\n",
            "name_column": 8
        },
        "update_interaction": {
            "type": "FunctionDef",
            "name": "update_interaction",
            "md_content": "",
            "code_start_line": 217,
            "code_end_line": 239,
            "parent": "InteractionDBInterface",
            "have_return": false,
            "code_content": "    def update_interaction(cls, db: Session, base_data: dict):\n        \"\"\"\n        update interaction\n\n        Args:\n            db (Session): db session\n            base_data (dict): interaction data\n\n        Returns:\n            None\n        \"\"\"\n        if \"interaction_id\" not in base_data:\n            raise XAgentError(\"interaction_id is required\")\n        interaction = db.query(Interaction).filter(\n            Interaction.interaction_id == base_data[\"interaction_id\"]).first()\n        if interaction is None:\n            raise XAgentError(\"interaction is not exist\")\n        for k, v in base_data.items():\n            if k == \"interaction_id\":\n                continue\n            setattr(interaction, k, v)\n        interaction.update_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        db.commit()\n",
            "name_column": 8
        },
        "update_interaction_status": {
            "type": "FunctionDef",
            "name": "update_interaction_status",
            "md_content": "",
            "code_start_line": 242,
            "code_end_line": 270,
            "parent": "InteractionDBInterface",
            "have_return": false,
            "code_content": "    def update_interaction_status(cls,\n                                  db: Session,\n                                  interaction_id: str,\n                                  status: str,\n                                  message: str,\n                                  current_step: int):\n        \"\"\"\n        update interaction status\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n            status (str): status\n            message (str): message\n            current_step (int): current step\n\n        Returns:\n            None\n        \"\"\"\n        db_interaction = db.query(Interaction).filter(\n            Interaction.interaction_id == interaction_id).first()\n        if db_interaction is None:\n            raise XAgentError(\"interaction is not exist\")\n\n        db_interaction.status = status\n        db_interaction.message = message\n        db_interaction.current_step = current_step\n        db_interaction.update_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        db.commit()\n",
            "name_column": 8
        },
        "update_interaction_parameter": {
            "type": "FunctionDef",
            "name": "update_interaction_parameter",
            "md_content": "",
            "code_start_line": 273,
            "code_end_line": 294,
            "parent": "InteractionDBInterface",
            "have_return": false,
            "code_content": "    def update_interaction_parameter(cls,\n                                     db: Session,\n                                     interaction_id: str,\n                                     parameter: InteractionParameter):\n        \"\"\"\n        update interaction parameter\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n            parameter (InteractionParameter): parameter\n\n        Returns:\n            None\n        \"\"\"\n        db_parameter = db.query(Parameter).filter(\n            Parameter.interaction_id == interaction_id,\n            Parameter.parameter_id == parameter.parameter_id).first()\n\n        if db_parameter is None:\n            db.add(Parameter(**parameter.to_dict()))\n        db.commit()\n",
            "name_column": 8
        },
        "is_running": {
            "type": "FunctionDef",
            "name": "is_running",
            "md_content": "",
            "code_start_line": 297,
            "code_end_line": 311,
            "parent": "InteractionDBInterface",
            "have_return": true,
            "code_content": "    def is_running(cls, db: Session, user_id: str):\n        \"\"\"\n        check user is only running one interaction\n\n        Args:\n            db (Session): db session\n            user_id (str): user id\n\n        Returns:    \n            bool: True or False\n        \"\"\"\n        interaction = db.query(Interaction).filter(\n            Interaction.user_id == user_id,\n            Interaction.status.in_((\"running\", \"waiting\"))).first()\n        return interaction is not None\n",
            "name_column": 8
        },
        "get_parameter": {
            "type": "FunctionDef",
            "name": "get_parameter",
            "md_content": "",
            "code_start_line": 314,
            "code_end_line": 329,
            "parent": "InteractionDBInterface",
            "have_return": true,
            "code_content": "    def get_parameter(cls, db: Session, interaction_id: str) -> list:\n        \"\"\"\n        get interaction running parameter\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n            list: parameter list\n        \"\"\"\n        raws = db.query(Raw).filter(\n            Raw.interaction_id == interaction_id,\n            Raw.is_human.is_(True),\n            Raw.human_data.is_not(None)).order_by(Raw.step.asc()).all()\n        return [raw.human_data for raw in raws]\n",
            "name_column": 8
        },
        "delete_interaction": {
            "type": "FunctionDef",
            "name": "delete_interaction",
            "md_content": "",
            "code_start_line": 332,
            "code_end_line": 351,
            "parent": "InteractionDBInterface",
            "have_return": false,
            "code_content": "    def delete_interaction(cls, db: Session, interaction_id: str):\n        \"\"\"\n        delete interaction\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n            None\n\n        Raises:\n            XAgentError: interaction is not exist\n        \"\"\"\n        interaction = db.query(Interaction).filter(\n            Interaction.interaction_id == interaction_id).first()\n        if interaction is None:\n            raise XAgentError(\"interaction is not exist\")\n        interaction.is_deleted = True\n        db.commit()\n",
            "name_column": 8
        },
        "add_share": {
            "type": "FunctionDef",
            "name": "add_share",
            "md_content": "",
            "code_start_line": 354,
            "code_end_line": 361,
            "parent": "InteractionDBInterface",
            "have_return": false,
            "code_content": "    def add_share(cls, db: Session, shared: SharedInteractionBase):\n        \"\"\"add share interaction\n\n        Args:\n            db (Session): db session\n            shared (SharedInteractionBase): shared interaction from community\n        \"\"\"\n        db.add(SharedInteraction(**shared.to_dict()))\n",
            "name_column": 8
        },
        "insert_raw": {
            "type": "FunctionDef",
            "name": "insert_raw",
            "md_content": "",
            "code_start_line": 364,
            "code_end_line": 391,
            "parent": "InteractionDBInterface",
            "have_return": false,
            "code_content": "    def insert_raw(cls, db: Session, process: XAgentRaw):\n        \"\"\"\n        insert an interaction process for recording\n\n        Args:\n            db (Session): db session\n            process (XAgentRaw): interaction process\n\n        Returns:\n            None\n\n        Raises:\n            XAgentError: interaction is not exist\n        \"\"\"\n        interaction = db.query(Interaction).filter(\n            process.interaction_id == process.interaction_id).first()\n        exist_process = db.query(Raw).filter(\n            Raw.interaction_id == process.interaction_id, Raw.is_deleted.is_(False)).order_by(Raw.step.desc()).first()\n        if interaction is None:\n            raise XAgentError(\"interaction is not exist\")\n\n        if exist_process is not None:\n            process.step = exist_process.step + 1\n        else:\n            process.step = 0\n\n        db.add(Raw(**process.to_dict()))\n        db.commit()\n",
            "name_column": 8
        },
        "search_many_raws": {
            "type": "FunctionDef",
            "name": "search_many_raws",
            "md_content": "",
            "code_start_line": 394,
            "code_end_line": 406,
            "parent": "InteractionDBInterface",
            "have_return": true,
            "code_content": "    def search_many_raws(cls, db: Session, interaction_id: str):\n        \"\"\"search many raws\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n            list[XAgentRaw]: interaction process list\n        \"\"\"\n        processes = db.query(Raw).filter(\n            Raw.interaction_id == interaction_id, Raw.is_deleted.is_(False)).order_by(Raw.step.asc()).all()\n        return processes\n",
            "name_column": 8
        },
        "get_raw": {
            "type": "FunctionDef",
            "name": "get_raw",
            "md_content": "",
            "code_start_line": 409,
            "code_end_line": 415,
            "parent": "InteractionDBInterface",
            "have_return": true,
            "code_content": "    def get_raw(cls, db: Session, interaction_id: str, node_id: str):\n        \"\"\"\n        get raw by interaction id and node id\n        \"\"\"\n        process = db.query(Raw).filter(\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id, Raw.is_deleted.is_(False)).first()\n        return process\n",
            "name_column": 8
        },
        "get_next_send": {
            "type": "FunctionDef",
            "name": "get_next_send",
            "md_content": "",
            "code_start_line": 418,
            "code_end_line": 432,
            "parent": "InteractionDBInterface",
            "have_return": true,
            "code_content": "    def get_next_send(cls, db: Session, interaction_id: str):\n        \"\"\"\n        get next send process\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n            XAgentRaw: interaction process\n        \"\"\"\n        processes = db.query(Raw).filter(Raw.interaction_id == interaction_id,\n                                         Raw.is_send.is_(False),\n                                         Raw.is_deleted.is_(False)).order_by(Raw.step.desc()).all()\n        return processes\n",
            "name_column": 8
        },
        "update_send_flag": {
            "type": "FunctionDef",
            "name": "update_send_flag",
            "md_content": "",
            "code_start_line": 435,
            "code_end_line": 458,
            "parent": "InteractionDBInterface",
            "have_return": false,
            "code_content": "    def update_send_flag(cls, db: Session, interaction_id: str, node_id: str):\n        \"\"\"\n        update send flag, if send success, update flag\n        if send flag is True, it means that the process has been sent\n        and no longer needs to be sent\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n            node_id (str): node id\n\n        Returns:\n            None\n\n        Raises:\n            XAgentError: process is not exist\n        \"\"\"\n        process = db.query(Raw).filter(\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id).first()\n        if process is None:\n            raise XAgentError(\"process is not exist\")\n        process.is_send = True\n        process.update_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        db.commit()\n",
            "name_column": 8
        },
        "update_receive_flag": {
            "type": "FunctionDef",
            "name": "update_receive_flag",
            "md_content": "",
            "code_start_line": 461,
            "code_end_line": 483,
            "parent": "InteractionDBInterface",
            "have_return": false,
            "code_content": "    def update_receive_flag(cls, db: Session, interaction_id: str, node_id: str):\n        \"\"\"\n        update receive flag, if receive success, update flag\n        if this flag is True, it means that the process has been received from human\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n            node_id (str): node id\n\n        Returns:\n            None\n\n        Raises:\n            XAgentError: process is not exist\n        \"\"\"\n        process = db.query(Raw).filter(\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id).first()\n        if process is None:\n            raise XAgentError(\"process is not exist\")\n        process.is_receive = True\n        process.update_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        db.commit()\n",
            "name_column": 8
        },
        "update_human_data": {
            "type": "FunctionDef",
            "name": "update_human_data",
            "md_content": "",
            "code_start_line": 486,
            "code_end_line": 509,
            "parent": "InteractionDBInterface",
            "have_return": false,
            "code_content": "    def update_human_data(cls, db: Session, interaction_id: str, node_id: str, human_data: dict):\n        \"\"\"\n        update human data\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n            node_id (str): node id\n            human_data (dict): human data\n\n        Returns:\n            None\n\n        Raises:\n            XAgentError: process is not exist\n        \"\"\"\n        process = db.query(Raw).filter(\n            Raw.interaction_id == interaction_id, Raw.node_id == node_id, Raw.is_deleted.is_(False)).first()\n        if process is None:\n            raise XAgentError(\"process is not exist\")\n        process.is_receive = True\n        process.is_human = True\n        process.human_data = human_data\n        db.commit()\n",
            "name_column": 8
        },
        "insert_error": {
            "type": "FunctionDef",
            "name": "insert_error",
            "md_content": "",
            "code_start_line": 512,
            "code_end_line": 541,
            "parent": "InteractionDBInterface",
            "have_return": false,
            "code_content": "    def insert_error(cls, db: Session, interaction_id: str, message: str):\n        \"\"\"\n        if interaction is failed, insert error message\n        this message will be displayed in the interaction list\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n            message (str): error message\n\n        Returns:\n            None\n\n        Raises:\n            None\n\n        \"\"\"\n        process = Raw(\n            node_id=uuid.uuid4().hex,\n            interaction_id=interaction_id,\n            current=\"\",\n            step=0,\n            data=message,\n            file_list=[],\n            status=StatusEnum.FAILED,\n            create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        )\n        db.add(process)\n        db.commit()\n",
            "name_column": 8
        },
        "get_finish_status": {
            "type": "FunctionDef",
            "name": "get_finish_status",
            "md_content": "",
            "code_start_line": 544,
            "code_end_line": 559,
            "parent": "InteractionDBInterface",
            "have_return": true,
            "code_content": "    def get_finish_status(cls, db: Session, interaction_id: str):\n        \"\"\"\n        get interaction finish status\n\n        Args:\n            db (Session): db session\n            interaction_id (str): interaction id\n\n        Returns:\n            Boolean: True or False\n        \"\"\"\n        process = db.query(Raw).filter(\n            Raw.interaction_id == interaction_id,\n            Raw.is_deleted.is_(False),\n            Raw.status == \"finished\").first()\n        return process is not None\n",
            "name_column": 8
        }
    },
    "XAgentServer/database/interface/recorder.py": {
        "RecordDBInterface": {
            "type": "ClassDef",
            "name": "RecordDBInterface",
            "md_content": "",
            "code_start_line": 10,
            "code_end_line": 99,
            "parent": null,
            "have_return": true,
            "code_content": "class RecordDBInterface(metaclass=abc.ABCMeta):\n    \"\"\"Recorder DB Interface\n\n    Args:\n        RecorderBaseInterface (_type_): _description_\n        metaclass (_type_, optional): _description_. Defaults to abc.ABCMeta.\n    \"\"\"\n\n    @classmethod\n    def get_record_list(cls, db: Session, record_id: str) -> list[XAgentRunningRecord]:\n        \"\"\"get all records\n\n        Args:\n            db (Session): db\n\n        Returns:\n            list[XAgentRunningRecord]: Recorder list\n        \"\"\"\n        records = db.query(RunningRecord).filter(\n            RunningRecord.record_id == record_id).all()\n        return [XAgentRunningRecord.from_db(Recorder) for Recorder in records]\n\n    @classmethod\n    def get_record(cls,\n                     db: Session,\n                     record_id: str | None = None\n                     ) -> XAgentRunningRecord | None:\n        \"\"\"get Recorder by Recorder_id or email\n\n        Args:\n            db (Session): db\n            Recorder_id (str | None, optional): Recorder id. Defaults to None.\n            email (str | None, optional): email. Defaults to None.\n\n        Returns:\n            XAgentRunningRecord | None: Recorder, if Recorder is not exist, return None\n        \"\"\"\n        record = db.query(RunningRecord).filter(RunningRecord.record_id == record_id,\n                                                  RunningRecord.deleted.is_(False)).first()\n\n        return XAgentRunningRecord.from_db(record) if record else None\n\n    @classmethod\n    def insert_record(cls,\n                      db: Session,\n                      record: XAgentRunningRecord):\n        \"\"\"insert Recorder\n\n        Args:\n            db (Session): db\n            record (XAgentRunningRecord): Recorder\n        \"\"\"\n        db_record = RunningRecord(**record.to_dict())\n        db.add(db_record)\n        db.commit()\n        db.refresh(db_record)\n        return db_record\n    \n    @classmethod\n    def get_record_by_type(cls,\n                           db: Session,\n                           record_id: str,\n                           node_id: str = \"\",\n                           node_type: str = \"\") -> list[XAgentRunningRecord]:\n        \"\"\"get Recorder by type\n\n        Args:\n            db (Session): db\n            record_id (str): record id\n            node_id (str): node id\n            node_type (str): node type\n\n        Returns:\n            list[XAgentRunningRecord]: Recorder list\n        \"\"\"\n\n        filters = [RunningRecord.deleted.is_(False)]\n\n        if record_id:\n            filters.append(RunningRecord.record_id == record_id)\n\n        if node_id:\n            filters.append(RunningRecord.node_id == node_id)\n\n        if node_type:\n            filters.append(RunningRecord.node_type == node_type)\n\n        records = db.query(RunningRecord).filter(*filters).all()\n\n        return [XAgentRunningRecord.from_db(Recorder) for Recorder in records]\n",
            "name_column": 6
        },
        "get_record_list": {
            "type": "FunctionDef",
            "name": "get_record_list",
            "md_content": "",
            "code_start_line": 19,
            "code_end_line": 30,
            "parent": "RecordDBInterface",
            "have_return": true,
            "code_content": "    def get_record_list(cls, db: Session, record_id: str) -> list[XAgentRunningRecord]:\n        \"\"\"get all records\n\n        Args:\n            db (Session): db\n\n        Returns:\n            list[XAgentRunningRecord]: Recorder list\n        \"\"\"\n        records = db.query(RunningRecord).filter(\n            RunningRecord.record_id == record_id).all()\n        return [XAgentRunningRecord.from_db(Recorder) for Recorder in records]\n",
            "name_column": 8
        },
        "get_record": {
            "type": "FunctionDef",
            "name": "get_record",
            "md_content": "",
            "code_start_line": 33,
            "code_end_line": 50,
            "parent": "RecordDBInterface",
            "have_return": true,
            "code_content": "    def get_record(cls,\n                     db: Session,\n                     record_id: str | None = None\n                     ) -> XAgentRunningRecord | None:\n        \"\"\"get Recorder by Recorder_id or email\n\n        Args:\n            db (Session): db\n            Recorder_id (str | None, optional): Recorder id. Defaults to None.\n            email (str | None, optional): email. Defaults to None.\n\n        Returns:\n            XAgentRunningRecord | None: Recorder, if Recorder is not exist, return None\n        \"\"\"\n        record = db.query(RunningRecord).filter(RunningRecord.record_id == record_id,\n                                                  RunningRecord.deleted.is_(False)).first()\n\n        return XAgentRunningRecord.from_db(record) if record else None\n",
            "name_column": 8
        },
        "insert_record": {
            "type": "FunctionDef",
            "name": "insert_record",
            "md_content": "",
            "code_start_line": 53,
            "code_end_line": 66,
            "parent": "RecordDBInterface",
            "have_return": true,
            "code_content": "    def insert_record(cls,\n                      db: Session,\n                      record: XAgentRunningRecord):\n        \"\"\"insert Recorder\n\n        Args:\n            db (Session): db\n            record (XAgentRunningRecord): Recorder\n        \"\"\"\n        db_record = RunningRecord(**record.to_dict())\n        db.add(db_record)\n        db.commit()\n        db.refresh(db_record)\n        return db_record\n",
            "name_column": 8
        },
        "get_record_by_type": {
            "type": "FunctionDef",
            "name": "get_record_by_type",
            "md_content": "",
            "code_start_line": 69,
            "code_end_line": 99,
            "parent": "RecordDBInterface",
            "have_return": true,
            "code_content": "    def get_record_by_type(cls,\n                           db: Session,\n                           record_id: str,\n                           node_id: str = \"\",\n                           node_type: str = \"\") -> list[XAgentRunningRecord]:\n        \"\"\"get Recorder by type\n\n        Args:\n            db (Session): db\n            record_id (str): record id\n            node_id (str): node id\n            node_type (str): node type\n\n        Returns:\n            list[XAgentRunningRecord]: Recorder list\n        \"\"\"\n\n        filters = [RunningRecord.deleted.is_(False)]\n\n        if record_id:\n            filters.append(RunningRecord.record_id == record_id)\n\n        if node_id:\n            filters.append(RunningRecord.node_id == node_id)\n\n        if node_type:\n            filters.append(RunningRecord.node_type == node_type)\n\n        records = db.query(RunningRecord).filter(*filters).all()\n\n        return [XAgentRunningRecord.from_db(Recorder) for Recorder in records]\n",
            "name_column": 8
        }
    },
    "XAgentServer/loggers/logs.py": {
        "JsonFileHandler": {
            "type": "ClassDef",
            "name": "JsonFileHandler",
            "md_content": "",
            "code_start_line": 16,
            "code_end_line": 24,
            "parent": null,
            "have_return": false,
            "code_content": "class JsonFileHandler(logging.FileHandler):\n    \"\"\"JsonFileHandler\"\"\"\n    def __init__(self, filename, mode=\"a\", encoding=None, delay=False):\n        super().__init__(filename, mode, encoding, delay)\n\n    def emit(self, record):\n        json_data = json.loads(self.format(record))\n        with open(self.baseFilename, \"w\", encoding=\"utf-8\") as f:\n            json.dump(json_data, f, ensure_ascii=False, indent=4)\n",
            "name_column": 6
        },
        "JsonFormatter": {
            "type": "ClassDef",
            "name": "JsonFormatter",
            "md_content": "",
            "code_start_line": 27,
            "code_end_line": 30,
            "parent": null,
            "have_return": true,
            "code_content": "class JsonFormatter(logging.Formatter):\n    \"\"\"Json Formatter\"\"\"\n    def format(self, record):\n        return record.msg\n",
            "name_column": 6
        },
        "Logger": {
            "type": "ClassDef",
            "name": "Logger",
            "md_content": "",
            "code_start_line": 33,
            "code_end_line": 191,
            "parent": null,
            "have_return": true,
            "code_content": "class Logger(metaclass=abc.ABCMeta):\n    \"\"\"\n    Logger that handle titles in different colors.\n    Outputs logs in console, activity.log, and errors.log\n    For console handler: simulates typing\n    \"\"\"\n\n    def __init__(self, log_dir: str = None, log_name: str= \"\", log_file: str = \"activity.log\", error_file: str = \"errors.log\"):\n        \"\"\"init\"\"\"\n        if not os.path.exists(log_dir):\n            os.makedirs(log_dir)\n\n        # create log directory if it doesn't exist\n        self.log_name = time.strftime(\"%Y-%m-%d\", time.localtime()) if not log_name else log_name\n        self.logger = logging.getLogger(self.log_name)\n        console_formatter = RecordFormatter(\"%(title_color)s %(message)s\")\n\n        # Create a handler for console which simulate typing\n        self.typing_console_handler = TypingConsoleHandler()\n        self.typing_console_handler.setLevel(logging.INFO)\n        self.typing_console_handler.setFormatter(console_formatter)\n\n        # Create a handler for console without typing simulation\n        self.console_handler = ConsoleHandler()\n        self.console_handler.setLevel(logging.DEBUG)\n        self.console_handler.setFormatter(console_formatter)\n\n        self.speak_mode = False\n        self.chat_plugins = []\n\n        # Info handler in activity.log\n        self.file_handler = logging.FileHandler(\n            os.path.join(log_dir, log_file), \"a\", \"utf-8\"\n        )\n        self.file_handler.setLevel(logging.DEBUG)\n        info_formatter = RecordFormatter(\n            \"%(asctime)s [%(threadName)s] %(levelname)s: %(title_color)s %(title)s %(message)s\"\n        )\n        self.file_handler.setFormatter(info_formatter)\n\n        # Error handler error.log\n        error_handler = logging.FileHandler(\n            os.path.join(log_dir, error_file), \"a\", \"utf-8\"\n        )\n        error_handler.setLevel(logging.ERROR)\n        error_formatter = RecordFormatter(\n            \"%(asctime)s [%(threadName)s] %(levelname)s %(module)s:%(funcName)s:%(lineno)d %(title_color)s %(title)s\"\n            \" %(message_no_color)s\"\n        )\n        error_handler.setFormatter(error_formatter)\n\n        # self.typing_logger = logging.getLogger(self.log_name)\n        # if not self.typing_logger.handlers:\n        #     self.typing_logger.addHandler(self.typing_console_handler)\n        #     self.typing_logger.addHandler(self.file_handler)\n        #     self.typing_logger.addHandler(error_handler)\n        # self.typing_logger.setLevel(logging.DEBUG)\n\n        if self.log_name.endswith(\"_INTERACT\") or not self.logger.handlers:\n            # self.logger.addHandler(self.typing_console_handler)\n            self.logger.addHandler(self.console_handler)\n            self.logger.addHandler(error_handler)\n            self.logger.addHandler(self.file_handler)\n            self.logger.setLevel(logging.DEBUG)\n    \n    def typewriter_log(\n        self, title=\"\", title_color=\"\", content=\"\", speak_text=False, level=logging.INFO\n    ):\n        # if speak_text and self.speak_mode:\n        #     say_text(f\"{title}. {content}\")\n\n        for plugin in self.chat_plugins:\n            plugin.report(f\"{title}. {content}\")\n\n        if content:\n            if isinstance(content, list):\n                content = \" \".join(content)\n        else:\n            content = \"\"\n\n        self.logger.log(\n            level, content, extra={\"title\": title, \"color\": title_color}\n        )\n\n    def debug(\n        self,\n        message,\n        title=\"\",\n        title_color=\"\",\n    ):\n        self._log(title, title_color, message, logging.DEBUG)\n\n    def info(\n        self,\n        message,\n        title=\"\",\n        title_color=\"\",\n    ):\n        self._log(title, title_color, message, logging.INFO)\n\n    def warn(\n        self,\n        message,\n        title=\"\",\n        title_color=\"\",\n    ):\n        self._log(title, title_color, message, logging.WARN)\n\n    def error(self, title, message=\"\"):\n        self._log(title, Fore.RED, message, logging.ERROR)\n\n    def _log(\n        self,\n        title: str = \"\",\n        title_color: str = \"\",\n        message: str = \"\",\n        level=logging.INFO,\n    ):\n        if message:\n            if isinstance(message, list):\n                message = \" \".join(message)\n        self.logger.log(\n            level, message, extra={\"title\": str(title), \"color\": str(title_color)}\n        )\n\n    def set_level(self, level):\n        self.logger.setLevel(level)\n        self.typing_logger.setLevel(level)\n\n    def double_check(self, additionalText=None):\n        if not additionalText:\n            additionalText = (\n                \"Please ensure you've setup and configured everything\"\n                \" correctly. Read https://github.com/Torantulino/Auto-GPT#readme to \"\n                \"double check. You can also create a github issue or join the discord\"\n                \" and ask there!\"\n            )\n\n        self.typewriter_log(\"DOUBLE CHECK CONFIGURATION\", Fore.YELLOW, additionalText)\n\n    def log_json(self, data: Any, file_name: str) -> None:\n        # Define log directory\n        this_files_dir_path = os.path.dirname(__file__)\n        log_dir = os.path.join(this_files_dir_path, \"../logs\")\n\n        # Create a handler for JSON files\n        json_file_path = os.path.join(log_dir, file_name)\n        json_data_handler = JsonFileHandler(json_file_path)\n        json_data_handler.setFormatter(JsonFormatter())\n\n        # Log the JSON data using the custom file handler\n        self.json_logger.addHandler(json_data_handler)\n        self.json_logger.debug(data)\n        self.json_logger.removeHandler(json_data_handler)\n\n    def get_log_directory(self):\n        this_files_dir_path = os.path.dirname(__file__)\n        log_dir = os.path.join(this_files_dir_path, \"../logs\")\n        return os.path.abspath(log_dir)\n",
            "name_column": 6
        },
        "TypingConsoleHandler": {
            "type": "ClassDef",
            "name": "TypingConsoleHandler",
            "md_content": "",
            "code_start_line": 199,
            "code_end_line": 218,
            "parent": null,
            "have_return": false,
            "code_content": "class TypingConsoleHandler(logging.StreamHandler):\n    def emit(self, record):\n        min_typing_speed = 0.05\n        max_typing_speed = 0.01\n\n        msg = self.format(record)\n        try:\n            words = msg.split()\n            for i, word in enumerate(words):\n                print(word, end=\"\", flush=True)\n                if i < len(words) - 1:\n                    print(\" \", end=\"\", flush=True)\n                typing_speed = random.uniform(min_typing_speed, max_typing_speed)\n                time.sleep(typing_speed)\n                # type faster after each word\n                min_typing_speed = min_typing_speed * 0.95\n                max_typing_speed = max_typing_speed * 0.95\n            print()\n        except Exception:\n            self.handleError(record)\n",
            "name_column": 6
        },
        "ConsoleHandler": {
            "type": "ClassDef",
            "name": "ConsoleHandler",
            "md_content": "",
            "code_start_line": 221,
            "code_end_line": 227,
            "parent": null,
            "have_return": false,
            "code_content": "class ConsoleHandler(logging.StreamHandler):\n    def emit(self, record) -> None:\n        msg = self.format(record)\n        try:\n            print(msg)\n        except Exception:\n            self.handleError(record)\n",
            "name_column": 6
        },
        "RecordFormatter": {
            "type": "ClassDef",
            "name": "RecordFormatter",
            "md_content": "",
            "code_start_line": 230,
            "code_end_line": 254,
            "parent": null,
            "have_return": true,
            "code_content": "class RecordFormatter(logging.Formatter):\n    \"\"\"\n    Allows to handle custom placeholders 'title_color' and 'message_no_color'.\n    To use this formatter, make sure to pass 'color', 'title' as log extras.\n    \"\"\"\n\n    def format(self, record: LogRecord) -> str:\n        if hasattr(record, \"color\"):\n            record.title_color = (\n                getattr(record, \"color\")\n                + getattr(record, \"title\", \"\")\n                + \" \"\n                + Style.RESET_ALL\n            )\n        else:\n            record.title_color = getattr(record, \"title\", \"\")\n\n        # Add this line to set 'title' to an empty string if it doesn't exist\n        record.title = getattr(record, \"title\", \"\")\n\n        if hasattr(record, \"msg\"):\n            record.message_no_color = remove_color_codes(getattr(record, \"msg\"))\n        else:\n            record.message_no_color = \"\"\n        return super().format(record)\n",
            "name_column": 6
        },
        "remove_color_codes": {
            "type": "FunctionDef",
            "name": "remove_color_codes",
            "md_content": "",
            "code_start_line": 257,
            "code_end_line": 259,
            "parent": null,
            "have_return": true,
            "code_content": "def remove_color_codes(s: str) -> str:\n    ansi_escape = re.compile(r\"\\x1B(?:[@-Z\\\\-_]|\\[[0-?]*[ -/]*[@-~])\")\n    return ansi_escape.sub(\"\", s)\n",
            "name_column": 4
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 40,
            "code_end_line": 96,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def __init__(self, log_dir: str = None, log_name: str= \"\", log_file: str = \"activity.log\", error_file: str = \"errors.log\"):\n        \"\"\"init\"\"\"\n        if not os.path.exists(log_dir):\n            os.makedirs(log_dir)\n\n        # create log directory if it doesn't exist\n        self.log_name = time.strftime(\"%Y-%m-%d\", time.localtime()) if not log_name else log_name\n        self.logger = logging.getLogger(self.log_name)\n        console_formatter = RecordFormatter(\"%(title_color)s %(message)s\")\n\n        # Create a handler for console which simulate typing\n        self.typing_console_handler = TypingConsoleHandler()\n        self.typing_console_handler.setLevel(logging.INFO)\n        self.typing_console_handler.setFormatter(console_formatter)\n\n        # Create a handler for console without typing simulation\n        self.console_handler = ConsoleHandler()\n        self.console_handler.setLevel(logging.DEBUG)\n        self.console_handler.setFormatter(console_formatter)\n\n        self.speak_mode = False\n        self.chat_plugins = []\n\n        # Info handler in activity.log\n        self.file_handler = logging.FileHandler(\n            os.path.join(log_dir, log_file), \"a\", \"utf-8\"\n        )\n        self.file_handler.setLevel(logging.DEBUG)\n        info_formatter = RecordFormatter(\n            \"%(asctime)s [%(threadName)s] %(levelname)s: %(title_color)s %(title)s %(message)s\"\n        )\n        self.file_handler.setFormatter(info_formatter)\n\n        # Error handler error.log\n        error_handler = logging.FileHandler(\n            os.path.join(log_dir, error_file), \"a\", \"utf-8\"\n        )\n        error_handler.setLevel(logging.ERROR)\n        error_formatter = RecordFormatter(\n            \"%(asctime)s [%(threadName)s] %(levelname)s %(module)s:%(funcName)s:%(lineno)d %(title_color)s %(title)s\"\n            \" %(message_no_color)s\"\n        )\n        error_handler.setFormatter(error_formatter)\n\n        # self.typing_logger = logging.getLogger(self.log_name)\n        # if not self.typing_logger.handlers:\n        #     self.typing_logger.addHandler(self.typing_console_handler)\n        #     self.typing_logger.addHandler(self.file_handler)\n        #     self.typing_logger.addHandler(error_handler)\n        # self.typing_logger.setLevel(logging.DEBUG)\n\n        if self.log_name.endswith(\"_INTERACT\") or not self.logger.handlers:\n            # self.logger.addHandler(self.typing_console_handler)\n            self.logger.addHandler(self.console_handler)\n            self.logger.addHandler(error_handler)\n            self.logger.addHandler(self.file_handler)\n            self.logger.setLevel(logging.DEBUG)\n",
            "name_column": 8
        },
        "emit": {
            "type": "FunctionDef",
            "name": "emit",
            "md_content": "",
            "code_start_line": 222,
            "code_end_line": 227,
            "parent": "ConsoleHandler",
            "have_return": false,
            "code_content": "    def emit(self, record) -> None:\n        msg = self.format(record)\n        try:\n            print(msg)\n        except Exception:\n            self.handleError(record)\n",
            "name_column": 8
        },
        "format": {
            "type": "FunctionDef",
            "name": "format",
            "md_content": "",
            "code_start_line": 236,
            "code_end_line": 254,
            "parent": "RecordFormatter",
            "have_return": true,
            "code_content": "    def format(self, record: LogRecord) -> str:\n        if hasattr(record, \"color\"):\n            record.title_color = (\n                getattr(record, \"color\")\n                + getattr(record, \"title\", \"\")\n                + \" \"\n                + Style.RESET_ALL\n            )\n        else:\n            record.title_color = getattr(record, \"title\", \"\")\n\n        # Add this line to set 'title' to an empty string if it doesn't exist\n        record.title = getattr(record, \"title\", \"\")\n\n        if hasattr(record, \"msg\"):\n            record.message_no_color = remove_color_codes(getattr(record, \"msg\"))\n        else:\n            record.message_no_color = \"\"\n        return super().format(record)\n",
            "name_column": 8
        },
        "typewriter_log": {
            "type": "FunctionDef",
            "name": "typewriter_log",
            "md_content": "",
            "code_start_line": 98,
            "code_end_line": 115,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def typewriter_log(\n        self, title=\"\", title_color=\"\", content=\"\", speak_text=False, level=logging.INFO\n    ):\n        # if speak_text and self.speak_mode:\n        #     say_text(f\"{title}. {content}\")\n\n        for plugin in self.chat_plugins:\n            plugin.report(f\"{title}. {content}\")\n\n        if content:\n            if isinstance(content, list):\n                content = \" \".join(content)\n        else:\n            content = \"\"\n\n        self.logger.log(\n            level, content, extra={\"title\": title, \"color\": title_color}\n        )\n",
            "name_column": 8
        },
        "debug": {
            "type": "FunctionDef",
            "name": "debug",
            "md_content": "",
            "code_start_line": 117,
            "code_end_line": 123,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def debug(\n        self,\n        message,\n        title=\"\",\n        title_color=\"\",\n    ):\n        self._log(title, title_color, message, logging.DEBUG)\n",
            "name_column": 8
        },
        "info": {
            "type": "FunctionDef",
            "name": "info",
            "md_content": "",
            "code_start_line": 125,
            "code_end_line": 131,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def info(\n        self,\n        message,\n        title=\"\",\n        title_color=\"\",\n    ):\n        self._log(title, title_color, message, logging.INFO)\n",
            "name_column": 8
        },
        "warn": {
            "type": "FunctionDef",
            "name": "warn",
            "md_content": "",
            "code_start_line": 133,
            "code_end_line": 139,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def warn(\n        self,\n        message,\n        title=\"\",\n        title_color=\"\",\n    ):\n        self._log(title, title_color, message, logging.WARN)\n",
            "name_column": 8
        },
        "error": {
            "type": "FunctionDef",
            "name": "error",
            "md_content": "",
            "code_start_line": 141,
            "code_end_line": 142,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def error(self, title, message=\"\"):\n        self._log(title, Fore.RED, message, logging.ERROR)\n",
            "name_column": 8
        },
        "_log": {
            "type": "FunctionDef",
            "name": "_log",
            "md_content": "",
            "code_start_line": 144,
            "code_end_line": 156,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def _log(\n        self,\n        title: str = \"\",\n        title_color: str = \"\",\n        message: str = \"\",\n        level=logging.INFO,\n    ):\n        if message:\n            if isinstance(message, list):\n                message = \" \".join(message)\n        self.logger.log(\n            level, message, extra={\"title\": str(title), \"color\": str(title_color)}\n        )\n",
            "name_column": 8
        },
        "set_level": {
            "type": "FunctionDef",
            "name": "set_level",
            "md_content": "",
            "code_start_line": 158,
            "code_end_line": 160,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def set_level(self, level):\n        self.logger.setLevel(level)\n        self.typing_logger.setLevel(level)\n",
            "name_column": 8
        },
        "double_check": {
            "type": "FunctionDef",
            "name": "double_check",
            "md_content": "",
            "code_start_line": 162,
            "code_end_line": 171,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def double_check(self, additionalText=None):\n        if not additionalText:\n            additionalText = (\n                \"Please ensure you've setup and configured everything\"\n                \" correctly. Read https://github.com/Torantulino/Auto-GPT#readme to \"\n                \"double check. You can also create a github issue or join the discord\"\n                \" and ask there!\"\n            )\n\n        self.typewriter_log(\"DOUBLE CHECK CONFIGURATION\", Fore.YELLOW, additionalText)\n",
            "name_column": 8
        },
        "log_json": {
            "type": "FunctionDef",
            "name": "log_json",
            "md_content": "",
            "code_start_line": 173,
            "code_end_line": 186,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def log_json(self, data: Any, file_name: str) -> None:\n        # Define log directory\n        this_files_dir_path = os.path.dirname(__file__)\n        log_dir = os.path.join(this_files_dir_path, \"../logs\")\n\n        # Create a handler for JSON files\n        json_file_path = os.path.join(log_dir, file_name)\n        json_data_handler = JsonFileHandler(json_file_path)\n        json_data_handler.setFormatter(JsonFormatter())\n\n        # Log the JSON data using the custom file handler\n        self.json_logger.addHandler(json_data_handler)\n        self.json_logger.debug(data)\n        self.json_logger.removeHandler(json_data_handler)\n",
            "name_column": 8
        },
        "get_log_directory": {
            "type": "FunctionDef",
            "name": "get_log_directory",
            "md_content": "",
            "code_start_line": 188,
            "code_end_line": 191,
            "parent": "Logger",
            "have_return": true,
            "code_content": "    def get_log_directory(self):\n        this_files_dir_path = os.path.dirname(__file__)\n        log_dir = os.path.join(this_files_dir_path, \"../logs\")\n        return os.path.abspath(log_dir)\n",
            "name_column": 8
        }
    },
    "XAgentServer/enums/recorder_type.py": {
        "RecorderTypeEnum": {
            "type": "ClassDef",
            "name": "RecorderTypeEnum",
            "md_content": "",
            "code_start_line": 4,
            "code_end_line": 20,
            "parent": null,
            "have_return": false,
            "code_content": "class RecorderTypeEnum:\n    \"\"\"XAgent Running Recorder Type Enum\n    \"\"\"\n    QUERY = \"query\"\n    CONFIG = \"config\"\n    LLM_INPUT_PAIR = \"llm_input_pair\"\n    TOOL_SERVER_PAIR = \"tool_server_pair\"\n    NOW_SUBTASK_ID = \"now_subtask_id\"\n    TOOL_CALL = \"tool_call\"\n    PLAN_REFINE = \"plan_refine\"\n    LLM_SERVER_CACHE = \"llm_server_cache\"\n    TOOL_SERVER_CACHE = \"tool_server_cache\"\n    TOOL_CALL_CACHE = \"tool_call_cache\"\n    PLAN_REFINE_CACHE = \"plan_refine_cache\"\n    LLM_INTERFACE_ID = \"llm_interface_id\"\n    TOOL_SERVER_INTERFACE_ID = \"toolserver_interface_id\"\n    TOOL_CALL_ID = \"tool_call_id\"\n",
            "name_column": 6
        }
    },
    "XAgentServer/enums/status.py": {
        "StatusEnum": {
            "type": "ClassDef",
            "name": "StatusEnum",
            "md_content": "",
            "code_start_line": 4,
            "code_end_line": 16,
            "parent": null,
            "have_return": false,
            "code_content": "class StatusEnum:\n    \"\"\"XAgent Status Enum\n    \"\"\"\n    START = \"start\"\n    SUBTASK = \"subtask\"\n    REFINEMENT = \"refinement\"\n    INNER = \"inner\"\n    FINISHED = \"finished\"\n    FAILED = \"failed\"\n    SUBMIT = \"subtask_submit\"\n    RUNNING = \"running\"\n    ASK_FOR_HUMAN_HELP = \"ask_for_human_help\"\n    CLOSED = \"closed\"\n",
            "name_column": 6
        }
    },
    "XAgentServer/models/user.py": {
        "XAgentUser": {
            "type": "ClassDef",
            "name": "XAgentUser",
            "md_content": "",
            "code_start_line": 7,
            "code_end_line": 105,
            "parent": null,
            "have_return": true,
            "code_content": "class XAgentUser(metaclass=abc.ABCMeta):\n\n    def __init__(self, \n                 user_id: str, \n                 email: str, \n                 name: str, \n                 token: str, \n                 available: bool = True,\n                 corporation: str = None,\n                 industry: str = None,\n                 position: str = None,\n                 create_time: str = None,\n                 update_time: str = None,\n                 deleted: bool = False,\n                 is_beta: bool = False,):\n        self.user_id = user_id\n        self.email = email\n        self.name = name\n        self.token = token\n        self.available = available\n        self.corporation = corporation\n        self.industry = industry\n        self.position = position\n        self.create_time = create_time\n        self.update_time = update_time\n        self.deleted = deleted\n        self.is_beta = is_beta\n\n    def to_dict(self):\n        return {\n            \"user_id\": self.user_id,\n            \"email\": self.email,\n            \"name\": self.name,\n            \"token\": self.token,\n            \"available\": self.available,\n            \"corporation\": self.corporation,\n            \"industry\": self.industry,\n            \"position\": self.position,\n            \"create_time\": self.create_time,\n            \"update_time\": self.update_time,\n            \"deleted\": self.deleted,\n            \"is_beta\": self.is_beta\n        }\n\n    def to_json(self):\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\n\n    @staticmethod\n    def from_dict(user_dict: dict):\n        return XAgentUser(\n            user_id=user_dict[\"user_id\"],\n            email=user_dict[\"email\"],\n            name=user_dict[\"name\"],\n            token=user_dict[\"token\"],\n            available=user_dict[\"available\"],\n            corporation=user_dict[\"corporation\"],\n            industry=user_dict[\"industry\"],\n            position=user_dict[\"position\"],\n            create_time=user_dict[\"create_time\"],\n            update_time=user_dict[\"update_time\"],\n            deleted=user_dict[\"deleted\"],\n            is_beta=user_dict[\"is_beta\"]\n        )\n\n    @staticmethod\n    def from_json(user_json: str):\n        return XAgentUser.from_dict(json.loads(user_json))\n\n    def is_available(self):\n        return self.available\n    \n    @staticmethod\n    def from_db(user: User):\n        user_id = user.user_id\n        email = user.email\n        name = user.name\n        token = user.token\n        available = user.available\n        corporation = user.corporation\n        industry = user.industry\n        position = user.position\n        create_time = user.create_time\n        update_time = user.update_time\n        deleted = user.deleted\n        is_beta = user.is_beta\n        return XAgentUser(\n            user_id=user_id,\n            email=email,\n            name=name,\n            token=token,\n            available=available,\n            corporation=corporation,\n            industry=industry,\n            position=position,\n            create_time=create_time,\n            update_time=update_time,\n            deleted=deleted,\n            is_beta=is_beta\n        )\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 9,
            "code_end_line": 33,
            "parent": "XAgentUser",
            "have_return": false,
            "code_content": "    def __init__(self, \n                 user_id: str, \n                 email: str, \n                 name: str, \n                 token: str, \n                 available: bool = True,\n                 corporation: str = None,\n                 industry: str = None,\n                 position: str = None,\n                 create_time: str = None,\n                 update_time: str = None,\n                 deleted: bool = False,\n                 is_beta: bool = False,):\n        self.user_id = user_id\n        self.email = email\n        self.name = name\n        self.token = token\n        self.available = available\n        self.corporation = corporation\n        self.industry = industry\n        self.position = position\n        self.create_time = create_time\n        self.update_time = update_time\n        self.deleted = deleted\n        self.is_beta = is_beta\n",
            "name_column": 8
        },
        "to_dict": {
            "type": "FunctionDef",
            "name": "to_dict",
            "md_content": "",
            "code_start_line": 35,
            "code_end_line": 49,
            "parent": "XAgentUser",
            "have_return": true,
            "code_content": "    def to_dict(self):\n        return {\n            \"user_id\": self.user_id,\n            \"email\": self.email,\n            \"name\": self.name,\n            \"token\": self.token,\n            \"available\": self.available,\n            \"corporation\": self.corporation,\n            \"industry\": self.industry,\n            \"position\": self.position,\n            \"create_time\": self.create_time,\n            \"update_time\": self.update_time,\n            \"deleted\": self.deleted,\n            \"is_beta\": self.is_beta\n        }\n",
            "name_column": 8
        },
        "to_json": {
            "type": "FunctionDef",
            "name": "to_json",
            "md_content": "",
            "code_start_line": 51,
            "code_end_line": 52,
            "parent": "XAgentUser",
            "have_return": true,
            "code_content": "    def to_json(self):\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\n",
            "name_column": 8
        },
        "from_dict": {
            "type": "FunctionDef",
            "name": "from_dict",
            "md_content": "",
            "code_start_line": 55,
            "code_end_line": 69,
            "parent": "XAgentUser",
            "have_return": true,
            "code_content": "    def from_dict(user_dict: dict):\n        return XAgentUser(\n            user_id=user_dict[\"user_id\"],\n            email=user_dict[\"email\"],\n            name=user_dict[\"name\"],\n            token=user_dict[\"token\"],\n            available=user_dict[\"available\"],\n            corporation=user_dict[\"corporation\"],\n            industry=user_dict[\"industry\"],\n            position=user_dict[\"position\"],\n            create_time=user_dict[\"create_time\"],\n            update_time=user_dict[\"update_time\"],\n            deleted=user_dict[\"deleted\"],\n            is_beta=user_dict[\"is_beta\"]\n        )\n",
            "name_column": 8
        },
        "from_json": {
            "type": "FunctionDef",
            "name": "from_json",
            "md_content": "",
            "code_start_line": 72,
            "code_end_line": 73,
            "parent": "XAgentUser",
            "have_return": true,
            "code_content": "    def from_json(user_json: str):\n        return XAgentUser.from_dict(json.loads(user_json))\n",
            "name_column": 8
        },
        "is_available": {
            "type": "FunctionDef",
            "name": "is_available",
            "md_content": "",
            "code_start_line": 75,
            "code_end_line": 76,
            "parent": "XAgentUser",
            "have_return": true,
            "code_content": "    def is_available(self):\n        return self.available\n",
            "name_column": 8
        },
        "from_db": {
            "type": "FunctionDef",
            "name": "from_db",
            "md_content": "",
            "code_start_line": 79,
            "code_end_line": 105,
            "parent": "XAgentUser",
            "have_return": true,
            "code_content": "    def from_db(user: User):\n        user_id = user.user_id\n        email = user.email\n        name = user.name\n        token = user.token\n        available = user.available\n        corporation = user.corporation\n        industry = user.industry\n        position = user.position\n        create_time = user.create_time\n        update_time = user.update_time\n        deleted = user.deleted\n        is_beta = user.is_beta\n        return XAgentUser(\n            user_id=user_id,\n            email=email,\n            name=name,\n            token=token,\n            available=available,\n            corporation=corporation,\n            industry=industry,\n            position=position,\n            create_time=create_time,\n            update_time=update_time,\n            deleted=deleted,\n            is_beta=is_beta\n        )\n",
            "name_column": 8
        }
    },
    "XAgentServer/models/interaction.py": {
        "InteractionBase": {
            "type": "ClassDef",
            "name": "InteractionBase",
            "md_content": "",
            "code_start_line": 8,
            "code_end_line": 86,
            "parent": null,
            "have_return": true,
            "code_content": "class InteractionBase(metaclass=abc.ABCMeta):\n    def __init__(self,\n                interaction_id: str,\n                user_id: str,\n                create_time: str,\n                description: str,\n                agent: str = \"\",\n                mode: str = \"\",\n                file_list: list = [],\n                recorder_root_dir: str = \"\",\n                status: str = \"\",\n                message: str = \"\",\n                current_step: str = \"\",\n                update_time: str = \"\",\n                is_deleted: bool = False,\n                call_method: str = \"web\",\n                ):\n        self.interaction_id = interaction_id\n        self.user_id = user_id\n        self.create_time = create_time\n        self.description = description\n        self.agent = agent\n        self.mode = mode\n        self.file_list = file_list\n        self.recorder_root_dir = recorder_root_dir\n        self.status = status\n        self.message = message\n        self.current_step = current_step\n        self.update_time = update_time\n        self.is_deleted = is_deleted\n        self.call_method = call_method\n\n    def to_dict(self, include=None, exclude=None):\n        data = {\n            \"interaction_id\": self.interaction_id,\n            \"user_id\": self.user_id,\n            \"create_time\": self.create_time,\n            \"description\": self.description,\n            \"agent\": self.agent,\n            \"mode\": self.mode,\n            \"file_list\": self.file_list,\n            \"recorder_root_dir\": self.recorder_root_dir,\n            \"status\": self.status,\n            \"message\": self.message,\n            \"current_step\": self.current_step,\n            \"update_time\": self.update_time,\n            \"is_deleted\": self.is_deleted,\n            \"call_method\": self.call_method,\n        }\n        if include:\n            data = {k: v for k, v in data.items() if k in include}\n        if exclude:\n            data = {k: v for k, v in data.items() if k not in exclude}\n        return data\n    \n    def to_json(self):\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\n    \n    @classmethod\n    def from_json(cls, json_data):\n        return cls(**json_data)\n    \n    @classmethod\n    def from_db(cls, interaction):\n        return cls(interaction.interaction_id,\n                    interaction.user_id,\n                    interaction.create_time,\n                    interaction.description,\n                    interaction.agent,\n                    interaction.mode,\n                    interaction.file_list,\n                    interaction.recorder_root_dir,\n                    interaction.status,\n                    interaction.message,\n                    interaction.current_step,\n                    interaction.update_time,\n                    interaction.is_deleted,\n                    interaction.call_method,\n                    )\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 9,
            "code_end_line": 38,
            "parent": "InteractionBase",
            "have_return": false,
            "code_content": "    def __init__(self,\n                interaction_id: str,\n                user_id: str,\n                create_time: str,\n                description: str,\n                agent: str = \"\",\n                mode: str = \"\",\n                file_list: list = [],\n                recorder_root_dir: str = \"\",\n                status: str = \"\",\n                message: str = \"\",\n                current_step: str = \"\",\n                update_time: str = \"\",\n                is_deleted: bool = False,\n                call_method: str = \"web\",\n                ):\n        self.interaction_id = interaction_id\n        self.user_id = user_id\n        self.create_time = create_time\n        self.description = description\n        self.agent = agent\n        self.mode = mode\n        self.file_list = file_list\n        self.recorder_root_dir = recorder_root_dir\n        self.status = status\n        self.message = message\n        self.current_step = current_step\n        self.update_time = update_time\n        self.is_deleted = is_deleted\n        self.call_method = call_method\n",
            "name_column": 8
        },
        "to_dict": {
            "type": "FunctionDef",
            "name": "to_dict",
            "md_content": "",
            "code_start_line": 40,
            "code_end_line": 61,
            "parent": "InteractionBase",
            "have_return": true,
            "code_content": "    def to_dict(self, include=None, exclude=None):\n        data = {\n            \"interaction_id\": self.interaction_id,\n            \"user_id\": self.user_id,\n            \"create_time\": self.create_time,\n            \"description\": self.description,\n            \"agent\": self.agent,\n            \"mode\": self.mode,\n            \"file_list\": self.file_list,\n            \"recorder_root_dir\": self.recorder_root_dir,\n            \"status\": self.status,\n            \"message\": self.message,\n            \"current_step\": self.current_step,\n            \"update_time\": self.update_time,\n            \"is_deleted\": self.is_deleted,\n            \"call_method\": self.call_method,\n        }\n        if include:\n            data = {k: v for k, v in data.items() if k in include}\n        if exclude:\n            data = {k: v for k, v in data.items() if k not in exclude}\n        return data\n",
            "name_column": 8
        },
        "to_json": {
            "type": "FunctionDef",
            "name": "to_json",
            "md_content": "",
            "code_start_line": 63,
            "code_end_line": 64,
            "parent": "InteractionBase",
            "have_return": true,
            "code_content": "    def to_json(self):\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\n",
            "name_column": 8
        },
        "from_json": {
            "type": "FunctionDef",
            "name": "from_json",
            "md_content": "",
            "code_start_line": 67,
            "code_end_line": 68,
            "parent": "InteractionBase",
            "have_return": true,
            "code_content": "    def from_json(cls, json_data):\n        return cls(**json_data)\n",
            "name_column": 8
        },
        "from_db": {
            "type": "FunctionDef",
            "name": "from_db",
            "md_content": "",
            "code_start_line": 71,
            "code_end_line": 86,
            "parent": "InteractionBase",
            "have_return": true,
            "code_content": "    def from_db(cls, interaction):\n        return cls(interaction.interaction_id,\n                    interaction.user_id,\n                    interaction.create_time,\n                    interaction.description,\n                    interaction.agent,\n                    interaction.mode,\n                    interaction.file_list,\n                    interaction.recorder_root_dir,\n                    interaction.status,\n                    interaction.message,\n                    interaction.current_step,\n                    interaction.update_time,\n                    interaction.is_deleted,\n                    interaction.call_method,\n                    )\n",
            "name_column": 8
        }
    },
    "XAgentServer/models/raw.py": {
        "XAgentRaw": {
            "type": "ClassDef",
            "name": "XAgentRaw",
            "md_content": "",
            "code_start_line": 6,
            "code_end_line": 110,
            "parent": null,
            "have_return": true,
            "code_content": "class XAgentRaw(metaclass=abc.ABCMeta):\n    \"\"\"XAgent Raw Object\"\"\"\n\n    def __init__(self, node_id: str,\n                 interaction_id: str,\n                 current: str,\n                 step: int,\n                 data: dict,\n                 file_list: list,\n                 status: str,\n                 do_interrupt: bool,\n                 wait_seconds: int,\n                 ask_for_human_help: bool,\n                 create_time: str,\n                 update_time: str,\n                 is_deleted: bool,\n                 is_human: bool,\n                 human_data: dict,\n                 human_file_list: list,\n                 is_send: bool,\n                 is_receive: bool,\n                 include_pictures: bool = False,):\n        self.node_id = node_id\n        self.interaction_id = interaction_id\n        self.current = current\n        self.step = step\n        self.data = data\n        self.file_list = file_list\n        self.status = status\n        self.do_interrupt = do_interrupt\n        self.wait_seconds = wait_seconds\n        self.ask_for_human_help = ask_for_human_help\n        self.create_time = create_time\n        self.update_time = update_time\n        self.is_deleted = is_deleted\n        self.is_human = is_human\n        self.human_data = human_data\n        self.human_file_list = human_file_list\n        self.is_send = is_send\n        self.is_receive = is_receive\n        self.include_pictures = include_pictures\n\n    def to_dict(self):\n        \"\"\"XAgent Raw Object to dict\"\"\"\n        return {\n            \"node_id\": self.node_id,\n            \"interaction_id\": self.interaction_id,\n            \"current\": self.current,\n            \"step\": self.step,\n            \"data\": self.data,\n            \"file_list\": self.file_list,\n            \"status\": self.status,\n            \"do_interrupt\": self.do_interrupt,\n            \"wait_seconds\": self.wait_seconds,\n            \"ask_for_human_help\": self.ask_for_human_help,\n            \"create_time\": self.create_time,\n            \"update_time\": self.update_time,\n            \"is_deleted\": self.is_deleted,\n            \"is_human\": self.is_human,\n            \"human_data\": self.human_data,\n            \"human_file_list\": self.human_file_list,\n            \"is_send\": self.is_send,\n            \"is_receive\": self.is_receive,\n            \"include_pictures\": self.include_pictures\n        }\n\n    def to_json(self):\n        \"\"\"XAgent Raw Object to json\"\"\"\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\n\n    @classmethod\n    def from_json(cls, json_data):\n        \"\"\"XAgent Raw Object from json\"\"\"\n        return cls(**json_data)\n\n    def update(self, update_data: dict):\n        \"\"\"XAgent Raw Object update\"\"\"\n        for k, v in update_data.items():\n            setattr(self, k, v)\n        return self\n\n    @classmethod\n    def from_db(cls, db_data):\n        \"\"\"XAgent Raw Object from db\"\"\"\n        return cls(\n            node_id=db_data.node_id,\n            interaction_id=db_data.interaction_id,\n            current=db_data.current,\n            step=db_data.step,\n            data=db_data.data,\n            file_list=db_data.file_list,\n            status=db_data.status,\n            do_interrupt=db_data.do_interrupt,\n            wait_seconds=db_data.wait_seconds,\n            ask_for_human_help=db_data.ask_for_human_help,\n            create_time=db_data.create_time,\n            update_time=db_data.update_time,\n            is_deleted=db_data.is_deleted,\n            is_human=db_data.is_human,\n            human_data=db_data.human_data,\n            human_file_list=db_data.human_file_list,\n            is_send=db_data.is_send,\n            is_receive=db_data.is_receive,\n            include_pictures=db_data.include_pictures\n        )\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 9,
            "code_end_line": 46,
            "parent": "XAgentRaw",
            "have_return": false,
            "code_content": "    def __init__(self, node_id: str,\n                 interaction_id: str,\n                 current: str,\n                 step: int,\n                 data: dict,\n                 file_list: list,\n                 status: str,\n                 do_interrupt: bool,\n                 wait_seconds: int,\n                 ask_for_human_help: bool,\n                 create_time: str,\n                 update_time: str,\n                 is_deleted: bool,\n                 is_human: bool,\n                 human_data: dict,\n                 human_file_list: list,\n                 is_send: bool,\n                 is_receive: bool,\n                 include_pictures: bool = False,):\n        self.node_id = node_id\n        self.interaction_id = interaction_id\n        self.current = current\n        self.step = step\n        self.data = data\n        self.file_list = file_list\n        self.status = status\n        self.do_interrupt = do_interrupt\n        self.wait_seconds = wait_seconds\n        self.ask_for_human_help = ask_for_human_help\n        self.create_time = create_time\n        self.update_time = update_time\n        self.is_deleted = is_deleted\n        self.is_human = is_human\n        self.human_data = human_data\n        self.human_file_list = human_file_list\n        self.is_send = is_send\n        self.is_receive = is_receive\n        self.include_pictures = include_pictures\n",
            "name_column": 8
        },
        "to_dict": {
            "type": "FunctionDef",
            "name": "to_dict",
            "md_content": "",
            "code_start_line": 48,
            "code_end_line": 70,
            "parent": "XAgentRaw",
            "have_return": true,
            "code_content": "    def to_dict(self):\n        \"\"\"XAgent Raw Object to dict\"\"\"\n        return {\n            \"node_id\": self.node_id,\n            \"interaction_id\": self.interaction_id,\n            \"current\": self.current,\n            \"step\": self.step,\n            \"data\": self.data,\n            \"file_list\": self.file_list,\n            \"status\": self.status,\n            \"do_interrupt\": self.do_interrupt,\n            \"wait_seconds\": self.wait_seconds,\n            \"ask_for_human_help\": self.ask_for_human_help,\n            \"create_time\": self.create_time,\n            \"update_time\": self.update_time,\n            \"is_deleted\": self.is_deleted,\n            \"is_human\": self.is_human,\n            \"human_data\": self.human_data,\n            \"human_file_list\": self.human_file_list,\n            \"is_send\": self.is_send,\n            \"is_receive\": self.is_receive,\n            \"include_pictures\": self.include_pictures\n        }\n",
            "name_column": 8
        },
        "to_json": {
            "type": "FunctionDef",
            "name": "to_json",
            "md_content": "",
            "code_start_line": 72,
            "code_end_line": 74,
            "parent": "XAgentRaw",
            "have_return": true,
            "code_content": "    def to_json(self):\n        \"\"\"XAgent Raw Object to json\"\"\"\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\n",
            "name_column": 8
        },
        "from_json": {
            "type": "FunctionDef",
            "name": "from_json",
            "md_content": "",
            "code_start_line": 77,
            "code_end_line": 79,
            "parent": "XAgentRaw",
            "have_return": true,
            "code_content": "    def from_json(cls, json_data):\n        \"\"\"XAgent Raw Object from json\"\"\"\n        return cls(**json_data)\n",
            "name_column": 8
        },
        "update": {
            "type": "FunctionDef",
            "name": "update",
            "md_content": "",
            "code_start_line": 81,
            "code_end_line": 85,
            "parent": "XAgentRaw",
            "have_return": true,
            "code_content": "    def update(self, update_data: dict):\n        \"\"\"XAgent Raw Object update\"\"\"\n        for k, v in update_data.items():\n            setattr(self, k, v)\n        return self\n",
            "name_column": 8
        },
        "from_db": {
            "type": "FunctionDef",
            "name": "from_db",
            "md_content": "",
            "code_start_line": 88,
            "code_end_line": 110,
            "parent": "XAgentRaw",
            "have_return": true,
            "code_content": "    def from_db(cls, db_data):\n        \"\"\"XAgent Raw Object from db\"\"\"\n        return cls(\n            node_id=db_data.node_id,\n            interaction_id=db_data.interaction_id,\n            current=db_data.current,\n            step=db_data.step,\n            data=db_data.data,\n            file_list=db_data.file_list,\n            status=db_data.status,\n            do_interrupt=db_data.do_interrupt,\n            wait_seconds=db_data.wait_seconds,\n            ask_for_human_help=db_data.ask_for_human_help,\n            create_time=db_data.create_time,\n            update_time=db_data.update_time,\n            is_deleted=db_data.is_deleted,\n            is_human=db_data.is_human,\n            human_data=db_data.human_data,\n            human_file_list=db_data.human_file_list,\n            is_send=db_data.is_send,\n            is_receive=db_data.is_receive,\n            include_pictures=db_data.include_pictures\n        )\n",
            "name_column": 8
        }
    },
    "XAgentServer/models/shared_interaction.py": {
        "SharedInteractionBase": {
            "type": "ClassDef",
            "name": "SharedInteractionBase",
            "md_content": "",
            "code_start_line": 9,
            "code_end_line": 68,
            "parent": null,
            "have_return": true,
            "code_content": "class SharedInteractionBase(metaclass=abc.ABCMeta):\n    def __init__(self,\n                interaction_id: str,\n                user_name: str,\n                create_time: str,\n                update_time: str,\n                description: str,\n                agent: str = \"\",\n                mode: str = \"\",\n                is_deleted: bool = False,\n                star: int = 0,\n                is_audit: bool = False\n                ):\n        self.interaction_id = interaction_id\n        self.user_name = user_name\n        self.create_time = create_time\n        self.update_time = update_time\n        self.description = description\n        self.agent = agent\n        self.mode = mode\n        self.is_deleted = is_deleted\n        self.star = star\n        self.is_audit = is_audit\n\n    def to_dict(self, include=None, exclude=None):\n        data = {\n            \"interaction_id\": self.interaction_id,\n            \"user_name\": self.user_name,\n            \"create_time\": self.create_time,\n            \"update_time\": self.update_time,\n            \"description\": self.description,\n            \"agent\": self.agent,\n            \"mode\": self.mode,\n            \"is_deleted\": self.is_deleted,\n            \"star\": self.star,\n            \"is_audit\": self.is_audit\n        }\n        if include:\n            data = {k: v for k, v in data.items() if k in include}\n        if exclude:\n            data = {k: v for k, v in data.items() if k not in exclude}\n        return data\n        \n    \n    def to_json(self):\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\n    \n    @classmethod\n    def from_db(cls, interaction):\n        return cls(interaction.interaction_id,\n                   interaction.user_name,\n                   interaction.create_time,\n                   interaction.update_time,\n                   interaction.description,\n                   interaction.agent,\n                   interaction.mode,\n                   interaction.is_deleted,\n                   interaction.star,\n                   interaction.is_audit\n                   )\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 10,
            "code_end_line": 31,
            "parent": "SharedInteractionBase",
            "have_return": false,
            "code_content": "    def __init__(self,\n                interaction_id: str,\n                user_name: str,\n                create_time: str,\n                update_time: str,\n                description: str,\n                agent: str = \"\",\n                mode: str = \"\",\n                is_deleted: bool = False,\n                star: int = 0,\n                is_audit: bool = False\n                ):\n        self.interaction_id = interaction_id\n        self.user_name = user_name\n        self.create_time = create_time\n        self.update_time = update_time\n        self.description = description\n        self.agent = agent\n        self.mode = mode\n        self.is_deleted = is_deleted\n        self.star = star\n        self.is_audit = is_audit\n",
            "name_column": 8
        },
        "to_dict": {
            "type": "FunctionDef",
            "name": "to_dict",
            "md_content": "",
            "code_start_line": 33,
            "code_end_line": 50,
            "parent": "SharedInteractionBase",
            "have_return": true,
            "code_content": "    def to_dict(self, include=None, exclude=None):\n        data = {\n            \"interaction_id\": self.interaction_id,\n            \"user_name\": self.user_name,\n            \"create_time\": self.create_time,\n            \"update_time\": self.update_time,\n            \"description\": self.description,\n            \"agent\": self.agent,\n            \"mode\": self.mode,\n            \"is_deleted\": self.is_deleted,\n            \"star\": self.star,\n            \"is_audit\": self.is_audit\n        }\n        if include:\n            data = {k: v for k, v in data.items() if k in include}\n        if exclude:\n            data = {k: v for k, v in data.items() if k not in exclude}\n        return data\n",
            "name_column": 8
        },
        "to_json": {
            "type": "FunctionDef",
            "name": "to_json",
            "md_content": "",
            "code_start_line": 53,
            "code_end_line": 54,
            "parent": "SharedInteractionBase",
            "have_return": true,
            "code_content": "    def to_json(self):\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\n",
            "name_column": 8
        },
        "from_db": {
            "type": "FunctionDef",
            "name": "from_db",
            "md_content": "",
            "code_start_line": 57,
            "code_end_line": 68,
            "parent": "SharedInteractionBase",
            "have_return": true,
            "code_content": "    def from_db(cls, interaction):\n        return cls(interaction.interaction_id,\n                   interaction.user_name,\n                   interaction.create_time,\n                   interaction.update_time,\n                   interaction.description,\n                   interaction.agent,\n                   interaction.mode,\n                   interaction.is_deleted,\n                   interaction.star,\n                   interaction.is_audit\n                   )\n",
            "name_column": 8
        }
    },
    "XAgentServer/models/recorder.py": {
        "XAgentRunningRecord": {
            "type": "ClassDef",
            "name": "XAgentRunningRecord",
            "md_content": "",
            "code_start_line": 7,
            "code_end_line": 67,
            "parent": null,
            "have_return": true,
            "code_content": "class XAgentRunningRecord(metaclass=abc.ABCMeta):\n    \"\"\"XAgent Running Recorder\"\"\"\n    def __init__(self,\n                 record_id: str,\n                 current: str,\n                 node_id: str,\n                 node_type: str,\n                 data: dict,\n                 create_time: str,\n                 update_time: str,\n                 is_deleted: bool,\n                 ):\n        self.record_id = record_id\n        self.current = current\n        self.node_id = node_id\n        self.node_type = node_type\n        self.data = data\n        self.create_time = create_time\n        self.update_time = update_time\n        self.is_deleted = is_deleted\n\n    def to_dict(self):\n        \"\"\"XAgent Running Recorder to dict\"\"\"\n        return {\n            \"record_id\": self.record_id,\n            \"current\": self.current,\n            \"node_id\": self.node_id,\n            \"node_type\": self.node_type,\n            \"data\": self.data,\n            \"create_time\": self.create_time,\n            \"update_time\": self.update_time,\n            \"is_deleted\": self.is_deleted,\n        }\n\n    @classmethod\n    def from_db(cls, db: RunningRecord):\n        \"\"\"From db\"\"\"\n        return cls(\n            record_id=db.record_id,\n            current=db.current,\n            node_id=db.node_id,\n            node_type=db.node_type,\n            data=db.data,\n            create_time=db.create_time,\n            update_time=db.update_time,\n            is_deleted=db.is_deleted,\n        )\n\n    @classmethod\n    def from_dict(cls, data: dict):\n        \"\"\"dict to XAgent Running Recorder\"\"\"\n        return cls(\n            record_id=data[\"record_id\"],\n            current=data[\"current\"],\n            node_id=data[\"node_id\"],\n            node_type=data[\"node_type\"],\n            data=data[\"data\"],\n            create_time=data[\"create_time\"],\n            update_time=data[\"update_time\"],\n            is_deleted=data[\"is_deleted\"],\n        )\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 9,
            "code_end_line": 26,
            "parent": "XAgentRunningRecord",
            "have_return": false,
            "code_content": "    def __init__(self,\n                 record_id: str,\n                 current: str,\n                 node_id: str,\n                 node_type: str,\n                 data: dict,\n                 create_time: str,\n                 update_time: str,\n                 is_deleted: bool,\n                 ):\n        self.record_id = record_id\n        self.current = current\n        self.node_id = node_id\n        self.node_type = node_type\n        self.data = data\n        self.create_time = create_time\n        self.update_time = update_time\n        self.is_deleted = is_deleted\n",
            "name_column": 8
        },
        "to_dict": {
            "type": "FunctionDef",
            "name": "to_dict",
            "md_content": "",
            "code_start_line": 28,
            "code_end_line": 39,
            "parent": "XAgentRunningRecord",
            "have_return": true,
            "code_content": "    def to_dict(self):\n        \"\"\"XAgent Running Recorder to dict\"\"\"\n        return {\n            \"record_id\": self.record_id,\n            \"current\": self.current,\n            \"node_id\": self.node_id,\n            \"node_type\": self.node_type,\n            \"data\": self.data,\n            \"create_time\": self.create_time,\n            \"update_time\": self.update_time,\n            \"is_deleted\": self.is_deleted,\n        }\n",
            "name_column": 8
        },
        "from_db": {
            "type": "FunctionDef",
            "name": "from_db",
            "md_content": "",
            "code_start_line": 42,
            "code_end_line": 53,
            "parent": "XAgentRunningRecord",
            "have_return": true,
            "code_content": "    def from_db(cls, db: RunningRecord):\n        \"\"\"From db\"\"\"\n        return cls(\n            record_id=db.record_id,\n            current=db.current,\n            node_id=db.node_id,\n            node_type=db.node_type,\n            data=db.data,\n            create_time=db.create_time,\n            update_time=db.update_time,\n            is_deleted=db.is_deleted,\n        )\n",
            "name_column": 8
        },
        "from_dict": {
            "type": "FunctionDef",
            "name": "from_dict",
            "md_content": "",
            "code_start_line": 56,
            "code_end_line": 67,
            "parent": "XAgentRunningRecord",
            "have_return": true,
            "code_content": "    def from_dict(cls, data: dict):\n        \"\"\"dict to XAgent Running Recorder\"\"\"\n        return cls(\n            record_id=data[\"record_id\"],\n            current=data[\"current\"],\n            node_id=data[\"node_id\"],\n            node_type=data[\"node_type\"],\n            data=data[\"data\"],\n            create_time=data[\"create_time\"],\n            update_time=data[\"update_time\"],\n            is_deleted=data[\"is_deleted\"],\n        )\n",
            "name_column": 8
        }
    },
    "XAgentServer/models/global_png.py": {
        "add_to_map": {
            "type": "FunctionDef",
            "name": "add_to_map",
            "md_content": "",
            "code_start_line": 4,
            "code_end_line": 5,
            "parent": null,
            "have_return": false,
            "code_content": "def add_to_map(key, value):\n    global_map[key] = value\n",
            "name_column": 4
        },
        "lookup_in_map": {
            "type": "FunctionDef",
            "name": "lookup_in_map",
            "md_content": "",
            "code_start_line": 8,
            "code_end_line": 9,
            "parent": null,
            "have_return": true,
            "code_content": "def lookup_in_map(key):\n    return global_map.get(key)\n",
            "name_column": 4
        }
    },
    "XAgentServer/models/parameter.py": {
        "InteractionParameter": {
            "type": "ClassDef",
            "name": "InteractionParameter",
            "md_content": "",
            "code_start_line": 6,
            "code_end_line": 39,
            "parent": null,
            "have_return": true,
            "code_content": "class InteractionParameter(metaclass=abc.ABCMeta):\n    \"\"\"\n    交互参数\n    \"\"\"\n\n    def __init__(self,\n                    interaction_id: str,\n                    parameter_id: str,\n                    args: Union[str, dict, None] = None\n                    ):\n        self.interaction_id = interaction_id\n        self.args = args\n        self.parameter_id = parameter_id\n\n    def to_dict(self):\n        return {\n            \"interaction_id\": self.interaction_id,\n            \"parameter_id\": self.parameter_id,\n            \"args\": self.args,\n        }\n\n    def to_json(self):\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\n\n    @classmethod\n    def from_json(cls, json_data):\n        return cls(**json_data)\n    \n    @classmethod\n    def from_db(cls, interaction):\n        return cls(interaction.interaction_id,\n                    interaction.parameter_id,\n                    interaction.args\n                    )",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 11,
            "code_end_line": 18,
            "parent": "InteractionParameter",
            "have_return": false,
            "code_content": "    def __init__(self,\n                    interaction_id: str,\n                    parameter_id: str,\n                    args: Union[str, dict, None] = None\n                    ):\n        self.interaction_id = interaction_id\n        self.args = args\n        self.parameter_id = parameter_id\n",
            "name_column": 8
        },
        "to_dict": {
            "type": "FunctionDef",
            "name": "to_dict",
            "md_content": "",
            "code_start_line": 20,
            "code_end_line": 25,
            "parent": "InteractionParameter",
            "have_return": true,
            "code_content": "    def to_dict(self):\n        return {\n            \"interaction_id\": self.interaction_id,\n            \"parameter_id\": self.parameter_id,\n            \"args\": self.args,\n        }\n",
            "name_column": 8
        },
        "to_json": {
            "type": "FunctionDef",
            "name": "to_json",
            "md_content": "",
            "code_start_line": 27,
            "code_end_line": 28,
            "parent": "InteractionParameter",
            "have_return": true,
            "code_content": "    def to_json(self):\n        return json.dumps(self.to_dict(), indent=2, ensure_ascii=False)\n",
            "name_column": 8
        },
        "from_json": {
            "type": "FunctionDef",
            "name": "from_json",
            "md_content": "",
            "code_start_line": 31,
            "code_end_line": 32,
            "parent": "InteractionParameter",
            "have_return": true,
            "code_content": "    def from_json(cls, json_data):\n        return cls(**json_data)\n",
            "name_column": 8
        },
        "from_db": {
            "type": "FunctionDef",
            "name": "from_db",
            "md_content": "",
            "code_start_line": 35,
            "code_end_line": 39,
            "parent": "InteractionParameter",
            "have_return": true,
            "code_content": "    def from_db(cls, interaction):\n        return cls(interaction.interaction_id,\n                    interaction.parameter_id,\n                    interaction.args\n                    )",
            "name_column": 8
        }
    },
    "XAgentServer/application/global_val.py": {
        "init_yag": {
            "type": "FunctionDef",
            "name": "init_yag",
            "md_content": "",
            "code_start_line": 19,
            "code_end_line": 30,
            "parent": null,
            "have_return": false,
            "code_content": "def init_yag(logger):\n    \"\"\"init yagmail service\n\n    Args:\n        logger (_type_): _description_\n    \"\"\"\n    global yag\n    if XAgentServerEnv.Email.send_email:\n        yag = yagmail.SMTP(user=XAgentServerEnv.Email.email_user,\n                           password=XAgentServerEnv.Email.email_password,\n                           host=XAgentServerEnv.Email.email_host)\n        logger.info(\"init yagmail\")\n",
            "name_column": 4
        },
        "init_executor": {
            "type": "FunctionDef",
            "name": "init_executor",
            "md_content": "",
            "code_start_line": 33,
            "code_end_line": 43,
            "parent": null,
            "have_return": false,
            "code_content": "def init_executor(logger):\n    \"\"\"init a thread pool executor\n\n    Args:\n        logger (_type_): _description_\n    \"\"\"\n    global executor\n    logger.typewriter_log(\n        title=f\"init a thread pool executor, max_workers: {XAgentServerEnv.workers}\",\n        title_color=Fore.RED)\n    executor = ThreadPoolExecutor(max_workers=XAgentServerEnv.workers)\n",
            "name_column": 4
        }
    },
    "XAgentServer/application/__init__.py": {},
    "XAgentServer/application/dependence.py": {
        "enable_logger": {
            "type": "FunctionDef",
            "name": "enable_logger",
            "md_content": "",
            "code_start_line": 10,
            "code_end_line": 18,
            "parent": null,
            "have_return": true,
            "code_content": "def enable_logger():\n    \"\"\"logger\"\"\"\n    if not os.path.exists(os.path.join(XAgentServerEnv.base_dir, \"logs\")):\n        os.makedirs(os.path.join(\n            XAgentServerEnv.base_dir, \"logs\"))\n\n    logger = Logger(log_dir=os.path.join(\n        XAgentServerEnv.base_dir, \"logs\"), log_file=\"app.log\", log_name=\"XAgentServerApp\")\n    return logger\n",
            "name_column": 4
        },
        "enable_dependence": {
            "type": "FunctionDef",
            "name": "enable_dependence",
            "md_content": "",
            "code_start_line": 21,
            "code_end_line": 30,
            "parent": null,
            "have_return": false,
            "code_content": "def enable_dependence(logger):\n    \"\"\"dependence\"\"\"\n    logger.typewriter_log(\n        title=\"XAgent Service Init Dependence.\",\n        title_color=Fore.RED)\n    init_yag(logger)\n    init_executor(logger)\n    logger.typewriter_log(\n        title=\"XAgent Service Init Dependence: Complete!\",\n        title_color=Fore.RED)\n",
            "name_column": 4
        },
        "get_db": {
            "type": "FunctionDef",
            "name": "get_db",
            "md_content": "",
            "code_start_line": 33,
            "code_end_line": 43,
            "parent": null,
            "have_return": false,
            "code_content": "def get_db():\n    \"\"\"db\"\"\"\n    session = SessionLocal()\n    try:\n        yield session\n        session.commit()\n    except Exception as e:\n        session.rollback()\n        raise e\n    finally:\n        session.close()\n",
            "name_column": 4
        }
    },
    "XAgentServer/application/main.py": {
        "db_session_middleware": {
            "type": "AsyncFunctionDef",
            "name": "db_session_middleware",
            "md_content": "",
            "code_start_line": 20,
            "code_end_line": 58,
            "parent": null,
            "have_return": true,
            "code_content": "async def db_session_middleware(request: Request, call_next):\n    \"\"\"\n    Exception middleware\n    \"\"\"\n    # 默认响应\n    message = \"Internal server error\"\n    response = Response(message, status_code=500)\n    try:\n        response = await call_next(request)\n    except XAgentDBError as error:\n        traceback.print_exc()\n        message = \"XAgent DB Error.\" if XAgentServerEnv.prod else error.message\n        response = JSONResponse(\n            status_code=500,\n            content={\"status\": \"failed\", \"message\": message}\n        )\n    except XAgentFileError as error:\n        traceback.print_exc()\n        message = \"XAgent File Error.\" if XAgentServerEnv.prod else error.message\n        response = JSONResponse(\n            status_code=500,\n            content={\"status\": \"failed\", \"message\": message}\n        )\n    except XAgentAuthError as error:\n        traceback.print_exc()\n        response = JSONResponse(\n            status_code=401,\n            content={\"status\": \"failed\", \"message\": error.message}\n        )\n    except XAgentError as error:\n        traceback.print_exc()\n        message = \"XAgent Error.\" if XAgentServerEnv.prod else error.message\n   \n        response = JSONResponse(\n            status_code=500,\n            content={\"status\": \"failed\", \"message\": message}\n        )\n\n    return response\n",
            "name_column": 10
        },
        "print_start_message": {
            "type": "AsyncFunctionDef",
            "name": "print_start_message",
            "md_content": "",
            "code_start_line": 61,
            "code_end_line": 100,
            "parent": null,
            "have_return": false,
            "code_content": "async def print_start_message():\n    \"\"\"\n    print start message\n    \"\"\"\n    logger.typewriter_log(\n        title=\"XAgent Server Dependences:\",\n        title_color=Fore.RED,\n        content=\"\"\"\n        Python: 3.10+ \n        FastAPI: Http server\n        Websocket: long connect with client\n        MySQL: save xagent data\n        SqlAlchemy: ORM with MySQL\n        Redis: save status of interaction\n        Threading: run interaction\n        APScheduler: send data to client and keep alive\n        FastAPI APIRouter: manage websocket route\n        XAgentError: XAgentServer.exts.exception_ext\"\"\",\n        )\n    logger.typewriter_log(\n        title=\"XAgent Server Version:\",\n        title_color=Fore.RED,\n        content=\"\"\"\n        V 1.1.0\"\"\",\n        )\n    logger.typewriter_log(\n        title=\"Notes:\",\n        title_color=Fore.RED,\n        content=\"\"\"\n        Since V 1.1.0, \n        Local storage will no longer be supported, replaced by Mysql.\n        The service depends on Redis and Mysql, \n        so you need to install Redis and Mysql before using it.\n        Before you use this service, please ensure that the following services are available:\n            1. Redis on docker, port: 6379, you can start it by docker, default password: xagent\n            2. Mysql on docker, port: 3306, you can start it by docker\n            3. XAgent Tool Server is runnning on port 8080\n            4. Port 8090 is not occupied\n        \"\"\",\n        )\n",
            "name_column": 10
        },
        "startup_event": {
            "type": "AsyncFunctionDef",
            "name": "startup_event",
            "md_content": "",
            "code_start_line": 103,
            "code_end_line": 110,
            "parent": null,
            "have_return": false,
            "code_content": "async def startup_event():\n    \"\"\"start up event\n    \"\"\"\n    logger.info(\"XAgent Service Startup Param:\")\n    for key, item in XAgentServerEnv.__dict__.items():\n        if not key.startswith(\"__\"):\n            logger.info(f\"{' '*10}{key}: {item}\")\n    enable_dependence(logger)\n",
            "name_column": 10
        },
        "startup": {
            "type": "AsyncFunctionDef",
            "name": "startup",
            "md_content": "",
            "code_start_line": 114,
            "code_end_line": 123,
            "parent": null,
            "have_return": false,
            "code_content": "async def startup():\n    \"\"\"\n    start up event\n    \"\"\"\n    await startup_event()\n    if XAgentServerEnv.default_login:\n        logger.typewriter_log(\n            title=\"Default user: Guest, token: xagent, you can use it to login\",\n            title_color=Fore.RED)\n    await print_start_message()\n",
            "name_column": 10
        },
        "shutdown": {
            "type": "AsyncFunctionDef",
            "name": "shutdown",
            "md_content": "",
            "code_start_line": 127,
            "code_end_line": 131,
            "parent": null,
            "have_return": false,
            "code_content": "async def shutdown():\n    \"\"\"\n    shut down event\n    \"\"\"\n    print(\"XAgent Service Shutdown!\")\n",
            "name_column": 10
        },
        "validation_exception_handler": {
            "type": "AsyncFunctionDef",
            "name": "validation_exception_handler",
            "md_content": "",
            "code_start_line": 135,
            "code_end_line": 148,
            "parent": null,
            "have_return": true,
            "code_content": "async def validation_exception_handler(request: Request, exc: RequestValidationError):\n    \"\"\"handle validation exception\n\n    Args:\n        request (Request): _description_\n        exc (RequestValidationError): _description_\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    return JSONResponse(\n        status_code=400,\n        content={\"status\": \"failed\", \"message\": exc.errors()}\n    )\n",
            "name_column": 10
        }
    },
    "XAgentServer/application/routers/user.py": {
        "register": {
            "type": "AsyncFunctionDef",
            "name": "register",
            "md_content": "",
            "code_start_line": 21,
            "code_end_line": 56,
            "parent": null,
            "have_return": true,
            "code_content": "async def register(email: str = Form(...),\n                   name: str = Form(...),\n                   corporation: str = Form(...),\n                   position: str = Form(...),\n                   industry: str = Form(...),\n                   db: Session = Depends(get_db)) -> ResponseBody:\n    \"\"\"\n    register user\n    \"\"\"\n    if UserCRUD.is_exist(db=db, email=email):\n        return ResponseBody(success=False, message=\"user is already exist\")\n\n    token = uuid.uuid4().hex\n    user = {\"user_id\": uuid.uuid4().hex, \"email\": email, \"name\": name,\n            \"token\": token, \"available\": False, \"corporation\": corporation,\n            \"position\": position, \"industry\": industry,\n            \"create_time\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            \"update_time\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            \"is_beta\": False}\n    try:\n\n        contents = email_content(user)\n\n        if XAgentServerEnv.Email.send_email:\n            from XAgentServer.application.global_val import yag\n            yag.send(user[\"email\"], 'XAgent Token Verification', contents)\n        else:\n            user[\"available\"] = True\n        UserCRUD.add_user(db=db, user_dict=user)\n    except smtplib.SMTPAuthenticationError:\n        return ResponseBody(success=False, message=\"email send failed!\", data=None)\n\n    except Exception:\n        return ResponseBody(success=False, message=\"register failed\", data=None)\n\n    return ResponseBody(data=user, success=True, message=\"Register success, we will send a email to you!\")\n",
            "name_column": 10
        },
        "auth": {
            "type": "AsyncFunctionDef",
            "name": "auth",
            "md_content": "",
            "code_start_line": 60,
            "code_end_line": 85,
            "parent": null,
            "have_return": true,
            "code_content": "async def auth(user_id: str = Query(...),\n               token: str = Query(...),\n               db: Session = Depends(get_db)\n               ) -> ResponseBody:\n    \"\"\"\n    user auth\n    \"\"\"\n    user = UserCRUD.get_user(db=db, user_id=user_id)\n    if user is None:\n        return ResponseBody(success=False, message=\"user is not exist\")\n\n    if user.token != token:\n        return ResponseBody(success=False, message=\"token is not correct\")\n    expired_time = datetime.now() - datetime.strptime(\n        user.update_time, \"%Y-%m-%d %H:%M:%S\")\n    if expired_time.seconds > 60 * 60 * 24 * 7:\n        return ResponseBody(success=False, message=\"token is expired\")\n    if not user.available:\n\n        user.available = True\n        user.update_time = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        UserCRUD.update_user(db=db, user=user)\n    else:\n        return ResponseBody(success=False, message=\"user is already available!\")\n\n    return ResponseBody(data=user.to_dict(), success=True, message=\"auth success\")\n",
            "name_column": 10
        },
        "login": {
            "type": "AsyncFunctionDef",
            "name": "login",
            "md_content": "",
            "code_start_line": 89,
            "code_end_line": 104,
            "parent": null,
            "have_return": true,
            "code_content": "async def login(email: str = Form(...),\n                token: str = Form(...),\n                db: Session = Depends(get_db)) -> ResponseBody:\n    \"\"\"\n    login\n    \"\"\"\n    user = UserCRUD.get_user(db=db, email=email)\n    if user is None:\n        return ResponseBody(success=False, message=\"user is not exist\")\n\n    if user.token != token:\n        return ResponseBody(success=False, message=\"token is not correct\")\n    if not user.available:\n        return ResponseBody(success=False, message=\"user is not available\")\n\n    return ResponseBody(data=user.to_dict(), success=True, message=\"login success\")\n",
            "name_column": 10
        },
        "check": {
            "type": "AsyncFunctionDef",
            "name": "check",
            "md_content": "",
            "code_start_line": 108,
            "code_end_line": 120,
            "parent": null,
            "have_return": true,
            "code_content": "async def check(token: str = Form(...), db: Session = Depends(get_db)) -> ResponseBody:\n    \"\"\"\n    check token is effective\n    \"\"\"\n    if token is None:\n        return ResponseBody(success=False, message=\"token is none\")\n\n    result = UserCRUD.token_is_exist(db=db, token=token, user_id=None)\n\n    if result:\n        return ResponseBody(data=result, success=True, message=\"token is effective\")\n\n    return ResponseBody(data=result, success=True, message=\"token is invalid\")\n",
            "name_column": 10
        }
    },
    "XAgentServer/application/routers/__init__.py": {},
    "XAgentServer/application/routers/conv.py": {
        "user_is_available": {
            "type": "FunctionDef",
            "name": "user_is_available",
            "md_content": "",
            "code_start_line": 31,
            "code_end_line": 44,
            "parent": null,
            "have_return": true,
            "code_content": "def user_is_available(\n        user_id: str = Form(...),\n        token: str = Form(...),\n        db: Session = Depends(get_db)):\n    \"\"\"\n    check user is available    \n    \"\"\"\n    if user_id == \"\":\n        raise XAgentAuthError(\"user_id is empty!\")\n    if not UserCRUD.is_exist(db=db, user_id=user_id):\n        raise XAgentAuthError(\"user is not exist!\")\n    if not UserCRUD.user_is_valid(db=db, user_id=user_id, token=token):\n        raise XAgentAuthError(\"user is not available!\")\n    return user_id\n",
            "name_column": 4
        },
        "get_all_interactions": {
            "type": "AsyncFunctionDef",
            "name": "get_all_interactions",
            "md_content": "",
            "code_start_line": 48,
            "code_end_line": 60,
            "parent": null,
            "have_return": true,
            "code_content": "async def get_all_interactions(user_id: str = Depends(user_is_available),\n                               page_size: int = Form(...),\n                               page_num: int = Form(...),\n                               db: Session = Depends(get_db)) -> ResponseBody:\n    \"\"\"\n    get all interactions by user_id\n    \"\"\"\n\n    data = InteractionCRUD.search_interaction_by_user_id(db=db,\n                                                         user_id=user_id,\n                                                         page_size=page_size,\n                                                         page_num=page_num)\n    return ResponseBody(data=data, success=True, message=\"success\")\n",
            "name_column": 10
        },
        "init_conv_env": {
            "type": "FunctionDef",
            "name": "init_conv_env",
            "md_content": "",
            "code_start_line": 64,
            "code_end_line": 92,
            "parent": null,
            "have_return": true,
            "code_content": "def init_conv_env(user_id: str = Depends(user_is_available),\n                  db: Session = Depends(get_db)):\n    \"\"\"\n    initialize conv env\n    \"\"\"\n\n    interaction = InteractionCRUD.get_ready_interaction(db=db, user_id=user_id)\n\n    if interaction is None:\n        interaction_id = uuid.uuid4().hex\n        base = InteractionBase(interaction_id=interaction_id,\n                               user_id=user_id,\n                               create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                               description=\"XAgent\",\n                               agent=\"\",\n                               mode=\"\",\n                               file_list=[],\n                               recorder_root_dir=\"\",\n                               status=\"ready\",\n                               message=\"ready...\",\n                               current_step=\"-1\",\n                               update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n                               )\n        InteractionCRUD.create_interaction(db=db, base=base)\n    else:\n        interaction_id = interaction.interaction_id\n\n    return ResponseBody(data={\"id\": interaction_id,\n                              \"t\": str(int(datetime.now().timestamp() * 1000))}, success=True, message=\"success\")\n",
            "name_column": 4
        },
        "get_share_interactions": {
            "type": "AsyncFunctionDef",
            "name": "get_share_interactions",
            "md_content": "",
            "code_start_line": 96,
            "code_end_line": 106,
            "parent": null,
            "have_return": true,
            "code_content": "async def get_share_interactions(user_id: str = Depends(user_is_available),\n                                 page_size: int = Form(...),\n                                 page_num: int = Form(...),\n                                 db: Session = Depends(get_db)) -> ResponseBody:\n    \"\"\"\n    get all interactions by user id\n    \"\"\"\n\n    data = InteractionCRUD.search_many_shared(\n        db=db, page_size=page_size, page_index=page_num)\n    return ResponseBody(data=data, success=True, message=\"success\")\n",
            "name_column": 10
        },
        "share_interaction": {
            "type": "AsyncFunctionDef",
            "name": "share_interaction",
            "md_content": "",
            "code_start_line": 110,
            "code_end_line": 168,
            "parent": null,
            "have_return": true,
            "code_content": "async def share_interaction(user_id: str = Depends(user_is_available),\n                            interaction_id: str = Form(...),\n                            db: Session = Depends(get_db)) -> ResponseBody:\n    \"\"\"\n    update_interaction_description\n    \"\"\"\n    interaction = InteractionCRUD.get_interaction(db=db,\n                                                  interaction_id=interaction_id)\n    if interaction is None:\n        return ResponseBody(success=False,\n                            message=f\"Don't find any interaction by interaction_id: \\\n                                {interaction_id}, Please check your interaction_id!\")\n\n    finish_status = InteractionCRUD.get_finish_status(\n        db=db, interaction_id=interaction_id)\n    if not finish_status:\n        return ResponseBody(success=False, message=\"interaction is not finish!\")\n    user = UserCRUD.get_user(db=db, user_id=user_id)\n    user_name = user.name\n    interaction_dir = os.path.join(XAgentServerEnv.base_dir,\n                                   \"localstorage\",\n                                   \"interact_records\",\n                                   interaction.create_time[:10],\n                                   interaction_id)\n    workspace_dir = os.path.join(interaction_dir, \"workspace\")\n    zip_file = os.path.join(interaction_dir, \"workspace.zip\")\n    if not os.path.exists(zip_file):\n        if os.path.exists(workspace_dir):\n            files = os.listdir(workspace_dir)\n            # zip workspace\n            with zipfile.ZipFile(zip_file, 'w', zipfile.ZIP_DEFLATED) as z:\n                for f in files:\n                    file = os.path.join(workspace_dir, f)\n                    z.write(file, arcname=f)\n\n    raws = InteractionCRUD.search_many_raws(\n        db=db, interaction_id=interaction_id)\n\n    share_data = {\n        \"user_id\": user_id,\n        \"user_name\": user_name,\n        \"token\": user.token,\n        \"interaction\": json.dumps(interaction.to_dict(), ensure_ascii=False),\n        \"raws\": json.dumps([raw.to_dict() for raw in raws], ensure_ascii=False),\n    }\n\n    with open(zip_file, 'rb') as f:\n        files = {\"files\": f.read()}\n    try:\n        res = requests.post(url=XAgentServerEnv.share_url,\n                            data=share_data,\n                            files=files,\n                            timeout=60)\n\n        data = res.json()\n\n        return ResponseBody(**data)\n    except Exception as e:\n        return ResponseBody(success=False, message=str(e), data=None)\n",
            "name_column": 10
        },
        "community": {
            "type": "FunctionDef",
            "name": "community",
            "md_content": "",
            "code_start_line": 172,
            "code_end_line": 250,
            "parent": null,
            "have_return": true,
            "code_content": "def community(user_id: str = Depends(user_is_available),\n              user_name: str = Form(...),\n              interaction: str = Form(...),\n              raws: str = Form(...),\n              files: UploadFile = File(...),\n              db: Session = Depends(get_db)):\n    \"\"\"\n    community, this api is runing on x-agent.net\n    \"\"\"\n    interaction = json.loads(interaction)\n    raws = json.loads(raws)\n    interaction_id = interaction[\"interaction_id\"]\n    old_share = InteractionCRUD.get_shared_interaction(\n        db=db, interaction_id=interaction_id)\n\n    # 如果已经分享过了，就不再分享了\n    if old_share:\n        raise XAgentWebError(\"interaction is exist!\")\n\n    contain_finish = False\n    for raw in raws:\n        if raw[\"status\"] == StatusEnum.FINISHED:\n            contain_finish = True\n            break\n    # 如果没有finish的节点，就不分享了\n    if not contain_finish:\n        raise XAgentWebError(\"interaction is not finish!\")\n\n    interaction_dir = os.path.join(XAgentServerEnv.base_dir,\n                                   \"localstorage\",\n                                   \"interact_records\",\n                                   interaction[\"create_time\"][:10],\n                                   interaction_id,\n                                   \"workspace\")\n\n    if not os.path.exists(interaction_dir):\n        os.makedirs(interaction_dir)\n\n    # 先暂存文件\n    with open(os.path.join(interaction_dir, \"workspace.zip\"), \"wb\") as f:\n        f.write(files.file.read())\n\n    # 解压文件\n    with zipfile.ZipFile(file=os.path.join(interaction_dir, \"workspace.zip\"), mode=\"r\") as zip_file:\n        zip_list = zip_file.namelist()  # 得到压缩包里所有文件\n        for f in zip_list:\n            zip_file.extract(f, interaction_dir)  # 循环解压文件到指定目录\n\n    # 删除压缩包\n    os.remove(os.path.join(interaction_dir, \"workspace.zip\"))\n\n    base = InteractionBase(**interaction)\n\n    share = SharedInteractionBase(\n        interaction_id=interaction_id,\n        user_name=user_name,\n        create_time=interaction[\"create_time\"],\n        update_time=interaction[\"update_time\"],\n        description=interaction[\"description\"],\n        agent=interaction[\"agent\"],\n        mode=interaction[\"mode\"],\n        is_deleted=False,\n        star=0,\n        is_audit=False\n    )\n\n    InteractionCRUD.create_interaction(db=db, base=base)\n\n    InteractionCRUD.add_share(db=db, share=share)\n\n    for raw in raws:\n        old_raw = InteractionCRUD.get_raw(db=db,\n                                          interaction_id=interaction_id,\n                                          node_id=raw[\"node_id\"])\n        if old_raw is None:\n            xraw = XAgentRaw(**raw)\n            InteractionCRUD.insert_raw(db=db, process=xraw)\n\n    return ResponseBody(data=None, success=True, message=\"success\")\n",
            "name_column": 4
        },
        "delete_interaction": {
            "type": "AsyncFunctionDef",
            "name": "delete_interaction",
            "md_content": "",
            "code_start_line": 254,
            "code_end_line": 264,
            "parent": null,
            "have_return": true,
            "code_content": "async def delete_interaction(user_id: str = Depends(user_is_available),\n                             interaction_id: str = Form(...),\n                             db: Session = Depends(get_db)) -> ResponseBody:\n    \"\"\"\n    delete\n    \"\"\"\n\n    data = InteractionCRUD.delete_interaction(db=db,\n                                              interaction_id=interaction_id)\n\n    return ResponseBody(data=data, success=True, message=\"success\")\n",
            "name_column": 10
        },
        "update_interaction_parameter": {
            "type": "AsyncFunctionDef",
            "name": "update_interaction_parameter",
            "md_content": "",
            "code_start_line": 268,
            "code_end_line": 293,
            "parent": null,
            "have_return": true,
            "code_content": "async def update_interaction_parameter(user_id: str = Depends(user_is_available),\n                                       mode: str = Form(...),\n                                       agent: str = Form(...),\n                                       file_list: List[str] = Form(...),\n                                       interaction_id: str = Form(...),\n                                       db: Session = Depends(get_db)\n                                       ) -> ResponseBody:\n    \"\"\"\n    update parameter\n\n    \"\"\"\n    if interaction_id == \"\":\n        return ResponseBody(success=False, message=\"interaction_id is empty!\")\n    interaction = InteractionCRUD.get_interaction(db=db,\n                                                  interaction_id=interaction_id)\n    if interaction is None:\n        return ResponseBody(success=False, message=f\"Don't find any interaction by interaction_id:\\\n            {interaction_id}, Please check your interaction_id!\")\n    update_data = {\n        \"interaction_id\": interaction_id,\n        \"agent\": agent,\n        \"mode\": mode,\n        \"file_list\": [json.loads(l) for l in file_list],\n    }\n    InteractionCRUD.update_interaction(db=db, base_data=update_data)\n    return ResponseBody(data=update_data, success=True, message=\"success!\")\n",
            "name_column": 10
        },
        "update_interaction_description": {
            "type": "AsyncFunctionDef",
            "name": "update_interaction_description",
            "md_content": "",
            "code_start_line": 297,
            "code_end_line": 318,
            "parent": null,
            "have_return": true,
            "code_content": "async def update_interaction_description(user_id: str = Depends(user_is_available),\n                                         description: str = Form(...),\n                                         interaction_id: str = Form(...),\n                                         db: Session = Depends(get_db)\n                                         ) -> ResponseBody:\n    \"\"\"\n    update description\n\n    \"\"\"\n    if interaction_id == \"\":\n        return ResponseBody(success=False, message=\"interaction_id is empty!\")\n    interaction = InteractionCRUD.get_interaction(db=db,\n                                                  interaction_id=interaction_id)\n    if interaction is None:\n        return ResponseBody(success=False, message=f\"Don't find any interaction by interaction_id:\\\n            {interaction_id}, Please check your interaction_id!\")\n    update_data = {\n        \"interaction_id\": interaction_id,\n        \"description\": description if description else \"XAgent\",\n    }\n    InteractionCRUD.update_interaction(db=db, base_data=update_data)\n    return ResponseBody(data=update_data, success=True, message=\"success!\")\n",
            "name_column": 10
        }
    },
    "XAgentServer/application/routers/workspace.py": {
        "user_is_available": {
            "type": "FunctionDef",
            "name": "user_is_available",
            "md_content": "",
            "code_start_line": 24,
            "code_end_line": 38,
            "parent": null,
            "have_return": true,
            "code_content": "def user_is_available(\n        user_id: str = Form(...),\n        token: str = Form(...),\n        db: Session = Depends(get_db)):\n    \"\"\"\n    check user is available    \n    \"\"\"\n    if user_id == \"\":\n        raise HTTPException(status_code=401, detail=\"user_id is empty!\")\n    if not UserCRUD.is_exist(db=db, user_id=user_id):\n        raise HTTPException(status_code=401, detail=\"user is not exist!\")\n    if not UserCRUD.user_is_valid(db=db, user_id=user_id, token=token):\n        raise HTTPException(\n            status_code=401, detail=\"user is not available!\")\n    return user_id\n",
            "name_column": 4
        },
        "create_upload_files": {
            "type": "AsyncFunctionDef",
            "name": "create_upload_files",
            "md_content": "",
            "code_start_line": 42,
            "code_end_line": 67,
            "parent": null,
            "have_return": true,
            "code_content": "async def create_upload_files(files: List[UploadFile] = File(...),\n                              user_id: str = Depends(user_is_available)) -> ResponseBody:\n    \"\"\"Upload Files\"\"\"\n\n    if len(files) == 0:\n        return ResponseBody(success=False, message=\"files is empty!\")\n    if len(files) > 5:\n        files = files[:5]\n\n    if not os.path.exists(os.path.join(XAgentServerEnv.Upload.upload_dir, user_id)):\n        os.makedirs(os.path.join(XAgentServerEnv.Upload.upload_dir, user_id))\n\n    for f in files:\n        if f.size > 1024 * 1024 * 1:\n            return ResponseBody(success=False,\n                                message=\"file size is too large, limit is 1MB for each file!\")\n\n    file_list = []\n    for file in files:\n        file_name = uuid.uuid4().hex + os.path.splitext(file.filename)[-1]\n        with open(os.path.join(XAgentServerEnv.Upload.upload_dir, user_id, file_name), \"wb\") as f:\n            f.write(await file.read())\n            file_list.append({\"uuid\": file_name, \"name\": file.filename})\n    return ResponseBody(data={\"user_id\": user_id,\n                              \"file_list\": file_list},\n                        success=True, message=\"upload success\")\n",
            "name_column": 10
        },
        "file": {
            "type": "AsyncFunctionDef",
            "name": "file",
            "md_content": "",
            "code_start_line": 71,
            "code_end_line": 139,
            "parent": null,
            "have_return": true,
            "code_content": "async def file(user_id: str = Depends(user_is_available),\n               interaction_id: str = Form(...),\n               db: Session = Depends(get_db),\n               file_name: str = Form(...)):\n    \"\"\"\n    get download file\n    \"\"\"\n    interaction = InteractionCRUD.get_interaction(db=db, interaction_id=interaction_id)\n\n    if interaction is None:\n        return ResponseBody(success=False, message=\"interaction is not exist!\")\n\n    time_str = interaction.create_time[:10]\n\n    file_path = os.path.join(\n        XAgentServerEnv.base_dir,\n        \"localstorage/interact_records\",\n        time_str,\n        interaction_id,\n        \"workspace\")\n    if not os.path.exists(file_path):\n        return ResponseBody(success=False,\n                            message=\"file is not exist!\")\n\n    file_suffix = file_name.split(\".\")[-1]\n    if file_suffix in [\"jpg\", \"png\",\n                       \"jpeg\", \"gif\", \"bmp\"]:\n        with open(os.path.join(file_path, file_name), \"rb\") as f:\n            data = base64.b64encode(f.read()).decode(\"utf-8\")\n        return ResponseBody(\n            data=f\"data:image/{file_suffix};base64,{data}\",\n            success=True,\n            message=\"get file success!\"\n        )\n\n    if file_suffix in [\"mp4\", \"avi\", \"mkv\",\n                       \"rmvb\", \"rm\", \"flv\", \"3gp\", \"wmv\"]:\n        return FileResponse(os.path.join(file_path, file_name),\n                            media_type=\"video/\" + file_suffix)\n\n    if file_suffix in [\"mp3\", \"wav\", \"wma\",\n                       \"ogg\", \"aac\", \"flac\", \"ape\"]:\n        return FileResponse(os.path.join(file_path, file_name),\n                            media_type=\"audio/\" + file_suffix)\n\n    if file_suffix in [\"pdf\", \"doc\", \"docx\",\n                       \"xls\", \"xlsx\", \"ppt\", \"pptx\"]:\n        return FileResponse(os.path.join(file_path, file_name),\n                            media_type=\"application/\" + file_suffix)\n\n    if file_suffix in [\"json\"]:\n        with open(os.path.join(file_path, file_name), 'r', encoding=\"utf-8\") as f:\n            data = json.load(f)\n\n        return ResponseBody(data=json.dumps(data,\n                                            ensure_ascii=False,\n                                            indent=4),\n                            success=True,\n                            message=\"get file success!\")\n\n    if file_suffix in [\"ipynb\"]:\n        return FileResponse(os.path.join(file_path, file_name),\n                            media_type=\"application/\" + file_suffix)\n    \n    \n    with open(os.path.join(file_path, file_name), 'r', encoding=\"utf-8\") as f:\n        data = f.read()\n\n    return ResponseBody(data=data, success=True, message=\"get file success!\")\n",
            "name_column": 10
        }
    },
    "XAgentServer/application/core/envs.py": {
        "XAgentServerEnv": {
            "type": "ClassDef",
            "name": "XAgentServerEnv",
            "md_content": "",
            "code_start_line": 11,
            "code_end_line": 90,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentServerEnv:\n    \"\"\"\n    XAgentServer environment variables\n    if you change value of the environment variable, you need to restart \n    the XAgentServer by running the following command:\n    `python start_server.py`\n    or start a unicorn server by yourself\n    \"\"\"\n    app = \"app:app\"\n    prod: bool = config.get(\"PROD\", \"False\").lower() == \"true\"\n    base_dir = \"XAgentServer\"\n    use_redis: bool = False\n    recorder_root_dir = \"running_records\"\n    # you can set default_login with True,\n    # use the default user \"admin\" with token \"xagent-admin\" to login,\n    default_login: bool = True\n    # only one XAgentServer can be set to check whether the interaction is running.\n    check_running: bool = False\n    host = \"0.0.0.0\"\n    port = 8090\n    debug = True\n    reload = True\n    workers = 1\n    share_url = \"https://x-agent.net/api/conv/community\"\n\n    class DB:\n        \"\"\"\n        database config\n        \"\"\"\n        use_db = True\n        db_url = \"mysql+pymysql://root:xagent@localhost:3306/xagent\"\n\n    class Redis:\n        \"\"\"\n        redis config\n        \"\"\"\n        use_redis = False\n        redis_url = \"redis://localhost\"\n        redis_host = \"localhost\"\n        redis_port = 6379\n        redis_db = 0\n        redis_password = \"xagent\"\n\n    # if you want to use email to send message,\n    # you can set send_email to True and set\n    # email_host,\n    # email_port,\n    # email_user,\n    # email_password,\n    # auth_server\n    class Email:\n        \"\"\"\n        email config\n        \"\"\"\n        send_email = False\n        email_host = \"\"\n        email_port = 465\n        email_user = \"\"\n        email_password = \"\"\n        auth_server = \"\"\n\n    # if you want to use upload function,\n    # you can set upload_dir to the path of the upload directory\n    # and set upload_allowed_types of the allowed types\n    class Upload:\n        \"\"\"\n        upload config\n        \"\"\"\n        upload_dir = \"XAgentServer/localstorage/upload\"\n        if not os.path.exists(upload_dir):\n            os.makedirs(upload_dir)\n        upload_allowed_types = [\"image/png\", \"image/jpeg\",\n                                \"image/gif\", \"text/plain\",\n                                \"application/msword\", \"pdf\",\n                                \"txt\", \"pptx\", \"xlsx\",\n                                \"doc\", \"ppt\", \"xls\",\n                                \"zip\", \"rar\", \"tar\",\n                                \"gz\", \"7z\", \"bz2\",\n                                \"tgz\", \"tbz2\", \"tar.gz\",\n                                \"tar.bz2\"]\n",
            "name_column": 6
        },
        "DB": {
            "type": "ClassDef",
            "name": "DB",
            "md_content": "",
            "code_start_line": 36,
            "code_end_line": 41,
            "parent": "XAgentServerEnv",
            "have_return": false,
            "code_content": "    class DB:\n        \"\"\"\n        database config\n        \"\"\"\n        use_db = True\n        db_url = \"mysql+pymysql://root:xagent@localhost:3306/xagent\"\n",
            "name_column": 10
        },
        "Redis": {
            "type": "ClassDef",
            "name": "Redis",
            "md_content": "",
            "code_start_line": 43,
            "code_end_line": 52,
            "parent": "XAgentServerEnv",
            "have_return": false,
            "code_content": "    class Redis:\n        \"\"\"\n        redis config\n        \"\"\"\n        use_redis = False\n        redis_url = \"redis://localhost\"\n        redis_host = \"localhost\"\n        redis_port = 6379\n        redis_db = 0\n        redis_password = \"xagent\"\n",
            "name_column": 10
        },
        "Email": {
            "type": "ClassDef",
            "name": "Email",
            "md_content": "",
            "code_start_line": 61,
            "code_end_line": 70,
            "parent": "XAgentServerEnv",
            "have_return": false,
            "code_content": "    class Email:\n        \"\"\"\n        email config\n        \"\"\"\n        send_email = False\n        email_host = \"\"\n        email_port = 465\n        email_user = \"\"\n        email_password = \"\"\n        auth_server = \"\"\n",
            "name_column": 10
        },
        "Upload": {
            "type": "ClassDef",
            "name": "Upload",
            "md_content": "",
            "code_start_line": 75,
            "code_end_line": 90,
            "parent": "XAgentServerEnv",
            "have_return": false,
            "code_content": "    class Upload:\n        \"\"\"\n        upload config\n        \"\"\"\n        upload_dir = \"XAgentServer/localstorage/upload\"\n        if not os.path.exists(upload_dir):\n            os.makedirs(upload_dir)\n        upload_allowed_types = [\"image/png\", \"image/jpeg\",\n                                \"image/gif\", \"text/plain\",\n                                \"application/msword\", \"pdf\",\n                                \"txt\", \"pptx\", \"xlsx\",\n                                \"doc\", \"ppt\", \"xls\",\n                                \"zip\", \"rar\", \"tar\",\n                                \"gz\", \"7z\", \"bz2\",\n                                \"tgz\", \"tbz2\", \"tar.gz\",\n                                \"tar.bz2\"]\n",
            "name_column": 10
        }
    },
    "XAgentServer/application/websockets/replayer.py": {
        "ReplayServer": {
            "type": "ClassDef",
            "name": "ReplayServer",
            "md_content": "",
            "code_start_line": 29,
            "code_end_line": 195,
            "parent": null,
            "have_return": true,
            "code_content": "class ReplayServer(WebSocketEndpoint):\n    \"\"\"Main Websocket Server\n    Extends:\n        WebSocketEndpoint\n    \n    Description:\n        In this websocket, we will receive the args from user,\n        and you can use it to run the interaction.\n        specifically, the args is a dict, \n        and it must contain a key named \"goal\" to tell XAgent what do you want to do.\n\n    \"\"\"\n\n    def __init__(self, websocket: WebSocket, db: Session = Depends(get_db), client_id: str = \"\"):\n        super().__init__(websocket.scope, websocket.receive, websocket.send)\n        self.db = db\n        self.client_id: str = client_id\n        self.websocket = websocket\n        self.date_str = datetime.now().strftime(\"%Y-%m-%d\")\n        self.log_dir = \"\"\n        self.logger = None\n        self.scheduler = AsyncIOScheduler()\n        \n    async def dispatch(self) -> None:\n        \"\"\"_summary_\n\n        Raises:\n            exc: _description_\n        \"\"\"\n        websocket = WebSocket(self.scope, receive=self.receive, send=self.send)\n        close_code = 1000\n        await self.on_connect(websocket)\n        try:\n            while True:\n                message = await websocket.receive()\n                if message[\"type\"] == \"websocket.receive\":\n                    data = await self.decode(websocket, message)\n                    await self.on_receive(websocket, data)\n                elif message[\"type\"] == \"websocket.disconnect\":\n                    close_code = 1000\n                    break\n        except Exception as exc:\n            close_code = 1011\n            raise exc\n        finally:\n            await self.on_disconnect(websocket, close_code)\n            if self.scheduler.running:\n                self.scheduler.shutdown()\n                self.logger.info(\"shutdown scheduler\")\n            if self.db:\n                self.db.close()\n                self.logger.info(\"close db\")\n            \n\n    async def on_connect(self, websocket: WebSocket):\n        \"\"\"Connect to client\n\n        Args:\n            websocket (WebSocket): A websocket object\n\n        Raises:\n            XAgentWebSocketConnectError: If the user is running, it will raise this error.\n        \"\"\"\n\n        self.log_dir = os.path.join(os.path.join(XAgentServerEnv.base_dir, \"localstorage\",\n                                    \"interact_records\"), self.date_str, self.client_id)\n        if not os.path.exists(self.log_dir):\n            os.makedirs(self.log_dir)\n\n        self.logger = Logger(\n            log_dir=self.log_dir, log_file=\"replay.log\", log_name=f\"{self.client_id}_REPLAY\")\n        query_string = self.scope.get(\"query_string\", b\"\").decode()\n        parameters = parse_qs(query_string)\n        user_id = parameters.get(\"user_id\", [\"\"])[0]\n        token = parameters.get(\"token\", [\"\"])[0]\n        self.logger.typewriter_log(\n            title=f\"Receive connection from {self.client_id}: \",\n            title_color=Fore.RED,\n            content=f\"user_id: {user_id}, token: {token}\")\n        await websocket.accept()\n        try:\n            await check_user(db=self.db, user_id=user_id, token=token)\n            # check running, you can edit it by yourself in envs.py to skip this check\n            if XAgentServerEnv.check_running:\n                if InteractionCRUD.is_running(db=self.db, user_id=user_id):\n                    raise XAgentWebSocketConnectError(\n                        \"You have a running interaction, please wait for it to finish!\")\n        except XAgentWebSocketConnectError as exc:\n            await websocket.send_text(\n                WebsocketResponseBody(status=\"connect\",\n                                    success=False,\n                                    message=str(exc),\n                                    data=None).to_text())\n            await websocket.close(code=1000)\n            return\n        await websocket.send_text(\n            WebsocketResponseBody(\n                status=\"connect\",\n                success=True,\n                message=\"connect success\",\n                data=None).to_text())\n\n    async def on_disconnect(self, websocket: WebSocket, close_code):\n        \"\"\"When disconnect with client, it will run this function\n        Override this function to do something when disconnect with client\n        \n        Args:\n            websocket (WebSocket): A websocket object\n            close_code (_type_): The close code, default is 0\n        \"\"\"\n        self.logger.typewriter_log(\n            title=f\"Disconnect with client {self.client_id}: \",\n            title_color=Fore.RED)\n        \n\n    async def on_receive(self, websocket: WebSocket, data: Any):\n        \"\"\"\n        When receive data from client, it will run this function\n        \n        Args:\n            websocket (WebSocket): A websocket object\n            data (any): The data from client\n        \"\"\"\n        data = json.loads(data)\n        self.logger.typewriter_log(\n            title=f\"Receive data from {self.client_id}: \",\n            title_color=Fore.RED,\n            content=json.dumps(data, indent=4, ensure_ascii=False)\n        )\n        if data.get(\"type\", \"\") == \"ping\":\n            # await self.pong()\n            pass\n        elif data.get(\"type\", \"\") == \"replay\":\n            if not self.scheduler.running:\n                self.scheduler.add_job(self.pong, \"interval\", seconds=20)\n                self.scheduler.add_job(self.send_data, \"date\", next_run_time=datetime.now())\n                self.scheduler.start()\n                 \n    async def pong(self):\n        \"\"\"\n        pong to client for keeping alive\n        \"\"\"\n        await self.websocket.send_text(json.dumps({\"type\": \"pong\"}, ensure_ascii=False, indent=2))\n\n    async def send_data(self):\n        \"\"\"\n        send data to client\n        \"\"\"\n        \n        rows = InteractionCRUD.search_many_raws(db=self.db, interaction_id=self.client_id)\n        for row in rows:\n            self.logger.typewriter_log(\n                title=f\"Send data to {self.client_id}: \",\n                title_color=Fore.RED,\n                content=f\"Send {row.node_id}data to client, length: {len(json.dumps(row.data))}.\"\n            )\n            root_dir = os.path.join(XAgentServerEnv.base_dir, \"localstorage\", \"interact_records\", row.create_time[:10], row.interaction_id)\n            await self.websocket.send_text(\n                WebsocketResponseBody(status=row.status,\n                                    success=True, message=\"success\",\n                                    data=handle_data(row=row, root_dir=root_dir),\n                                    current=row.current,\n                                    node_id=row.node_id,\n                                    workspace_file_list=handle_workspace_filelist(row.file_list)).to_text())\n            # await asyncio.sleep(random.randint(1, 3))\n        if self.scheduler.running:\n            self.scheduler.shutdown()",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 42,
            "code_end_line": 50,
            "parent": "ReplayServer",
            "have_return": false,
            "code_content": "    def __init__(self, websocket: WebSocket, db: Session = Depends(get_db), client_id: str = \"\"):\n        super().__init__(websocket.scope, websocket.receive, websocket.send)\n        self.db = db\n        self.client_id: str = client_id\n        self.websocket = websocket\n        self.date_str = datetime.now().strftime(\"%Y-%m-%d\")\n        self.log_dir = \"\"\n        self.logger = None\n        self.scheduler = AsyncIOScheduler()\n",
            "name_column": 8
        },
        "dispatch": {
            "type": "AsyncFunctionDef",
            "name": "dispatch",
            "md_content": "",
            "code_start_line": 52,
            "code_end_line": 80,
            "parent": "ReplayServer",
            "have_return": false,
            "code_content": "    async def dispatch(self) -> None:\n        \"\"\"_summary_\n\n        Raises:\n            exc: _description_\n        \"\"\"\n        websocket = WebSocket(self.scope, receive=self.receive, send=self.send)\n        close_code = 1000\n        await self.on_connect(websocket)\n        try:\n            while True:\n                message = await websocket.receive()\n                if message[\"type\"] == \"websocket.receive\":\n                    data = await self.decode(websocket, message)\n                    await self.on_receive(websocket, data)\n                elif message[\"type\"] == \"websocket.disconnect\":\n                    close_code = 1000\n                    break\n        except Exception as exc:\n            close_code = 1011\n            raise exc\n        finally:\n            await self.on_disconnect(websocket, close_code)\n            if self.scheduler.running:\n                self.scheduler.shutdown()\n                self.logger.info(\"shutdown scheduler\")\n            if self.db:\n                self.db.close()\n                self.logger.info(\"close db\")\n",
            "name_column": 14
        },
        "on_connect": {
            "type": "AsyncFunctionDef",
            "name": "on_connect",
            "md_content": "",
            "code_start_line": 83,
            "code_end_line": 129,
            "parent": "ReplayServer",
            "have_return": true,
            "code_content": "    async def on_connect(self, websocket: WebSocket):\n        \"\"\"Connect to client\n\n        Args:\n            websocket (WebSocket): A websocket object\n\n        Raises:\n            XAgentWebSocketConnectError: If the user is running, it will raise this error.\n        \"\"\"\n\n        self.log_dir = os.path.join(os.path.join(XAgentServerEnv.base_dir, \"localstorage\",\n                                    \"interact_records\"), self.date_str, self.client_id)\n        if not os.path.exists(self.log_dir):\n            os.makedirs(self.log_dir)\n\n        self.logger = Logger(\n            log_dir=self.log_dir, log_file=\"replay.log\", log_name=f\"{self.client_id}_REPLAY\")\n        query_string = self.scope.get(\"query_string\", b\"\").decode()\n        parameters = parse_qs(query_string)\n        user_id = parameters.get(\"user_id\", [\"\"])[0]\n        token = parameters.get(\"token\", [\"\"])[0]\n        self.logger.typewriter_log(\n            title=f\"Receive connection from {self.client_id}: \",\n            title_color=Fore.RED,\n            content=f\"user_id: {user_id}, token: {token}\")\n        await websocket.accept()\n        try:\n            await check_user(db=self.db, user_id=user_id, token=token)\n            # check running, you can edit it by yourself in envs.py to skip this check\n            if XAgentServerEnv.check_running:\n                if InteractionCRUD.is_running(db=self.db, user_id=user_id):\n                    raise XAgentWebSocketConnectError(\n                        \"You have a running interaction, please wait for it to finish!\")\n        except XAgentWebSocketConnectError as exc:\n            await websocket.send_text(\n                WebsocketResponseBody(status=\"connect\",\n                                    success=False,\n                                    message=str(exc),\n                                    data=None).to_text())\n            await websocket.close(code=1000)\n            return\n        await websocket.send_text(\n            WebsocketResponseBody(\n                status=\"connect\",\n                success=True,\n                message=\"connect success\",\n                data=None).to_text())\n",
            "name_column": 14
        },
        "on_disconnect": {
            "type": "AsyncFunctionDef",
            "name": "on_disconnect",
            "md_content": "",
            "code_start_line": 131,
            "code_end_line": 141,
            "parent": "ReplayServer",
            "have_return": false,
            "code_content": "    async def on_disconnect(self, websocket: WebSocket, close_code):\n        \"\"\"When disconnect with client, it will run this function\n        Override this function to do something when disconnect with client\n        \n        Args:\n            websocket (WebSocket): A websocket object\n            close_code (_type_): The close code, default is 0\n        \"\"\"\n        self.logger.typewriter_log(\n            title=f\"Disconnect with client {self.client_id}: \",\n            title_color=Fore.RED)\n",
            "name_column": 14
        },
        "on_receive": {
            "type": "AsyncFunctionDef",
            "name": "on_receive",
            "md_content": "",
            "code_start_line": 144,
            "code_end_line": 165,
            "parent": "ReplayServer",
            "have_return": false,
            "code_content": "    async def on_receive(self, websocket: WebSocket, data: Any):\n        \"\"\"\n        When receive data from client, it will run this function\n        \n        Args:\n            websocket (WebSocket): A websocket object\n            data (any): The data from client\n        \"\"\"\n        data = json.loads(data)\n        self.logger.typewriter_log(\n            title=f\"Receive data from {self.client_id}: \",\n            title_color=Fore.RED,\n            content=json.dumps(data, indent=4, ensure_ascii=False)\n        )\n        if data.get(\"type\", \"\") == \"ping\":\n            # await self.pong()\n            pass\n        elif data.get(\"type\", \"\") == \"replay\":\n            if not self.scheduler.running:\n                self.scheduler.add_job(self.pong, \"interval\", seconds=20)\n                self.scheduler.add_job(self.send_data, \"date\", next_run_time=datetime.now())\n                self.scheduler.start()\n",
            "name_column": 14
        },
        "pong": {
            "type": "AsyncFunctionDef",
            "name": "pong",
            "md_content": "",
            "code_start_line": 167,
            "code_end_line": 171,
            "parent": "ReplayServer",
            "have_return": false,
            "code_content": "    async def pong(self):\n        \"\"\"\n        pong to client for keeping alive\n        \"\"\"\n        await self.websocket.send_text(json.dumps({\"type\": \"pong\"}, ensure_ascii=False, indent=2))\n",
            "name_column": 14
        },
        "send_data": {
            "type": "AsyncFunctionDef",
            "name": "send_data",
            "md_content": "",
            "code_start_line": 173,
            "code_end_line": 195,
            "parent": "ReplayServer",
            "have_return": false,
            "code_content": "    async def send_data(self):\n        \"\"\"\n        send data to client\n        \"\"\"\n        \n        rows = InteractionCRUD.search_many_raws(db=self.db, interaction_id=self.client_id)\n        for row in rows:\n            self.logger.typewriter_log(\n                title=f\"Send data to {self.client_id}: \",\n                title_color=Fore.RED,\n                content=f\"Send {row.node_id}data to client, length: {len(json.dumps(row.data))}.\"\n            )\n            root_dir = os.path.join(XAgentServerEnv.base_dir, \"localstorage\", \"interact_records\", row.create_time[:10], row.interaction_id)\n            await self.websocket.send_text(\n                WebsocketResponseBody(status=row.status,\n                                    success=True, message=\"success\",\n                                    data=handle_data(row=row, root_dir=root_dir),\n                                    current=row.current,\n                                    node_id=row.node_id,\n                                    workspace_file_list=handle_workspace_filelist(row.file_list)).to_text())\n            # await asyncio.sleep(random.randint(1, 3))\n        if self.scheduler.running:\n            self.scheduler.shutdown()",
            "name_column": 14
        }
    },
    "XAgentServer/application/websockets/recorder.py": {
        "RecorderServer": {
            "type": "ClassDef",
            "name": "RecorderServer",
            "md_content": "",
            "code_start_line": 36,
            "code_end_line": 326,
            "parent": null,
            "have_return": true,
            "code_content": "class RecorderServer(WebSocketEndpoint):\n    \"\"\"Recorder Websocket Server\n    Extends:\n        WebSocketEndpoint\n    \n    Recorder:\n        You can use this to reproduce the recorder you have executed\n        You can find this in XAgent GUI Menu: Settings -> Run Recorder\n\n    \"\"\"\n\n    def __init__(self, websocket: WebSocket, db: Session = Depends(get_db), client_id: str = \"\"):\n        super().__init__(websocket.scope, websocket.receive, websocket.send)\n        self.db = db\n        self.client_id: str = client_id\n        self.websocket = websocket\n        self.date_str = datetime.now().strftime(\"%Y-%m-%d\")\n        self.log_dir = \"\"\n        self.logger = None\n        self.scheduler = AsyncIOScheduler()\n        self.continue_flag = True\n\n    async def dispatch(self) -> None:\n        \"\"\"XAgent Websocket Server Dispatch Function\n        extend from WebSocketEndpoint\n\n        override this function block: loop flag and finally block to do something\n        Raises:\n            exc: extend from WebSocketEndpoint\n        \"\"\"\n        websocket = WebSocket(self.scope, receive=self.receive, send=self.send)\n        close_code = 1000\n        await self.on_connect(websocket)\n        redis.set_key(f\"{self.client_id}\", \"alive\")\n        try:\n            while self.continue_flag:\n                message = await websocket.receive()\n                if message[\"type\"] == \"websocket.receive\":\n                    data = await self.decode(websocket, message)\n                    await self.on_receive(websocket, data)\n                elif message[\"type\"] == \"websocket.disconnect\":\n                    close_code = 1000\n                    break\n        except Exception as exc:\n            close_code = 1011\n            raise exc\n        finally:\n            try:\n                await self.on_disconnect(websocket, close_code)\n                if self.scheduler.running:\n                    self.scheduler.shutdown()\n                    self.logger.info(\"shutdown scheduler\")\n                if self.db:\n                    self.db.close()\n                    self.logger.info(\"close db\")\n            finally:\n                # this is notice the agent to stop if user close the websocket\n                redis.set_key(f\"{self.client_id}\", \"close\")\n\n    async def on_connect(self, websocket: WebSocket):\n        \"\"\"Connect to client\n\n        Args:\n            websocket (WebSocket): A websocket object\n\n        Raises:\n            XAgentWebSocketConnectError: If you have an interaction running, \n            you can't connect to XAgent\n        \"\"\"\n\n        self.log_dir = os.path.join(os.path.join(XAgentServerEnv.base_dir, \"localstorage\",\n                                    \"interact_records\"), self.date_str, self.client_id)\n        if not os.path.exists(self.log_dir):\n            os.makedirs(self.log_dir)\n\n        self.logger = Logger(\n            log_dir=self.log_dir, log_file=\"interact.log\", log_name=f\"{self.client_id}_INTERACT\")\n        query_string = self.scope.get(\"query_string\", b\"\").decode()\n        parameters = parse_qs(query_string)\n        user_id = parameters.get(\"user_id\", [\"\"])[0]\n        token = parameters.get(\"token\", [\"\"])[0]\n        recorder_dir = parameters.get(\"recorder_dir\", [\"\"])[0]\n        description = \"XAgent Recorder\"\n        self.logger.typewriter_log(\n            title=f\"Receive connection from {self.client_id}: \",\n            title_color=Fore.RED,\n            content=f\"user_id: {user_id}, token: {token}, recorder_dir: {recorder_dir}\")\n        await websocket.accept()\n        try:\n            await check_user(db=self.db, user_id=user_id, token=token)\n            # check running, you can edit it by yourself in envs.py to skip this check\n            if XAgentServerEnv.check_running:\n                if InteractionCRUD.is_running(db=self.db, user_id=user_id):\n                    raise XAgentWebSocketConnectError(\n                        \"You have a running interaction, please wait for it to finish!\")\n\n            base = InteractionBase(interaction_id=self.client_id,\n                                user_id=user_id,\n                                create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                                description=description if description else \"XAgent Recorder\",\n                                agent=\"XAgent\",\n                                mode=\"auto\",\n                                file_list=[],\n                                recorder_root_dir=os.path.join(\n                                    XAgentServerEnv.recorder_root_dir, recorder_dir),\n                                status=\"waiting\",\n                                message=\"waiting...\",\n                                current_step=uuid.uuid4().hex,\n                                update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                                call_method=\"recorder\",\n                                )\n            InteractionCRUD.create_interaction(db=self.db, base=base)\n        except XAgentWebSocketConnectError as e:\n            self.logger.error(\n                f\"Error in on_connect of {self.client_id}: {e}\")\n            await websocket.send_text(\n                WebsocketResponseBody(\n                    status=\"failed\",\n                    success=False,\n                    message=str(e),\n                    data=None).to_text())\n            await websocket.close(code=1000)\n            return\n        await websocket.send_text(\n            WebsocketResponseBody(\n                status=\"connect\",\n                success=True,\n                message=\"connect success\",\n                data=base.to_dict()).to_text())\n\n    async def on_disconnect(self, websocket: WebSocket, close_code):\n        \"\"\"When disconnect with client, it will run this function\n        Override this function to do something when disconnect with client\n\n        Args:\n            websocket (WebSocket): A websocket object\n            close_code (_type_): The close code, default is 0\n        \"\"\"\n        self.logger.typewriter_log(\n            title=f\"Disconnect with client {self.client_id}: \",\n            title_color=Fore.RED)\n        # await websocket.close(code=close_code)\n\n    async def on_receive(self, websocket: WebSocket, data: Any):\n        \"\"\"\n        When receive data from client, it will run this function\n        \n        Args:\n            websocket (WebSocket): A websocket object\n            data (any): The data from client\n        \"\"\"\n        data = json.loads(data)\n        self.logger.typewriter_log(\n            title=f\"Receive data from {self.client_id}: \",\n            title_color=Fore.RED,\n            content=json.dumps(data, indent=4, ensure_ascii=False)\n        )\n        if data.get(\"type\", \"\") == \"ping\":\n            # await self.pong()\n            pass\n        elif data.get(\"type\", \"\") == \"recorder\":\n            if not self.scheduler.running:\n                self.scheduler.add_job(self.pong, \"interval\", seconds=20)\n                self.scheduler.add_job(self.send_data, \"interval\", seconds=1)\n                self.scheduler.start()\n                t = threading.Thread(target=self.task_handler)\n                t.start()\n\n\n    def task_handler(self):\n        \"\"\"\n        define a long task to run interaction\n        \n        Args:\n            parameter (InteractionParameter): The parameter of interaction\n        \"\"\"\n        try:\n            InteractionCRUD.insert_raw(db=self.db, process=XAgentRaw(\n                interaction_id=self.client_id,\n                node_id=uuid.uuid4().hex,\n                status=StatusEnum.RUNNING,\n                create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                current=\"\",\n                step=-1,\n                data=None,\n                file_list=[],\n                do_interrupt=False,\n                wait_seconds=0,\n                ask_for_human_help=False,\n                is_human=True,\n                human_data=None,\n                human_file_list=[],\n                is_send=False,\n                is_receive=False,\n                is_deleted=False\n            ))\n            redis.set_key(f\"{self.client_id}_send\", 1)\n\n            current_step = uuid.uuid4().hex\n            base = InteractionCRUD.get_interaction(db=self.db,\n                                                interaction_id=self.client_id)\n            InteractionCRUD.update_interaction_status(db=self.db,\n                                                    interaction_id=base.interaction_id,\n                                                    status=\"running\",\n                                                    message=\"running\",\n                                                    current_step=current_step)\n\n            # Create XAgentInteraction to run interaction\n            interaction = XAgentInteraction(\n                base=base, parameter=None, interrupt=False, call_method=\"recorder\")\n\n            # Register logger, dbinto interaction\n            interaction.resister_logger(self.logger)\n            self.logger.info(\n                f\"Register logger into interaction of {base.interaction_id}, done!\")\n\n            interaction.register_db(db=self.db)\n            self.logger.info(\n                f\"Register db into interaction of {base.interaction_id}, done!\")\n            # Create XAgentServer\n            server = XAgentServer(logger=self.logger)\n            self.logger.info(\n                f\"Register logger into XAgentServer of {base.interaction_id}, done!\")\n            self.logger.info(\n                f\"Start a new thread to run interaction of {base.interaction_id}, done!\")\n            # await server.interact(interaction=interaction)\n            server.interact(interaction=interaction)\n        except XAgentError as e:\n            self.logger.error(\n                f\"Error in task_handler of {self.client_id}: {e}\")\n            InteractionCRUD.insert_error(\n                db=self.db, interaction_id=self.client_id, message=str(e))\n            redis.set_key(self.client_id + \"_send\", 1)\n            InteractionCRUD.update_interaction_status(db=self.db,\n                                                      interaction_id=self.client_id,\n                                                      status=\"failed\",\n                                                      message=str(e),\n                                                      current_step=current_step)\n\n    async def pong(self):\n        \"\"\"\n        pong to client for keeping alive\n        \"\"\"\n        await self.websocket.send_text(json.dumps({\"type\": \"pong\"}, ensure_ascii=False, indent=2))\n\n    async def send_data(self):\n        \"\"\"\n        send data to client\n        \"\"\"\n        send_status = redis.get_key(f\"{self.client_id}_send\")\n        if send_status:\n            rows = InteractionCRUD.get_next_send(\n                db=self.db, interaction_id=self.client_id)\n            rows = rows[::-1]\n            for row in rows:\n                if not row.is_send:\n                    self.logger.typewriter_log(\n                        title=f\"Send data to {self.client_id}: \",\n                        title_color=Fore.RED,\n                        content=f\"Send {row.node_id}data to client, length: {len(json.dumps(row.data))}.\"\n                    )\n                    if row.status in [StatusEnum.FAILED]:\n                        # when interaction is falied, we will send the message to client\n                        # and the message is the result of interaction\n                        message = row.data\n                    else:\n                        message = \"success\"\n\n                    root_dir = os.path.join(XAgentServerEnv.base_dir,\n                                            \"localstorage\",\n                                            \"interact_records\",\n                                            row.create_time[:10],\n                                            row.interaction_id)\n                    await self.websocket.send_text(\n                        WebsocketResponseBody(\n                            status=row.status,\n                            success=True, message=message,\n                            data=handle_data(row=row, root_dir=root_dir),\n                            current=row.current,\n                            node_id=row.node_id,\n                            workspace_file_list=handle_workspace_filelist(\n                                row.file_list)\n                        ).to_text())\n                    InteractionCRUD.update_send_flag(\n                        db=self.db, interaction_id=self.client_id, node_id=row.node_id)\n                    redis.delete_key(f\"{self.client_id}_send\")\n\n                    if row.status in [StatusEnum.FAILED, StatusEnum.FINISHED]:\n                        self.continue_flag = False\n                        break\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 47,
            "code_end_line": 56,
            "parent": "RecorderServer",
            "have_return": false,
            "code_content": "    def __init__(self, websocket: WebSocket, db: Session = Depends(get_db), client_id: str = \"\"):\n        super().__init__(websocket.scope, websocket.receive, websocket.send)\n        self.db = db\n        self.client_id: str = client_id\n        self.websocket = websocket\n        self.date_str = datetime.now().strftime(\"%Y-%m-%d\")\n        self.log_dir = \"\"\n        self.logger = None\n        self.scheduler = AsyncIOScheduler()\n        self.continue_flag = True\n",
            "name_column": 8
        },
        "dispatch": {
            "type": "AsyncFunctionDef",
            "name": "dispatch",
            "md_content": "",
            "code_start_line": 58,
            "code_end_line": 93,
            "parent": "RecorderServer",
            "have_return": false,
            "code_content": "    async def dispatch(self) -> None:\n        \"\"\"XAgent Websocket Server Dispatch Function\n        extend from WebSocketEndpoint\n\n        override this function block: loop flag and finally block to do something\n        Raises:\n            exc: extend from WebSocketEndpoint\n        \"\"\"\n        websocket = WebSocket(self.scope, receive=self.receive, send=self.send)\n        close_code = 1000\n        await self.on_connect(websocket)\n        redis.set_key(f\"{self.client_id}\", \"alive\")\n        try:\n            while self.continue_flag:\n                message = await websocket.receive()\n                if message[\"type\"] == \"websocket.receive\":\n                    data = await self.decode(websocket, message)\n                    await self.on_receive(websocket, data)\n                elif message[\"type\"] == \"websocket.disconnect\":\n                    close_code = 1000\n                    break\n        except Exception as exc:\n            close_code = 1011\n            raise exc\n        finally:\n            try:\n                await self.on_disconnect(websocket, close_code)\n                if self.scheduler.running:\n                    self.scheduler.shutdown()\n                    self.logger.info(\"shutdown scheduler\")\n                if self.db:\n                    self.db.close()\n                    self.logger.info(\"close db\")\n            finally:\n                # this is notice the agent to stop if user close the websocket\n                redis.set_key(f\"{self.client_id}\", \"close\")\n",
            "name_column": 14
        },
        "on_connect": {
            "type": "AsyncFunctionDef",
            "name": "on_connect",
            "md_content": "",
            "code_start_line": 95,
            "code_end_line": 164,
            "parent": "RecorderServer",
            "have_return": true,
            "code_content": "    async def on_connect(self, websocket: WebSocket):\n        \"\"\"Connect to client\n\n        Args:\n            websocket (WebSocket): A websocket object\n\n        Raises:\n            XAgentWebSocketConnectError: If you have an interaction running, \n            you can't connect to XAgent\n        \"\"\"\n\n        self.log_dir = os.path.join(os.path.join(XAgentServerEnv.base_dir, \"localstorage\",\n                                    \"interact_records\"), self.date_str, self.client_id)\n        if not os.path.exists(self.log_dir):\n            os.makedirs(self.log_dir)\n\n        self.logger = Logger(\n            log_dir=self.log_dir, log_file=\"interact.log\", log_name=f\"{self.client_id}_INTERACT\")\n        query_string = self.scope.get(\"query_string\", b\"\").decode()\n        parameters = parse_qs(query_string)\n        user_id = parameters.get(\"user_id\", [\"\"])[0]\n        token = parameters.get(\"token\", [\"\"])[0]\n        recorder_dir = parameters.get(\"recorder_dir\", [\"\"])[0]\n        description = \"XAgent Recorder\"\n        self.logger.typewriter_log(\n            title=f\"Receive connection from {self.client_id}: \",\n            title_color=Fore.RED,\n            content=f\"user_id: {user_id}, token: {token}, recorder_dir: {recorder_dir}\")\n        await websocket.accept()\n        try:\n            await check_user(db=self.db, user_id=user_id, token=token)\n            # check running, you can edit it by yourself in envs.py to skip this check\n            if XAgentServerEnv.check_running:\n                if InteractionCRUD.is_running(db=self.db, user_id=user_id):\n                    raise XAgentWebSocketConnectError(\n                        \"You have a running interaction, please wait for it to finish!\")\n\n            base = InteractionBase(interaction_id=self.client_id,\n                                user_id=user_id,\n                                create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                                description=description if description else \"XAgent Recorder\",\n                                agent=\"XAgent\",\n                                mode=\"auto\",\n                                file_list=[],\n                                recorder_root_dir=os.path.join(\n                                    XAgentServerEnv.recorder_root_dir, recorder_dir),\n                                status=\"waiting\",\n                                message=\"waiting...\",\n                                current_step=uuid.uuid4().hex,\n                                update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                                call_method=\"recorder\",\n                                )\n            InteractionCRUD.create_interaction(db=self.db, base=base)\n        except XAgentWebSocketConnectError as e:\n            self.logger.error(\n                f\"Error in on_connect of {self.client_id}: {e}\")\n            await websocket.send_text(\n                WebsocketResponseBody(\n                    status=\"failed\",\n                    success=False,\n                    message=str(e),\n                    data=None).to_text())\n            await websocket.close(code=1000)\n            return\n        await websocket.send_text(\n            WebsocketResponseBody(\n                status=\"connect\",\n                success=True,\n                message=\"connect success\",\n                data=base.to_dict()).to_text())\n",
            "name_column": 14
        },
        "on_disconnect": {
            "type": "AsyncFunctionDef",
            "name": "on_disconnect",
            "md_content": "",
            "code_start_line": 166,
            "code_end_line": 176,
            "parent": "RecorderServer",
            "have_return": false,
            "code_content": "    async def on_disconnect(self, websocket: WebSocket, close_code):\n        \"\"\"When disconnect with client, it will run this function\n        Override this function to do something when disconnect with client\n\n        Args:\n            websocket (WebSocket): A websocket object\n            close_code (_type_): The close code, default is 0\n        \"\"\"\n        self.logger.typewriter_log(\n            title=f\"Disconnect with client {self.client_id}: \",\n            title_color=Fore.RED)\n",
            "name_column": 14
        },
        "on_receive": {
            "type": "AsyncFunctionDef",
            "name": "on_receive",
            "md_content": "",
            "code_start_line": 179,
            "code_end_line": 202,
            "parent": "RecorderServer",
            "have_return": false,
            "code_content": "    async def on_receive(self, websocket: WebSocket, data: Any):\n        \"\"\"\n        When receive data from client, it will run this function\n        \n        Args:\n            websocket (WebSocket): A websocket object\n            data (any): The data from client\n        \"\"\"\n        data = json.loads(data)\n        self.logger.typewriter_log(\n            title=f\"Receive data from {self.client_id}: \",\n            title_color=Fore.RED,\n            content=json.dumps(data, indent=4, ensure_ascii=False)\n        )\n        if data.get(\"type\", \"\") == \"ping\":\n            # await self.pong()\n            pass\n        elif data.get(\"type\", \"\") == \"recorder\":\n            if not self.scheduler.running:\n                self.scheduler.add_job(self.pong, \"interval\", seconds=20)\n                self.scheduler.add_job(self.send_data, \"interval\", seconds=1)\n                self.scheduler.start()\n                t = threading.Thread(target=self.task_handler)\n                t.start()\n",
            "name_column": 14
        },
        "task_handler": {
            "type": "FunctionDef",
            "name": "task_handler",
            "md_content": "",
            "code_start_line": 205,
            "code_end_line": 274,
            "parent": "RecorderServer",
            "have_return": false,
            "code_content": "    def task_handler(self):\n        \"\"\"\n        define a long task to run interaction\n        \n        Args:\n            parameter (InteractionParameter): The parameter of interaction\n        \"\"\"\n        try:\n            InteractionCRUD.insert_raw(db=self.db, process=XAgentRaw(\n                interaction_id=self.client_id,\n                node_id=uuid.uuid4().hex,\n                status=StatusEnum.RUNNING,\n                create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                current=\"\",\n                step=-1,\n                data=None,\n                file_list=[],\n                do_interrupt=False,\n                wait_seconds=0,\n                ask_for_human_help=False,\n                is_human=True,\n                human_data=None,\n                human_file_list=[],\n                is_send=False,\n                is_receive=False,\n                is_deleted=False\n            ))\n            redis.set_key(f\"{self.client_id}_send\", 1)\n\n            current_step = uuid.uuid4().hex\n            base = InteractionCRUD.get_interaction(db=self.db,\n                                                interaction_id=self.client_id)\n            InteractionCRUD.update_interaction_status(db=self.db,\n                                                    interaction_id=base.interaction_id,\n                                                    status=\"running\",\n                                                    message=\"running\",\n                                                    current_step=current_step)\n\n            # Create XAgentInteraction to run interaction\n            interaction = XAgentInteraction(\n                base=base, parameter=None, interrupt=False, call_method=\"recorder\")\n\n            # Register logger, dbinto interaction\n            interaction.resister_logger(self.logger)\n            self.logger.info(\n                f\"Register logger into interaction of {base.interaction_id}, done!\")\n\n            interaction.register_db(db=self.db)\n            self.logger.info(\n                f\"Register db into interaction of {base.interaction_id}, done!\")\n            # Create XAgentServer\n            server = XAgentServer(logger=self.logger)\n            self.logger.info(\n                f\"Register logger into XAgentServer of {base.interaction_id}, done!\")\n            self.logger.info(\n                f\"Start a new thread to run interaction of {base.interaction_id}, done!\")\n            # await server.interact(interaction=interaction)\n            server.interact(interaction=interaction)\n        except XAgentError as e:\n            self.logger.error(\n                f\"Error in task_handler of {self.client_id}: {e}\")\n            InteractionCRUD.insert_error(\n                db=self.db, interaction_id=self.client_id, message=str(e))\n            redis.set_key(self.client_id + \"_send\", 1)\n            InteractionCRUD.update_interaction_status(db=self.db,\n                                                      interaction_id=self.client_id,\n                                                      status=\"failed\",\n                                                      message=str(e),\n                                                      current_step=current_step)\n",
            "name_column": 8
        },
        "pong": {
            "type": "AsyncFunctionDef",
            "name": "pong",
            "md_content": "",
            "code_start_line": 276,
            "code_end_line": 280,
            "parent": "RecorderServer",
            "have_return": false,
            "code_content": "    async def pong(self):\n        \"\"\"\n        pong to client for keeping alive\n        \"\"\"\n        await self.websocket.send_text(json.dumps({\"type\": \"pong\"}, ensure_ascii=False, indent=2))\n",
            "name_column": 14
        },
        "send_data": {
            "type": "AsyncFunctionDef",
            "name": "send_data",
            "md_content": "",
            "code_start_line": 282,
            "code_end_line": 326,
            "parent": "RecorderServer",
            "have_return": false,
            "code_content": "    async def send_data(self):\n        \"\"\"\n        send data to client\n        \"\"\"\n        send_status = redis.get_key(f\"{self.client_id}_send\")\n        if send_status:\n            rows = InteractionCRUD.get_next_send(\n                db=self.db, interaction_id=self.client_id)\n            rows = rows[::-1]\n            for row in rows:\n                if not row.is_send:\n                    self.logger.typewriter_log(\n                        title=f\"Send data to {self.client_id}: \",\n                        title_color=Fore.RED,\n                        content=f\"Send {row.node_id}data to client, length: {len(json.dumps(row.data))}.\"\n                    )\n                    if row.status in [StatusEnum.FAILED]:\n                        # when interaction is falied, we will send the message to client\n                        # and the message is the result of interaction\n                        message = row.data\n                    else:\n                        message = \"success\"\n\n                    root_dir = os.path.join(XAgentServerEnv.base_dir,\n                                            \"localstorage\",\n                                            \"interact_records\",\n                                            row.create_time[:10],\n                                            row.interaction_id)\n                    await self.websocket.send_text(\n                        WebsocketResponseBody(\n                            status=row.status,\n                            success=True, message=message,\n                            data=handle_data(row=row, root_dir=root_dir),\n                            current=row.current,\n                            node_id=row.node_id,\n                            workspace_file_list=handle_workspace_filelist(\n                                row.file_list)\n                        ).to_text())\n                    InteractionCRUD.update_send_flag(\n                        db=self.db, interaction_id=self.client_id, node_id=row.node_id)\n                    redis.delete_key(f\"{self.client_id}_send\")\n\n                    if row.status in [StatusEnum.FAILED, StatusEnum.FINISHED]:\n                        self.continue_flag = False\n                        break\n",
            "name_column": 14
        }
    },
    "XAgentServer/application/websockets/__init__.py": {},
    "XAgentServer/application/websockets/common.py": {
        "check_user": {
            "type": "AsyncFunctionDef",
            "name": "check_user",
            "md_content": "",
            "code_start_line": 9,
            "code_end_line": 22,
            "parent": null,
            "have_return": false,
            "code_content": "async def check_user(db, user_id, token):\n    \"\"\"\n    check user for websocket connection\n    \"\"\"\n    if not UserCRUD.is_exist(db=db, user_id=user_id):\n        raise XAgentWebSocketConnectError(\"user is not exist!\")\n    # auth\n    if not UserCRUD.user_is_valid(db=db, user_id=user_id, token=token):\n        raise XAgentWebSocketConnectError(\"user is not available!\")\n\n    user = UserCRUD.get_user(db=db, user_id=user_id)\n    if not user or user.token != token or user.available is False or user.is_beta is False:\n        raise XAgentWebSocketConnectError(\n            \"XAgentServer is running in production mode, if you want to use it, please contact the administrator.\")\n",
            "name_column": 10
        },
        "handle_data": {
            "type": "FunctionDef",
            "name": "handle_data",
            "md_content": "",
            "code_start_line": 24,
            "code_end_line": 65,
            "parent": null,
            "have_return": true,
            "code_content": "def handle_data(row: Raw, root_dir: str):\n    \"\"\"\n    handle data for websocket response\n    \"\"\"\n    data = row.data\n    try:\n        using_tools = data.get(\"using_tools\", \"\")\n        if not using_tools:\n            return data\n        tool_name = using_tools.get(\"tool_name\", \"\") if isinstance(\n            using_tools, dict) else \"\"\n        tool_output = using_tools.get(\n            \"tool_output\", {}) if isinstance(using_tools, dict) else \"\"\n        tool_input = using_tools.get(\n            \"tool_input\", {}) if isinstance(using_tools, dict) else \"\"\n        if row.include_pictures:\n            if tool_name == \"PythonNotebook_execute_cell\":\n                for output in tool_output:\n                    if isinstance(output, dict) and 'file_name' in output:\n                        file_name = output['file_name']\n                        png_base64 = None\n                        if file_name:\n                            file_path = os.path.join(\n                                root_dir, \"workspace\", file_name)\n                            if os.path.exists(file_path):\n                                try:\n                                    with open(file_path, \"rb\") as f:\n                                        png_base64 = base64.b64encode(\n                                            f.read()).decode(\"utf-8\")\n                                except Exception:\n                                    pass\n\n                        output[\"file_data\"] = png_base64\n                        using_tools[\"is_include_pictures\"] = True\n    \n        if tool_input:\n            data[\"using_tools\"][\"tool_input\"] = tool_input.encode(\"utf-8\").decode(\"unicode_escape\")\n        if tool_output and isinstance(tool_output, str):\n            data[\"using_tools\"][\"tool_output\"] = tool_output.encode(\"utf-8\").decode(\"unicode_escape\")\n    except Exception:\n        pass\n    return data\n",
            "name_column": 4
        },
        "handle_workspace_filelist": {
            "type": "FunctionDef",
            "name": "handle_workspace_filelist",
            "md_content": "",
            "code_start_line": 68,
            "code_end_line": 79,
            "parent": null,
            "have_return": true,
            "code_content": "def handle_workspace_filelist(file_list):\n    \"\"\"handle workspace file list\n\n    Args:\n        file_list (_type_): file_list is a list of file name\n\n    Returns:\n        List[Dict]: element list, each element is a dict with name and suffix\n    \"\"\"\n    if not isinstance(file_list, list) or not file_list:\n        return []\n    return [{\"name\": file, \"suffix\": file.split(\".\")[-1]}  for file in file_list]\n",
            "name_column": 4
        }
    },
    "XAgentServer/application/websockets/share.py": {
        "ReplayServer": {
            "type": "ClassDef",
            "name": "ReplayServer",
            "md_content": "",
            "code_start_line": 29,
            "code_end_line": 198,
            "parent": null,
            "have_return": true,
            "code_content": "class ReplayServer(WebSocketEndpoint):\n    \"\"\"Main Websocket Server\n    Extends:\n        WebSocketEndpoint\n    \n    Description:\n        In this websocket, we will receive the args from user,\n        and you can use it to run the interaction.\n        specifically, the args is a dict, \n        and it must contain a key named \"goal\" to tell XAgent what do you want to do.\n\n    \"\"\"\n\n    def __init__(self, websocket: WebSocket, db: Session = Depends(get_db), client_id: str = \"\"):\n        super().__init__(websocket.scope, websocket.receive, websocket.send)\n        self.db = db\n        self.client_id: str = client_id\n        self.websocket = websocket\n        self.date_str = datetime.now().strftime(\"%Y-%m-%d\")\n        self.log_dir = \"\"\n        self.logger = None\n        self.scheduler = AsyncIOScheduler()\n        \n    async def dispatch(self) -> None:\n        \"\"\"_summary_\n\n        Raises:\n            exc: _description_\n        \"\"\"\n        websocket = WebSocket(self.scope, receive=self.receive, send=self.send)\n        close_code = 1000\n        await self.on_connect(websocket)\n        try:\n            while True:\n                message = await websocket.receive()\n                if message[\"type\"] == \"websocket.receive\":\n                    data = await self.decode(websocket, message)\n                    await self.on_receive(websocket, data)\n                elif message[\"type\"] == \"websocket.disconnect\":\n                    close_code = 1000\n                    break\n        except Exception as exc:\n            close_code = 1011\n            raise exc\n        finally:\n            await self.on_disconnect(websocket, close_code)\n            if self.scheduler.running:\n                self.scheduler.shutdown()\n                self.logger.info(\"shutdown scheduler\")\n            if self.db:\n                self.db.close()\n                self.logger.info(\"close db\")\n            \n    async def on_connect(self, websocket: WebSocket):\n        \"\"\"Connect to client\n\n        Args:\n            websocket (WebSocket): A websocket object\n\n        Raises:\n            XAgentWebSocketConnectError: If the user is running, it will raise this error.\n        \"\"\"\n        \n        self.log_dir = os.path.join(os.path.join(XAgentServerEnv.base_dir, \"localstorage\",\n                                    \"interact_records\"), self.date_str, self.client_id)\n        if not os.path.exists(self.log_dir):\n            os.makedirs(self.log_dir)\n\n        self.logger = Logger(\n            log_dir=self.log_dir, log_file=\"share.log\", log_name=f\"{self.client_id}_SHARE\")\n        query_string = self.scope.get(\"query_string\", b\"\").decode()\n        parameters = parse_qs(query_string)\n        user_id = parameters.get(\"user_id\", [\"\"])[0]\n        token = parameters.get(\"token\", [\"\"])[0]\n        self.logger.typewriter_log(\n            title=f\"Receive connection from {self.client_id}: \",\n            title_color=Fore.RED,\n            content=f\"user_id: {user_id}, token: {token}\")\n        await websocket.accept()\n        try:\n            # await check_user(db=self.db, user_id=user_id, token=token)\n            # check running, you can edit it by yourself in envs.py to skip this check\n            if XAgentServerEnv.check_running:\n                if InteractionCRUD.is_running(db=self.db, user_id=user_id):\n                    raise XAgentWebSocketConnectError(\n                        \"You have a running interaction, please wait for it to finish!\")\n        except XAgentWebSocketConnectError as exc:\n            await websocket.send_text(\n                WebsocketResponseBody(\n                    status=\"connect\",\n                    success=False,\n                    message=str(exc),\n                    data=None).to_text())\n            await websocket.close(code=1000)\n            return\n        await websocket.send_text(\n            WebsocketResponseBody(\n                status=\"connect\",\n                success=True,\n                message=\"connect success\",\n                data=None).to_text())\n\n    async def on_disconnect(self, websocket: WebSocket, close_code):\n        \"\"\"When disconnect with client, it will run this function\n        Override this function to do something when disconnect with client\n        \n        Args:\n            websocket (WebSocket): A websocket object\n            close_code (_type_): The close code, default is 0\n        \"\"\"\n        self.logger.typewriter_log(\n            title=f\"Disconnect with client {self.client_id}: \",\n            title_color=Fore.RED)\n        \n\n    async def on_receive(self, websocket: WebSocket, data: Any):\n        \"\"\"\n        When receive data from client, it will run this function\n        \n        Args:\n            websocket (WebSocket): A websocket object\n            data (any): The data from client\n        \"\"\"\n        data = json.loads(data)\n        self.logger.typewriter_log(\n            title=f\"Receive data from {self.client_id}: \",\n            title_color=Fore.RED,\n            content=json.dumps(data, indent=4, ensure_ascii=False)\n        )\n        if data.get(\"type\", \"\") == \"ping\":\n            # await self.pong()\n            pass\n        elif data.get(\"type\", \"\") == \"shared\":\n            if not self.scheduler.running:\n                self.scheduler.add_job(self.pong, \"interval\", seconds=20)\n                self.scheduler.add_job(self.send_data, \"date\", next_run_time=datetime.now())\n                self.scheduler.start()\n                 \n    async def pong(self):\n        \"\"\"\n        pong to client for keeping alive\n        \"\"\"\n        await self.websocket.send_text(json.dumps({\"type\": \"pong\"}, ensure_ascii=False, indent=2))\n\n    async def send_data(self):\n        \"\"\"\n        send data to client\n        \"\"\"\n        try:\n            rows = InteractionCRUD.search_many_raws(db=self.db, interaction_id=self.client_id)\n            for row in rows:\n                self.logger.typewriter_log(\n                    title=f\"Send data to {self.client_id}: \",\n                    title_color=Fore.RED,\n                    content=f\"Send {row.node_id}data to client, length: {len(json.dumps(row.data))}.\"\n                )\n                root_dir = os.path.join(XAgentServerEnv.base_dir, \"localstorage\", \"interact_records\", row.create_time[:10], row.interaction_id)\n                await self.websocket.send_text(\n                    WebsocketResponseBody(status=row.status,\n                                        success=True, message=\"success\",\n                                        data=handle_data(row=row, root_dir=root_dir),\n                                        current=row.current,\n                                        node_id=row.node_id,\n                                        workspace_file_list=handle_workspace_filelist(row.file_list)).to_text())\n                await asyncio.sleep(random.randint(1, 3))\n            if self.scheduler.running:\n                self.scheduler.shutdown()\n        except:\n            if self.scheduler.running:\n                self.scheduler.shutdown()",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 42,
            "code_end_line": 50,
            "parent": "ReplayServer",
            "have_return": false,
            "code_content": "    def __init__(self, websocket: WebSocket, db: Session = Depends(get_db), client_id: str = \"\"):\n        super().__init__(websocket.scope, websocket.receive, websocket.send)\n        self.db = db\n        self.client_id: str = client_id\n        self.websocket = websocket\n        self.date_str = datetime.now().strftime(\"%Y-%m-%d\")\n        self.log_dir = \"\"\n        self.logger = None\n        self.scheduler = AsyncIOScheduler()\n",
            "name_column": 8
        },
        "dispatch": {
            "type": "AsyncFunctionDef",
            "name": "dispatch",
            "md_content": "",
            "code_start_line": 52,
            "code_end_line": 80,
            "parent": "ReplayServer",
            "have_return": false,
            "code_content": "    async def dispatch(self) -> None:\n        \"\"\"_summary_\n\n        Raises:\n            exc: _description_\n        \"\"\"\n        websocket = WebSocket(self.scope, receive=self.receive, send=self.send)\n        close_code = 1000\n        await self.on_connect(websocket)\n        try:\n            while True:\n                message = await websocket.receive()\n                if message[\"type\"] == \"websocket.receive\":\n                    data = await self.decode(websocket, message)\n                    await self.on_receive(websocket, data)\n                elif message[\"type\"] == \"websocket.disconnect\":\n                    close_code = 1000\n                    break\n        except Exception as exc:\n            close_code = 1011\n            raise exc\n        finally:\n            await self.on_disconnect(websocket, close_code)\n            if self.scheduler.running:\n                self.scheduler.shutdown()\n                self.logger.info(\"shutdown scheduler\")\n            if self.db:\n                self.db.close()\n                self.logger.info(\"close db\")\n",
            "name_column": 14
        },
        "on_connect": {
            "type": "AsyncFunctionDef",
            "name": "on_connect",
            "md_content": "",
            "code_start_line": 82,
            "code_end_line": 129,
            "parent": "ReplayServer",
            "have_return": true,
            "code_content": "    async def on_connect(self, websocket: WebSocket):\n        \"\"\"Connect to client\n\n        Args:\n            websocket (WebSocket): A websocket object\n\n        Raises:\n            XAgentWebSocketConnectError: If the user is running, it will raise this error.\n        \"\"\"\n        \n        self.log_dir = os.path.join(os.path.join(XAgentServerEnv.base_dir, \"localstorage\",\n                                    \"interact_records\"), self.date_str, self.client_id)\n        if not os.path.exists(self.log_dir):\n            os.makedirs(self.log_dir)\n\n        self.logger = Logger(\n            log_dir=self.log_dir, log_file=\"share.log\", log_name=f\"{self.client_id}_SHARE\")\n        query_string = self.scope.get(\"query_string\", b\"\").decode()\n        parameters = parse_qs(query_string)\n        user_id = parameters.get(\"user_id\", [\"\"])[0]\n        token = parameters.get(\"token\", [\"\"])[0]\n        self.logger.typewriter_log(\n            title=f\"Receive connection from {self.client_id}: \",\n            title_color=Fore.RED,\n            content=f\"user_id: {user_id}, token: {token}\")\n        await websocket.accept()\n        try:\n            # await check_user(db=self.db, user_id=user_id, token=token)\n            # check running, you can edit it by yourself in envs.py to skip this check\n            if XAgentServerEnv.check_running:\n                if InteractionCRUD.is_running(db=self.db, user_id=user_id):\n                    raise XAgentWebSocketConnectError(\n                        \"You have a running interaction, please wait for it to finish!\")\n        except XAgentWebSocketConnectError as exc:\n            await websocket.send_text(\n                WebsocketResponseBody(\n                    status=\"connect\",\n                    success=False,\n                    message=str(exc),\n                    data=None).to_text())\n            await websocket.close(code=1000)\n            return\n        await websocket.send_text(\n            WebsocketResponseBody(\n                status=\"connect\",\n                success=True,\n                message=\"connect success\",\n                data=None).to_text())\n",
            "name_column": 14
        },
        "on_disconnect": {
            "type": "AsyncFunctionDef",
            "name": "on_disconnect",
            "md_content": "",
            "code_start_line": 131,
            "code_end_line": 141,
            "parent": "ReplayServer",
            "have_return": false,
            "code_content": "    async def on_disconnect(self, websocket: WebSocket, close_code):\n        \"\"\"When disconnect with client, it will run this function\n        Override this function to do something when disconnect with client\n        \n        Args:\n            websocket (WebSocket): A websocket object\n            close_code (_type_): The close code, default is 0\n        \"\"\"\n        self.logger.typewriter_log(\n            title=f\"Disconnect with client {self.client_id}: \",\n            title_color=Fore.RED)\n",
            "name_column": 14
        },
        "on_receive": {
            "type": "AsyncFunctionDef",
            "name": "on_receive",
            "md_content": "",
            "code_start_line": 144,
            "code_end_line": 165,
            "parent": "ReplayServer",
            "have_return": false,
            "code_content": "    async def on_receive(self, websocket: WebSocket, data: Any):\n        \"\"\"\n        When receive data from client, it will run this function\n        \n        Args:\n            websocket (WebSocket): A websocket object\n            data (any): The data from client\n        \"\"\"\n        data = json.loads(data)\n        self.logger.typewriter_log(\n            title=f\"Receive data from {self.client_id}: \",\n            title_color=Fore.RED,\n            content=json.dumps(data, indent=4, ensure_ascii=False)\n        )\n        if data.get(\"type\", \"\") == \"ping\":\n            # await self.pong()\n            pass\n        elif data.get(\"type\", \"\") == \"shared\":\n            if not self.scheduler.running:\n                self.scheduler.add_job(self.pong, \"interval\", seconds=20)\n                self.scheduler.add_job(self.send_data, \"date\", next_run_time=datetime.now())\n                self.scheduler.start()\n",
            "name_column": 14
        },
        "pong": {
            "type": "AsyncFunctionDef",
            "name": "pong",
            "md_content": "",
            "code_start_line": 167,
            "code_end_line": 171,
            "parent": "ReplayServer",
            "have_return": false,
            "code_content": "    async def pong(self):\n        \"\"\"\n        pong to client for keeping alive\n        \"\"\"\n        await self.websocket.send_text(json.dumps({\"type\": \"pong\"}, ensure_ascii=False, indent=2))\n",
            "name_column": 14
        },
        "send_data": {
            "type": "AsyncFunctionDef",
            "name": "send_data",
            "md_content": "",
            "code_start_line": 173,
            "code_end_line": 198,
            "parent": "ReplayServer",
            "have_return": false,
            "code_content": "    async def send_data(self):\n        \"\"\"\n        send data to client\n        \"\"\"\n        try:\n            rows = InteractionCRUD.search_many_raws(db=self.db, interaction_id=self.client_id)\n            for row in rows:\n                self.logger.typewriter_log(\n                    title=f\"Send data to {self.client_id}: \",\n                    title_color=Fore.RED,\n                    content=f\"Send {row.node_id}data to client, length: {len(json.dumps(row.data))}.\"\n                )\n                root_dir = os.path.join(XAgentServerEnv.base_dir, \"localstorage\", \"interact_records\", row.create_time[:10], row.interaction_id)\n                await self.websocket.send_text(\n                    WebsocketResponseBody(status=row.status,\n                                        success=True, message=\"success\",\n                                        data=handle_data(row=row, root_dir=root_dir),\n                                        current=row.current,\n                                        node_id=row.node_id,\n                                        workspace_file_list=handle_workspace_filelist(row.file_list)).to_text())\n                await asyncio.sleep(random.randint(1, 3))\n            if self.scheduler.running:\n                self.scheduler.shutdown()\n        except:\n            if self.scheduler.running:\n                self.scheduler.shutdown()",
            "name_column": 14
        }
    },
    "XAgentServer/application/websockets/base.py": {
        "MainServer": {
            "type": "ClassDef",
            "name": "MainServer",
            "md_content": "",
            "code_start_line": 57,
            "code_end_line": 390,
            "parent": null,
            "have_return": true,
            "code_content": "class MainServer(WebSocketEndpoint):\n    \"\"\"Main Websocket Server\n    Extends:\n        WebSocketEndpoint\n\n    Description:\n        In this websocket, we will receive the args from user,\n        and you can use it to run the interaction.\n        specifically, the args is a dict, \n        and it must contain a key named \"goal\" to tell XAgent what do you want to do.\n\n    \"\"\"\n\n    def __init__(self, websocket: WebSocket, db: Session = Depends(get_db), client_id: str = \"\"):\n        super().__init__(websocket.scope, websocket.receive, websocket.send)\n        self.db = db\n        self.client_id: str = client_id\n        self.websocket = websocket\n        self.date_str = datetime.now().strftime(\"%Y-%m-%d\")\n        self.log_dir = \"\"\n        self.logger = None\n        self.scheduler = AsyncIOScheduler()\n        self.continue_flag = True\n\n    async def dispatch(self) -> None:\n        \"\"\"XAgent Websocket Server Dispatch Function\n        extend from WebSocketEndpoint\n\n        override this function block: loop flag and finally block to do something\n        Raises:\n            exc: extend from WebSocketEndpoint\n        \"\"\"\n        websocket = WebSocket(self.scope, receive=self.receive, send=self.send)\n        close_code = 1000\n        await self.on_connect(websocket)\n        redis.set_key(f\"{self.client_id}\", \"alive\")\n        try:\n            while self.continue_flag:\n                message = await websocket.receive()\n                if message[\"type\"] == \"websocket.receive\":\n                    data = await self.decode(websocket, message)\n                    await self.on_receive(websocket, data)\n                elif message[\"type\"] == \"websocket.disconnect\":\n                    close_code = 1000\n                    break\n        except Exception as exc:\n            close_code = 1011\n            raise exc\n        finally:\n            interaction = InteractionCRUD.get_interaction(\n                db=self.db, interaction_id=self.client_id)\n            if interaction.status not in [StatusEnum.FINISHED, StatusEnum.FAILED]:\n                InteractionCRUD.update_interaction_status(db=self.db,\n                                                          interaction_id=self.client_id,\n                                                          status=StatusEnum.CLOSED,\n                                                          message=\"closed\",\n                                                          current_step=\"0\")\n            try:\n                await self.on_disconnect(websocket, close_code)\n                if self.scheduler.running:\n                    self.scheduler.shutdown()\n                    self.logger.info(\"shutdown scheduler\")\n                if self.db:\n                    self.db.close()\n                    self.logger.info(\"close db\")\n            finally:\n                # notice the agent stop if user close the websocket\n                redis.set_key(f\"{self.client_id}\", \"close\")\n\n    async def on_connect(self, websocket: WebSocket):\n        \"\"\"Connect to client\n\n        Args:\n            websocket (WebSocket): A websocket object\n\n        Raises:\n            XAgentWebSocketConnectError: If the user is running, it will raise this error.\n        \"\"\"\n\n        self.log_dir = os.path.join(os.path.join(XAgentServerEnv.base_dir, \"localstorage\",\n                                    \"interact_records\"), self.date_str, self.client_id)\n        if not os.path.exists(self.log_dir):\n            os.makedirs(self.log_dir)\n\n        self.logger = Logger(\n            log_dir=self.log_dir, log_file=\"interact.log\", log_name=f\"{self.client_id}_INTERACT\")\n        query_string = self.scope.get(\"query_string\", b\"\").decode()\n        parameters = parse_qs(query_string)\n        user_id = parameters.get(\"user_id\", [\"\"])[0]\n        token = parameters.get(\"token\", [\"\"])[0]\n        description = parameters.get(\"description\", [\"\"])[0]\n        self.logger.typewriter_log(\n            title=f\"Receive connection from {self.client_id}: \",\n            title_color=Fore.RED,\n            content=f\"user_id: {user_id}, token: {token}, description: {description}\")\n        await websocket.accept()\n        try:\n            await check_user(db=self.db, user_id=user_id, token=token)\n            # check running, you can edit it by yourself in envs.py to skip this check\n            if XAgentServerEnv.check_running:\n                if InteractionCRUD.is_running(db=self.db, user_id=user_id):\n                    raise XAgentWebSocketConnectError(\n                        \"You have a running interaction, please wait for it to finish!\")\n            base = InteractionCRUD.get_interaction(db=self.db,\n                                                   interaction_id=self.client_id)\n            if base is None:\n                raise XAgentWebSocketConnectError(\n                    \"init interaction failed, please restart!\")\n\n            InteractionCRUD.update_interaction(db=self.db,\n                                               base_data={\n                                                   \"interaction_id\": self.client_id,\n                                                   \"status\": \"connected\",\n                                                   \"message\": \"connected\",\n                                                   \"current_step\": \"0\",\n                                                   \"description\": description}\n                                               )\n\n        except XAgentWebSocketConnectError as e:\n            self.logger.error(\n                f\"Error in on_connect of {self.client_id}: {e}\")\n            await websocket.send_text(\n                WebsocketResponseBody(\n                    status=\"connect\",\n                    success=False,\n                    message=str(e),\n                    data=None).to_text())\n            await websocket.close(code=1000)\n            return\n        await websocket.send_text(\n            WebsocketResponseBody(\n                status=\"connect\",\n                success=True,\n                message=\"connect success\",\n                data=base.to_dict()).to_text())\n\n    async def on_disconnect(self, websocket: WebSocket, close_code):\n        \"\"\"When disconnect with client, it will run this function\n        Override this function to do something when disconnect with client\n\n        Args:\n            websocket (WebSocket): A websocket object\n            close_code (_type_): The close code, default is 0\n        \"\"\"\n        self.logger.typewriter_log(\n            title=f\"Disconnect with client {self.client_id}: \",\n            title_color=Fore.RED)\n        # await websocket.close(code=close_code)\n\n    async def on_receive(self, websocket: WebSocket, data: Any):\n        \"\"\"\n        When receive data from client, it will run this function\n\n        Args:\n            websocket (WebSocket): A websocket object\n            data (any): The data from client\n        \"\"\"\n        data = json.loads(data)\n        if data.get(\"type\", \"\") != \"ping\":\n            self.logger.typewriter_log(\n                title=f\"Receive data from {self.client_id}: \",\n                title_color=Fore.RED,\n                content=json.dumps(data, indent=4, ensure_ascii=False)\n            )\n        if data.get(\"type\", \"\") == \"data\":\n            args = data.get(\"args\", {})\n            agent = data.get(\"agent\", \"\")\n            mode = data.get(\"mode\", \"\")\n            file_list = data.get(\"file_list\", [])\n            node_id = data.get(\"node_id\", \"\")\n            parameter = InteractionParameter(\n                interaction_id=self.client_id,\n                parameter_id=uuid.uuid4().hex,\n                args=args,\n            )\n            InteractionCRUD.add_parameter(db=self.db, parameter=parameter)\n\n            if node_id:\n                InteractionCRUD.update_human_data(\n                    db=self.db, interaction_id=self.client_id, node_id=node_id, human_data=args)\n                redis.set_key(f\"{self.client_id}_{node_id}_receive\", 1)\n\n            else:\n                InteractionCRUD.update_interaction(db=self.db,\n                                                   base_data={\n                                                       \"interaction_id\": self.client_id,\n                                                       \"agent\": agent,\n                                                       \"mode\": mode,\n                                                       \"file_list\": file_list,\n                                                       \"create_time\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")}\n                                                   )\n                # Create a new raw data to record\n                InteractionCRUD.insert_raw(db=self.db, process=XAgentRaw(\n                    interaction_id=self.client_id,\n                    node_id=uuid.uuid4().hex,\n                    status=StatusEnum.RUNNING,\n                    create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                    update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                    current=\"\",\n                    step=-1,\n                    data=None,\n                    file_list=[],\n                    do_interrupt=mode != \"auto\",\n                    wait_seconds=0,\n                    ask_for_human_help=False,\n                    is_human=True,\n                    human_data=args,\n                    human_file_list=file_list,\n                    is_send=False,\n                    is_receive=False,\n                    is_deleted=False\n                ))\n                redis.set_key(f\"{self.client_id}_send\", 1)\n\n            if not self.scheduler.running:\n                # add pong job to scheduler\n                self.scheduler.add_job(self.pong, \"interval\", seconds=20)\n                # add send data job to scheduler\n                self.scheduler.add_job(self.send_data, \"interval\", seconds=1)\n                self.scheduler.start()\n\n                # start a new thread to run interaction\n                t = threading.Thread(\n                    target=self.task_handler, args=(parameter,))\n                t.start()\n\n    def task_handler(self, parameter: InteractionParameter):\n        \"\"\"\n        define a long task to run interaction\n\n        Args:\n            parameter (InteractionParameter): The parameter of interaction\n        \"\"\"\n\n        try:\n            current_step = uuid.uuid4().hex\n            base = InteractionCRUD.get_interaction(db=self.db,\n                                                   interaction_id=self.client_id)\n            InteractionCRUD.update_interaction_status(db=self.db,\n                                                      interaction_id=base.interaction_id,\n                                                      status=\"running\",\n                                                      message=\"running\",\n                                                      current_step=current_step)\n\n            # if mode is not auto, we will interrupt the interaction\n            # and you can change the wait_seconds\n            # default 10 min.\n            interaction = XAgentInteraction(\n                base=base,\n                parameter=parameter,\n                interrupt=base.mode != \"auto\")\n\n            # Register logger, dbinto interaction\n            interaction.resister_logger(self.logger)\n            self.logger.info(\n                f\"Register logger into interaction of {base.interaction_id}, done!\")\n\n            interaction.register_db(db=self.db)\n            self.logger.info(\n                f\"Register db into interaction of {base.interaction_id}, done!\")\n            # Create XAgentServer\n            server = XAgentServer(logger=self.logger)\n            self.logger.info(\n                f\"Register logger into XAgentServer of {base.interaction_id}, done!\")\n            self.logger.info(\n                f\"Start a new thread to run interaction of {base.interaction_id}, done!\")\n            # await server.interact(interaction=interaction)\n            server.interact(interaction=interaction)\n        except XAgentError as e:\n            traceback.print_exc()\n            self.logger.error(\n                f\"Error in task_handler of {self.client_id}: {e}\")\n            InteractionCRUD.insert_error(\n                db=self.db, interaction_id=self.client_id, message=str(e))\n            redis.set_key(self.client_id + \"_send\", 1)\n            InteractionCRUD.update_interaction_status(db=self.db,\n                                                      interaction_id=self.client_id,\n                                                      status=\"failed\",\n                                                      message=str(e),\n                                                      current_step=current_step)\n\n    async def pong(self):\n        \"\"\"\n        pong to client for keeping alive\n        \"\"\"\n        await self.websocket.send_text(json.dumps({\"type\": \"pong\"}, ensure_ascii=False, indent=2))\n\n    async def send_data(self):\n        \"\"\"\n        send data to client\n        \"\"\"\n        send_status = redis.get_key(f\"{self.client_id}_send\")\n        try:\n            if send_status:\n                rows = InteractionCRUD.get_next_send(\n                    db=self.db, interaction_id=self.client_id)\n                rows = rows[::-1]\n                for row in rows:\n                    if not row.is_send:\n                        self.logger.typewriter_log(\n                            title=f\"Send data to {self.client_id}: \",\n                            title_color=Fore.RED,\n                            content=f\"Send {row.node_id}data to client, length: {len(json.dumps(row.data))}.\"\n                        )\n                        if row.status in [StatusEnum.FAILED]:\n                            # when interaction is falied, we will send the message to client\n                            # and the message is the result of interaction\n                            message = row.data\n                        else:\n                            message = \"success\"\n\n                        await self.websocket.send_text(\n                            WebsocketResponseBody(\n                                status=row.status,\n                                success=True, message=message,\n                                data=handle_data(row=row, root_dir=self.log_dir),\n                                current=row.current,\n                                node_id=row.node_id,\n                                workspace_file_list=handle_workspace_filelist(\n                                    row.file_list)\n                            ).to_text())\n                        InteractionCRUD.update_send_flag(\n                            db=self.db, interaction_id=self.client_id, node_id=row.node_id)\n                        redis.delete_key(f\"{self.client_id}_send\")\n\n                        if row.status in [StatusEnum.FAILED, StatusEnum.FINISHED]:\n                            self.continue_flag = False\n                            break\n        except Exception as e:\n            self.logger.error(\n                f\"Error in send_data of {self.client_id}: {e}\")\n            traceback.print_exc()\n            self.continue_flag = False\n            raise XAgentError(e) from e",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 70,
            "code_end_line": 79,
            "parent": "MainServer",
            "have_return": false,
            "code_content": "    def __init__(self, websocket: WebSocket, db: Session = Depends(get_db), client_id: str = \"\"):\n        super().__init__(websocket.scope, websocket.receive, websocket.send)\n        self.db = db\n        self.client_id: str = client_id\n        self.websocket = websocket\n        self.date_str = datetime.now().strftime(\"%Y-%m-%d\")\n        self.log_dir = \"\"\n        self.logger = None\n        self.scheduler = AsyncIOScheduler()\n        self.continue_flag = True\n",
            "name_column": 8
        },
        "dispatch": {
            "type": "AsyncFunctionDef",
            "name": "dispatch",
            "md_content": "",
            "code_start_line": 81,
            "code_end_line": 124,
            "parent": "MainServer",
            "have_return": false,
            "code_content": "    async def dispatch(self) -> None:\n        \"\"\"XAgent Websocket Server Dispatch Function\n        extend from WebSocketEndpoint\n\n        override this function block: loop flag and finally block to do something\n        Raises:\n            exc: extend from WebSocketEndpoint\n        \"\"\"\n        websocket = WebSocket(self.scope, receive=self.receive, send=self.send)\n        close_code = 1000\n        await self.on_connect(websocket)\n        redis.set_key(f\"{self.client_id}\", \"alive\")\n        try:\n            while self.continue_flag:\n                message = await websocket.receive()\n                if message[\"type\"] == \"websocket.receive\":\n                    data = await self.decode(websocket, message)\n                    await self.on_receive(websocket, data)\n                elif message[\"type\"] == \"websocket.disconnect\":\n                    close_code = 1000\n                    break\n        except Exception as exc:\n            close_code = 1011\n            raise exc\n        finally:\n            interaction = InteractionCRUD.get_interaction(\n                db=self.db, interaction_id=self.client_id)\n            if interaction.status not in [StatusEnum.FINISHED, StatusEnum.FAILED]:\n                InteractionCRUD.update_interaction_status(db=self.db,\n                                                          interaction_id=self.client_id,\n                                                          status=StatusEnum.CLOSED,\n                                                          message=\"closed\",\n                                                          current_step=\"0\")\n            try:\n                await self.on_disconnect(websocket, close_code)\n                if self.scheduler.running:\n                    self.scheduler.shutdown()\n                    self.logger.info(\"shutdown scheduler\")\n                if self.db:\n                    self.db.close()\n                    self.logger.info(\"close db\")\n            finally:\n                # notice the agent stop if user close the websocket\n                redis.set_key(f\"{self.client_id}\", \"close\")\n",
            "name_column": 14
        },
        "on_connect": {
            "type": "AsyncFunctionDef",
            "name": "on_connect",
            "md_content": "",
            "code_start_line": 126,
            "code_end_line": 191,
            "parent": "MainServer",
            "have_return": true,
            "code_content": "    async def on_connect(self, websocket: WebSocket):\n        \"\"\"Connect to client\n\n        Args:\n            websocket (WebSocket): A websocket object\n\n        Raises:\n            XAgentWebSocketConnectError: If the user is running, it will raise this error.\n        \"\"\"\n\n        self.log_dir = os.path.join(os.path.join(XAgentServerEnv.base_dir, \"localstorage\",\n                                    \"interact_records\"), self.date_str, self.client_id)\n        if not os.path.exists(self.log_dir):\n            os.makedirs(self.log_dir)\n\n        self.logger = Logger(\n            log_dir=self.log_dir, log_file=\"interact.log\", log_name=f\"{self.client_id}_INTERACT\")\n        query_string = self.scope.get(\"query_string\", b\"\").decode()\n        parameters = parse_qs(query_string)\n        user_id = parameters.get(\"user_id\", [\"\"])[0]\n        token = parameters.get(\"token\", [\"\"])[0]\n        description = parameters.get(\"description\", [\"\"])[0]\n        self.logger.typewriter_log(\n            title=f\"Receive connection from {self.client_id}: \",\n            title_color=Fore.RED,\n            content=f\"user_id: {user_id}, token: {token}, description: {description}\")\n        await websocket.accept()\n        try:\n            await check_user(db=self.db, user_id=user_id, token=token)\n            # check running, you can edit it by yourself in envs.py to skip this check\n            if XAgentServerEnv.check_running:\n                if InteractionCRUD.is_running(db=self.db, user_id=user_id):\n                    raise XAgentWebSocketConnectError(\n                        \"You have a running interaction, please wait for it to finish!\")\n            base = InteractionCRUD.get_interaction(db=self.db,\n                                                   interaction_id=self.client_id)\n            if base is None:\n                raise XAgentWebSocketConnectError(\n                    \"init interaction failed, please restart!\")\n\n            InteractionCRUD.update_interaction(db=self.db,\n                                               base_data={\n                                                   \"interaction_id\": self.client_id,\n                                                   \"status\": \"connected\",\n                                                   \"message\": \"connected\",\n                                                   \"current_step\": \"0\",\n                                                   \"description\": description}\n                                               )\n\n        except XAgentWebSocketConnectError as e:\n            self.logger.error(\n                f\"Error in on_connect of {self.client_id}: {e}\")\n            await websocket.send_text(\n                WebsocketResponseBody(\n                    status=\"connect\",\n                    success=False,\n                    message=str(e),\n                    data=None).to_text())\n            await websocket.close(code=1000)\n            return\n        await websocket.send_text(\n            WebsocketResponseBody(\n                status=\"connect\",\n                success=True,\n                message=\"connect success\",\n                data=base.to_dict()).to_text())\n",
            "name_column": 14
        },
        "on_disconnect": {
            "type": "AsyncFunctionDef",
            "name": "on_disconnect",
            "md_content": "",
            "code_start_line": 193,
            "code_end_line": 203,
            "parent": "MainServer",
            "have_return": false,
            "code_content": "    async def on_disconnect(self, websocket: WebSocket, close_code):\n        \"\"\"When disconnect with client, it will run this function\n        Override this function to do something when disconnect with client\n\n        Args:\n            websocket (WebSocket): A websocket object\n            close_code (_type_): The close code, default is 0\n        \"\"\"\n        self.logger.typewriter_log(\n            title=f\"Disconnect with client {self.client_id}: \",\n            title_color=Fore.RED)\n",
            "name_column": 14
        },
        "on_receive": {
            "type": "AsyncFunctionDef",
            "name": "on_receive",
            "md_content": "",
            "code_start_line": 206,
            "code_end_line": 281,
            "parent": "MainServer",
            "have_return": false,
            "code_content": "    async def on_receive(self, websocket: WebSocket, data: Any):\n        \"\"\"\n        When receive data from client, it will run this function\n\n        Args:\n            websocket (WebSocket): A websocket object\n            data (any): The data from client\n        \"\"\"\n        data = json.loads(data)\n        if data.get(\"type\", \"\") != \"ping\":\n            self.logger.typewriter_log(\n                title=f\"Receive data from {self.client_id}: \",\n                title_color=Fore.RED,\n                content=json.dumps(data, indent=4, ensure_ascii=False)\n            )\n        if data.get(\"type\", \"\") == \"data\":\n            args = data.get(\"args\", {})\n            agent = data.get(\"agent\", \"\")\n            mode = data.get(\"mode\", \"\")\n            file_list = data.get(\"file_list\", [])\n            node_id = data.get(\"node_id\", \"\")\n            parameter = InteractionParameter(\n                interaction_id=self.client_id,\n                parameter_id=uuid.uuid4().hex,\n                args=args,\n            )\n            InteractionCRUD.add_parameter(db=self.db, parameter=parameter)\n\n            if node_id:\n                InteractionCRUD.update_human_data(\n                    db=self.db, interaction_id=self.client_id, node_id=node_id, human_data=args)\n                redis.set_key(f\"{self.client_id}_{node_id}_receive\", 1)\n\n            else:\n                InteractionCRUD.update_interaction(db=self.db,\n                                                   base_data={\n                                                       \"interaction_id\": self.client_id,\n                                                       \"agent\": agent,\n                                                       \"mode\": mode,\n                                                       \"file_list\": file_list,\n                                                       \"create_time\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")}\n                                                   )\n                # Create a new raw data to record\n                InteractionCRUD.insert_raw(db=self.db, process=XAgentRaw(\n                    interaction_id=self.client_id,\n                    node_id=uuid.uuid4().hex,\n                    status=StatusEnum.RUNNING,\n                    create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                    update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                    current=\"\",\n                    step=-1,\n                    data=None,\n                    file_list=[],\n                    do_interrupt=mode != \"auto\",\n                    wait_seconds=0,\n                    ask_for_human_help=False,\n                    is_human=True,\n                    human_data=args,\n                    human_file_list=file_list,\n                    is_send=False,\n                    is_receive=False,\n                    is_deleted=False\n                ))\n                redis.set_key(f\"{self.client_id}_send\", 1)\n\n            if not self.scheduler.running:\n                # add pong job to scheduler\n                self.scheduler.add_job(self.pong, \"interval\", seconds=20)\n                # add send data job to scheduler\n                self.scheduler.add_job(self.send_data, \"interval\", seconds=1)\n                self.scheduler.start()\n\n                # start a new thread to run interaction\n                t = threading.Thread(\n                    target=self.task_handler, args=(parameter,))\n                t.start()\n",
            "name_column": 14
        },
        "task_handler": {
            "type": "FunctionDef",
            "name": "task_handler",
            "md_content": "",
            "code_start_line": 283,
            "code_end_line": 336,
            "parent": "MainServer",
            "have_return": false,
            "code_content": "    def task_handler(self, parameter: InteractionParameter):\n        \"\"\"\n        define a long task to run interaction\n\n        Args:\n            parameter (InteractionParameter): The parameter of interaction\n        \"\"\"\n\n        try:\n            current_step = uuid.uuid4().hex\n            base = InteractionCRUD.get_interaction(db=self.db,\n                                                   interaction_id=self.client_id)\n            InteractionCRUD.update_interaction_status(db=self.db,\n                                                      interaction_id=base.interaction_id,\n                                                      status=\"running\",\n                                                      message=\"running\",\n                                                      current_step=current_step)\n\n            # if mode is not auto, we will interrupt the interaction\n            # and you can change the wait_seconds\n            # default 10 min.\n            interaction = XAgentInteraction(\n                base=base,\n                parameter=parameter,\n                interrupt=base.mode != \"auto\")\n\n            # Register logger, dbinto interaction\n            interaction.resister_logger(self.logger)\n            self.logger.info(\n                f\"Register logger into interaction of {base.interaction_id}, done!\")\n\n            interaction.register_db(db=self.db)\n            self.logger.info(\n                f\"Register db into interaction of {base.interaction_id}, done!\")\n            # Create XAgentServer\n            server = XAgentServer(logger=self.logger)\n            self.logger.info(\n                f\"Register logger into XAgentServer of {base.interaction_id}, done!\")\n            self.logger.info(\n                f\"Start a new thread to run interaction of {base.interaction_id}, done!\")\n            # await server.interact(interaction=interaction)\n            server.interact(interaction=interaction)\n        except XAgentError as e:\n            traceback.print_exc()\n            self.logger.error(\n                f\"Error in task_handler of {self.client_id}: {e}\")\n            InteractionCRUD.insert_error(\n                db=self.db, interaction_id=self.client_id, message=str(e))\n            redis.set_key(self.client_id + \"_send\", 1)\n            InteractionCRUD.update_interaction_status(db=self.db,\n                                                      interaction_id=self.client_id,\n                                                      status=\"failed\",\n                                                      message=str(e),\n                                                      current_step=current_step)\n",
            "name_column": 8
        },
        "pong": {
            "type": "AsyncFunctionDef",
            "name": "pong",
            "md_content": "",
            "code_start_line": 338,
            "code_end_line": 342,
            "parent": "MainServer",
            "have_return": false,
            "code_content": "    async def pong(self):\n        \"\"\"\n        pong to client for keeping alive\n        \"\"\"\n        await self.websocket.send_text(json.dumps({\"type\": \"pong\"}, ensure_ascii=False, indent=2))\n",
            "name_column": 14
        },
        "send_data": {
            "type": "AsyncFunctionDef",
            "name": "send_data",
            "md_content": "",
            "code_start_line": 344,
            "code_end_line": 390,
            "parent": "MainServer",
            "have_return": false,
            "code_content": "    async def send_data(self):\n        \"\"\"\n        send data to client\n        \"\"\"\n        send_status = redis.get_key(f\"{self.client_id}_send\")\n        try:\n            if send_status:\n                rows = InteractionCRUD.get_next_send(\n                    db=self.db, interaction_id=self.client_id)\n                rows = rows[::-1]\n                for row in rows:\n                    if not row.is_send:\n                        self.logger.typewriter_log(\n                            title=f\"Send data to {self.client_id}: \",\n                            title_color=Fore.RED,\n                            content=f\"Send {row.node_id}data to client, length: {len(json.dumps(row.data))}.\"\n                        )\n                        if row.status in [StatusEnum.FAILED]:\n                            # when interaction is falied, we will send the message to client\n                            # and the message is the result of interaction\n                            message = row.data\n                        else:\n                            message = \"success\"\n\n                        await self.websocket.send_text(\n                            WebsocketResponseBody(\n                                status=row.status,\n                                success=True, message=message,\n                                data=handle_data(row=row, root_dir=self.log_dir),\n                                current=row.current,\n                                node_id=row.node_id,\n                                workspace_file_list=handle_workspace_filelist(\n                                    row.file_list)\n                            ).to_text())\n                        InteractionCRUD.update_send_flag(\n                            db=self.db, interaction_id=self.client_id, node_id=row.node_id)\n                        redis.delete_key(f\"{self.client_id}_send\")\n\n                        if row.status in [StatusEnum.FAILED, StatusEnum.FINISHED]:\n                            self.continue_flag = False\n                            break\n        except Exception as e:\n            self.logger.error(\n                f\"Error in send_data of {self.client_id}: {e}\")\n            traceback.print_exc()\n            self.continue_flag = False\n            raise XAgentError(e) from e",
            "name_column": 14
        }
    },
    "XAgentServer/application/schemas/response_body.py": {
        "ResponseBody": {
            "type": "ClassDef",
            "name": "ResponseBody",
            "md_content": "",
            "code_start_line": 8,
            "code_end_line": 23,
            "parent": null,
            "have_return": true,
            "code_content": "class ResponseBody(BaseModel):\n    \"\"\"Response body\n    \"\"\"\n    data: Union[str, dict, list, Json, None] = None\n    success: bool = True\n    message: Union[str, None] = None\n\n    def to_dict(self):\n        \"\"\"to dict\n        \"\"\"\n        return self.dict()\n\n    def to_json(self):\n        \"\"\"to json\n        \"\"\"\n        return self.json()\n",
            "name_column": 6
        },
        "WebsocketResponseBody": {
            "type": "ClassDef",
            "name": "WebsocketResponseBody",
            "md_content": "",
            "code_start_line": 26,
            "code_end_line": 62,
            "parent": null,
            "have_return": true,
            "code_content": "class WebsocketResponseBody():\n    r\"\"\"\n    WerSocket 返回值对象\n\n    Attributes:\n        data: 返回的数据\n\n        status: 状态\n\n        message: 消息\n\n        kwargs: 其他参数, 会被添加到返回值中\n    \"\"\"\n\n    def __init__(self,\n                 data: Union[str, dict, list, Json, None],\n                 status: str = \"success\",\n                 message: Union[str, None] = None,\n                 **kwargs):\n        self.data = data\n        self.status = status\n        self.message = message\n        self.extend(kwargs)\n\n    def to_text(self):\n        r\"\"\"\n        返回json格式的字符串\n        \"\"\"\n\n        return json.dumps(self.__dict__, ensure_ascii=False, indent=2)\n\n    def extend(self, extend: dict):\n        \"\"\"extend attributes\n        \"\"\"\n        for key, value in extend.items():\n            if key not in self.__dict__.keys():\n                self.__dict__[key] = value\n",
            "name_column": 6
        },
        "to_dict": {
            "type": "FunctionDef",
            "name": "to_dict",
            "md_content": "",
            "code_start_line": 15,
            "code_end_line": 18,
            "parent": "ResponseBody",
            "have_return": true,
            "code_content": "    def to_dict(self):\n        \"\"\"to dict\n        \"\"\"\n        return self.dict()\n",
            "name_column": 8
        },
        "to_json": {
            "type": "FunctionDef",
            "name": "to_json",
            "md_content": "",
            "code_start_line": 20,
            "code_end_line": 23,
            "parent": "ResponseBody",
            "have_return": true,
            "code_content": "    def to_json(self):\n        \"\"\"to json\n        \"\"\"\n        return self.json()\n",
            "name_column": 8
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 40,
            "code_end_line": 48,
            "parent": "WebsocketResponseBody",
            "have_return": false,
            "code_content": "    def __init__(self,\n                 data: Union[str, dict, list, Json, None],\n                 status: str = \"success\",\n                 message: Union[str, None] = None,\n                 **kwargs):\n        self.data = data\n        self.status = status\n        self.message = message\n        self.extend(kwargs)\n",
            "name_column": 8
        },
        "to_text": {
            "type": "FunctionDef",
            "name": "to_text",
            "md_content": "",
            "code_start_line": 50,
            "code_end_line": 55,
            "parent": "WebsocketResponseBody",
            "have_return": true,
            "code_content": "    def to_text(self):\n        r\"\"\"\n        返回json格式的字符串\n        \"\"\"\n\n        return json.dumps(self.__dict__, ensure_ascii=False, indent=2)\n",
            "name_column": 8
        },
        "extend": {
            "type": "FunctionDef",
            "name": "extend",
            "md_content": "",
            "code_start_line": 57,
            "code_end_line": 62,
            "parent": "WebsocketResponseBody",
            "have_return": false,
            "code_content": "    def extend(self, extend: dict):\n        \"\"\"extend attributes\n        \"\"\"\n        for key, value in extend.items():\n            if key not in self.__dict__.keys():\n                self.__dict__[key] = value\n",
            "name_column": 8
        }
    },
    "XAgentServer/application/schemas/request_body.py": {
        "RequestBody": {
            "type": "ClassDef",
            "name": "RequestBody",
            "md_content": "",
            "code_start_line": 7,
            "code_end_line": 12,
            "parent": null,
            "have_return": false,
            "code_content": "class RequestBody(BaseModel):\n    \"\"\"RequestBody\n    \"\"\"\n    token: str\n    query: str\n    mode: str\n",
            "name_column": 6
        }
    },
    "XAgentServer/application/cruds/user.py": {
        "UserCRUD": {
            "type": "ClassDef",
            "name": "UserCRUD",
            "md_content": "",
            "code_start_line": 11,
            "code_end_line": 152,
            "parent": null,
            "have_return": true,
            "code_content": "class UserCRUD(metaclass=abc.ABCMeta):\n    \"\"\"\n    User CRUD\n    \"\"\"\n\n    @classmethod\n    def get_user_list(cls, db: Session) -> list[XAgentUser]:\n        \"\"\"\n        get all users\n        \n        Args:\n            db: database session\n        \"\"\"\n        try:\n            return UserDBInterface.get_user_list(db=db)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [User Module]: {str(e)}\") from e\n\n    @classmethod\n    def get_user(cls,\n                 db: Session,\n                 user_id: str | None = None,\n                 email: str | None = None) -> XAgentUser | None:\n        \"\"\"\n        get user by user_id or email\n        \n        Args:\n            db: database session\n            user_id: user_id\n            email: email\n        \n        Returns:\n            user\n        \n        \"\"\"\n        try:\n            return UserDBInterface.get_user(db=db, user_id=user_id, email=email)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [User Module]: {str(e)}\") from e\n\n    @classmethod\n    def is_exist(cls,\n                 db: Session,\n                 user_id: str | None = None,\n                 email: str | None = None):\n        \"\"\"\n        check user is exist\n        \n        Args:\n            db: database session\n            user_id: user_id\n            email: email\n            \n        Returns:\n            bool\n\n        \"\"\"\n        try:\n            return UserDBInterface.is_exist(db=db, user_id=user_id, email=email)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [User Module]: {str(e)}\") from e\n\n    @classmethod\n    def token_is_exist(cls,\n                       db: Session,\n                       user_id: str,\n                       token: str | None = None):\n        \"\"\"\n        check token is exist\n        \n        Args:\n            db: database session\n            user_id: user_id\n            token: token\n            \n        Returns:\n            bool\n\n        \"\"\"\n        try:\n            return UserDBInterface.token_is_exist(db=db, user_id=user_id, token=token)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [User Module]: {str(e)}\") from e\n\n    @classmethod\n    def user_is_valid(cls, db: Session,\n                      user_id: str | None = None,\n                      email: str | None = None,\n                      token: str | None = None):\n        \"\"\"\n        check user is valid\n        \n        Args:\n            db: database session\n            user_id: user_id\n            email: email\n            token: token\n            \n        Returns:\n            bool\n\n        \"\"\"\n        try:\n            return UserDBInterface.user_is_valid(db=db, user_id=user_id, email=email, token=token)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [User Module]: {str(e)}\") from e\n\n    @classmethod\n    def add_user(cls, db: Session, user_dict: dict):\n        \"\"\"\n        add user\n        \n        Args:\n            db: database session\n            user_dict: user dict\n            \n        Returns:\n            None\n\n        \"\"\"\n        try:\n            UserDBInterface.add_user(db=db, user_dict=user_dict)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [User Module]: {str(e)}\") from e\n\n    @classmethod\n    def update_user(cls, db: Session, user: XAgentUser):\n        \"\"\"\n        update user\n        \n        Args:\n            db: database session\n            user: user\n            \n        Returns:\n            None\n\n        \"\"\"\n        try:\n            UserDBInterface.update_user(db=db, user=user)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [User Module]: {str(e)}\") from e\n",
            "name_column": 6
        },
        "get_user_list": {
            "type": "FunctionDef",
            "name": "get_user_list",
            "md_content": "",
            "code_start_line": 17,
            "code_end_line": 27,
            "parent": "UserCRUD",
            "have_return": true,
            "code_content": "    def get_user_list(cls, db: Session) -> list[XAgentUser]:\n        \"\"\"\n        get all users\n        \n        Args:\n            db: database session\n        \"\"\"\n        try:\n            return UserDBInterface.get_user_list(db=db)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [User Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "get_user": {
            "type": "FunctionDef",
            "name": "get_user",
            "md_content": "",
            "code_start_line": 30,
            "code_end_line": 49,
            "parent": "UserCRUD",
            "have_return": true,
            "code_content": "    def get_user(cls,\n                 db: Session,\n                 user_id: str | None = None,\n                 email: str | None = None) -> XAgentUser | None:\n        \"\"\"\n        get user by user_id or email\n        \n        Args:\n            db: database session\n            user_id: user_id\n            email: email\n        \n        Returns:\n            user\n        \n        \"\"\"\n        try:\n            return UserDBInterface.get_user(db=db, user_id=user_id, email=email)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [User Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "is_exist": {
            "type": "FunctionDef",
            "name": "is_exist",
            "md_content": "",
            "code_start_line": 52,
            "code_end_line": 71,
            "parent": "UserCRUD",
            "have_return": true,
            "code_content": "    def is_exist(cls,\n                 db: Session,\n                 user_id: str | None = None,\n                 email: str | None = None):\n        \"\"\"\n        check user is exist\n        \n        Args:\n            db: database session\n            user_id: user_id\n            email: email\n            \n        Returns:\n            bool\n\n        \"\"\"\n        try:\n            return UserDBInterface.is_exist(db=db, user_id=user_id, email=email)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [User Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "token_is_exist": {
            "type": "FunctionDef",
            "name": "token_is_exist",
            "md_content": "",
            "code_start_line": 74,
            "code_end_line": 93,
            "parent": "UserCRUD",
            "have_return": true,
            "code_content": "    def token_is_exist(cls,\n                       db: Session,\n                       user_id: str,\n                       token: str | None = None):\n        \"\"\"\n        check token is exist\n        \n        Args:\n            db: database session\n            user_id: user_id\n            token: token\n            \n        Returns:\n            bool\n\n        \"\"\"\n        try:\n            return UserDBInterface.token_is_exist(db=db, user_id=user_id, token=token)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [User Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "user_is_valid": {
            "type": "FunctionDef",
            "name": "user_is_valid",
            "md_content": "",
            "code_start_line": 96,
            "code_end_line": 116,
            "parent": "UserCRUD",
            "have_return": true,
            "code_content": "    def user_is_valid(cls, db: Session,\n                      user_id: str | None = None,\n                      email: str | None = None,\n                      token: str | None = None):\n        \"\"\"\n        check user is valid\n        \n        Args:\n            db: database session\n            user_id: user_id\n            email: email\n            token: token\n            \n        Returns:\n            bool\n\n        \"\"\"\n        try:\n            return UserDBInterface.user_is_valid(db=db, user_id=user_id, email=email, token=token)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [User Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "add_user": {
            "type": "FunctionDef",
            "name": "add_user",
            "md_content": "",
            "code_start_line": 119,
            "code_end_line": 134,
            "parent": "UserCRUD",
            "have_return": false,
            "code_content": "    def add_user(cls, db: Session, user_dict: dict):\n        \"\"\"\n        add user\n        \n        Args:\n            db: database session\n            user_dict: user dict\n            \n        Returns:\n            None\n\n        \"\"\"\n        try:\n            UserDBInterface.add_user(db=db, user_dict=user_dict)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [User Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "update_user": {
            "type": "FunctionDef",
            "name": "update_user",
            "md_content": "",
            "code_start_line": 137,
            "code_end_line": 152,
            "parent": "UserCRUD",
            "have_return": false,
            "code_content": "    def update_user(cls, db: Session, user: XAgentUser):\n        \"\"\"\n        update user\n        \n        Args:\n            db: database session\n            user: user\n            \n        Returns:\n            None\n\n        \"\"\"\n        try:\n            UserDBInterface.update_user(db=db, user=user)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [User Module]: {str(e)}\") from e\n",
            "name_column": 8
        }
    },
    "XAgentServer/application/cruds/interaction.py": {
        "InteractionCRUD": {
            "type": "ClassDef",
            "name": "InteractionCRUD",
            "md_content": "",
            "code_start_line": 17,
            "code_end_line": 543,
            "parent": null,
            "have_return": true,
            "code_content": "class InteractionCRUD(metaclass=abc.ABCMeta):\n    \"\"\"\n    interaction crud\n    \"\"\"\n\n    @classmethod\n    def search_many_interaction(cls, db: Session) -> list:\n        \"\"\"\n        search many interaction\n        \"\"\"\n        try:\n            return InteractionDBInterface.search_many_interaction(db=db)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def get_interaction(cls, db: Session, interaction_id: str) -> InteractionBase | None:\n        \"\"\"\n        get interaction\n        Args:\n            db: db\n            interaction_id: interaction id\n        Returns:\n            interaction InteractionBase\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.get_interaction(db=db, interaction_id=interaction_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def create_interaction(cls, db: Session, base: InteractionBase):\n        \"\"\"\n        create interaction\n        Args:\n            db: db\n            base: base\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.create_interaction(db=db, base=base)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n        \n    @classmethod\n    def get_ready_interaction(cls, db: Session, user_id: str):\n        \"\"\"\n        create interaction\n        Args:\n            db: db\n            user_id: user_id\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.get_ready_interaction(db=db, user_id=user_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n\n    @classmethod\n    def add_parameter(cls, db: Session, parameter: InteractionParameter = None):\n        \"\"\"\n        add parameter\n        Args:\n            db: db\n            parameter: parameter\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.add_parameter(db=db, parameter=parameter)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def get_parameter(cls, db: Session, interaction_id: str) -> list:\n        \"\"\"\n        get parameter\n        Args:\n            db: db\n            interaction_id: interaction id\n        Returns:\n            parameter list [InteractionParameter]\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.get_parameter(db=db, interaction_id=interaction_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n        \n        \n    @classmethod\n    def get_init_parameter(cls, db: Session, interaction_id: str) -> InteractionParameter:\n        \"\"\"\n        get init parameter\n        Args:\n            db: db\n            interaction_id: interaction id\n        Returns:\n            parameter InteractionParameter\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            parameters = InteractionDBInterface.get_parameter(db=db, interaction_id=interaction_id)\n            init_parameter = parameters[0]\n            parameter = InteractionParameter.from_json({\"args\": init_parameter, \"interaction_id\": interaction_id, \"parameter_id\": None})\n            return parameter\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def search_interaction_by_user_id(cls,\n                                   db: Session,\n                                   user_id: str,\n                                   page_size: int = 10,\n                                   page_num: int = 1) -> list[dict]:\n        \"\"\"\n        get interaction by user id\n        Args:\n            db: db\n            user_id: user id\n            page_size: page size\n            page_num: page num\n        Returns:\n            interaction list [dict]\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        return InteractionDBInterface.search_interaction_by_user_id(db=db,\n                                                        user_id=user_id,\n                                                        page_size=page_size,\n                                                        page_num=page_num)\n\n    @classmethod\n    def is_exist(cls, db: Session, interaction_id: str) -> bool:\n        \"\"\"\n        interaction is exist\n        Args:\n            db: db\n            interaction_id: interaction id\n        Returns:\n            True if interaction is exist, else False\n        \n        Raises:\n            XAgentDBError: XAgent DB Error    \n        \"\"\"\n        try:\n            return InteractionDBInterface.is_exist(db=db, interaction_id=interaction_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def update_interaction(cls, db: Session, base_data: dict):\n        \"\"\"\n        update interaction\n        Args:\n            db: db\n            base_data: base data\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.update_interaction(db=db, base_data=base_data)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def update_interaction_status(cls,\n                                  db: Session,\n                                  interaction_id: str,\n                                  status: str,\n                                  message: str,\n                                  current_step: int):\n        \"\"\"\n        update interaction status\n        Args:\n            db: db\n            interaction_id: interaction id\n            status: status\n            message: message\n            current_step: current step\n        \n        Raises:\n            XAgentDBError: XAgent DB Error    \n        \"\"\"\n        try:\n            InteractionDBInterface.update_interaction_status(\n                db=db,\n                interaction_id=interaction_id,\n                status=status,\n                message=message,\n                current_step=current_step)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def update_interaction_parameter(cls,\n                                     db: Session,\n                                     interaction_id: str,\n                                     parameter: InteractionParameter):\n        \"\"\"\n        update interaction parameter\n        Args:\n            db: db\n            interaction_id: interaction id\n            parameter: parameter\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.update_interaction_parameter(\n                db=db,\n                interaction_id=interaction_id,\n                parameter=parameter)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def is_running(cls, db: Session, user_id: str):\n        \"\"\"\n        is running\n        Args:\n            db: db\n            user_id: user id\n        Returns:\n            True if running, else False\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.is_running(db=db, user_id=user_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def delete_interaction(cls, db: Session, interaction_id: str):\n        \"\"\"\n        delete interaction\n        Args:\n            db: db\n            interaction_id: interaction id\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.delete_interaction(\n                db=db, interaction_id=interaction_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def get_shared_interaction(cls,\n                               db: Session,\n                               interaction_id: str) -> InteractionBase | None:\n        \"\"\"\n        get shared interaction\n        Args:\n            db: db\n            interaction_id: interaction id\n            Returns:\n                interaction InteractionBase, if not found, return None\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.get_shared_interaction(\n                db=db,\n                interaction_id=interaction_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def search_many_shared(cls,\n                           db: Session,\n                           page_size: int = 20,\n                           page_index: int = 1) -> list[dict]:\n        \"\"\"\n        search many shared\n        Args:\n            db: db\n            page_size: page size\n            page_index: page index\n        Returns:\n            interaction list [dict]\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.search_many_shared(db=db,\n                                                    page_size=page_size,\n                                                    page_index=page_index)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def insert_raw(cls, db: Session, process: XAgentRaw):\n        \"\"\"\n        insert raw\n        Args:\n            db: db\n            process: process\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.insert_raw(db=db, process=process)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def search_many_raws(cls, db: Session, interaction_id: str) -> List[XAgentRaw] | None:\n        \"\"\"\n        search many raws\n        Args:\n            db: db\n            interaction_id: interaction id\n        Returns:\n            raw list [XAgentRaw]\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return [XAgentRaw.from_db(raw) for raw in \n                    InteractionDBInterface.search_many_raws(db=db, interaction_id=interaction_id)]\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def get_raw(cls, db: Session, interaction_id: str, node_id: str) -> XAgentRaw | None:\n        \"\"\"\n        get raw\n        Args:\n            db: db\n            interaction_id: interaction id\n            node_id: node id\n        Returns:\n            raw XAgentRaw, if not found, return None\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.get_raw(db=db,\n                                                  interaction_id=interaction_id,\n                                                  node_id=node_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def get_next_send(cls, db: Session, interaction_id: str) -> List[Raw] | None:\n        \"\"\"\n        get next send\n        Args:\n            db: db\n            interaction_id: interaction id\n        Returns:\n            raw list [Raw]\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.get_next_send(db=db, interaction_id=interaction_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def update_send_flag(cls, db: Session, interaction_id: str, node_id: str):\n        \"\"\"\n        update send flag\n        Args:\n            db: db\n            interaction_id: interaction id\n            node_id: node id\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.update_send_flag(\n                db=db, interaction_id=interaction_id, node_id=node_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def update_receive_flag(cls, db: Session, interaction_id: str, node_id: str):\n        \"\"\"\n        update receive flag\n        Args:\n            db: db\n            interaction_id: interaction id\n            node_id: node id\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.update_receive_flag(\n                db=db, interaction_id=interaction_id, node_id=node_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def update_human_data(cls,\n                          db: Session,\n                          interaction_id: str,\n                          node_id: str,\n                          human_data: dict):\n        \"\"\"\n        update human data\n        Args:\n            db: db\n            interaction_id: interaction id\n            node_id: node id\n            human_data: human data\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.update_human_data(db=db,\n                                            interaction_id=interaction_id,\n                                            node_id=node_id,\n                                            human_data=human_data)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def insert_error(cls,\n                     db: Session,\n                     interaction_id: str,\n                     message: str,\n                     status: str = \"failed\"):\n        \"\"\"\n        insert error\n        Args:\n            db: db\n            interaction_id: interaction id\n            message: message\n            status: status, default is failed\n        Returns:\n            raw XAgentRaw\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            process = XAgentRaw(\n                node_id=uuid.uuid4().hex,\n                interaction_id=interaction_id,\n                current=\"\",\n                step=0,\n                data=message,\n                file_list=[],\n                status=status,\n                do_interrupt=False,\n                wait_seconds=0,\n                ask_for_human_help=False,\n                create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                is_deleted=False,\n                is_human=False,\n                human_data={},\n                human_file_list=[],\n                is_send=False,\n                is_receive=False,\n                include_pictures=False,\n            )\n            InteractionDBInterface.insert_raw(db=db, process=process)\n            return process\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n\n    @classmethod\n    def add_share(cls, db: Session, share):\n        \"\"\"\n        add share\n        Args:\n            db: db\n            share: share\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.add_share(db=db, shared=share)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n        \n        \n    @classmethod\n    def get_finish_status(cls, db: Session, interaction_id: str) -> bool:\n        \"\"\"\n        get finish status\n        \n        Args:\n            db: db\n            interaction_id: interaction id\n            \n        Returns:\n            True if finish, else False\n        \"\"\"\n        try:\n            return InteractionDBInterface.get_finish_status(db=db, interaction_id=interaction_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 6
        },
        "search_many_interaction": {
            "type": "FunctionDef",
            "name": "search_many_interaction",
            "md_content": "",
            "code_start_line": 23,
            "code_end_line": 30,
            "parent": "InteractionCRUD",
            "have_return": true,
            "code_content": "    def search_many_interaction(cls, db: Session) -> list:\n        \"\"\"\n        search many interaction\n        \"\"\"\n        try:\n            return InteractionDBInterface.search_many_interaction(db=db)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "get_interaction": {
            "type": "FunctionDef",
            "name": "get_interaction",
            "md_content": "",
            "code_start_line": 33,
            "code_end_line": 48,
            "parent": "InteractionCRUD",
            "have_return": true,
            "code_content": "    def get_interaction(cls, db: Session, interaction_id: str) -> InteractionBase | None:\n        \"\"\"\n        get interaction\n        Args:\n            db: db\n            interaction_id: interaction id\n        Returns:\n            interaction InteractionBase\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.get_interaction(db=db, interaction_id=interaction_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "create_interaction": {
            "type": "FunctionDef",
            "name": "create_interaction",
            "md_content": "",
            "code_start_line": 51,
            "code_end_line": 64,
            "parent": "InteractionCRUD",
            "have_return": false,
            "code_content": "    def create_interaction(cls, db: Session, base: InteractionBase):\n        \"\"\"\n        create interaction\n        Args:\n            db: db\n            base: base\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.create_interaction(db=db, base=base)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "get_ready_interaction": {
            "type": "FunctionDef",
            "name": "get_ready_interaction",
            "md_content": "",
            "code_start_line": 67,
            "code_end_line": 80,
            "parent": "InteractionCRUD",
            "have_return": true,
            "code_content": "    def get_ready_interaction(cls, db: Session, user_id: str):\n        \"\"\"\n        create interaction\n        Args:\n            db: db\n            user_id: user_id\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.get_ready_interaction(db=db, user_id=user_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "add_parameter": {
            "type": "FunctionDef",
            "name": "add_parameter",
            "md_content": "",
            "code_start_line": 84,
            "code_end_line": 97,
            "parent": "InteractionCRUD",
            "have_return": false,
            "code_content": "    def add_parameter(cls, db: Session, parameter: InteractionParameter = None):\n        \"\"\"\n        add parameter\n        Args:\n            db: db\n            parameter: parameter\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.add_parameter(db=db, parameter=parameter)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "get_parameter": {
            "type": "FunctionDef",
            "name": "get_parameter",
            "md_content": "",
            "code_start_line": 100,
            "code_end_line": 115,
            "parent": "InteractionCRUD",
            "have_return": true,
            "code_content": "    def get_parameter(cls, db: Session, interaction_id: str) -> list:\n        \"\"\"\n        get parameter\n        Args:\n            db: db\n            interaction_id: interaction id\n        Returns:\n            parameter list [InteractionParameter]\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.get_parameter(db=db, interaction_id=interaction_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "get_init_parameter": {
            "type": "FunctionDef",
            "name": "get_init_parameter",
            "md_content": "",
            "code_start_line": 119,
            "code_end_line": 137,
            "parent": "InteractionCRUD",
            "have_return": true,
            "code_content": "    def get_init_parameter(cls, db: Session, interaction_id: str) -> InteractionParameter:\n        \"\"\"\n        get init parameter\n        Args:\n            db: db\n            interaction_id: interaction id\n        Returns:\n            parameter InteractionParameter\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            parameters = InteractionDBInterface.get_parameter(db=db, interaction_id=interaction_id)\n            init_parameter = parameters[0]\n            parameter = InteractionParameter.from_json({\"args\": init_parameter, \"interaction_id\": interaction_id, \"parameter_id\": None})\n            return parameter\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "search_interaction_by_user_id": {
            "type": "FunctionDef",
            "name": "search_interaction_by_user_id",
            "md_content": "",
            "code_start_line": 140,
            "code_end_line": 161,
            "parent": "InteractionCRUD",
            "have_return": true,
            "code_content": "    def search_interaction_by_user_id(cls,\n                                   db: Session,\n                                   user_id: str,\n                                   page_size: int = 10,\n                                   page_num: int = 1) -> list[dict]:\n        \"\"\"\n        get interaction by user id\n        Args:\n            db: db\n            user_id: user id\n            page_size: page size\n            page_num: page num\n        Returns:\n            interaction list [dict]\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        return InteractionDBInterface.search_interaction_by_user_id(db=db,\n                                                        user_id=user_id,\n                                                        page_size=page_size,\n                                                        page_num=page_num)\n",
            "name_column": 8
        },
        "is_exist": {
            "type": "FunctionDef",
            "name": "is_exist",
            "md_content": "",
            "code_start_line": 164,
            "code_end_line": 179,
            "parent": "InteractionCRUD",
            "have_return": true,
            "code_content": "    def is_exist(cls, db: Session, interaction_id: str) -> bool:\n        \"\"\"\n        interaction is exist\n        Args:\n            db: db\n            interaction_id: interaction id\n        Returns:\n            True if interaction is exist, else False\n        \n        Raises:\n            XAgentDBError: XAgent DB Error    \n        \"\"\"\n        try:\n            return InteractionDBInterface.is_exist(db=db, interaction_id=interaction_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "update_interaction": {
            "type": "FunctionDef",
            "name": "update_interaction",
            "md_content": "",
            "code_start_line": 182,
            "code_end_line": 195,
            "parent": "InteractionCRUD",
            "have_return": false,
            "code_content": "    def update_interaction(cls, db: Session, base_data: dict):\n        \"\"\"\n        update interaction\n        Args:\n            db: db\n            base_data: base data\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.update_interaction(db=db, base_data=base_data)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "update_interaction_status": {
            "type": "FunctionDef",
            "name": "update_interaction_status",
            "md_content": "",
            "code_start_line": 198,
            "code_end_line": 224,
            "parent": "InteractionCRUD",
            "have_return": false,
            "code_content": "    def update_interaction_status(cls,\n                                  db: Session,\n                                  interaction_id: str,\n                                  status: str,\n                                  message: str,\n                                  current_step: int):\n        \"\"\"\n        update interaction status\n        Args:\n            db: db\n            interaction_id: interaction id\n            status: status\n            message: message\n            current_step: current step\n        \n        Raises:\n            XAgentDBError: XAgent DB Error    \n        \"\"\"\n        try:\n            InteractionDBInterface.update_interaction_status(\n                db=db,\n                interaction_id=interaction_id,\n                status=status,\n                message=message,\n                current_step=current_step)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "update_interaction_parameter": {
            "type": "FunctionDef",
            "name": "update_interaction_parameter",
            "md_content": "",
            "code_start_line": 227,
            "code_end_line": 247,
            "parent": "InteractionCRUD",
            "have_return": false,
            "code_content": "    def update_interaction_parameter(cls,\n                                     db: Session,\n                                     interaction_id: str,\n                                     parameter: InteractionParameter):\n        \"\"\"\n        update interaction parameter\n        Args:\n            db: db\n            interaction_id: interaction id\n            parameter: parameter\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.update_interaction_parameter(\n                db=db,\n                interaction_id=interaction_id,\n                parameter=parameter)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "is_running": {
            "type": "FunctionDef",
            "name": "is_running",
            "md_content": "",
            "code_start_line": 250,
            "code_end_line": 265,
            "parent": "InteractionCRUD",
            "have_return": true,
            "code_content": "    def is_running(cls, db: Session, user_id: str):\n        \"\"\"\n        is running\n        Args:\n            db: db\n            user_id: user id\n        Returns:\n            True if running, else False\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.is_running(db=db, user_id=user_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "delete_interaction": {
            "type": "FunctionDef",
            "name": "delete_interaction",
            "md_content": "",
            "code_start_line": 268,
            "code_end_line": 282,
            "parent": "InteractionCRUD",
            "have_return": false,
            "code_content": "    def delete_interaction(cls, db: Session, interaction_id: str):\n        \"\"\"\n        delete interaction\n        Args:\n            db: db\n            interaction_id: interaction id\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.delete_interaction(\n                db=db, interaction_id=interaction_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "get_shared_interaction": {
            "type": "FunctionDef",
            "name": "get_shared_interaction",
            "md_content": "",
            "code_start_line": 285,
            "code_end_line": 304,
            "parent": "InteractionCRUD",
            "have_return": true,
            "code_content": "    def get_shared_interaction(cls,\n                               db: Session,\n                               interaction_id: str) -> InteractionBase | None:\n        \"\"\"\n        get shared interaction\n        Args:\n            db: db\n            interaction_id: interaction id\n            Returns:\n                interaction InteractionBase, if not found, return None\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.get_shared_interaction(\n                db=db,\n                interaction_id=interaction_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "search_many_shared": {
            "type": "FunctionDef",
            "name": "search_many_shared",
            "md_content": "",
            "code_start_line": 307,
            "code_end_line": 328,
            "parent": "InteractionCRUD",
            "have_return": true,
            "code_content": "    def search_many_shared(cls,\n                           db: Session,\n                           page_size: int = 20,\n                           page_index: int = 1) -> list[dict]:\n        \"\"\"\n        search many shared\n        Args:\n            db: db\n            page_size: page size\n            page_index: page index\n        Returns:\n            interaction list [dict]\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.search_many_shared(db=db,\n                                                    page_size=page_size,\n                                                    page_index=page_index)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "insert_raw": {
            "type": "FunctionDef",
            "name": "insert_raw",
            "md_content": "",
            "code_start_line": 331,
            "code_end_line": 344,
            "parent": "InteractionCRUD",
            "have_return": false,
            "code_content": "    def insert_raw(cls, db: Session, process: XAgentRaw):\n        \"\"\"\n        insert raw\n        Args:\n            db: db\n            process: process\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.insert_raw(db=db, process=process)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "search_many_raws": {
            "type": "FunctionDef",
            "name": "search_many_raws",
            "md_content": "",
            "code_start_line": 347,
            "code_end_line": 363,
            "parent": "InteractionCRUD",
            "have_return": true,
            "code_content": "    def search_many_raws(cls, db: Session, interaction_id: str) -> List[XAgentRaw] | None:\n        \"\"\"\n        search many raws\n        Args:\n            db: db\n            interaction_id: interaction id\n        Returns:\n            raw list [XAgentRaw]\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return [XAgentRaw.from_db(raw) for raw in \n                    InteractionDBInterface.search_many_raws(db=db, interaction_id=interaction_id)]\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "get_raw": {
            "type": "FunctionDef",
            "name": "get_raw",
            "md_content": "",
            "code_start_line": 366,
            "code_end_line": 384,
            "parent": "InteractionCRUD",
            "have_return": true,
            "code_content": "    def get_raw(cls, db: Session, interaction_id: str, node_id: str) -> XAgentRaw | None:\n        \"\"\"\n        get raw\n        Args:\n            db: db\n            interaction_id: interaction id\n            node_id: node id\n        Returns:\n            raw XAgentRaw, if not found, return None\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.get_raw(db=db,\n                                                  interaction_id=interaction_id,\n                                                  node_id=node_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "get_next_send": {
            "type": "FunctionDef",
            "name": "get_next_send",
            "md_content": "",
            "code_start_line": 387,
            "code_end_line": 402,
            "parent": "InteractionCRUD",
            "have_return": true,
            "code_content": "    def get_next_send(cls, db: Session, interaction_id: str) -> List[Raw] | None:\n        \"\"\"\n        get next send\n        Args:\n            db: db\n            interaction_id: interaction id\n        Returns:\n            raw list [Raw]\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            return InteractionDBInterface.get_next_send(db=db, interaction_id=interaction_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "update_send_flag": {
            "type": "FunctionDef",
            "name": "update_send_flag",
            "md_content": "",
            "code_start_line": 405,
            "code_end_line": 420,
            "parent": "InteractionCRUD",
            "have_return": false,
            "code_content": "    def update_send_flag(cls, db: Session, interaction_id: str, node_id: str):\n        \"\"\"\n        update send flag\n        Args:\n            db: db\n            interaction_id: interaction id\n            node_id: node id\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.update_send_flag(\n                db=db, interaction_id=interaction_id, node_id=node_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "update_receive_flag": {
            "type": "FunctionDef",
            "name": "update_receive_flag",
            "md_content": "",
            "code_start_line": 423,
            "code_end_line": 438,
            "parent": "InteractionCRUD",
            "have_return": false,
            "code_content": "    def update_receive_flag(cls, db: Session, interaction_id: str, node_id: str):\n        \"\"\"\n        update receive flag\n        Args:\n            db: db\n            interaction_id: interaction id\n            node_id: node id\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.update_receive_flag(\n                db=db, interaction_id=interaction_id, node_id=node_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "update_human_data": {
            "type": "FunctionDef",
            "name": "update_human_data",
            "md_content": "",
            "code_start_line": 441,
            "code_end_line": 463,
            "parent": "InteractionCRUD",
            "have_return": false,
            "code_content": "    def update_human_data(cls,\n                          db: Session,\n                          interaction_id: str,\n                          node_id: str,\n                          human_data: dict):\n        \"\"\"\n        update human data\n        Args:\n            db: db\n            interaction_id: interaction id\n            node_id: node id\n            human_data: human data\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.update_human_data(db=db,\n                                            interaction_id=interaction_id,\n                                            node_id=node_id,\n                                            human_data=human_data)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "insert_error": {
            "type": "FunctionDef",
            "name": "insert_error",
            "md_content": "",
            "code_start_line": 466,
            "code_end_line": 509,
            "parent": "InteractionCRUD",
            "have_return": true,
            "code_content": "    def insert_error(cls,\n                     db: Session,\n                     interaction_id: str,\n                     message: str,\n                     status: str = \"failed\"):\n        \"\"\"\n        insert error\n        Args:\n            db: db\n            interaction_id: interaction id\n            message: message\n            status: status, default is failed\n        Returns:\n            raw XAgentRaw\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            process = XAgentRaw(\n                node_id=uuid.uuid4().hex,\n                interaction_id=interaction_id,\n                current=\"\",\n                step=0,\n                data=message,\n                file_list=[],\n                status=status,\n                do_interrupt=False,\n                wait_seconds=0,\n                ask_for_human_help=False,\n                create_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                update_time=datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                is_deleted=False,\n                is_human=False,\n                human_data={},\n                human_file_list=[],\n                is_send=False,\n                is_receive=False,\n                include_pictures=False,\n            )\n            InteractionDBInterface.insert_raw(db=db, process=process)\n            return process\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "add_share": {
            "type": "FunctionDef",
            "name": "add_share",
            "md_content": "",
            "code_start_line": 512,
            "code_end_line": 525,
            "parent": "InteractionCRUD",
            "have_return": false,
            "code_content": "    def add_share(cls, db: Session, share):\n        \"\"\"\n        add share\n        Args:\n            db: db\n            share: share\n        \n        Raises:\n            XAgentDBError: XAgent DB Error\n        \"\"\"\n        try:\n            InteractionDBInterface.add_share(db=db, shared=share)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "get_finish_status": {
            "type": "FunctionDef",
            "name": "get_finish_status",
            "md_content": "",
            "code_start_line": 529,
            "code_end_line": 543,
            "parent": "InteractionCRUD",
            "have_return": true,
            "code_content": "    def get_finish_status(cls, db: Session, interaction_id: str) -> bool:\n        \"\"\"\n        get finish status\n        \n        Args:\n            db: db\n            interaction_id: interaction id\n            \n        Returns:\n            True if finish, else False\n        \"\"\"\n        try:\n            return InteractionDBInterface.get_finish_status(db=db, interaction_id=interaction_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Interact Module]: {str(e)}\") from e\n",
            "name_column": 8
        }
    },
    "XAgentServer/application/cruds/recorder.py": {
        "RunningRecordCRUD": {
            "type": "ClassDef",
            "name": "RunningRecordCRUD",
            "md_content": "",
            "code_start_line": 12,
            "code_end_line": 91,
            "parent": null,
            "have_return": true,
            "code_content": "class RunningRecordCRUD(metaclass=abc.ABCMeta):\n    \"\"\"\n    Recorder CRUD\n    \"\"\"\n\n    @classmethod\n    def get_record_list(cls, db: Session, record_id: str) -> list[XAgentRunningRecord]:\n        \"\"\"\n        get all records\n        \n        Args:\n            db: database session\n            record_id: record_id\n        \"\"\"\n        try:\n            return RecordDBInterface.get_record_list(db=db, record_id=record_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Recorder Module]: {str(e)}\") from e\n\n    @classmethod\n    def get_record(cls,\n                     db: Session,\n                     record_id: str | None = None) -> XAgentRunningRecord | None:\n        \"\"\"\n        get record by record_id\n        \n        Args:\n            db: database session\n            record_id: record_id\n        \n        Returns:\n            record\n        \n        \"\"\"\n        try:\n            return RecordDBInterface.get_record(db=db, record_id=record_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Recorder Module]: {str(e)}\") from e\n\n    @classmethod\n    def insert_record(cls,\n                      db: Session,\n                      record: XAgentRunningRecord):\n        \"\"\"\n        insert record\n        \n        Args:\n            db: database session\n            record: record\n        \n        \"\"\"\n        try:\n            RecordDBInterface.insert_record(db=db, record=record)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Recorder Module]: {str(e)}\") from e\n\n    @classmethod\n    def get_record_by_type(cls,\n                         db: Session,\n                         record_id: str,\n                         node_id: str = \"\",\n                         node_type: str = \"\") -> List[XAgentRunningRecord]:\n        \"\"\"\n        get record by id\n        \n        Args:\n            db: database session\n            record_id: record_id\n        \n        Returns:\n            record\n        \n        \"\"\"\n        try:\n            return RecordDBInterface.get_record_by_type(db=db,\n                                                        record_id=record_id,\n                                                        node_id=node_id,\n                                                        node_type=node_type)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Recorder Module]: {str(e)}\") from e\n",
            "name_column": 6
        },
        "get_record_list": {
            "type": "FunctionDef",
            "name": "get_record_list",
            "md_content": "",
            "code_start_line": 18,
            "code_end_line": 29,
            "parent": "RunningRecordCRUD",
            "have_return": true,
            "code_content": "    def get_record_list(cls, db: Session, record_id: str) -> list[XAgentRunningRecord]:\n        \"\"\"\n        get all records\n        \n        Args:\n            db: database session\n            record_id: record_id\n        \"\"\"\n        try:\n            return RecordDBInterface.get_record_list(db=db, record_id=record_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Recorder Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "get_record": {
            "type": "FunctionDef",
            "name": "get_record",
            "md_content": "",
            "code_start_line": 32,
            "code_end_line": 49,
            "parent": "RunningRecordCRUD",
            "have_return": true,
            "code_content": "    def get_record(cls,\n                     db: Session,\n                     record_id: str | None = None) -> XAgentRunningRecord | None:\n        \"\"\"\n        get record by record_id\n        \n        Args:\n            db: database session\n            record_id: record_id\n        \n        Returns:\n            record\n        \n        \"\"\"\n        try:\n            return RecordDBInterface.get_record(db=db, record_id=record_id)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Recorder Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "insert_record": {
            "type": "FunctionDef",
            "name": "insert_record",
            "md_content": "",
            "code_start_line": 52,
            "code_end_line": 66,
            "parent": "RunningRecordCRUD",
            "have_return": false,
            "code_content": "    def insert_record(cls,\n                      db: Session,\n                      record: XAgentRunningRecord):\n        \"\"\"\n        insert record\n        \n        Args:\n            db: database session\n            record: record\n        \n        \"\"\"\n        try:\n            RecordDBInterface.insert_record(db=db, record=record)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Recorder Module]: {str(e)}\") from e\n",
            "name_column": 8
        },
        "get_record_by_type": {
            "type": "FunctionDef",
            "name": "get_record_by_type",
            "md_content": "",
            "code_start_line": 69,
            "code_end_line": 91,
            "parent": "RunningRecordCRUD",
            "have_return": true,
            "code_content": "    def get_record_by_type(cls,\n                         db: Session,\n                         record_id: str,\n                         node_id: str = \"\",\n                         node_type: str = \"\") -> List[XAgentRunningRecord]:\n        \"\"\"\n        get record by id\n        \n        Args:\n            db: database session\n            record_id: record_id\n        \n        Returns:\n            record\n        \n        \"\"\"\n        try:\n            return RecordDBInterface.get_record_by_type(db=db,\n                                                        record_id=record_id,\n                                                        node_id=node_id,\n                                                        node_type=node_type)\n        except Exception as e:\n            raise XAgentDBError(f\"XAgent DB Error [Recorder Module]: {str(e)}\") from e\n",
            "name_column": 8
        }
    },
    "XAgent/config.py": {
        "XAgentConfig": {
            "type": "ClassDef",
            "name": "XAgentConfig",
            "md_content": "",
            "code_start_line": 7,
            "code_end_line": 121,
            "parent": null,
            "have_return": true,
            "code_content": "class XAgentConfig(dict):\n    \"\"\"\n    A dictionary-like configuration class with attribute-style access.\n\n    Inherited from dictionary, this class provides methods for accessing and modifying\n    dictionary items using attributes and methods.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Initialize class instance.\n\n        Args:\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n\n    def __getattr__(self, key):\n        \"\"\"\n        Access the class attribute.\n\n        Args:\n            key (str): Key to access the class attribute.\n\n        Returns:\n            Value of the class attribute for the input key.\n\n        Raises:\n            AttributeError: If the input key is not present in the dictionary.\n        \"\"\"\n        if key in self:\n            return self[key]\n        raise AttributeError(f\"'DotDict' object has no attribute '{key}'\")\n\n    def __setattr__(self, key, value):\n        \"\"\"\n        Set the value of the class attribute.\n\n        Args:\n            key (str): Key for the attribute to set.\n            value : Value to be set for the input key.\n        \"\"\"\n        self[key] = value\n\n    def __delattr__(self, key):\n        \"\"\"\n        Delete the class attribute.\n\n        Args:\n            key (str): Key of the attribute to delete.\n\n        Raises:\n            AttributeError: If the input key is not present in the dictionary.\n        \"\"\"\n        if key in self:\n            del self[key]\n        else:\n            raise AttributeError(f\"'DotDict' object has no attribute '{key}'\")\n\n    def to_dict(self, safe=False):\n        \"\"\"\n        Convert the xAgentConfig object to dictionary.\n\n        Args:\n            safe (bool, optional): If True, 'api_keys' will be excluded from the output.\n                Default is False.\n\n        Returns:\n            dict: Dictionary representation of the instance.\n        \"\"\"\n        if safe:\n            right_value = deepcopy(self)\n            right_value.pop(\"api_keys\", \"\")\n            return right_value\n        else:\n            return self\n\n    def reload(self, config_file='assets/config.yml'):\n        \"\"\"\n        Load configuration data from YAML file and environment variables. And also update\n        the ARGS with new data.\n\n        Args:\n            config_file (str, optional): Path to the YAML configuration file.\n                Default is 'assets/config.yml'.\n        \"\"\"\n        config_file = os.getenv('CONFIG_FILE', config_file)\n        print('---config file---\\n'+str(config_file))\n        self.__init__(\n            **yaml.load(open(config_file, 'r'), Loader=yaml.FullLoader))\n        # check environment variables\n        self['selfhost_toolserver_url'] = os.getenv(\n            'TOOLSERVER_URL', self['selfhost_toolserver_url'])\n        print('---args---\\n'+str(ARGS))\n        self.update(ARGS)\n\n    @staticmethod\n    def get_default_config(config_file='assets/config.yml'):\n        \"\"\"\n        Get default configuration data from given file through environment variable.\n\n        Args:\n            config_file (str, optional): Path to the YAML configuration file.\n                Default is 'assets/config.yml'.\n\n        Returns:\n            XAgentConfig: An instance of XAgentConfig with loaded configuration data.\n        \"\"\"\n        try:\n            config_file = os.getenv('CONFIG_FILE', config_file)\n            cfg = yaml.load(open(config_file, 'r'), Loader=yaml.FullLoader)\n        except:\n            cfg = {}\n        return XAgentConfig(**cfg)\n",
            "name_column": 6
        },
        "get_model_name": {
            "type": "FunctionDef",
            "name": "get_model_name",
            "md_content": "",
            "code_start_line": 128,
            "code_end_line": 170,
            "parent": null,
            "have_return": true,
            "code_content": "def get_model_name(model_name: str = None):\n    \"\"\"\n    Get the normalized model name for a given input model name.\n\n    Args:\n        model_name (str, optional): Input model name. Default is None.\n\n    Returns:\n        str: Normalized model name.\n\n    Raises:\n        Exception: If the model name is not recognized.\n    \"\"\"\n    if model_name is None:\n        model_name = CONFIG.default_completion_kwargs['model']\n\n    normalized_model_name = ''\n    match model_name.lower():\n        case 'gpt-4':\n            normalized_model_name = 'gpt-4'\n        case 'gpt-4-32k':\n            normalized_model_name = 'gpt-4-32k'\n        case 'gpt-4-1106-preview':\n            normalized_model_name = 'gpt-4-1106-preview'\n        case 'gpt-4-turbo':\n            normalized_model_name = 'gpt-4-1106-preview'\n        case 'gpt-3.5-turbo-16k':\n            normalized_model_name = 'gpt-3.5-turbo-16k'\n        case 'gpt-3.5-turbo-1106':\n            normalized_model_name = 'gpt-3.5-turbo-1106'\n\n        case 'gpt4':\n            normalized_model_name = 'gpt-4'\n        case 'gpt4-32':\n            normalized_model_name = 'gpt-4-32k'\n        case 'gpt-35-16k':\n            normalized_model_name = 'gpt-3.5-turbo-16k'\n        case 'xagentllm':\n            normalized_model_name = 'xagentllm'\n        case _:\n            raise Exception(f\"Unknown model name {model_name}\")\n\n    return normalized_model_name\n",
            "name_column": 4
        },
        "get_apiconfig_by_model": {
            "type": "FunctionDef",
            "name": "get_apiconfig_by_model",
            "md_content": "",
            "code_start_line": 173,
            "code_end_line": 190,
            "parent": null,
            "have_return": true,
            "code_content": "def get_apiconfig_by_model(model_name: str) -> dict:\n    \"\"\"\n    Get API configuration for a model by its name.\n\n    The function first normalizes the name, then fetches the API keys for this model\n    from the CONFIG and rotates the keys.\n\n    Args:\n        model_name (str): Name of the model.\n\n    Returns:\n        dict: Dictionary containing the fetched API configuration.\n    \"\"\"\n    normalized_model_name = get_model_name(model_name)\n    apiconfig = deepcopy(CONFIG.api_keys[normalized_model_name][0])\n    CONFIG.api_keys[normalized_model_name].append(\n        CONFIG.api_keys[normalized_model_name].pop(0))\n    return apiconfig\n",
            "name_column": 4
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 15,
            "code_end_line": 23,
            "parent": "XAgentConfig",
            "have_return": false,
            "code_content": "    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Initialize class instance.\n\n        Args:\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n",
            "name_column": 8
        },
        "__getattr__": {
            "type": "FunctionDef",
            "name": "__getattr__",
            "md_content": "",
            "code_start_line": 25,
            "code_end_line": 40,
            "parent": "XAgentConfig",
            "have_return": true,
            "code_content": "    def __getattr__(self, key):\n        \"\"\"\n        Access the class attribute.\n\n        Args:\n            key (str): Key to access the class attribute.\n\n        Returns:\n            Value of the class attribute for the input key.\n\n        Raises:\n            AttributeError: If the input key is not present in the dictionary.\n        \"\"\"\n        if key in self:\n            return self[key]\n        raise AttributeError(f\"'DotDict' object has no attribute '{key}'\")\n",
            "name_column": 8
        },
        "__setattr__": {
            "type": "FunctionDef",
            "name": "__setattr__",
            "md_content": "",
            "code_start_line": 42,
            "code_end_line": 50,
            "parent": "XAgentConfig",
            "have_return": false,
            "code_content": "    def __setattr__(self, key, value):\n        \"\"\"\n        Set the value of the class attribute.\n\n        Args:\n            key (str): Key for the attribute to set.\n            value : Value to be set for the input key.\n        \"\"\"\n        self[key] = value\n",
            "name_column": 8
        },
        "__delattr__": {
            "type": "FunctionDef",
            "name": "__delattr__",
            "md_content": "",
            "code_start_line": 52,
            "code_end_line": 65,
            "parent": "XAgentConfig",
            "have_return": false,
            "code_content": "    def __delattr__(self, key):\n        \"\"\"\n        Delete the class attribute.\n\n        Args:\n            key (str): Key of the attribute to delete.\n\n        Raises:\n            AttributeError: If the input key is not present in the dictionary.\n        \"\"\"\n        if key in self:\n            del self[key]\n        else:\n            raise AttributeError(f\"'DotDict' object has no attribute '{key}'\")\n",
            "name_column": 8
        },
        "to_dict": {
            "type": "FunctionDef",
            "name": "to_dict",
            "md_content": "",
            "code_start_line": 67,
            "code_end_line": 83,
            "parent": "XAgentConfig",
            "have_return": true,
            "code_content": "    def to_dict(self, safe=False):\n        \"\"\"\n        Convert the xAgentConfig object to dictionary.\n\n        Args:\n            safe (bool, optional): If True, 'api_keys' will be excluded from the output.\n                Default is False.\n\n        Returns:\n            dict: Dictionary representation of the instance.\n        \"\"\"\n        if safe:\n            right_value = deepcopy(self)\n            right_value.pop(\"api_keys\", \"\")\n            return right_value\n        else:\n            return self\n",
            "name_column": 8
        },
        "reload": {
            "type": "FunctionDef",
            "name": "reload",
            "md_content": "",
            "code_start_line": 85,
            "code_end_line": 102,
            "parent": "XAgentConfig",
            "have_return": false,
            "code_content": "    def reload(self, config_file='assets/config.yml'):\n        \"\"\"\n        Load configuration data from YAML file and environment variables. And also update\n        the ARGS with new data.\n\n        Args:\n            config_file (str, optional): Path to the YAML configuration file.\n                Default is 'assets/config.yml'.\n        \"\"\"\n        config_file = os.getenv('CONFIG_FILE', config_file)\n        print('---config file---\\n'+str(config_file))\n        self.__init__(\n            **yaml.load(open(config_file, 'r'), Loader=yaml.FullLoader))\n        # check environment variables\n        self['selfhost_toolserver_url'] = os.getenv(\n            'TOOLSERVER_URL', self['selfhost_toolserver_url'])\n        print('---args---\\n'+str(ARGS))\n        self.update(ARGS)\n",
            "name_column": 8
        },
        "get_default_config": {
            "type": "FunctionDef",
            "name": "get_default_config",
            "md_content": "",
            "code_start_line": 105,
            "code_end_line": 121,
            "parent": "XAgentConfig",
            "have_return": true,
            "code_content": "    def get_default_config(config_file='assets/config.yml'):\n        \"\"\"\n        Get default configuration data from given file through environment variable.\n\n        Args:\n            config_file (str, optional): Path to the YAML configuration file.\n                Default is 'assets/config.yml'.\n\n        Returns:\n            XAgentConfig: An instance of XAgentConfig with loaded configuration data.\n        \"\"\"\n        try:\n            config_file = os.getenv('CONFIG_FILE', config_file)\n            cfg = yaml.load(open(config_file, 'r'), Loader=yaml.FullLoader)\n        except:\n            cfg = {}\n        return XAgentConfig(**cfg)\n",
            "name_column": 8
        }
    },
    "XAgent/running_recorder.py": {
        "dump_common_things": {
            "type": "FunctionDef",
            "name": "dump_common_things",
            "md_content": "**dump_common_things函数**: 这个函数的功能是将常用的数据类型（如str、int、float、bool、字典和列表）进行序列化。\n\n该函数接受一个参数object，表示要序列化的对象。根据对象的类型，函数会执行不同的操作：\n\n- 如果对象的类型是str、int、float或bool，直接返回该对象。\n- 如果对象的类型是字典，遍历字典中的每个键值对，对键和值分别调用dump_common_things函数进行递归序列化，并返回序列化后的字典。\n- 如果对象的类型是列表，遍历列表中的每个元素，对每个元素调用dump_common_things函数进行递归序列化，并返回序列化后的列表。\n- 如果对象具有to_json方法，调用该方法并返回结果。\n\n**注意**: \n- 该函数会递归地序列化对象，直到对象的类型为str、int、float、bool、字典或列表。\n- 如果对象具有to_json方法，该方法将被调用并返回结果。\n- 如果对象的类型不属于上述情况，函数将返回None。\n\n**输出示例**:\n- 输入: \"Hello World\"\n  输出: \"Hello World\"\n- 输入: {\"name\": \"John\", \"age\": 30}\n  输出: {\"name\": \"John\", \"age\": 30}\n- 输入: [1, 2, 3, 4, 5]\n  输出: [1, 2, 3, 4, 5]\n- 输入: datetime.datetime(2022, 1, 1)\n  输出: None",
            "code_start_line": 14,
            "code_end_line": 32,
            "parent": null,
            "have_return": true,
            "code_content": "def dump_common_things(object):\n    \"\"\"\n    Serialize commonly used data types, like str, int, float, bool, dictionaries, and lists.\n\n    Args:\n        object (Any): The object to serialize.\n\n    Returns:\n        object: The cpickled object.\n    \"\"\"\n    if type(object) in [str, int, float, bool]:\n        return object\n    if type(object) == dict:\n        return {dump_common_things(key): dump_common_things(value) for key, value in object.items()}\n    if type(object) == list:\n        return [dump_common_things(cont) for cont in object]\n    method = getattr(object, 'to_json', None)\n    if callable(method):\n        return method()\n",
            "name_column": 4
        },
        "RunningRecoder": {
            "type": "ClassDef",
            "name": "RunningRecoder",
            "md_content": "**RunningRecoder函数**：这个类用于记录程序的运行序列，包括程序的查询状态和配置数据。\n\n详细代码分析和描述：\n- `__init__(self, record_root_dir=\"./running_records/\")`：初始化RunningRecorder对象。接受一个可选的参数`record_root_dir`，表示运行记录的根目录。在初始化过程中，会根据当前时间和随机生成的字符串创建一个唯一的子目录，作为记录的存储路径。同时，会在子目录下创建两个子目录\"LLM_inout_pair\"和\"tool_server_pair\"，用于存储LLM输入输出对和工具服务器的记录。其他属性的初始值为默认值。\n\n- `get_query_id(self)`：获取查询的ID。每次调用该方法，会返回当前查询计数，并将计数加1。\n\n- `decrease_query_id(self)`：减少查询的ID。每次调用该方法，会将查询计数减1。\n\n- `change_now_task(self, new_subtask_id)`：更改当前子任务。接受一个参数`new_subtask_id`，表示新子任务的ID。在调用该方法后，会将当前子任务ID更新为新的ID，并将工具调用ID和计划细化ID重置为0。\n\n- `regist_plan_modify(self, refine_function_name, refine_function_input, refine_function_output, plan_after)`：注册计划修改。接受四个参数：`refine_function_name`表示计划修改函数的名称，`refine_function_input`表示计划修改函数的输入，`refine_function_output`表示计划修改函数的输出，`plan_after`表示修改后的计划。在注册过程中，会将计划修改记录以JSON格式保存到当前子任务的目录下。\n\n- `regist_llm_inout(self, llm_query_id, messages, functions=None, function_call=None, model=None, stop=None, output_data=None, **other_args)`：注册LLM输入输出对。接受多个参数：`llm_query_id`表示LLM查询的ID，`messages`表示通信的消息，`functions`表示使用的函数列表，`function_call`表示调用的函数，`model`表示使用的模型，`stop`表示是否停止，`output_data`表示输出数据，`other_args`表示其他参数。在注册过程中，会将LLM输入输出对以JSON格式保存到\"LLM_inout_pair\"目录下，并将LLM输入输出对添加到缓存中。\n\n- `query_llm_inout(self, llm_query_id, messages, functions=None, function_call=None, model=None, stop=None, **other_args)`：查询LLM输入输出对。接受多个参数：`llm_query_id`表示LLM查询的ID，`messages`表示通信的消息，`functions`表示使用的函数列表，`function_call`表示调用的函数，`model`表示使用的模型，`stop`表示是否停止，`other_args`表示其他参数。在查询过程中，会根据输入参数和缓存中的LLM输入输出对进行匹配，如果匹配成功，则返回对应的输出数据。\n\n- `regist_tool_call(self, tool_name, tool_input, tool_output, tool_status_code, thought_data=None)`：注册工具调用。接受五个参数：`tool_name`表示工具的名称，`tool_input`表示工具的输入，`tool_output`表示工具的输出，`tool_status_code`表示工具的状态码，`thought_data`表示思考数据。在注册过程中，会将工具调用记录以JSON格式保存到当前子任务的目录下。\n\n- `regist_tool_server(self, url, payload, tool_output, response_status_code)`：注册工具服务器。接受四个参数：`url`表示服务器的URL，`payload`表示工具的负载，`tool_output`表示工具的输出，`response_status_code`表示响应的状态码。在注册过程中，会将工具服务器记录以JSON格式保存到\"tool_server_pair\"目录下。\n\n- `query_tool_server_cache(self, url, payload)`：查询工具服务器缓存。接受两个参数：`url`表示服务器的URL，`payload`表示要发送的负载。在查询过程中，会根据输入参数和缓存中的工具服务器记录进行匹配，如果匹配成功，则返回工具服务器的输出和响应状态码。\n\n- `regist_query(self, query)`：注册查询。接受一个参数`query`，表示要注册的查询。在注册过程中，会将查询以JSON格式保存到记录的根目录下的\"query.json\"文件中。\n\n- `get_query(self)`：获取注册的查询。在调用该方法后，会从记录的根目录下的\"query.json\"文件中读取查询，并返回查询对象。\n\n- `regist_config(self, config: XAgentConfig)`：注册配置。接受一个参数`config`，表示要注册的配置。在注册过程中，会将配置以YAML格式保存到记录的根目录下的\"config.yml\"文件中。\n\n- `get_config(self)`：获取注册的配置。在调用该方法后，会从记录的根目录下的\"config.yml\"文件中读取配置，并返回配置对象。\n\n- `regist_father_info(self, record_dir)`：注册父信息。接受一个参数`record_dir`，表示记录的目录。在注册过程中，会将父信息以YAML格式保存到记录的根目录下的\"This-Is-A-Reload-Run.yml\"文件中。\n\n- `load_from_disk(self, record_dir)`：从磁盘加载记录。接受一个参数`record_dir`，表示记录的目录。在加载过程中，会读取记录目录下的相关文件，并将数据加载到对象的属性中。\n\n**注意**：在使用RunningRecoder类时，需要注意以下几点：\n- 在初始化对象时，可以指定记录的根目录，如果不指定，默认为\"./running_records/\"。\n- 在注册LLM输入输出对和工具服务器记录时，会将记录以JSON格式保存到相应的目录下。\n- 在查询LLM输入输出对和工具服务器缓存时，会根据输入参数和缓存中的记录进行匹配，如果匹配成功，则返回相应的输出数据。\n- 在注册查询和配置时，会将查询和配置以JSON和YAML格式保存到相应的文件中。\n- 在加载记录时，会读取记录目录下的相关文件，并将数据加载到对象的属性中。\n\n**输出示例**：\n```python\nrunning_recorder = RunningRecoder()\nrunning_recorder.regist_llm_inout(1, \"Hello\", output_data=\"World\")\nrunning_recorder.query_llm_inout(1, \"Hello\")  # 返回 \"World\"\n```",
            "code_start_line": 34,
            "code_end_line": 395,
            "parent": null,
            "have_return": true,
            "code_content": "class RunningRecoder():\n    \"\"\"\n    A class used to record the running sequences of the program, also including program query status and config data.\n\n    Attributes:\n        record_root_dir (str): The root directory of the running records.\n        newly_start (bool): A flag to indicate whether or not a new task has started.\n        toolserver_interface_id (int): The id of the tool server interface.\n        tool_call_id (int): The id of the tool call.\n        plan_refine_id (int): The id of the plan refinement.\n        llm_server_cache (dict): The cache for the llm server.\n        tool_server_cache (dict): The cache for the tool server.\n        tool_call_cache (dict): The cache for the tool call.\n        plan_refine_cache (dict): The cache for the plan refinement.\n        query_count (int): The count of the queries.\n    \"\"\"\n    def __init__(self, record_root_dir=\"./running_records/\"):\n        \"\"\"\n        Initialize the RunningRecorder.\n\n        Args:\n            record_root_dir (str): The root directory of the running records.\n        \"\"\"\n        now = int(round(time.time() * 1000))\n        strip = time.strftime('%Y_%m_%d_%H_%M_%S', time.localtime(now / 1000)) + uuid.uuid4().hex[:8]\n\n        self.record_root_dir = os.path.join(record_root_dir, strip)\n        os.makedirs(self.record_root_dir, exist_ok=True)\n\n        for subdir_name in [\"LLM_inout_pair\", \"tool_server_pair\"]:\n            os.makedirs(os.path.join(self.record_root_dir, subdir_name), exist_ok=True)\n\n        self.newly_start = True  \n\n        self.toolserver_interface_id = 0\n\n        self.tool_call_id = 0\n        self.plan_refine_id = 0\n\n        self.llm_server_cache = []\n        self.tool_server_cache = []\n        self.tool_call_cache = []\n        self.plan_refine_cache = []\n\n        self.query_count = 0\n\n    def get_query_id(self):\n        \"\"\"\n        Get the query id.\n\n        Returns:\n            int: The id of the query.\n        \"\"\"\n        query_id = deepcopy(self.query_count)\n        self.query_count += 1\n        return query_id\n\n    def decrease_query_id(self):\n        \"\"\"\n        Decrease the query id.\n        \"\"\"\n        self.query_count -= 1\n    \n    def change_now_task(self, new_subtask_id):\n        \"\"\"\n        Change the current subtask.\n\n        Args:\n            new_subtask_id (int): The id of the new subtask.\n        \"\"\"\n        self.now_subtask_id = new_subtask_id\n        self.tool_call_id = 0\n        self.plan_refine_id = 0\n\n    def regist_plan_modify(self, refine_function_name, refine_function_input, refine_function_output, plan_after):\n        \"\"\"\n        Register plan modification.\n\n        Args:\n            refine_function_name (str): The name of the refine function.\n            refine_function_input (Any): The input of the refine function.\n            refine_function_output (Any): The output of the refine function.\n            plan_after (str): The plan after modification.\n        \"\"\"\n        os.makedirs(os.path.join(self.record_root_dir, self.now_subtask_id), exist_ok=True)\n        with open(\n                os.path.join(self.record_root_dir, self.now_subtask_id, f\"plan_refine_{self.plan_refine_id:05d}.json\"),\"w\",encoding=\"utf-8\") as writer:\n            plan_refine_record = {\n                \"refine_function_name\": dump_common_things(refine_function_name),\n                \"refine_function_input\": dump_common_things(refine_function_input),\n                \"refine_function_output\": dump_common_things(refine_function_output),\n                \"plan_after\": dump_common_things(plan_after),\n            }\n            json.dump(plan_refine_record, writer, indent=2, ensure_ascii=False)\n\n        self.plan_refine_id += 1\n    def regist_llm_inout(self, llm_query_id, messages, functions=None, function_call=None, model=None, stop=None, output_data=None,**other_args):\n        \"\"\"\n        Register llm input output pairs.\n\n        Args:\n            llm_query_id (int): The id of the llm query.\n            messages (Any): The messages communicated.\n            functions (list, optional): The list of functions used.\n            function_call (Any, optional): The function called.\n            model (Any, optional): The model used.\n            stop (bool, optional): A flag to indicate whether or not to stop.\n            output_data (Any, optional): The output data.\n            other_args (dict, optional): Other arguments.\n        \"\"\"\n        with open(os.path.join(self.record_root_dir, \"LLM_inout_pair\", f\"{llm_query_id:05d}.json\"),\"w\",encoding=\"utf-8\") as writer:\n            llm_inout_record = {\n                \"input\": {\n                    \"messages\": dump_common_things(messages),\n                    \"functions\": dump_common_things(functions),\n                    \"function_call\": dump_common_things(function_call),\n                    \"model\": dump_common_things(model),\n                    \"stop\": dump_common_things(stop),\n                    \"other_args\": dump_common_things(other_args),\n                },\n                \"output\": dump_common_things(output_data),\n                \"llm_interface_id\": llm_query_id,\n            }\n            json.dump(llm_inout_record, writer, indent=2, ensure_ascii=False)\n            self.llm_server_cache.append(llm_inout_record)\n            logger.typewriter_log(\"LLM inout registed:\",Fore.RED, f\"query-id={llm_query_id}\",level=logging.DEBUG)\n\n    def query_llm_inout(self, llm_query_id, messages, functions=None, function_call=None, model=None, stop=None, **other_args):\n        \"\"\"\n        Query llm input and output pairs.\n\n        Args:\n            llm_query_id (int): The id of the llm query.\n            messages (Any): The messages communicated.\n            functions (list, optional): The list of functions used.\n            function_call (Any, optional): The function called.\n            model (Any, optional): The model used.\n            stop (bool, optional): A flag to indicate whether or not to stop.\n            other_args (dict, optional): Other arguments.\n\n        Returns:\n            Any: The output data.\n        \"\"\"\n        if self.newly_start:\n            return None\n        input_data = {\n            \"messages\": dump_common_things(messages),\n            \"functions\": dump_common_things(functions),\n            \"function_call\": dump_common_things(function_call),\n            \"model\": dump_common_things(model),\n            \"stop\": dump_common_things(stop),\n            \"other_args\": dump_common_things(other_args),\n        }\n        if llm_query_id >= len(self.llm_server_cache):\n            logger.typewriter_log(\"Reach the max length of record\")\n            return None\n        cache = self.llm_server_cache[llm_query_id]\n        if input_data == cache[\"input\"]:\n            logger.typewriter_log(\n                \"get a llm_server response from Record\",\n                Fore.BLUE,\n                f\"query-id={llm_query_id}\"\n            )\n            return cache[\"output\"]\n        \n        return None\n\n    def regist_tool_call(self, tool_name, tool_input, tool_output, tool_status_code, thought_data=None):\n        \"\"\"\n        Register tool call.\n\n        Args:\n            tool_name (str): The name of the tool.\n            tool_input (Any): The input for the tool.\n            tool_output (Any): The output from the tool.\n            tool_status_code (int): The status code of the tool.\n            thought_data (Any, optional): The thought data.\n        \"\"\"\n        os.makedirs(os.path.join(self.record_root_dir, self.now_subtask_id), exist_ok=True)\n        with open(os.path.join(self.record_root_dir, self.now_subtask_id, f\"tool_{self.tool_call_id:05d}.json\"),\"w\",encoding=\"utf-8\",) as writer:\n            tool_record = {\n                \"tool_name\": dump_common_things(tool_name),\n                \"tool_input\": dump_common_things(tool_input),\n                \"tool_output\": dump_common_things(tool_output),\n                \"tool_status_code\": dump_common_things(tool_status_code),\n            }\n            if thought_data:\n                tool_record[\"thought\"] = dump_common_things(thought_data)\n            json.dump(tool_record, writer, indent=2, ensure_ascii=False)\n\n        self.tool_call_id += 1\n\n    def regist_tool_server(self, url, payload, tool_output,  response_status_code):\n        \"\"\"\n        Register tool server.\n\n        Args:\n            url (str): The url of the server.\n            payload (Any): The payload for the tool.\n            tool_output (Any): The output from the tool.\n            response_status_code (int): The response status code.\n        \"\"\"\n        with open(os.path.join(self.record_root_dir, \"tool_server_pair\", f\"{self.toolserver_interface_id:05d}.json\"),\"w\",encoding=\"utf-8\",) as writer:\n            tool_record = {\n                \"url\": dump_common_things(url.split(\"/\")[-1]),\n                \"payload\": dump_common_things(payload),\n                \"response_status_code\": dump_common_things(response_status_code),\n                \"tool_output\": dump_common_things(tool_output),\n            }\n            json.dump(tool_record, writer, indent=2, ensure_ascii=False)\n\n        self.toolserver_interface_id += 1\n\n    def query_tool_server_cache(self, url, payload):\n        \"\"\"\n        Query the tool server.\n\n        Args:\n            url (str): The url of the server.\n            payload (Any): The payload to send.\n\n        Returns:\n            dict: The output from the tool server and the response status code.\n        \"\"\"\n        if self.newly_start:\n            return None\n        if self.toolserver_interface_id >= len(self.tool_server_cache):\n            return None\n\n        cache = self.tool_server_cache[self.toolserver_interface_id]\n\n        if cache[\"url\"] == url.split(\"/\")[-1] and cache[\"payload\"] == dump_common_things(payload):\n            logger.typewriter_log(\n                \"get a tool_server response from Record\",\n                Fore.BLUE,\n                cache[\"url\"],\n            )\n            return {\n                \"tool_output\": cache[\"tool_output\"], \n                \"response_status_code\": cache[\"response_status_code\"]\n            }\n\n        return None\n\n\n    def regist_query(self, query):\n        \"\"\"\n        Register a query.\n\n        Args:\n            query (AutoGPTQuery): The query to register.\n        \"\"\"\n        with open(os.path.join(self.record_root_dir, f\"query.json\"), \"w\",encoding=\"utf-8\",) as writer:\n            json.dump(query.to_json(), writer, indent=2, ensure_ascii=False)\n\n    def get_query(self):\n        \"\"\"\n        Get the registered query.\n\n        Returns:\n            AutoGPTQuery: The registered query.\n        \"\"\"\n        logger.typewriter_log(\n            \"load a query from Record\",\n            Fore.BLUE,\n        )\n        return self.query\n\n    def regist_config(self, config: XAgentConfig):\n        \"\"\"\n        Register a configuration.\n\n        Args:\n            config (XAgentConfig): The configuration to register.\n        \"\"\"\n        with open(os.path.join(self.record_root_dir, f\"config.yml\"), \"w\",encoding=\"utf-8\") as writer:\n            writer.write(yaml.safe_dump(dict(config.to_dict(safe=True)), allow_unicode=True))\n\n\n    def get_config(self):\n        \"\"\"\n        Get the registered configuration.\n\n        Returns:\n            XAgentConfig: The registered configuration.\n        \"\"\"\n        logger.typewriter_log(\n            \"load a config from Record\",\n            Fore.BLUE,\n        )\n        return self.config\n\n    def regist_father_info(self, record_dir):\n        \"\"\"\n        Register father info.\n\n        Args:\n            record_dir (str): The directory of the record.\n        \"\"\"\n        with open(os.path.join(self.record_root_dir, f\"This-Is-A-Reload-Run.yml\"), \"w\",encoding=\"utf-8\") as writer:\n            writer.write(yaml.safe_dump({\n                \"load_record_dir\": record_dir,\n            }, allow_unicode=True))\n\n    def load_from_disk(self, record_dir):\n        \"\"\"\n        Load from a record in disk.\n\n        Args:\n            record_dir (str): The directory of the record.\n        \"\"\"\n        logger.typewriter_log(\n            \"load from a disk record, overwrite all the existing config-info\",\n            Fore.BLUE,\n            record_dir,\n        )\n        self.regist_father_info(record_dir)\n        self.newly_start = False\n\n        for dir_name in os.listdir(record_dir):\n            if dir_name == \"query.json\":\n                with open(os.path.join(record_dir, dir_name), \"r\",encoding=\"utf-8\") as reader:\n                    self.query_json = json.load(reader)\n                    self.query = AutoGPTQuery.from_json(self.query_json)\n            elif dir_name == \"config.yml\":\n                CONFIG.reload(os.path.join(record_dir, dir_name))\n            elif dir_name == \"LLM_inout_pair\":\n                inout_count = len(os.listdir(os.path.join(record_dir, dir_name)))\n                self.llm_server_cache = [None]*inout_count\n                for file_name in os.listdir(os.path.join(record_dir, dir_name)):\n                    inout_id = int(file_name.split(\".\")[0])\n                    with open(os.path.join(record_dir, dir_name, file_name), \"r\",encoding=\"utf-8\") as reader:\n                        llm_pair = json.load(reader)\n                        self.llm_server_cache[inout_id] = llm_pair\n                logger.typewriter_log(\n                    f\"Record contain {inout_count} LLM inout\",\n                    Fore.BLUE,\n                )\n            elif dir_name == \"tool_server_pair\":\n                inout_count = len(os.listdir(os.path.join(record_dir, dir_name)))\n                self.tool_server_cache = [None]*inout_count\n                for file_name in os.listdir(os.path.join(record_dir, dir_name)):\n                    inout_id = int(file_name.split(\".\")[0])\n                    with open(os.path.join(record_dir, dir_name, file_name), \"r\",encoding=\"utf-8\") as reader:\n                        tool_pair = json.load(reader)\n                        self.tool_server_cache[inout_id] = tool_pair\n                logger.typewriter_log(\n                    f\"Record contain {len(os.listdir(os.path.join(record_dir, dir_name)))} Tool call\",\n                    Fore.BLUE,\n                )\n            elif os.path.isdir(os.path.join(record_dir, dir_name)):\n                for file_name in os.listdir(os.path.join(record_dir, dir_name)):\n                    if file_name.startswith(\"plan_refine\"):\n                        with open(os.path.join(record_dir, dir_name, file_name),encoding=\"utf-8\") as reader:\n                            plan_refine = json.load(reader)\n                            self.plan_refine_cache.append(plan_refine)\n                    elif file_name.startswith(\"tool\"):\n                        with open(os.path.join(record_dir, dir_name, file_name),encoding=\"utf-8\") as reader:\n                            tool_call = json.load(reader)\n                            self.tool_call_cache.append(tool_call)\n                    else:\n                        raise NotImplementedError\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__函数**：该函数的功能是初始化RunningRecorder。\n\n该函数接受一个参数record_root_dir，用于指定运行记录的根目录，默认为\"./running_records/\"。函数内部首先获取当前时间戳now，并将其转换为毫秒级别的时间戳。然后使用time模块将时间戳格式化为\"%Y_%m_%d_%H_%M_%S\"的字符串形式，并结合一个随机生成的8位十六进制字符串，生成一个唯一的strip字符串作为子目录的名称。\n\n接下来，函数将record_root_dir和strip拼接起来作为运行记录的根目录，并使用os.makedirs函数创建该目录（如果目录不存在）。\n\n然后，函数使用os.makedirs函数分别创建\"LLM_inout_pair\"和\"tool_server_pair\"两个子目录，用于存储LLM和工具服务器的运行记录。\n\n接下来，函数将self.newly_start设置为True，表示Recorder刚刚启动。\n\n然后，函数将self.toolserver_interface_id、self.tool_call_id和self.plan_refine_id都设置为0，用于记录工具服务器接口、工具调用和计划细化的ID。\n\n接下来，函数分别创建self.llm_server_cache、self.tool_server_cache、self.tool_call_cache和self.plan_refine_cache四个空列表，用于缓存LLM服务器、工具服务器、工具调用和计划细化的记录。\n\n最后，函数将self.query_count设置为0，用于记录查询次数。\n\n**注意**：使用该代码时需要注意以下几点：\n- record_root_dir参数用于指定运行记录的根目录，默认为\"./running_records/\"。\n- 该函数会根据当前时间和随机字符串生成一个唯一的子目录，用于存储运行记录。\n- 函数内部会创建\"LLM_inout_pair\"和\"tool_server_pair\"两个子目录，用于存储LLM和工具服务器的运行记录。\n- 使用该函数时，需要确保运行记录的根目录存在，并有足够的权限进行创建子目录和文件的操作。",
            "code_start_line": 50,
            "code_end_line": 78,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def __init__(self, record_root_dir=\"./running_records/\"):\n        \"\"\"\n        Initialize the RunningRecorder.\n\n        Args:\n            record_root_dir (str): The root directory of the running records.\n        \"\"\"\n        now = int(round(time.time() * 1000))\n        strip = time.strftime('%Y_%m_%d_%H_%M_%S', time.localtime(now / 1000)) + uuid.uuid4().hex[:8]\n\n        self.record_root_dir = os.path.join(record_root_dir, strip)\n        os.makedirs(self.record_root_dir, exist_ok=True)\n\n        for subdir_name in [\"LLM_inout_pair\", \"tool_server_pair\"]:\n            os.makedirs(os.path.join(self.record_root_dir, subdir_name), exist_ok=True)\n\n        self.newly_start = True  \n\n        self.toolserver_interface_id = 0\n\n        self.tool_call_id = 0\n        self.plan_refine_id = 0\n\n        self.llm_server_cache = []\n        self.tool_server_cache = []\n        self.tool_call_cache = []\n        self.plan_refine_cache = []\n\n        self.query_count = 0\n",
            "name_column": 8
        },
        "get_query_id": {
            "type": "FunctionDef",
            "name": "get_query_id",
            "md_content": "**get_query_id函数**：该函数的作用是获取查询的id。\n\n该函数首先使用深拷贝将查询计数器的值赋给query_id变量，然后将查询计数器的值加1。最后返回query_id作为查询的id。\n\n该函数没有任何参数。\n\n**注意**：在调用该函数之前，需要确保查询计数器的值已经正确初始化。\n\n**输出示例**：假设查询计数器的初始值为0，调用get_query_id函数后，返回值为1。",
            "code_start_line": 80,
            "code_end_line": 89,
            "parent": "RunningRecoder",
            "have_return": true,
            "code_content": "    def get_query_id(self):\n        \"\"\"\n        Get the query id.\n\n        Returns:\n            int: The id of the query.\n        \"\"\"\n        query_id = deepcopy(self.query_count)\n        self.query_count += 1\n        return query_id\n",
            "name_column": 8
        },
        "decrease_query_id": {
            "type": "FunctionDef",
            "name": "decrease_query_id",
            "md_content": "**decrease_query_id函数**：该函数的功能是减少查询ID。\n\n该函数用于减少查询ID。在调用该函数时，会将查询计数减1。\n\n**注意**：在使用该代码时需要注意以下几点：\n- 该函数只能在ToolServerManager类的实例对象中调用。\n- 调用该函数后，查询计数会减少1。",
            "code_start_line": 91,
            "code_end_line": 95,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def decrease_query_id(self):\n        \"\"\"\n        Decrease the query id.\n        \"\"\"\n        self.query_count -= 1\n",
            "name_column": 8
        },
        "change_now_task": {
            "type": "FunctionDef",
            "name": "change_now_task",
            "md_content": "**change_now_task函数**: 这个函数的功能是改变当前子任务。\n\n这个函数接受一个参数new_subtask_id，它是新子任务的id。在函数内部，它将当前子任务的id（now_subtask_id）设置为new_subtask_id，将工具调用的id（tool_call_id）设置为0，将计划细化的id（plan_refine_id）设置为0。\n\n**注意**: 使用这段代码时需要注意以下几点：\n- 确保传入的new_subtask_id是一个整数类型的值。\n- 在调用这个函数之后，当前子任务的id将被改变，工具调用的id和计划细化的id将被重置为0。",
            "code_start_line": 97,
            "code_end_line": 106,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def change_now_task(self, new_subtask_id):\n        \"\"\"\n        Change the current subtask.\n\n        Args:\n            new_subtask_id (int): The id of the new subtask.\n        \"\"\"\n        self.now_subtask_id = new_subtask_id\n        self.tool_call_id = 0\n        self.plan_refine_id = 0\n",
            "name_column": 8
        },
        "regist_plan_modify": {
            "type": "FunctionDef",
            "name": "regist_plan_modify",
            "md_content": "**regist_plan_modify函数**：该函数的功能是注册计划修改。\n\n该函数用于注册计划的修改，接收四个参数：refine_function_name（修改函数的名称）、refine_function_input（修改函数的输入）、refine_function_output（修改函数的输出）和plan_after（修改后的计划）。该函数会将修改后的计划记录到文件中。\n\n在函数内部，首先会创建一个目录，用于存储记录文件。然后，使用`open`函数创建一个文件对象，将修改后的计划记录写入文件中。计划的记录以JSON格式保存，包括修改函数的名称、输入、输出以及修改后的计划。最后，通过`json.dump`函数将记录写入文件。\n\n需要注意的是，函数中使用了`os.makedirs`函数创建目录，确保目录存在。同时，使用`json.dump`函数将记录以JSON格式写入文件时，需要指定`indent`参数为2，以便以缩进的形式保存JSON数据。\n\n**注意**：在使用该函数时，需要确保`self.record_root_dir`和`self.now_subtask_id`的值已经正确设置，以便正确创建记录文件的路径。此外，还需要注意确保文件的编码为UTF-8。",
            "code_start_line": 108,
            "code_end_line": 129,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def regist_plan_modify(self, refine_function_name, refine_function_input, refine_function_output, plan_after):\n        \"\"\"\n        Register plan modification.\n\n        Args:\n            refine_function_name (str): The name of the refine function.\n            refine_function_input (Any): The input of the refine function.\n            refine_function_output (Any): The output of the refine function.\n            plan_after (str): The plan after modification.\n        \"\"\"\n        os.makedirs(os.path.join(self.record_root_dir, self.now_subtask_id), exist_ok=True)\n        with open(\n                os.path.join(self.record_root_dir, self.now_subtask_id, f\"plan_refine_{self.plan_refine_id:05d}.json\"),\"w\",encoding=\"utf-8\") as writer:\n            plan_refine_record = {\n                \"refine_function_name\": dump_common_things(refine_function_name),\n                \"refine_function_input\": dump_common_things(refine_function_input),\n                \"refine_function_output\": dump_common_things(refine_function_output),\n                \"plan_after\": dump_common_things(plan_after),\n            }\n            json.dump(plan_refine_record, writer, indent=2, ensure_ascii=False)\n\n        self.plan_refine_id += 1\n",
            "name_column": 8
        },
        "regist_llm_inout": {
            "type": "FunctionDef",
            "name": "regist_llm_inout",
            "md_content": "**regist_llm_inout函数**：这个函数的功能是注册llm的输入输出对。\n\n该函数用于注册llm的输入输出对。它接受以下参数：\n- llm_query_id（int）：llm查询的id。\n- messages（Any）：通信的消息。\n- functions（list，可选）：使用的函数列表。\n- function_call（Any，可选）：调用的函数。\n- model（Any，可选）：使用的模型。\n- stop（bool，可选）：一个标志，指示是否停止。\n- output_data（Any，可选）：输出数据。\n- other_args（dict，可选）：其他参数。\n\n该函数首先将llm的输入输出对记录到文件中。它创建一个包含输入和输出信息的字典，并将其转换为JSON格式后写入文件。然后，它将记录添加到llm_server_cache列表中，并使用logger.typewriter_log函数打印日志信息。\n\n在项目中的XAgent/ai_functions/request/obj_generator.py文件中的chatcompletion函数中调用了regist_llm_inout函数。在调用之前，先获取了llm_query_id，并将其作为参数传递给regist_llm_inout函数。调用regist_llm_inout函数后，将llm_query_id、copyed_kwargs和response作为参数传递给regist_llm_inout函数。\n\n**注意**：在使用regist_llm_inout函数时，需要注意传递正确的参数，并确保llm_query_id的唯一性。",
            "code_start_line": 130,
            "code_end_line": 159,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def regist_llm_inout(self, llm_query_id, messages, functions=None, function_call=None, model=None, stop=None, output_data=None,**other_args):\n        \"\"\"\n        Register llm input output pairs.\n\n        Args:\n            llm_query_id (int): The id of the llm query.\n            messages (Any): The messages communicated.\n            functions (list, optional): The list of functions used.\n            function_call (Any, optional): The function called.\n            model (Any, optional): The model used.\n            stop (bool, optional): A flag to indicate whether or not to stop.\n            output_data (Any, optional): The output data.\n            other_args (dict, optional): Other arguments.\n        \"\"\"\n        with open(os.path.join(self.record_root_dir, \"LLM_inout_pair\", f\"{llm_query_id:05d}.json\"),\"w\",encoding=\"utf-8\") as writer:\n            llm_inout_record = {\n                \"input\": {\n                    \"messages\": dump_common_things(messages),\n                    \"functions\": dump_common_things(functions),\n                    \"function_call\": dump_common_things(function_call),\n                    \"model\": dump_common_things(model),\n                    \"stop\": dump_common_things(stop),\n                    \"other_args\": dump_common_things(other_args),\n                },\n                \"output\": dump_common_things(output_data),\n                \"llm_interface_id\": llm_query_id,\n            }\n            json.dump(llm_inout_record, writer, indent=2, ensure_ascii=False)\n            self.llm_server_cache.append(llm_inout_record)\n            logger.typewriter_log(\"LLM inout registed:\",Fore.RED, f\"query-id={llm_query_id}\",level=logging.DEBUG)\n",
            "name_column": 8
        },
        "query_llm_inout": {
            "type": "FunctionDef",
            "name": "query_llm_inout",
            "md_content": "**query_llm_inout函数**：该函数的功能是查询llm的输入和输出对。\n\n该函数接受以下参数：\n- llm_query_id（int）：llm查询的id。\n- messages（Any）：通信的消息。\n- functions（list，可选）：使用的函数列表。\n- function_call（Any，可选）：调用的函数。\n- model（Any，可选）：使用的模型。\n- stop（bool，可选）：一个标志，指示是否停止。\n- other_args（dict，可选）：其他参数。\n\n该函数的返回值为任意类型的输出数据。\n\n该函数首先判断是否是新启动的状态，如果是，则返回None。接着，将输入数据以字典形式存储在input_data变量中。然后，判断llm_query_id是否超过了llm_server_cache的长度，如果是，则打印日志信息并返回None。接下来，将llm_query_id对应的缓存数据存储在cache变量中。如果input_data与cache[\"input\"]相等，则打印日志信息并返回cache[\"output\"]。否则，返回None。\n\n该函数在以下文件中被调用：\n文件路径：XAgent/ai_functions/request/obj_generator.py\n调用代码如下：\n```python\ndef chatcompletion(self, *, schema_validation=True, **kwargs):\n    \"\"\"\n    处理聊天完成请求并获取响应。\n\n    参数：\n        kwargs：请求数据参数。\n\n    返回值：\n        从AI服务调用中检索到的字典格式响应。\n\n    异常：\n        Exception：处理请求时发生错误。\n        NotImplementedError：接收到的请求类型当前未实现。\n    \"\"\"\n    \n    request_type = kwargs.pop('request_type', CONFIG.default_request_type)\n    for k in list(kwargs.keys()):\n        if kwargs[k] is None:\n            kwargs.pop(k)\n    \n    llm_query_id = recorder.get_query_id()\n    try:   \n        copyed_kwargs = deepcopy(kwargs)\n        if (response := recorder.query_llm_inout(llm_query_id=llm_query_id, **copyed_kwargs)) is None:\n            response = self._get_chatcompletion_request_func(request_type)(**kwargs)\n        recorder.regist_llm_inout(llm_query_id=llm_query_id, **copyed_kwargs, output_data=response)\n    except Exception as e:\n        traceback.print_exc()\n        logger.typewriter_log(f\"chatcompletion error: {e}\", Fore.RED)\n        recorder.decrease_query_id()\n        raise e\n\n    if schema_validation:\n        # refine the response\n        match request_type:\n            case 'openai':                \n                response = self.function_call_refine(kwargs, response)\n            case 'xagent':\n                pass\n            case _:\n                raise NotImplementedError(f\"Request type {request_type} not implemented\")\n    \n    return response\n```\n\n**注意**：关于代码使用的注意事项。\n\n**输出示例**：模拟代码返回值的可能外观。",
            "code_start_line": 161,
            "code_end_line": 199,
            "parent": "RunningRecoder",
            "have_return": true,
            "code_content": "    def query_llm_inout(self, llm_query_id, messages, functions=None, function_call=None, model=None, stop=None, **other_args):\n        \"\"\"\n        Query llm input and output pairs.\n\n        Args:\n            llm_query_id (int): The id of the llm query.\n            messages (Any): The messages communicated.\n            functions (list, optional): The list of functions used.\n            function_call (Any, optional): The function called.\n            model (Any, optional): The model used.\n            stop (bool, optional): A flag to indicate whether or not to stop.\n            other_args (dict, optional): Other arguments.\n\n        Returns:\n            Any: The output data.\n        \"\"\"\n        if self.newly_start:\n            return None\n        input_data = {\n            \"messages\": dump_common_things(messages),\n            \"functions\": dump_common_things(functions),\n            \"function_call\": dump_common_things(function_call),\n            \"model\": dump_common_things(model),\n            \"stop\": dump_common_things(stop),\n            \"other_args\": dump_common_things(other_args),\n        }\n        if llm_query_id >= len(self.llm_server_cache):\n            logger.typewriter_log(\"Reach the max length of record\")\n            return None\n        cache = self.llm_server_cache[llm_query_id]\n        if input_data == cache[\"input\"]:\n            logger.typewriter_log(\n                \"get a llm_server response from Record\",\n                Fore.BLUE,\n                f\"query-id={llm_query_id}\"\n            )\n            return cache[\"output\"]\n        \n        return None\n",
            "name_column": 8
        },
        "regist_tool_call": {
            "type": "FunctionDef",
            "name": "regist_tool_call",
            "md_content": "**regist_tool_call函数**：该函数的功能是注册工具调用。\n\n该函数用于注册工具的调用信息，包括工具的名称、输入、输出、状态码以及思考数据。具体参数说明如下：\n\n- tool_name (str)：工具的名称。\n- tool_input (Any)：工具的输入。\n- tool_output (Any)：工具的输出。\n- tool_status_code (int)：工具的状态码。\n- thought_data (Any, 可选)：思考数据。\n\n函数内部首先创建一个目录，用于存储记录的信息。然后将工具的调用信息以JSON格式写入文件中。具体步骤如下：\n\n1. 使用`os.makedirs`函数创建目录，目录路径为`self.record_root_dir`和`self.now_subtask_id`的组合。如果目录已存在，则不进行任何操作。\n2. 使用`open`函数打开文件，文件路径为`self.record_root_dir`、`self.now_subtask_id`和`tool_{self.tool_call_id:05d}.json`的组合。以写入模式打开文件，并指定编码为UTF-8。\n3. 创建一个字典`tool_record`，包含工具的名称、输入、输出和状态码。使用`dump_common_things`函数对这些信息进行序列化处理。\n4. 如果存在思考数据，则将思考数据添加到`tool_record`字典中，同样使用`dump_common_things`函数进行序列化处理。\n5. 使用`json.dump`函数将`tool_record`字典以缩进为2的格式写入文件中，同时确保不进行ASCII编码。\n6. 增加`self.tool_call_id`的值，用于记录下一个工具调用的ID。\n\n**注意**：在使用该函数时，需要确保`self.record_root_dir`和`self.now_subtask_id`的值已经正确设置，并且`dump_common_things`函数能够正确序列化工具的输入、输出和状态码。",
            "code_start_line": 201,
            "code_end_line": 224,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def regist_tool_call(self, tool_name, tool_input, tool_output, tool_status_code, thought_data=None):\n        \"\"\"\n        Register tool call.\n\n        Args:\n            tool_name (str): The name of the tool.\n            tool_input (Any): The input for the tool.\n            tool_output (Any): The output from the tool.\n            tool_status_code (int): The status code of the tool.\n            thought_data (Any, optional): The thought data.\n        \"\"\"\n        os.makedirs(os.path.join(self.record_root_dir, self.now_subtask_id), exist_ok=True)\n        with open(os.path.join(self.record_root_dir, self.now_subtask_id, f\"tool_{self.tool_call_id:05d}.json\"),\"w\",encoding=\"utf-8\",) as writer:\n            tool_record = {\n                \"tool_name\": dump_common_things(tool_name),\n                \"tool_input\": dump_common_things(tool_input),\n                \"tool_output\": dump_common_things(tool_output),\n                \"tool_status_code\": dump_common_things(tool_status_code),\n            }\n            if thought_data:\n                tool_record[\"thought\"] = dump_common_things(thought_data)\n            json.dump(tool_record, writer, indent=2, ensure_ascii=False)\n\n        self.tool_call_id += 1\n",
            "name_column": 8
        },
        "regist_tool_server": {
            "type": "FunctionDef",
            "name": "regist_tool_server",
            "md_content": "**regist_tool_server函数**：这个函数的功能是注册工具服务器。\n\n该函数的作用是将工具服务器的相关信息记录下来，并保存到文件中。具体来说，该函数接收四个参数：url（服务器的URL）、payload（工具的输入参数）、tool_output（工具的输出结果）和response_status_code（响应状态码）。然后，函数将这些信息以JSON格式保存到文件中。\n\n在函数内部，首先使用`open`函数打开一个文件，将文件路径设置为`self.record_root_dir`下的`tool_server_pair`目录，并以`self.toolserver_interface_id:05d`作为文件名。然后，创建一个字典`tool_record`，将传入的参数以及一些其他信息存储在其中。接下来，使用`json.dump`函数将`tool_record`以缩进为2的格式写入文件中。\n\n最后，将`self.toolserver_interface_id`加1，以便下一次记录时使用新的文件名。\n\n**注意**：在使用该函数时，需要确保传入正确的参数，并且`self.record_root_dir`和`self.toolserver_interface_id`的值已经正确设置。另外，需要注意文件的编码格式为UTF-8。",
            "code_start_line": 226,
            "code_end_line": 245,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def regist_tool_server(self, url, payload, tool_output,  response_status_code):\n        \"\"\"\n        Register tool server.\n\n        Args:\n            url (str): The url of the server.\n            payload (Any): The payload for the tool.\n            tool_output (Any): The output from the tool.\n            response_status_code (int): The response status code.\n        \"\"\"\n        with open(os.path.join(self.record_root_dir, \"tool_server_pair\", f\"{self.toolserver_interface_id:05d}.json\"),\"w\",encoding=\"utf-8\",) as writer:\n            tool_record = {\n                \"url\": dump_common_things(url.split(\"/\")[-1]),\n                \"payload\": dump_common_things(payload),\n                \"response_status_code\": dump_common_things(response_status_code),\n                \"tool_output\": dump_common_things(tool_output),\n            }\n            json.dump(tool_record, writer, indent=2, ensure_ascii=False)\n\n        self.toolserver_interface_id += 1\n",
            "name_column": 8
        },
        "query_tool_server_cache": {
            "type": "FunctionDef",
            "name": "query_tool_server_cache",
            "md_content": "**query_tool_server_cache函数**：该函数的功能是查询工具服务器。\n\n该函数接受两个参数，url和payload。url是服务器的URL地址，payload是要发送的数据。\n\n函数首先会检查是否是新启动的工具服务器，如果是，则返回None。然后会检查toolserver_interface_id是否超过了工具服务器缓存的长度，如果超过了，则返回None。\n\n接下来，函数会获取tool_server_cache中对应toolserver_interface_id的缓存数据。\n\n函数会比较缓存数据中的url和payload是否与传入的参数相匹配，如果匹配，则返回缓存数据中的工具服务器响应结果和响应状态码。\n\n如果没有匹配的缓存数据，则返回None。\n\n**注意**：使用该代码时需要注意以下几点：\n- 需要传入正确的url和payload参数。\n- 需要确保工具服务器缓存中存在对应的数据。\n\n**输出示例**：模拟代码返回值的可能外观。\n\n{\n    \"tool_output\": \"工具服务器响应结果\",\n    \"response_status_code\": \"响应状态码\"\n}",
            "code_start_line": 247,
            "code_end_line": 276,
            "parent": "RunningRecoder",
            "have_return": true,
            "code_content": "    def query_tool_server_cache(self, url, payload):\n        \"\"\"\n        Query the tool server.\n\n        Args:\n            url (str): The url of the server.\n            payload (Any): The payload to send.\n\n        Returns:\n            dict: The output from the tool server and the response status code.\n        \"\"\"\n        if self.newly_start:\n            return None\n        if self.toolserver_interface_id >= len(self.tool_server_cache):\n            return None\n\n        cache = self.tool_server_cache[self.toolserver_interface_id]\n\n        if cache[\"url\"] == url.split(\"/\")[-1] and cache[\"payload\"] == dump_common_things(payload):\n            logger.typewriter_log(\n                \"get a tool_server response from Record\",\n                Fore.BLUE,\n                cache[\"url\"],\n            )\n            return {\n                \"tool_output\": cache[\"tool_output\"], \n                \"response_status_code\": cache[\"response_status_code\"]\n            }\n\n        return None\n",
            "name_column": 8
        },
        "regist_query": {
            "type": "FunctionDef",
            "name": "regist_query",
            "md_content": "**regist_query函数**：该函数的功能是注册一个查询。\n\n该函数接受一个名为query的参数，该参数是一个AutoGPTQuery对象，表示要注册的查询。\n\n函数内部通过打开一个名为\"query.json\"的文件，并以写入模式打开，将query对象转换为JSON格式，并写入文件中。写入时使用了UTF-8编码，并设置了缩进为2个空格，确保写入的内容是可读的，并且不使用ASCII编码。\n\n**注意**：使用该代码时需要注意以下几点：\n- 确保self.record_root_dir变量指向正确的目录，以便正确保存查询文件。\n- 确保query对象是AutoGPTQuery类型的对象，否则可能会导致写入的内容不符合预期。",
            "code_start_line": 279,
            "code_end_line": 287,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def regist_query(self, query):\n        \"\"\"\n        Register a query.\n\n        Args:\n            query (AutoGPTQuery): The query to register.\n        \"\"\"\n        with open(os.path.join(self.record_root_dir, f\"query.json\"), \"w\",encoding=\"utf-8\",) as writer:\n            json.dump(query.to_json(), writer, indent=2, ensure_ascii=False)\n",
            "name_column": 8
        },
        "get_query": {
            "type": "FunctionDef",
            "name": "get_query",
            "md_content": "**get_query函数**：该函数的功能是获取已注册的查询。\n\n该函数用于从记录中获取已注册的查询，并返回该查询。在函数内部，首先使用logger.typewriter_log函数记录一条日志，表示正在从记录中加载查询。然后，函数返回已注册的查询。\n\n**注意**：使用该函数前需要确保已注册查询。\n\n**输出示例**：返回已注册的查询对象。",
            "code_start_line": 289,
            "code_end_line": 300,
            "parent": "RunningRecoder",
            "have_return": true,
            "code_content": "    def get_query(self):\n        \"\"\"\n        Get the registered query.\n\n        Returns:\n            AutoGPTQuery: The registered query.\n        \"\"\"\n        logger.typewriter_log(\n            \"load a query from Record\",\n            Fore.BLUE,\n        )\n        return self.query\n",
            "name_column": 8
        },
        "regist_config": {
            "type": "FunctionDef",
            "name": "regist_config",
            "md_content": "**regist_config函数**：这个函数的功能是注册一个配置。\n\n该函数接受一个名为config的参数，类型为XAgentConfig，表示要注册的配置。\n\n函数内部通过打开一个名为config.yml的文件，并将config对象转换为字典形式后写入文件中。写入时使用了yaml.safe_dump函数将字典转换为yaml格式，并设置了参数allow_unicode=True以支持中文字符。\n\n**注意**：使用该代码时需要注意以下几点：\n- 确保record_root_dir变量指定的目录存在，并且有写入权限。\n- 确保XAgentConfig对象的to_dict方法能够正确地将配置转换为字典形式。",
            "code_start_line": 302,
            "code_end_line": 310,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def regist_config(self, config: XAgentConfig):\n        \"\"\"\n        Register a configuration.\n\n        Args:\n            config (XAgentConfig): The configuration to register.\n        \"\"\"\n        with open(os.path.join(self.record_root_dir, f\"config.yml\"), \"w\",encoding=\"utf-8\") as writer:\n            writer.write(yaml.safe_dump(dict(config.to_dict(safe=True)), allow_unicode=True))\n",
            "name_column": 8
        },
        "get_config": {
            "type": "FunctionDef",
            "name": "get_config",
            "md_content": "**get_config函数**：该函数的功能是获取已注册的配置。\n\n该函数用于从记录中获取已注册的配置，并返回一个XAgentConfig对象。在函数内部，首先使用logger.typewriter_log函数记录一条日志，该日志内容为\"load a config from Record\"，并设置日志颜色为蓝色。然后，函数返回self.config，即已注册的配置。\n\n**注意**：使用该函数前需要确保已注册配置，并且需要导入XAgentConfig类。\n\n**输出示例**：返回一个已注册的配置对象XAgentConfig。",
            "code_start_line": 313,
            "code_end_line": 324,
            "parent": "RunningRecoder",
            "have_return": true,
            "code_content": "    def get_config(self):\n        \"\"\"\n        Get the registered configuration.\n\n        Returns:\n            XAgentConfig: The registered configuration.\n        \"\"\"\n        logger.typewriter_log(\n            \"load a config from Record\",\n            Fore.BLUE,\n        )\n        return self.config\n",
            "name_column": 8
        },
        "regist_father_info": {
            "type": "FunctionDef",
            "name": "regist_father_info",
            "md_content": "**regist_father_info函数**: 这个函数的功能是注册父信息。\n\n该函数接受一个参数record_dir，表示记录的目录。函数的作用是将记录的目录信息写入到文件中。\n\n在函数内部，使用open函数创建一个文件，文件名为\"This-Is-A-Reload-Run.yml\"，并以写入模式打开。然后使用yaml.safe_dump函数将record_dir的值以字典的形式写入文件中。写入的内容是一个字典，包含一个键值对，键为\"load_record_dir\"，值为record_dir。最后关闭文件。\n\n**注意**: 使用该函数时需要传入正确的record_dir参数，确保目录存在且具有写入权限。",
            "code_start_line": 326,
            "code_end_line": 336,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def regist_father_info(self, record_dir):\n        \"\"\"\n        Register father info.\n\n        Args:\n            record_dir (str): The directory of the record.\n        \"\"\"\n        with open(os.path.join(self.record_root_dir, f\"This-Is-A-Reload-Run.yml\"), \"w\",encoding=\"utf-8\") as writer:\n            writer.write(yaml.safe_dump({\n                \"load_record_dir\": record_dir,\n            }, allow_unicode=True))\n",
            "name_column": 8
        },
        "load_from_disk": {
            "type": "FunctionDef",
            "name": "load_from_disk",
            "md_content": "**load_from_disk函数**：该函数的功能是从磁盘中加载记录。\n\n该函数接受一个参数record_dir，表示记录的目录。\n\n函数首先使用logger.typewriter_log函数打印一条日志，指示正在从磁盘记录中加载数据，并覆盖所有现有的配置信息。日志的内容为\"load from a disk record, overwrite all the existing config-info\"，使用蓝色字体显示，并附带record_dir作为参数。\n\n接下来，函数调用self.regist_father_info函数，将record_dir作为参数传递给该函数。\n\n然后，函数将self.newly_start设置为False。\n\n接下来，函数遍历record_dir目录下的所有文件和文件夹。对于每个文件夹，函数根据文件夹的名称进行不同的处理。\n\n如果文件夹的名称为\"query.json\"，则打开该文件并使用json.load函数将其内容加载为self.query_json。然后，函数调用AutoGPTQuery.from_json函数，将self.query_json转换为AutoGPTQuery对象，并将其赋值给self.query。\n\n如果文件夹的名称为\"config.yml\"，则调用CONFIG.reload函数，将该文件的路径作为参数传递给该函数。\n\n如果文件夹的名称为\"LLM_inout_pair\"，则遍历该文件夹下的所有文件。对于每个文件，函数解析文件名中的数字作为inout_id，并使用json.load函数将文件内容加载为llm_pair。然后，将llm_pair存储在self.llm_server_cache列表的相应位置。\n\n如果文件夹的名称为\"tool_server_pair\"，则遍历该文件夹下的所有文件。对于每个文件，函数解析文件名中的数字作为inout_id，并使用json.load函数将文件内容加载为tool_pair。然后，将tool_pair存储在self.tool_server_cache列表的相应位置。\n\n如果文件夹的名称为其他名称，并且该文件夹是一个子文件夹，则遍历该子文件夹下的所有文件。对于每个文件，函数根据文件名的前缀进行不同的处理。如果文件名以\"plan_refine\"开头，则使用json.load函数将文件内容加载为plan_refine，并将其添加到self.plan_refine_cache列表中。如果文件名以\"tool\"开头，则使用json.load函数将文件内容加载为tool_call，并将其添加到self.tool_call_cache列表中。否则，抛出NotImplementedError异常。\n\n**注意**：在使用该函数时需要注意以下几点：\n- 函数需要传入一个有效的记录目录，否则会出现错误。\n- 记录目录中需要包含特定的文件和文件夹，否则函数无法正确加载数据。\n- 函数会覆盖所有现有的配置信息，需要谨慎使用。",
            "code_start_line": 338,
            "code_end_line": 395,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def load_from_disk(self, record_dir):\n        \"\"\"\n        Load from a record in disk.\n\n        Args:\n            record_dir (str): The directory of the record.\n        \"\"\"\n        logger.typewriter_log(\n            \"load from a disk record, overwrite all the existing config-info\",\n            Fore.BLUE,\n            record_dir,\n        )\n        self.regist_father_info(record_dir)\n        self.newly_start = False\n\n        for dir_name in os.listdir(record_dir):\n            if dir_name == \"query.json\":\n                with open(os.path.join(record_dir, dir_name), \"r\",encoding=\"utf-8\") as reader:\n                    self.query_json = json.load(reader)\n                    self.query = AutoGPTQuery.from_json(self.query_json)\n            elif dir_name == \"config.yml\":\n                CONFIG.reload(os.path.join(record_dir, dir_name))\n            elif dir_name == \"LLM_inout_pair\":\n                inout_count = len(os.listdir(os.path.join(record_dir, dir_name)))\n                self.llm_server_cache = [None]*inout_count\n                for file_name in os.listdir(os.path.join(record_dir, dir_name)):\n                    inout_id = int(file_name.split(\".\")[0])\n                    with open(os.path.join(record_dir, dir_name, file_name), \"r\",encoding=\"utf-8\") as reader:\n                        llm_pair = json.load(reader)\n                        self.llm_server_cache[inout_id] = llm_pair\n                logger.typewriter_log(\n                    f\"Record contain {inout_count} LLM inout\",\n                    Fore.BLUE,\n                )\n            elif dir_name == \"tool_server_pair\":\n                inout_count = len(os.listdir(os.path.join(record_dir, dir_name)))\n                self.tool_server_cache = [None]*inout_count\n                for file_name in os.listdir(os.path.join(record_dir, dir_name)):\n                    inout_id = int(file_name.split(\".\")[0])\n                    with open(os.path.join(record_dir, dir_name, file_name), \"r\",encoding=\"utf-8\") as reader:\n                        tool_pair = json.load(reader)\n                        self.tool_server_cache[inout_id] = tool_pair\n                logger.typewriter_log(\n                    f\"Record contain {len(os.listdir(os.path.join(record_dir, dir_name)))} Tool call\",\n                    Fore.BLUE,\n                )\n            elif os.path.isdir(os.path.join(record_dir, dir_name)):\n                for file_name in os.listdir(os.path.join(record_dir, dir_name)):\n                    if file_name.startswith(\"plan_refine\"):\n                        with open(os.path.join(record_dir, dir_name, file_name),encoding=\"utf-8\") as reader:\n                            plan_refine = json.load(reader)\n                            self.plan_refine_cache.append(plan_refine)\n                    elif file_name.startswith(\"tool\"):\n                        with open(os.path.join(record_dir, dir_name, file_name),encoding=\"utf-8\") as reader:\n                            tool_call = json.load(reader)\n                            self.tool_call_cache.append(tool_call)\n                    else:\n                        raise NotImplementedError\n",
            "name_column": 8
        }
    },
    "XAgent/recorder.py": {
        "dump_common_things": {
            "type": "FunctionDef",
            "name": "dump_common_things",
            "md_content": "**dump_common_things函数**: 这个函数的功能是将对象转换为可序列化的形式。\n\n该函数接受一个对象作为参数，并根据对象的类型进行不同的处理。如果对象的类型是字符串、整数、浮点数或布尔值之一，则直接返回该对象。如果对象是字典类型，则递归地对字典的键和值进行处理，并返回处理后的字典。如果对象是列表类型，则递归地对列表中的每个元素进行处理，并返回处理后的列表。\n\n如果对象具有名为\"to_json\"的方法，并且该方法是可调用的，则调用该方法并返回其结果。\n\n该函数的主要作用是将复杂的对象转换为可序列化的形式，以便在存储或传输数据时使用。\n\n**注意**: \n- 该函数对于复杂对象的处理是递归的，因此需要确保对象的属性和方法能够正确地处理。\n- 该函数假设对象的属性和方法都是可序列化的，否则可能会导致错误或异常。\n\n**输出示例**:\n- 示例1:\n  ```\n  object = \"Hello World\"\n  result = dump_common_things(object)\n  print(result)\n  输出: \"Hello World\"\n  ```\n\n- 示例2:\n  ```\n  object = {\"name\": \"John\", \"age\": 30}\n  result = dump_common_things(object)\n  print(result)\n  输出: {\"name\": \"John\", \"age\": 30}\n  ```\n\n- 示例3:\n  ```\n  object = [1, 2, 3, {\"name\": \"John\"}]\n  result = dump_common_things(object)\n  print(result)\n  输出: [1, 2, 3, {\"name\": \"John\"}]\n  ```\n\n- 示例4:\n  ```\n  class Person:\n      def __init__(self, name):\n          self.name = name\n      def to_json(self):\n          return {\"name\": self.name}\n  \n  object = Person(\"John\")\n  result = dump_common_things(object)\n  print(result)\n  输出: {\"name\": \"John\"}\n  ```\n\n以上是对dump_common_things函数的详细分析和说明。该函数的主要作用是将对象转换为可序列化的形式，以便在存储或传输数据时使用。需要注意的是，该函数对于复杂对象的处理是递归的，因此需要确保对象的属性和方法都是可序列化的。",
            "code_start_line": 19,
            "code_end_line": 29,
            "parent": null,
            "have_return": true,
            "code_content": "def dump_common_things(object):\n    \"\"\"common\"\"\"\n    if type(object) in [str, int, float, bool]:\n        return object\n    if isinstance(object, dict):\n        return {dump_common_things(key): dump_common_things(value) for key, value in object.items()}\n    if isinstance(object, list):\n        return [dump_common_things(cont) for cont in object]\n    method = getattr(object, 'to_json', None)\n    if callable(method):\n        return method()\n",
            "name_column": 4
        },
        "get_db": {
            "type": "FunctionDef",
            "name": "get_db",
            "md_content": "**get_db函数**：该函数的功能是提供一个围绕一系列操作的事务范围。\n\n该函数使用了一个上下文管理器（context manager）来创建一个数据库会话（session），并在操作完成后进行提交或回滚。具体流程如下：\n\n1. 创建一个数据库会话（session）。\n2. 使用yield语句将会话（session）作为生成器的返回值，使得函数可以在yield处暂停执行，并在下次调用时从yield处继续执行。\n3. 在try块中执行yield语句，将会话（session）作为生成器的返回值返回给调用者，并等待调用者继续执行。\n4. 如果try块中的代码执行出现异常，则执行except块中的代码，回滚会话（session）中的操作，并重新抛出异常。\n5. 无论try块中的代码是否出现异常，都会执行finally块中的代码，关闭会话（session）。\n\n**注意**：在使用get_db函数时，需要将其放在with语句中，以确保会话（session）能够正确地进行提交或回滚，并在使用完毕后关闭会话（session）。",
            "code_start_line": 33,
            "code_end_line": 45,
            "parent": null,
            "have_return": false,
            "code_content": "def get_db():\n    \"\"\"\n    Provide a transactional scope around a series of operations.\n    \"\"\"\n    session = SessionLocal()\n    try:\n        yield session\n        session.commit()\n    except:\n        session.rollback()\n        raise\n    finally:\n        session.close()\n",
            "name_column": 4
        },
        "RunningRecoder": {
            "type": "ClassDef",
            "name": "RunningRecoder",
            "md_content": "**RunningRecoder函数**：这个类的功能是记录程序的运行序列，包括程序查询状态和配置数据。\n\n该类具有以下方法：\n\n- `__init__(self, record_id: str, newly_start=True, root_dir=None, logger: Logger=None)`：初始化方法，用于创建RunningRecoder对象。参数`record_id`表示记录的唯一标识符，`newly_start`表示是否是全新启动的程序，`root_dir`表示记录的根目录，`logger`表示日志记录器。\n\n- `change_now_task(self, new_subtask_id)`：更改当前任务的方法。参数`new_subtask_id`表示新的子任务的ID。\n\n- `generate_record(self, current, node_id, node_type, data)`：生成记录的方法。参数`current`表示当前子任务的ID，`node_id`表示节点的ID，`node_type`表示节点的类型，`data`表示要记录的数据。\n\n- `regist_plan_modify(self, refine_function_name, refine_function_input, refine_function_output, plan_after)`：注册一个plan_refine的记录的方法。参数`refine_function_name`表示refine函数的名称，`refine_function_input`表示refine函数的输入，`refine_function_output`表示refine函数的输出，`plan_after`表示refine后的计划。\n\n- `regist_llm_inout(self, messages, functions, function_call, model, stop, other_args, output_data)`：注册一个llm_inout的记录的方法。参数`messages`表示消息列表，`functions`表示函数列表，`function_call`表示函数调用，`model`表示模型，`stop`表示停止标志，`other_args`表示其他参数，`output_data`表示输出数据。\n\n- `query_llm_inout(self, restrict_cache_query, messages, functions, function_call, model, stop, other_args)`：查询llm_inout记录的方法。参数`restrict_cache_query`表示是否要求llm_interface_id也一样，`messages`表示消息列表，`functions`表示函数列表，`function_call`表示函数调用，`model`表示模型，`stop`表示停止标志，`other_args`表示其他参数。\n\n- `regist_tool_call(self, tool_name, tool_input, tool_output, tool_status_code, thought_data=None)`：注册一个tool_call的记录的方法。参数`tool_name`表示工具的名称，`tool_input`表示工具的输入，`tool_output`表示工具的输出，`tool_status_code`表示工具的状态码，`thought_data`表示思考数据。\n\n- `regist_tool_server(self, url, payload, tool_output, response_status_code)`：注册一个tool_server的记录的方法。参数`url`表示服务器的URL，`payload`表示工具的payload，`tool_output`表示工具的输出，`response_status_code`表示响应的状态码。\n\n- `query_tool_server_cache(self, url, payload)`：查询tool_server缓存的方法。参数`url`表示服务器的URL，`payload`表示工具的payload。\n\n- `regist_query(self, query)`：记录查询信息的方法。参数`query`表示查询对象。\n\n- `get_query(self)`：从数据库中获取查询信息的方法。\n\n- `regist_config(self, config: XAgentConfig)`：记录配置信息的方法。参数`config`表示配置对象。\n\n- `get_config(self)`：从数据库中获取运行配置的方法。\n\n- `load_from_db(self, record_id)`：从数据库中加载记录的方法。参数`record_id`表示记录的ID。\n\n**注意**：该类用于记录程序的运行序列和配置信息，以及查询和工具调用的记录。可以通过调用不同的方法来注册和查询记录。\n\n**输出示例**：\n```\nRunningRecoder对象已成功创建。\n```",
            "code_start_line": 48,
            "code_end_line": 346,
            "parent": null,
            "have_return": true,
            "code_content": "class RunningRecoder():\n    \"\"\"A class used to record the running sequences of the program, also including program query status and config data.\n    \"\"\"\n\n    def __init__(self, record_id: str, newly_start=True, root_dir=None, logger: Logger=None):\n        self.record_id = record_id\n        self.record_root_dir = root_dir\n        if not os.path.exists(self.record_root_dir):\n            os.makedirs(self.record_root_dir, exist_ok=True)\n\n        self.newly_start = newly_start  # 是全新启动的\n        self.logger = logger\n        self.query = {}\n        self.config = {}\n\n        self.llm_interface_id = 0\n        self.toolserver_interface_id = 0\n\n        self.tool_call_id = 0\n        self.plan_refine_id = 0\n\n        self.llm_server_cache = []\n        self.tool_server_cache = []\n        self.tool_call_cache = []\n        self.plan_refine_cache = []\n\n        self.now_subtask_id = None\n\n    def change_now_task(self, new_subtask_id):\n        \"\"\"change now task\"\"\"\n        self.now_subtask_id = new_subtask_id\n        self.tool_call_id = 0\n        self.plan_refine_id = 0\n\n    def generate_record(self, current, node_id, node_type, data):\n        \"\"\"generate a recorder\"\"\"\n        self.logger.typewriter_log(title=\"-=-=-=-=-=-=-=Recorder Start-=-=-=-=-=-=-=\\n\",\n                                   title_color=Fore.GREEN,\n                                   content=f\"Current: {current} Node: {node_type} {node_id}\")\n        json_str = json.dumps(data, ensure_ascii=False, indent=4)\n        json_str=re.sub(r'\"api_key\": \"(.+?)\"', r'\"api_key\": \"**\"', json_str)\n        self.logger.typewriter_log(title=\"-=-=-=-=-=-=-=Data -=-=-=-=-=-=-=\\n\",\n                                   title_color=Fore.GREEN,\n                                   content=json_str)\n        self.logger.typewriter_log(title=\"-=-=-=-=-=-=-=Recorder End-=-=-=-=-=-=-=\",\n                                   title_color=Fore.GREEN,\n                                   content=\"\")\n\n        return XAgentRunningRecord(\n            record_id=self.record_id,\n            current=current,\n            node_id=node_id,\n            node_type=node_type,\n            data=data,\n            create_time=datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            update_time=datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            is_deleted=False,\n        )\n\n\n    def regist_plan_modify(self,\n                           refine_function_name,\n                           refine_function_input,\n                           refine_function_output,\n                           plan_after):\n        \"\"\"注册一个plan_refine的记录\"\"\"\n        plan_refine_record = {\n            \"refine_function_name\": dump_common_things(refine_function_name),\n            \"refine_function_input\": dump_common_things(refine_function_input),\n            \"refine_function_output\": dump_common_things(refine_function_output),\n            \"plan_after\": dump_common_things(plan_after),\n        }\n        record = self.generate_record(\n            current=self.now_subtask_id,\n            node_id=self.plan_refine_id,\n            node_type=RecorderTypeEnum.PLAN_REFINE,\n            data=plan_refine_record,\n        )\n\n\n        with get_db() as db:\n            RunningRecordCRUD.insert_record(db=db, record=record)\n        self.plan_refine_id += 1\n\n    def regist_llm_inout(self,\n                         messages,\n                         functions,\n                         function_call,\n                         model,\n                         stop,\n                         other_args,\n                         output_data):\n        \"\"\"注册一个llm_inout的记录\"\"\"\n        llm_inout_record = {\n            \"input\": {\n                \"messages\": dump_common_things(messages),\n                \"functions\": dump_common_things(functions),\n                \"function_call\": dump_common_things(function_call),\n                \"model\": dump_common_things(model),\n                \"stop\": dump_common_things(stop),\n                \"other_args\": dump_common_things(other_args),\n            },\n            \"output\": dump_common_things(output_data),\n            \"llm_interface_id\": self.llm_interface_id,\n        }\n        record = self.generate_record(\n            current=self.now_subtask_id,\n            node_id=self.llm_interface_id,\n            node_type=RecorderTypeEnum.LLM_INPUT_PAIR,\n            data=llm_inout_record,\n        )\n        with get_db() as db:\n            RunningRecordCRUD.insert_record(db=db, record=record)\n        self.llm_interface_id += 1\n\n    def query_llm_inout(self, restrict_cache_query, messages, functions, function_call, model, stop, other_args):\n        \"\"\"restrict_cache_query: 是否要求llm_interface_id也一样\n\n        \"\"\"\n        if self.newly_start:\n            return None\n        input_data = {\n            \"messages\": dump_common_things(messages),\n            \"functions\": dump_common_things(functions),\n            \"function_call\": dump_common_things(function_call),\n            \"model\": dump_common_things(model),\n            \"stop\": dump_common_things(stop),\n            \"other_args\": dump_common_things(other_args),\n        }\n        for cache in self.llm_server_cache:\n            if input_data == cache[\"input\"]:\n                if restrict_cache_query and self.llm_interface_id != cache[\"llm_interface_id\"]:\n                    continue\n\n                # import pdb; pdb.set_trace()\n                return cache[\"output\"]\n        return None\n\n    def regist_tool_call(self,\n                         tool_name,\n                         tool_input,\n                         tool_output,\n                         tool_status_code,\n                         thought_data=None):\n        \"\"\"代管tool server上的所有操作\n        \"\"\"\n        tool_record = {\n            \"tool_name\": dump_common_things(tool_name),\n            \"tool_input\": dump_common_things(tool_input),\n            \"tool_output\": dump_common_things(tool_output),\n            \"tool_status_code\": dump_common_things(tool_status_code),\n        }\n        if thought_data:\n            tool_record[\"thought\"] = dump_common_things(thought_data)\n\n        record = self.generate_record(\n            current=self.now_subtask_id,\n            node_id=self.tool_call_id,\n            node_type=RecorderTypeEnum.TOOL_CALL,\n            data=tool_record,\n        )\n        with get_db() as db:\n            RunningRecordCRUD.insert_record(db=db, record=record)\n\n        self.tool_call_id += 1\n\n    def regist_tool_server(self,\n                           url,\n                           payload,\n                           tool_output,\n                           response_status_code):\n        \"\"\"\n        Register tool server.\n\n        Args:\n            url (str): The url of the server.\n            payload (Any): The payload for the tool.\n            tool_output (Any): The output from the tool.\n            response_status_code (int): The response status code.\n        \"\"\"\n        tool_record = {\n            \"url\": dump_common_things(url.split(\"/\")[-1]),\n            \"payload\": dump_common_things(payload),\n            \"response_status_code\": dump_common_things(response_status_code),\n            \"tool_output\": dump_common_things(tool_output),\n        }\n        record = self.generate_record(\n            current=self.now_subtask_id,\n            node_id=self.toolserver_interface_id,\n            node_type=RecorderTypeEnum.TOOL_SERVER_PAIR,\n            data=tool_record,\n        )\n        with get_db() as db:\n            RunningRecordCRUD.insert_record(db=db, record=record)\n\n        self.toolserver_interface_id += 1\n\n    def query_tool_server_cache(self, url, payload):\n        \"\"\"query tool server cache\"\"\"\n        if self.newly_start:\n            return None\n\n        if not self.tool_server_cache:\n            with get_db() as db:\n                tool_record = RunningRecordCRUD.get_record_by_type(\n                    db=db,\n                    record_id=self.record_id,\n                    node_id=0,\n                    node_type=RecorderTypeEnum.TOOL_SERVER_PAIR,\n                )\n\n            self.tool_server_cache = [json.loads(\n                record.data) for record in tool_record]\n\n        for cache in self.tool_server_cache:\n            # import pdb; pdb.set_trace()\n            if cache[\"url\"] == url.split(\"/\")[-1] \\\n                    and cache[\"payload\"] == dump_common_things(payload):\n                print(f\"get a tool_server response from Record: {cache['tool_output']}\")\n                return cache[\"tool_output\"]\n\n        return None\n\n    def regist_query(self, query):\n        \"\"\"记录query的相关信息\n        \"\"\"\n        record = self.generate_record(\n            current=self.now_subtask_id,\n            node_id=0,\n            node_type=RecorderTypeEnum.QUERY,\n            data=query.to_json(),\n        )\n        with get_db() as db:\n            RunningRecordCRUD.insert_record(db=db, record=record)\n\n    def get_query(self):\n        \"\"\"get query from db\"\"\"\n        with get_db() as db:\n            records = RunningRecordCRUD.get_record_by_type(\n                db=db,\n                record_id=self.record_id,\n                node_id=0,\n                node_type=RecorderTypeEnum.QUERY,\n            )\n\n        self.query = AutoGPTQuery.from_json(records[0].data)\n        return self.query\n\n    def regist_config(self, config: XAgentConfig):\n        \"\"\"记录config的相关信息\n        \"\"\"\n        record = self.generate_record(\n            current=self.now_subtask_id,\n            node_id=0,\n            node_type=RecorderTypeEnum.CONFIG,\n            data=config.to_dict(),\n        )\n        with get_db() as db:\n            RunningRecordCRUD.insert_record(db=db, record=record)\n\n    def get_config(self):\n        \"\"\"get running config from db\"\"\"\n        with get_db() as db:\n            records = RunningRecordCRUD.get_record_by_type(\n                db=db,\n                record_id=self.record_id,\n                node_id=0,\n                node_type=RecorderTypeEnum.CONFIG,\n            )\n        return json.loads(records[0].data)\n\n    def load_from_db(self, record_id):\n        \"\"\"从本地文件夹加载record，用于后面的直接复现\n        \"\"\"\n\n        self.newly_start = False\n\n        with get_db() as db:\n            records = RunningRecordCRUD.get_record_by_type(\n                db=db,\n                record_id=record_id\n            )\n\n        for record in records:\n            if record.node_type == RecorderTypeEnum.QUERY:\n                self.query = AutoGPTQuery.from_json(record.data)\n            elif record.node_type == RecorderTypeEnum.CONFIG:\n                self.config = XAgentConfig()\n                self.config.merge_from_dict(record.data)\n            elif record.node_type == RecorderTypeEnum.LLM_INPUT_PAIR:\n                self.llm_server_cache.append(record.data)\n            elif record.node_type == RecorderTypeEnum.TOOL_SERVER_PAIR:\n                self.tool_server_cache.append(record.data)\n            elif record.node_type == RecorderTypeEnum.PLAN_REFINE:\n                self.plan_refine_cache.append(record.data)\n            elif record.node_type == RecorderTypeEnum.TOOL_CALL:\n                self.tool_call_cache.append(record.data)\n            else:\n                raise NotImplementedError\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__函数**：这个函数的作用是初始化一个Recorder对象。\n\n在代码中，我们可以看到__init__函数有以下几个参数：\n- record_id: str类型，表示记录的ID。\n- newly_start: bool类型，表示是否是全新启动的Recorder对象。\n- root_dir: str类型，表示记录的根目录。\n- logger: Logger类型，表示记录器的日志对象。\n\n在函数内部，首先将传入的参数赋值给对应的实例变量。然后，通过判断记录的根目录是否存在，如果不存在则创建该目录。\n\n接下来，初始化一些实例变量，包括query和config，它们分别用于存储查询和配置信息。\n\n然后，初始化一些用于记录接口和调用的ID的实例变量，包括llm_interface_id、toolserver_interface_id、tool_call_id和plan_refine_id。\n\n接着，初始化一些用于缓存的列表，包括llm_server_cache、tool_server_cache、tool_call_cache和plan_refine_cache。\n\n最后，初始化一个用于记录当前子任务ID的实例变量now_subtask_id。\n\n**注意**：在使用这段代码时，需要注意传入正确的参数，并确保记录的根目录存在。",
            "code_start_line": 52,
            "code_end_line": 74,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def __init__(self, record_id: str, newly_start=True, root_dir=None, logger: Logger=None):\n        self.record_id = record_id\n        self.record_root_dir = root_dir\n        if not os.path.exists(self.record_root_dir):\n            os.makedirs(self.record_root_dir, exist_ok=True)\n\n        self.newly_start = newly_start  # 是全新启动的\n        self.logger = logger\n        self.query = {}\n        self.config = {}\n\n        self.llm_interface_id = 0\n        self.toolserver_interface_id = 0\n\n        self.tool_call_id = 0\n        self.plan_refine_id = 0\n\n        self.llm_server_cache = []\n        self.tool_server_cache = []\n        self.tool_call_cache = []\n        self.plan_refine_cache = []\n\n        self.now_subtask_id = None\n",
            "name_column": 8
        },
        "change_now_task": {
            "type": "FunctionDef",
            "name": "change_now_task",
            "md_content": "**change_now_task函数**: 这个函数的功能是改变当前任务。\n\n该函数用于改变当前任务的子任务ID，以便在工作流中处理下一个子任务。它接受一个新的子任务ID作为参数，并将当前子任务ID、工具调用ID和计划细化ID重置为0。这样可以确保在处理下一个子任务时，这些变量的初始状态是正确的。\n\n**注意**: 在使用这段代码时需要注意以下几点：\n- 确保传入的新子任务ID是有效的，并且与工作流中的子任务ID相对应。\n- 在调用这个函数之前，确保已经初始化了相关的变量，以免出现意外的结果。\n- 这个函数只负责改变当前任务的子任务ID，不涉及其他与任务相关的操作。",
            "code_start_line": 76,
            "code_end_line": 80,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def change_now_task(self, new_subtask_id):\n        \"\"\"change now task\"\"\"\n        self.now_subtask_id = new_subtask_id\n        self.tool_call_id = 0\n        self.plan_refine_id = 0\n",
            "name_column": 8
        },
        "generate_record": {
            "type": "FunctionDef",
            "name": "generate_record",
            "md_content": "**generate_record函数**：此函数的功能是生成一个记录。\n\n该函数接受四个参数：current（当前子任务ID）、node_id（节点ID）、node_type（节点类型）和data（数据）。函数首先使用logger对象将一些信息打印到日志中，然后将data转换为JSON字符串，并对其中的敏感信息进行脱敏处理。最后，函数返回一个XAgentRunningRecord对象，其中包含了记录的各个字段。\n\n该函数在以下文件中被调用：\n- XAgent/recorder.py：regist_plan_modify函数中调用了generate_record函数，用于注册一个plan_refine的记录。\n- XAgent/recorder.py：regist_llm_inout函数中调用了generate_record函数，用于注册一个llm_inout的记录。\n- XAgent/recorder.py：regist_tool_call函数中调用了generate_record函数，用于注册一个tool_call的记录。\n- XAgent/recorder.py：regist_tool_server函数中调用了generate_record函数，用于注册一个tool_server的记录。\n- XAgent/recorder.py：regist_query函数中调用了generate_record函数，用于注册一个query的记录。\n- XAgent/recorder.py：regist_config函数中调用了generate_record函数，用于注册一个config的记录。\n\n**注意**：在使用该函数时需要注意以下几点：\n- 函数的四个参数都是必填项，不能省略。\n- data参数必须是一个可转换为JSON格式的对象。\n\n**输出示例**：以下是该函数可能返回值的示例：\n```\n{\n    \"record_id\": 1,\n    \"current\": 1,\n    \"node_id\": 1,\n    \"node_type\": \"PLAN_REFINE\",\n    \"data\": {\n        \"refine_function_name\": \"refine_function\",\n        \"refine_function_input\": \"input_data\",\n        \"refine_function_output\": \"output_data\",\n        \"plan_after\": \"new_plan\"\n    },\n    \"create_time\": \"2022-01-01 00:00:00\",\n    \"update_time\": \"2022-01-01 00:00:00\",\n    \"is_deleted\": false\n}\n```",
            "code_start_line": 82,
            "code_end_line": 105,
            "parent": "RunningRecoder",
            "have_return": true,
            "code_content": "    def generate_record(self, current, node_id, node_type, data):\n        \"\"\"generate a recorder\"\"\"\n        self.logger.typewriter_log(title=\"-=-=-=-=-=-=-=Recorder Start-=-=-=-=-=-=-=\\n\",\n                                   title_color=Fore.GREEN,\n                                   content=f\"Current: {current} Node: {node_type} {node_id}\")\n        json_str = json.dumps(data, ensure_ascii=False, indent=4)\n        json_str=re.sub(r'\"api_key\": \"(.+?)\"', r'\"api_key\": \"**\"', json_str)\n        self.logger.typewriter_log(title=\"-=-=-=-=-=-=-=Data -=-=-=-=-=-=-=\\n\",\n                                   title_color=Fore.GREEN,\n                                   content=json_str)\n        self.logger.typewriter_log(title=\"-=-=-=-=-=-=-=Recorder End-=-=-=-=-=-=-=\",\n                                   title_color=Fore.GREEN,\n                                   content=\"\")\n\n        return XAgentRunningRecord(\n            record_id=self.record_id,\n            current=current,\n            node_id=node_id,\n            node_type=node_type,\n            data=data,\n            create_time=datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            update_time=datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n            is_deleted=False,\n        )\n",
            "name_column": 8
        },
        "regist_plan_modify": {
            "type": "FunctionDef",
            "name": "regist_plan_modify",
            "md_content": "**regist_plan_modify函数**：该函数的功能是注册一个plan_refine的记录。\n\n该函数接受四个参数：refine_function_name，refine_function_input，refine_function_output和plan_after。其中，refine_function_name表示refine函数的名称，refine_function_input表示refine函数的输入，refine_function_output表示refine函数的输出，plan_after表示refine函数执行后的plan。\n\n在函数内部，首先创建一个plan_refine_record字典，包含了refine_function_name、refine_function_input、refine_function_output和plan_after这四个字段。这些字段的值通过调用dump_common_things函数对参数进行序列化处理。\n\n接下来，调用self.generate_record函数生成一个记录。该记录包含了当前子任务的ID（current）、plan_refine的节点ID（node_id）、节点类型（node_type）和plan_refine_record数据。\n\n然后，通过调用get_db函数获取数据库连接，并使用RunningRecordCRUD的insert_record方法将记录插入数据库。\n\n最后，将plan_refine_id加1，以便下次注册时使用。\n\n**注意**：在使用该函数时需要注意以下几点：\n- 确保传入的参数refine_function_name、refine_function_input、refine_function_output和plan_after的类型正确。\n- 确保数据库连接正常，并且RunningRecordCRUD的insert_record方法能够正确插入记录。\n- 每次注册plan_refine记录后，需要将plan_refine_id加1，以保证下次注册时使用的ID是唯一的。",
            "code_start_line": 108,
            "code_end_line": 130,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def regist_plan_modify(self,\n                           refine_function_name,\n                           refine_function_input,\n                           refine_function_output,\n                           plan_after):\n        \"\"\"注册一个plan_refine的记录\"\"\"\n        plan_refine_record = {\n            \"refine_function_name\": dump_common_things(refine_function_name),\n            \"refine_function_input\": dump_common_things(refine_function_input),\n            \"refine_function_output\": dump_common_things(refine_function_output),\n            \"plan_after\": dump_common_things(plan_after),\n        }\n        record = self.generate_record(\n            current=self.now_subtask_id,\n            node_id=self.plan_refine_id,\n            node_type=RecorderTypeEnum.PLAN_REFINE,\n            data=plan_refine_record,\n        )\n\n\n        with get_db() as db:\n            RunningRecordCRUD.insert_record(db=db, record=record)\n        self.plan_refine_id += 1\n",
            "name_column": 8
        },
        "regist_llm_inout": {
            "type": "FunctionDef",
            "name": "regist_llm_inout",
            "md_content": "**regist_llm_inout函数**: 这个函数的作用是注册一个llm_inout的记录。\n\n该函数接受以下参数：\n- messages: 一个消息列表，包含了与当前记录相关的所有消息。\n- functions: 一个函数列表，包含了与当前记录相关的所有函数。\n- function_call: 一个函数调用列表，包含了与当前记录相关的所有函数调用。\n- model: 一个模型对象，包含了与当前记录相关的模型信息。\n- stop: 一个布尔值，表示当前记录是否停止。\n- other_args: 一个其他参数列表，包含了与当前记录相关的其他参数。\n- output_data: 一个输出数据对象，包含了与当前记录相关的输出数据。\n\n该函数首先创建了一个llm_inout_record字典，其中包含了输入和输出的相关信息。输入信息包括了messages、functions、function_call、model、stop和other_args，这些信息都通过dump_common_things函数进行了转换。输出信息则通过dump_common_things函数将output_data转换为字符串。\n\n接下来，函数调用了generate_record方法，生成了一个record对象。该record对象包含了当前子任务的ID、llm_interface_id、RecorderTypeEnum.LLM_INPUT_PAIR和llm_inout_record。\n\n然后，函数使用get_db函数获取数据库连接，并调用RunningRecordCRUD的insert_record方法将record插入到数据库中。\n\n最后，函数将llm_interface_id加1，以便下次记录时使用。\n\n**注意**: 使用该代码时需要注意以下几点：\n- 确保传入的参数类型正确，否则可能会导致错误。\n- 确保数据库连接正常，否则无法插入记录。",
            "code_start_line": 132,
            "code_end_line": 161,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def regist_llm_inout(self,\n                         messages,\n                         functions,\n                         function_call,\n                         model,\n                         stop,\n                         other_args,\n                         output_data):\n        \"\"\"注册一个llm_inout的记录\"\"\"\n        llm_inout_record = {\n            \"input\": {\n                \"messages\": dump_common_things(messages),\n                \"functions\": dump_common_things(functions),\n                \"function_call\": dump_common_things(function_call),\n                \"model\": dump_common_things(model),\n                \"stop\": dump_common_things(stop),\n                \"other_args\": dump_common_things(other_args),\n            },\n            \"output\": dump_common_things(output_data),\n            \"llm_interface_id\": self.llm_interface_id,\n        }\n        record = self.generate_record(\n            current=self.now_subtask_id,\n            node_id=self.llm_interface_id,\n            node_type=RecorderTypeEnum.LLM_INPUT_PAIR,\n            data=llm_inout_record,\n        )\n        with get_db() as db:\n            RunningRecordCRUD.insert_record(db=db, record=record)\n        self.llm_interface_id += 1\n",
            "name_column": 8
        },
        "query_llm_inout": {
            "type": "FunctionDef",
            "name": "query_llm_inout",
            "md_content": "**query_llm_inout函数**：这个函数的作用是查询LLM的输入输出。\n\n该函数接受以下参数：\n- restrict_cache_query：是否要求LLM接口ID也一样。\n- messages：消息列表。\n- functions：函数列表。\n- function_call：函数调用列表。\n- model：模型列表。\n- stop：停止标志列表。\n- other_args：其他参数列表。\n\n该函数首先判断是否是新启动的LLM，如果是，则返回None。\n\n然后，将输入数据以字典形式存储在input_data变量中，包括了messages、functions、function_call、model、stop和other_args。\n\n接下来，遍历llm_server_cache列表中的缓存项，判断输入数据是否与缓存项的input字段相等。如果相等，则根据restrict_cache_query的值判断是否要求llm_interface_id也一样。如果要求一样且llm_interface_id不一样，则继续遍历下一个缓存项。如果不要求一样或者llm_interface_id一样，则返回缓存项的output字段。\n\n如果遍历完所有缓存项后仍未找到匹配的缓存项，则返回None。\n\n**注意**：在使用该代码时需要注意以下几点：\n- 需要提供正确的参数。\n- 需要正确设置restrict_cache_query参数。\n- 需要正确设置llm_interface_id参数。\n\n**输出示例**：返回缓存项的output字段的值。",
            "code_start_line": 163,
            "code_end_line": 184,
            "parent": "RunningRecoder",
            "have_return": true,
            "code_content": "    def query_llm_inout(self, restrict_cache_query, messages, functions, function_call, model, stop, other_args):\n        \"\"\"restrict_cache_query: 是否要求llm_interface_id也一样\n\n        \"\"\"\n        if self.newly_start:\n            return None\n        input_data = {\n            \"messages\": dump_common_things(messages),\n            \"functions\": dump_common_things(functions),\n            \"function_call\": dump_common_things(function_call),\n            \"model\": dump_common_things(model),\n            \"stop\": dump_common_things(stop),\n            \"other_args\": dump_common_things(other_args),\n        }\n        for cache in self.llm_server_cache:\n            if input_data == cache[\"input\"]:\n                if restrict_cache_query and self.llm_interface_id != cache[\"llm_interface_id\"]:\n                    continue\n\n                # import pdb; pdb.set_trace()\n                return cache[\"output\"]\n        return None\n",
            "name_column": 8
        },
        "regist_tool_call": {
            "type": "FunctionDef",
            "name": "regist_tool_call",
            "md_content": "**regist_tool_call函数**：这个函数的作用是代管tool server上的所有操作。\n\n该函数接受以下参数：\n- tool_name：工具的名称。\n- tool_input：工具的输入。\n- tool_output：工具的输出。\n- tool_status_code：工具的状态码。\n- thought_data：思考数据（可选）。\n\n该函数的主要功能是生成工具调用的记录，并将记录插入到运行记录中。具体步骤如下：\n1. 将工具的名称、输入、输出和状态码存储到tool_record字典中。\n2. 如果存在思考数据，则将思考数据存储到tool_record字典中。\n3. 调用generate_record函数生成记录，并传入当前子任务ID、工具调用ID、记录类型和数据。\n4. 使用get_db函数获取数据库连接，并调用RunningRecordCRUD的insert_record方法将记录插入到数据库中。\n5. 增加工具调用ID的值。\n\n**注意**：在使用该函数时，需要注意以下几点：\n- 需要提供正确的工具名称、输入、输出和状态码。\n- 如果有思考数据，需要将其传入thought_data参数。\n- 在调用该函数之前，需要确保已经正确配置了数据库连接。\n- 在调用该函数之后，可以通过查询数据库来获取工具调用的记录。",
            "code_start_line": 186,
            "code_end_line": 212,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def regist_tool_call(self,\n                         tool_name,\n                         tool_input,\n                         tool_output,\n                         tool_status_code,\n                         thought_data=None):\n        \"\"\"代管tool server上的所有操作\n        \"\"\"\n        tool_record = {\n            \"tool_name\": dump_common_things(tool_name),\n            \"tool_input\": dump_common_things(tool_input),\n            \"tool_output\": dump_common_things(tool_output),\n            \"tool_status_code\": dump_common_things(tool_status_code),\n        }\n        if thought_data:\n            tool_record[\"thought\"] = dump_common_things(thought_data)\n\n        record = self.generate_record(\n            current=self.now_subtask_id,\n            node_id=self.tool_call_id,\n            node_type=RecorderTypeEnum.TOOL_CALL,\n            data=tool_record,\n        )\n        with get_db() as db:\n            RunningRecordCRUD.insert_record(db=db, record=record)\n\n        self.tool_call_id += 1\n",
            "name_column": 8
        },
        "regist_tool_server": {
            "type": "FunctionDef",
            "name": "regist_tool_server",
            "md_content": "**regist_tool_server函数**：该函数用于注册工具服务器。\n\n该函数接受以下参数：\n- url（str）：服务器的URL。\n- payload（Any）：工具的payload。\n- tool_output（Any）：工具的输出。\n- response_status_code（int）：响应状态码。\n\n该函数的作用是将工具服务器的信息注册到记录器中，并将记录插入到运行记录中。\n\n使用示例：\n```python\nregist_tool_server(url, payload, tool_output, response_status_code)\n```\n\n**注意**：在使用该函数时，需要确保传入正确的参数，并且保证服务器的URL、payload、工具输出和响应状态码的正确性。",
            "code_start_line": 214,
            "code_end_line": 243,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def regist_tool_server(self,\n                           url,\n                           payload,\n                           tool_output,\n                           response_status_code):\n        \"\"\"\n        Register tool server.\n\n        Args:\n            url (str): The url of the server.\n            payload (Any): The payload for the tool.\n            tool_output (Any): The output from the tool.\n            response_status_code (int): The response status code.\n        \"\"\"\n        tool_record = {\n            \"url\": dump_common_things(url.split(\"/\")[-1]),\n            \"payload\": dump_common_things(payload),\n            \"response_status_code\": dump_common_things(response_status_code),\n            \"tool_output\": dump_common_things(tool_output),\n        }\n        record = self.generate_record(\n            current=self.now_subtask_id,\n            node_id=self.toolserver_interface_id,\n            node_type=RecorderTypeEnum.TOOL_SERVER_PAIR,\n            data=tool_record,\n        )\n        with get_db() as db:\n            RunningRecordCRUD.insert_record(db=db, record=record)\n\n        self.toolserver_interface_id += 1\n",
            "name_column": 8
        },
        "query_tool_server_cache": {
            "type": "FunctionDef",
            "name": "query_tool_server_cache",
            "md_content": "**query_tool_server_cache函数**：该函数用于查询工具服务器缓存。\n\n该函数的作用是查询工具服务器缓存，根据给定的URL和payload参数，从缓存中查找匹配的工具服务器响应。如果找到匹配的缓存，则返回缓存中的工具服务器响应；如果未找到匹配的缓存，则返回None。\n\n函数参数说明：\n- url：工具服务器的URL。\n- payload：请求的参数。\n\n函数内部逻辑说明：\n1. 首先判断是否是新启动的工具服务器，如果是，则直接返回None。\n2. 如果工具服务器缓存为空，则从数据库中获取工具服务器记录，并将其转换为JSON格式的列表，存储在self.tool_server_cache中。\n3. 遍历self.tool_server_cache列表，逐个比较缓存中的URL和payload与给定的url和payload是否匹配。如果匹配，则打印匹配的工具服务器响应，并返回该响应。\n4. 如果遍历完整个self.tool_server_cache列表仍未找到匹配的缓存，则返回None。\n\n**注意**：在使用该函数时，需要确保工具服务器缓存已经被正确初始化，并且传入的url和payload参数与缓存中的URL和payload格式一致。\n\n**输出示例**：假设工具服务器缓存中存在匹配的缓存，返回工具服务器响应的示例：\n```\nget a tool_server response from Record: {\"output\": \"example output\"}\n```",
            "code_start_line": 245,
            "code_end_line": 269,
            "parent": "RunningRecoder",
            "have_return": true,
            "code_content": "    def query_tool_server_cache(self, url, payload):\n        \"\"\"query tool server cache\"\"\"\n        if self.newly_start:\n            return None\n\n        if not self.tool_server_cache:\n            with get_db() as db:\n                tool_record = RunningRecordCRUD.get_record_by_type(\n                    db=db,\n                    record_id=self.record_id,\n                    node_id=0,\n                    node_type=RecorderTypeEnum.TOOL_SERVER_PAIR,\n                )\n\n            self.tool_server_cache = [json.loads(\n                record.data) for record in tool_record]\n\n        for cache in self.tool_server_cache:\n            # import pdb; pdb.set_trace()\n            if cache[\"url\"] == url.split(\"/\")[-1] \\\n                    and cache[\"payload\"] == dump_common_things(payload):\n                print(f\"get a tool_server response from Record: {cache['tool_output']}\")\n                return cache[\"tool_output\"]\n\n        return None\n",
            "name_column": 8
        },
        "regist_query": {
            "type": "FunctionDef",
            "name": "regist_query",
            "md_content": "**regist_query函数**：该函数的功能是记录query的相关信息。\n\n该函数接受一个参数query，用于记录相关信息。首先，通过调用generate_record函数生成一个记录对象record，该对象包含了当前子任务ID、节点ID、节点类型和query的JSON数据。然后，使用get_db函数获取数据库连接，并调用RunningRecordCRUD的insert_record方法将记录插入数据库。\n\n该函数在以下文件中被调用：\n文件路径：XAgent/core.py\n调用代码如下：\n```python\ndef resister_recorder(self, param: XAgentParam):\n    \"\"\"\n    register a recorder to the core components\n    \"\"\"\n    self.recorder = RunningRecoder(\n        record_id=self.interaction.base.interaction_id,\n        newly_start=param.newly_created,\n        root_dir=self.base_dir,\n        logger=self.logger\n    )\n    if param.newly_created:\n        self.recorder.regist_query(param.query)\n        self.recorder.regist_config(param.config)\n    else:\n        self.recorder.load_from_db(self.interaction.base.recorder_root_dir)\n        self.recorder.regist_query(param.query)\n        self.recorder.regist_config(param.config)\n\n    XAgentCoreComponents.global_recorder = self.recorder\n```\n该函数在resister_recorder函数中被调用，用于向核心组件注册一个记录器。首先，创建一个RunningRecoder对象，传入记录ID、是否新创建、根目录和日志记录器等参数。然后，根据是否新创建的标志，调用记录器的regist_query方法和regist_config方法注册query和config。最后，将记录器赋值给全局变量XAgentCoreComponents.global_recorder。\n\n**注意**：使用该函数时需要注意以下几点：\n- 需要提供一个有效的query参数。\n- 在调用该函数之前，需要确保数据库连接已经建立。\n- 调用该函数后，相关信息将被记录到数据库中。",
            "code_start_line": 271,
            "code_end_line": 281,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def regist_query(self, query):\n        \"\"\"记录query的相关信息\n        \"\"\"\n        record = self.generate_record(\n            current=self.now_subtask_id,\n            node_id=0,\n            node_type=RecorderTypeEnum.QUERY,\n            data=query.to_json(),\n        )\n        with get_db() as db:\n            RunningRecordCRUD.insert_record(db=db, record=record)\n",
            "name_column": 8
        },
        "get_query": {
            "type": "FunctionDef",
            "name": "get_query",
            "md_content": "**get_query函数**：该函数的功能是从数据库中获取查询。\n\n该函数首先使用`get_db()`函数获取数据库连接，并在`with`语句块中使用该连接。然后，通过调用`RunningRecordCRUD.get_record_by_type()`函数从数据库中获取记录。该函数接受以下参数：\n- `db`：数据库连接对象。\n- `record_id`：记录ID。\n- `node_id`：节点ID，此处为0。\n- `node_type`：节点类型，此处为RecorderTypeEnum.QUERY。\n\n获取到的记录存储在`records`变量中。接下来，通过调用`AutoGPTQuery.from_json()`函数将记录中的数据转换为`AutoGPTQuery`对象，并将其赋值给`self.query`变量。最后，函数返回`self.query`。\n\n**注意**：使用该函数前需要确保数据库连接已经建立，并且需要传入正确的记录ID、节点ID和节点类型。\n\n**输出示例**：假设从数据库中获取的记录数据为`{\"query\": \"SELECT * FROM table\"}`，则函数返回的`self.query`对象为`AutoGPTQuery(query=\"SELECT * FROM table\")`。",
            "code_start_line": 283,
            "code_end_line": 294,
            "parent": "RunningRecoder",
            "have_return": true,
            "code_content": "    def get_query(self):\n        \"\"\"get query from db\"\"\"\n        with get_db() as db:\n            records = RunningRecordCRUD.get_record_by_type(\n                db=db,\n                record_id=self.record_id,\n                node_id=0,\n                node_type=RecorderTypeEnum.QUERY,\n            )\n\n        self.query = AutoGPTQuery.from_json(records[0].data)\n        return self.query\n",
            "name_column": 8
        },
        "regist_config": {
            "type": "FunctionDef",
            "name": "regist_config",
            "md_content": "**regist_config函数**: 这个函数的功能是记录config的相关信息。\n\n这个函数的作用是将传入的config对象的相关信息记录下来，并保存到数据库中。具体实现过程如下：\n\n1. 首先，通过调用self.generate_record方法生成一个记录对象record，该记录对象包含了当前子任务的ID（current）、节点ID（node_id）、节点类型（node_type）和config对象的字典形式数据（data）。\n\n2. 然后，通过调用get_db函数获取数据库连接，并将record插入到数据库中，实现记录的持久化。\n\n在项目中的调用情况如下：\n\n文件路径：XAgent/core.py\n调用代码如下：\n```python\ndef resister_recorder(self, param: XAgentParam):\n    \"\"\"\n    register a recorder to the core components\n    \"\"\"\n    self.recorder = RunningRecoder(\n        record_id=self.interaction.base.interaction_id,\n        newly_start=param.newly_created,\n        root_dir=self.base_dir,\n        logger=self.logger\n    )\n    if param.newly_created:\n        self.recorder.regist_query(param.query)\n        self.recorder.regist_config(param.config)\n    else:\n        self.recorder.load_from_db(self.interaction.base.recorder_root_dir)\n        self.recorder.regist_query(param.query)\n        self.recorder.regist_config(param.config)\n\n    XAgentCoreComponents.global_recorder = self.recorder\n```\n\n这段代码的作用是将一个recorder对象注册到核心组件中。在注册过程中，会根据传入的参数判断是否为新创建的recorder，如果是，则会先注册查询参数（param.query）和config参数（param.config），然后将recorder对象赋值给XAgentCoreComponents.global_recorder；如果不是新创建的recorder，则会从数据库中加载recorder，并进行相同的注册操作。\n\n**注意**：在使用regist_config函数时，需要传入一个XAgentConfig对象作为参数。",
            "code_start_line": 296,
            "code_end_line": 306,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def regist_config(self, config: XAgentConfig):\n        \"\"\"记录config的相关信息\n        \"\"\"\n        record = self.generate_record(\n            current=self.now_subtask_id,\n            node_id=0,\n            node_type=RecorderTypeEnum.CONFIG,\n            data=config.to_dict(),\n        )\n        with get_db() as db:\n            RunningRecordCRUD.insert_record(db=db, record=record)\n",
            "name_column": 8
        },
        "get_config": {
            "type": "FunctionDef",
            "name": "get_config",
            "md_content": "**get_config函数**：该函数的功能是从数据库中获取运行配置。\n\n该函数使用了一个数据库操作函数`get_db()`来获取数据库连接，然后使用`RunningRecordCRUD.get_record_by_type()`函数从数据库中获取指定类型的记录。具体来说，该函数会根据`record_id`、`node_id`和`node_type`参数来查询数据库中的记录。查询结果是一个记录列表，然后通过`json.loads()`函数将第一个记录的数据解析为JSON格式。\n\n**注意**：使用该函数前需要确保数据库连接已经建立，并且需要传入正确的`record_id`参数。\n\n**输出示例**：模拟该函数返回值的可能外观。\n\n```python\n{\n    \"key1\": \"value1\",\n    \"key2\": \"value2\",\n    ...\n}\n```",
            "code_start_line": 308,
            "code_end_line": 317,
            "parent": "RunningRecoder",
            "have_return": true,
            "code_content": "    def get_config(self):\n        \"\"\"get running config from db\"\"\"\n        with get_db() as db:\n            records = RunningRecordCRUD.get_record_by_type(\n                db=db,\n                record_id=self.record_id,\n                node_id=0,\n                node_type=RecorderTypeEnum.CONFIG,\n            )\n        return json.loads(records[0].data)\n",
            "name_column": 8
        },
        "load_from_db": {
            "type": "FunctionDef",
            "name": "load_from_db",
            "md_content": "**load_from_db函数**: 这个函数的功能是从本地文件夹加载record，用于后面的直接复现。\n\n该函数接受一个record_id作为参数，用于指定要加载的record的ID。函数首先将self.newly_start设置为False，表示不是新的record。\n\n然后，通过调用get_db()函数获取数据库连接，并使用RunningRecordCRUD的get_record_by_type方法从数据库中获取指定record_id的记录。\n\n接下来，对于每个获取到的record，根据其node_type的不同，将其data加载到相应的缓存中。具体的加载方式如下：\n- 如果node_type为RecorderTypeEnum.QUERY，则将record的data转换为AutoGPTQuery对象，并将其赋值给self.query。\n- 如果node_type为RecorderTypeEnum.CONFIG，则创建一个XAgentConfig对象，并使用record的data更新该对象的属性。\n- 如果node_type为RecorderTypeEnum.LLM_INPUT_PAIR，则将record的data添加到self.llm_server_cache列表中。\n- 如果node_type为RecorderTypeEnum.TOOL_SERVER_PAIR，则将record的data添加到self.tool_server_cache列表中。\n- 如果node_type为RecorderTypeEnum.PLAN_REFINE，则将record的data添加到self.plan_refine_cache列表中。\n- 如果node_type为RecorderTypeEnum.TOOL_CALL，则将record的data添加到self.tool_call_cache列表中。\n- 如果node_type为其他类型，则抛出NotImplementedError异常。\n\n**注意**: 使用该函数时需要确保传入正确的record_id参数，并且该record_id对应的记录存在于数据库中。",
            "code_start_line": 319,
            "code_end_line": 346,
            "parent": "RunningRecoder",
            "have_return": false,
            "code_content": "    def load_from_db(self, record_id):\n        \"\"\"从本地文件夹加载record，用于后面的直接复现\n        \"\"\"\n\n        self.newly_start = False\n\n        with get_db() as db:\n            records = RunningRecordCRUD.get_record_by_type(\n                db=db,\n                record_id=record_id\n            )\n\n        for record in records:\n            if record.node_type == RecorderTypeEnum.QUERY:\n                self.query = AutoGPTQuery.from_json(record.data)\n            elif record.node_type == RecorderTypeEnum.CONFIG:\n                self.config = XAgentConfig()\n                self.config.merge_from_dict(record.data)\n            elif record.node_type == RecorderTypeEnum.LLM_INPUT_PAIR:\n                self.llm_server_cache.append(record.data)\n            elif record.node_type == RecorderTypeEnum.TOOL_SERVER_PAIR:\n                self.tool_server_cache.append(record.data)\n            elif record.node_type == RecorderTypeEnum.PLAN_REFINE:\n                self.plan_refine_cache.append(record.data)\n            elif record.node_type == RecorderTypeEnum.TOOL_CALL:\n                self.tool_call_cache.append(record.data)\n            else:\n                raise NotImplementedError\n",
            "name_column": 8
        }
    },
    "XAgent/summarization_system.py": {
        "SummarizationNode": {
            "type": "ClassDef",
            "name": "SummarizationNode",
            "md_content": "**SummarizationNode函数**: 这个类的功能是表示摘要树中的节点。\n\n这个类继承自XAgent.data_structure.node中定义的Node类。\n\n**属性**:\n- father (SummarizationNode): 父节点。\n- children (List[SummarizationNode]): 子节点列表。\n- message (Message): 与该节点相关联的消息。\n- summarization_from_root_to_here: 从根节点到该节点的摘要。\n\n**方法**:\n- `__init__(self)`: 构造函数，初始化节点的属性。\n- `add_father_child_relation(cls, father, child)`: 添加父节点和子节点之间的关系。\n- `add_father_child_relation(cls, father, child)`: 添加父节点和子节点之间的关系。\n\n**注意**: \n- `add_father_child_relation`方法会检查子节点是否已经存在于父节点的子节点列表中，如果存在则会抛出`AssertionError`异常。\n- `SummarizationNode`类的实例可以通过`add_father_child_relation`方法来建立父子节点之间的关系。\n\n该对象在以下文件中被调用：\n- XAgent/summarization_system.py中的SummarizationTrieTree类的`query`方法和`insert`方法中使用了SummarizationNode类的实例。\n- XAgent/summarization_system.py中的SummarizationTrieTree类的`generate_summary`方法中使用了SummarizationNode类的实例。\n\n**SummarizationTrieTree函数**: 这个类表示摘要Trie树，用于生成摘要。\n\n**属性**:\n- root (SummarizationNode): 树的根节点。\n- config: 树的配置数据。\n\n**方法**:\n- `__init__(self, config)`: 构造函数，初始化树的属性。\n- `query(self, message_list: List[Message]) -> SummarizationTreeQueryResult`: 使用给定的消息列表查询树。\n- `insert(self, message_list)`: 将消息列表插入到树中。\n- `get_summarzation_message_all(cls, father_summarize_node: SummarizationNode, message_list: List[Message]) -> List[Message]`: 获取所有摘要消息。\n- `get_summarzation_message_recursive(cls, father_summarize_node: SummarizationNode, new_message: Message)`: 递归获取摘要消息。\n- `generate_summary(self, message_list, recursive_mode=True, agent_dispatcher=None)`: 为给定的消息列表生成摘要。\n\n**注意**: \n- `query`方法用于查询树中是否存在给定的消息列表，返回查询结果和查询结束的节点。\n- `insert`方法用于将消息列表插入到树中，并返回插入后的节点。\n- `get_summarzation_message_all`方法用于获取所有摘要消息。\n- `get_summarzation_message_recursive`方法用于递归获取摘要消息。\n- `generate_summary`方法用于生成给定消息列表的摘要。\n\n该对象在以下文件中被调用：\n- XAgent/summarization_system.py中的SummarizationTrieTree类的`generate_summary`方法中使用了SummarizationNode类的实例。",
            "code_start_line": 9,
            "code_end_line": 41,
            "parent": null,
            "have_return": false,
            "code_content": "class SummarizationNode(Node):\n    \"\"\"Class to represent nodes in the summarization tree.\n\n    Inherits from the Node class defined in XAgent.data_structure.node.\n\n    Attributes:\n        father (SummarizationNode): Parent SummarizationNode.\n        children (List[SummarizationNode]): List of child SummarizationNodes.\n        message (Message): Message associated with this node.\n        summarization_from_root_to_here: Summary from root node to this node.\n    \"\"\"\n    def __init__(self):\n        self.father: SummarizationNode = None\n        self.children: List[SummarizationNode] = []\n\n        self.message: Message = None\n\n        self.summarization_from_root_to_here = None\n\n    @classmethod\n    def add_father_child_relation(cls, father, child):\n        \"\"\"Adds relation between father SummarizationNode and child SummarizationNode.\n\n        Args:\n            father (SummarizationNode): Parent node.\n            child (SummarizationNode): Child node to be added to the parent node's children list.\n\n        Raises:\n            AssertionError: If the child node is already in the father's children list.\n        \"\"\"\n        assert child not in father.children\n        father.children.append(child)\n        child.father = father\n",
            "name_column": 6
        },
        "SummarizationTreeQueryResult": {
            "type": "ClassDef",
            "name": "SummarizationTreeQueryResult",
            "md_content": "**SummarizationTreeQueryResult函数**：这个类的功能是枚举查询摘要树时可能的结果。\n\n这个类定义了以下枚举值：\n- have_summary：表示查询的消息列表在摘要树中有摘要。\n- not_in_tree：表示查询的消息列表不在摘要树中。\n- in_tree_but_no_summary：表示查询的消息列表在摘要树中，但没有摘要。\n\n在项目中，这个类被以下文件调用：\n- 文件路径：XAgent/summarization_system.py\n- 调用代码：\n    def query(self, message_list: List[Message]) -> SummarizationTreeQueryResult:\n        \"\"\"使用给定的消息列表查询树。\n\n        参数:\n            message_list (List[Message]): 用于查询树的消息列表。\n\n        返回:\n            SummarizationTreeQueryResult: 与查询相关的摘要状态。\n            SummarizationNode: 如果消息列表在树中，则返回搜索结束的节点。\n        \"\"\"\n        # 查询树的代码\n\n    def generate_summary(self, message_list, recursive_mode=True, agent_dispatcher=None):\n        \"\"\"为给定的消息列表生成摘要。\n\n        参数:\n            message_list (List[Message]): 要进行摘要的消息列表。\n            recursive_mode (bool): 是否需要递归模式摘要。\n            \n        返回:\n            str: 新生成的摘要内容文本。\n        \"\"\"\n        # 生成摘要的代码\n\n**注意**：在使用这个类时需要注意以下几点：\n- 可以使用`query`函数查询给定消息列表在摘要树中的状态和节点。\n- 可以使用`generate_summary`函数为给定消息列表生成摘要。可以选择是否使用递归模式进行摘要。",
            "code_start_line": 45,
            "code_end_line": 49,
            "parent": null,
            "have_return": false,
            "code_content": "class SummarizationTreeQueryResult(Enum):\n    \"\"\"Enumeration for possible results when querying the summarization tree.\"\"\"\n    have_summary = 0\n    not_in_tree = 1\n    in_tree_but_no_summary = 2\n",
            "name_column": 6
        },
        "SummarizationTrieTree": {
            "type": "ClassDef",
            "name": "SummarizationTrieTree",
            "md_content": "**SummarizationTrieTree函数**: 这个类的函数是用来表示摘要Trie树的。该树用于生成摘要。\n\n该类具有以下属性：\n- root (SummarizationNode): 树的根节点。\n- config: 树的配置数据。\n\n**__init__函数**:\n- 参数: config (配置数据)\n- 功能: 初始化SummarizationTrieTree对象。\n- 返回值: 无\n\n**query函数**:\n- 参数: message_list (消息列表)\n- 功能: 使用给定的消息列表查询树。\n- 返回值: \n  - SummarizationTreeQueryResult: 与查询相关的摘要状态。\n  - SummarizationNode: 如果消息列表在树中，则返回搜索结束的节点。\n\n**insert函数**:\n- 参数: message_list (消息列表)\n- 功能: 将消息列表插入到Trie树中。\n- 返回值: 插入后的最后一个节点。\n\n**get_summarzation_message_all函数**:\n- 参数: father_summarize_node (父节点), message_list (消息列表)\n- 功能: 获取所有摘要消息。\n- 返回值: 摘要消息列表。\n\n**get_summarzation_message_recursive函数**:\n- 参数: father_summarize_node (父节点), new_message (新消息)\n- 功能: 递归获取摘要消息。\n- 返回值: 摘要消息列表。\n\n**generate_summary函数**:\n- 参数: message_list (消息列表), recursive_mode (递归模式), agent_dispatcher (代理调度器)\n- 功能: 为给定的消息列表生成摘要。\n- 返回值: 新的摘要内容文本。\n\n**注意**: 使用代码的注意事项。\n\n**输出示例**:\n```\n新的摘要内容文本\n```",
            "code_start_line": 52,
            "code_end_line": 217,
            "parent": null,
            "have_return": true,
            "code_content": "class SummarizationTrieTree:\n    \"\"\"Class to represent the Summarization Trie Tree. The tree is used to generate summaries.\n\n    Attributes:\n        root (SummarizationNode): Root node of the tree.\n        config: Configuration data for the tree.\n    \"\"\"\n    def __init__(self, config):\n        self.root = SummarizationNode()\n        self.config = config\n\n    def query(self, message_list: List[Message]) -> SummarizationTreeQueryResult:\n        \"\"\"Queries the tree with the given list of messages.\n\n        Args:\n            message_list (List[Message]): The list of messages for the tree query.\n\n        Returns:\n            SummarizationTreeQueryResult: The state of summary related to the query.\n            SummarizationNode: If the list of messages is in the tree, returns the node where the search ended.\n        \"\"\"\n        now_node = self.root\n\n        now_position = 0\n        while now_position < len(message_list):\n            now_message = message_list[now_position]\n            find = False\n            for child in now_node.children:\n                if Message.equal(child.message, now_message):\n                    find = True\n                    now_node = child\n                    break\n            \n            if find:\n                now_position += 1\n            else:\n                return SummarizationTreeQueryResult.not_in_tree, now_node\n        \n        if now_node.summarzation_from_root_to_here:\n            return SummarizationTreeQueryResult.have_summary, now_node\n        else:\n            return SummarizationTreeQueryResult.in_tree_but_no_summary, now_node\n        \n\n    def insert(self,message_list):\n        now_node = self.root\n\n        now_position = 0\n        while now_position < len(message_list):\n            now_message = message_list[now_position]\n            find = False\n            for child in now_node.children:\n                if Message.equal(child.message, now_message):\n                    find = True\n                    now_node = child\n                    break\n            \n            if find:\n                now_position += 1\n            else:\n                break\n\n        assert now_position < len(message_list)\n\n\n        for i in range(now_position, len(message_list)):\n            new_node = SummarizationNode()\n            new_node.message = message_list[i]\n            SummarizationNode.add_father_child_relation(now_node,new_node)\n            now_node = new_node\n\n        return now_node\n\n\n    def insert(self, message_list):\n        \"\"\"Inserts a list of messages into the trie tree.\n\n        Args:\n            message_list (List[Message]): List of messages to be inserted into the tree.\n\n        Returns:\n            SummarizationNode: Returns the end node after insertion.\n        \"\"\"\n\n    @classmethod\n    def get_summarzation_message_all(cls, father_summarize_node: SummarizationNode, message_list: List[Message]) -> List[Message]:\n        system_prompt = f'''Your task is to create a concise running summary of actions and information results in the provided text, focusing on key and potentially important information to remember.\n\n        You will receive the current summary and the your latest actions. Combine them, adding relevant key information from the latest development in 1st person past tense and keeping the summary concise.\n\n        Latest Development:\n        \"\"\"\n        {[message.content for message in message_list] or \"Nothing new happened.\"}\n        \"\"\"\n        '''\n\n        message_list = [Message(\"system\",system_prompt )]\n\n        return message_list\n\n\n\n    @classmethod\n    def get_summarzation_message_recursive(cls, father_summarize_node: SummarizationNode, new_message: Message):\n        system_prompt = f'''Your task is to create a concise running summary of actions and information results in the provided text, focusing on key and potentially important information to remember.\n\n        You will receive the current summary and the your latest actions. Combine them, adding relevant key information from the latest development in 1st person past tense and keeping the summary concise.\n\n        Summary So Far:\n        \"\"\"\n        {father_summarize_node.summarization_from_root_to_here}\n        \"\"\"\n\n        Latest Development:\n        \"\"\"\n        {[message.content for message in new_message] or \"Nothing new happened.\"}\n        \"\"\"\n        '''\n\n        message_list = [Message(\"system\",system_prompt )]\n\n        return message_list\n\n\n    def generate_summary(self, message_list, recursive_mode=True, agent_dispatcher=None):\n        \"\"\"Generates a summary for the given list of messages.\n\n        Args:\n            message_list (List[Message]): List of messages to be summarized.\n            recursive_mode (bool): Flag indicating if recursive mode summarization is required.\n            \n        Returns:\n            str: The new summarized content text.\n        \"\"\"\n        status_code, summarize_node = self.query(message_list)\n        assert status_code != SummarizationTreeQueryResult.have_summary\n        if recursive_mode:\n            status_code, summarize_node = self.query(message_list[:-1])\n            assert status_code == SummarizationTreeQueryResult.have_summary\n\n            summarize_message_list = self.get_summarzation_message_recursive(summarize_node, message_list[-1])\n        else:\n            \n            if status_code == SummarizationTreeQueryResult.not_in_tree:\n                summarize_node = self.insert(message_list)\n            summarize_message_list = self.get_summarzation_message_all( summarize_node, message_list)\n\n\n        # print(summarize_message_list)\n        agent = agent_dispatcher.dispatch(\n            RequiredAbilities.summarization, \n            \"Summarize the given content\"\n        )\n\n        _, new_message, _ = agent.parse(placeholders={\n            \"system\": {\n                \"running_summary\": summarize_node.summarization_from_root_to_here,\n                \"new_message\": [message.content for message in message_list] or \"Nothing new happened.\"\n            }\n        })\n\n        new_summary = new_message[\"content\"]\n\n        summarize_node.summarization_from_root_to_here = new_summary\n\n        return new_summary\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__函数**：这个函数的功能是初始化一个SummarizationSystem对象。\n\n在这个函数中，我们可以看到有一个参数config，它是用来传递配置信息的。在函数体内部，我们可以看到有两个属性的初始化操作，分别是self.root和self.config。\n\nself.root是一个SummarizationNode对象，它是整个摘要系统的根节点。通过这个根节点，我们可以访问到整个摘要系统的各个节点和功能。\n\nself.config是一个配置对象，用来存储和管理摘要系统的配置信息。通过这个对象，我们可以对摘要系统进行配置和设置。\n\n**注意**：在使用这个函数时，需要传入一个有效的配置对象作为参数。配置对象中应包含摘要系统的相关配置信息。",
            "code_start_line": 59,
            "code_end_line": 61,
            "parent": "SummarizationTrieTree",
            "have_return": false,
            "code_content": "    def __init__(self, config):\n        self.root = SummarizationNode()\n        self.config = config\n",
            "name_column": 8
        },
        "add_father_child_relation": {
            "type": "FunctionDef",
            "name": "add_father_child_relation",
            "md_content": "**add_father_child_relation函数**：此函数的功能是将父节点和子节点之间建立关系。\n\n该函数用于在父节点和子节点之间建立关系。父节点和子节点都是SummarizationNode类型的对象。在建立关系之前，会先检查子节点是否已经存在于父节点的子节点列表中，如果存在则会抛出AssertionError异常。建立关系后，会将子节点添加到父节点的子节点列表中，并将子节点的父节点属性设置为父节点。\n\n**注意**：如果子节点已经存在于父节点的子节点列表中，则会抛出AssertionError异常。",
            "code_start_line": 29,
            "code_end_line": 41,
            "parent": "SummarizationNode",
            "have_return": false,
            "code_content": "    def add_father_child_relation(cls, father, child):\n        \"\"\"Adds relation between father SummarizationNode and child SummarizationNode.\n\n        Args:\n            father (SummarizationNode): Parent node.\n            child (SummarizationNode): Child node to be added to the parent node's children list.\n\n        Raises:\n            AssertionError: If the child node is already in the father's children list.\n        \"\"\"\n        assert child not in father.children\n        father.children.append(child)\n        child.father = father\n",
            "name_column": 8
        },
        "query": {
            "type": "FunctionDef",
            "name": "query",
            "md_content": "**query函数**：该函数用于查询给定消息列表在树中的状态。\n\n该函数接受一个消息列表作为参数，并返回一个包含两个元素的元组。第一个元素表示查询的结果状态，第二个元素表示查询结束时所在的节点。\n\n在函数内部，首先将当前节点设置为根节点，然后通过循环遍历消息列表中的每个消息。对于每个消息，遍历当前节点的子节点，如果找到与当前消息相等的子节点，则将当前节点更新为该子节点，并将循环指针后移一位。\n\n如果找到了与当前消息相等的子节点，则继续下一个消息的查询。如果未找到与当前消息相等的子节点，则返回查询结果为\"not_in_tree\"，并将当前节点作为查询结束时所在的节点。\n\n最后，根据查询结束时所在的节点的状态，返回相应的查询结果和节点。\n\n**注意**：在使用该函数时，需要将消息列表作为参数传入，并根据返回的查询结果进行相应的处理。\n\n**输出示例**：假设查询结果为\"have_summary\"，查询结束时所在的节点为节点A。\n\n",
            "code_start_line": 63,
            "code_end_line": 93,
            "parent": "SummarizationTrieTree",
            "have_return": true,
            "code_content": "    def query(self, message_list: List[Message]) -> SummarizationTreeQueryResult:\n        \"\"\"Queries the tree with the given list of messages.\n\n        Args:\n            message_list (List[Message]): The list of messages for the tree query.\n\n        Returns:\n            SummarizationTreeQueryResult: The state of summary related to the query.\n            SummarizationNode: If the list of messages is in the tree, returns the node where the search ended.\n        \"\"\"\n        now_node = self.root\n\n        now_position = 0\n        while now_position < len(message_list):\n            now_message = message_list[now_position]\n            find = False\n            for child in now_node.children:\n                if Message.equal(child.message, now_message):\n                    find = True\n                    now_node = child\n                    break\n            \n            if find:\n                now_position += 1\n            else:\n                return SummarizationTreeQueryResult.not_in_tree, now_node\n        \n        if now_node.summarzation_from_root_to_here:\n            return SummarizationTreeQueryResult.have_summary, now_node\n        else:\n            return SummarizationTreeQueryResult.in_tree_but_no_summary, now_node\n",
            "name_column": 8
        },
        "insert": {
            "type": "FunctionDef",
            "name": "insert",
            "md_content": "**insert函数**：这个函数的功能是将一组消息插入到trie树中。\n\n该函数接受一个消息列表作为参数，将这些消息插入到树中，并返回插入后的最后一个节点。\n\n在插入过程中，函数会遍历消息列表，并在树中查找每个消息对应的节点。如果找到了对应的节点，则将当前节点更新为找到的子节点，并继续遍历下一个消息。如果没有找到对应的节点，则停止遍历。\n\n在遍历完消息列表后，函数会创建新的节点，并将其与当前节点建立父子关系。然后将当前节点更新为新创建的节点，并继续遍历剩余的消息列表。\n\n最后，函数返回插入后的最后一个节点。\n\n**注意**：使用该函数时需要注意以下几点：\n- 插入的消息列表应该是按照顺序排列的，即从根节点到叶子节点的路径。\n- 插入的消息列表中的每个消息应该是唯一的，不能重复。\n- 插入的消息列表中的每个消息应该是有效的，不能为None或空字符串。\n\n该函数在以下文件中被调用：\n- 文件路径：XAgent/summarization_system.py\n- 调用代码：\n    ```\n    summarize_node = self.insert(message_list)\n    ```",
            "code_start_line": 126,
            "code_end_line": 134,
            "parent": "SummarizationTrieTree",
            "have_return": false,
            "code_content": "    def insert(self, message_list):\n        \"\"\"Inserts a list of messages into the trie tree.\n\n        Args:\n            message_list (List[Message]): List of messages to be inserted into the tree.\n\n        Returns:\n            SummarizationNode: Returns the end node after insertion.\n        \"\"\"\n",
            "name_column": 8
        },
        "get_summarzation_message_all": {
            "type": "FunctionDef",
            "name": "get_summarzation_message_all",
            "md_content": "**get_summarzation_message_all函数**: 该函数的功能是将提供的文本中的行动和信息结果创建为简明扼要的运行摘要，重点关注关键和可能重要的信息以供记忆。\n\n该函数接受两个参数：father_summarize_node（SummarizationNode类型）和message_list（List[Message]类型），并返回一个List[Message]类型的结果。\n\n函数内部首先构建了一个系统提示(system_prompt)字符串，该字符串包含了当前摘要和最新行动的关键信息。然后将该系统提示作为一条消息添加到message_list中。\n\n最后，函数返回更新后的message_list。\n\n**注意**: 使用该函数时需要注意以下几点：\n- father_summarize_node参数是一个SummarizationNode类型的对象，表示父节点的摘要信息。\n- message_list参数是一个List[Message]类型的对象，表示消息列表。\n- 返回值是一个List[Message]类型的对象，表示更新后的消息列表。\n\n**输出示例**:\n```\n[\n    Message(sender='system', content='Your task is to create a concise running summary of actions and information results in the provided text, focusing on key and potentially important information to remember.\\n\\nYou will receive the current summary and the your latest actions. Combine them, adding relevant key information from the latest development in 1st person past tense and keeping the summary concise.\\n\\nLatest Development:\\n\"\"\"\\n[message.content for message in message_list] or \"Nothing new happened.\"\\n\"\"\"\\n')\n]\n```",
            "code_start_line": 137,
            "code_end_line": 150,
            "parent": "SummarizationTrieTree",
            "have_return": true,
            "code_content": "    def get_summarzation_message_all(cls, father_summarize_node: SummarizationNode, message_list: List[Message]) -> List[Message]:\n        system_prompt = f'''Your task is to create a concise running summary of actions and information results in the provided text, focusing on key and potentially important information to remember.\n\n        You will receive the current summary and the your latest actions. Combine them, adding relevant key information from the latest development in 1st person past tense and keeping the summary concise.\n\n        Latest Development:\n        \"\"\"\n        {[message.content for message in message_list] or \"Nothing new happened.\"}\n        \"\"\"\n        '''\n\n        message_list = [Message(\"system\",system_prompt )]\n\n        return message_list\n",
            "name_column": 8
        },
        "get_summarzation_message_recursive": {
            "type": "FunctionDef",
            "name": "get_summarzation_message_recursive",
            "md_content": "**get_summarzation_message_recursive函数**：该函数的功能是生成一个包含系统提示和最新开发的消息列表。\n\n该函数接受两个参数：father_summarize_node（SummarizationNode类型）和new_message（Message类型）。father_summarize_node表示当前的摘要节点，new_message表示最新的消息。\n\n函数首先根据father_summarize_node和new_message生成系统提示，系统提示包括当前的摘要和最新的开发。然后将系统提示封装成Message对象，并将其添加到message_list中。\n\n最后，函数返回message_list作为结果。\n\n**注意**：该函数依赖于SummarizationNode和Message两个类。\n\n**输出示例**：\n```\n[\n    Message(\n        sender=\"system\",\n        content=\"Your task is to create a concise running summary of actions and information results in the provided text, focusing on key and potentially important information to remember.\\n\\nYou will receive the current summary and the your latest actions. Combine them, adding relevant key information from the latest development in 1st person past tense and keeping the summary concise.\\n\\nSummary So Far:\\n\\\"\\\"\\\"\\n{father_summarize_node.summarization_from_root_to_here}\\n\\\"\\\"\\\"\\n\\nLatest Development:\\n\\\"\\\"\\\"\\n{[message.content for message in new_message] or \"Nothing new happened.\"}\\n\\\"\\\"\\\"\\n\"\n    )\n]\n```",
            "code_start_line": 155,
            "code_end_line": 173,
            "parent": "SummarizationTrieTree",
            "have_return": true,
            "code_content": "    def get_summarzation_message_recursive(cls, father_summarize_node: SummarizationNode, new_message: Message):\n        system_prompt = f'''Your task is to create a concise running summary of actions and information results in the provided text, focusing on key and potentially important information to remember.\n\n        You will receive the current summary and the your latest actions. Combine them, adding relevant key information from the latest development in 1st person past tense and keeping the summary concise.\n\n        Summary So Far:\n        \"\"\"\n        {father_summarize_node.summarization_from_root_to_here}\n        \"\"\"\n\n        Latest Development:\n        \"\"\"\n        {[message.content for message in new_message] or \"Nothing new happened.\"}\n        \"\"\"\n        '''\n\n        message_list = [Message(\"system\",system_prompt )]\n\n        return message_list\n",
            "name_column": 8
        },
        "generate_summary": {
            "type": "FunctionDef",
            "name": "generate_summary",
            "md_content": "**generate_summary函数**：该函数的功能是为给定的消息列表生成摘要。\n\n该函数接受以下参数：\n- message_list（List[Message]）：要进行摘要的消息列表。\n- recursive_mode（bool）：指示是否需要递归模式摘要的标志。\n\n该函数返回一个字符串，表示新生成的摘要内容文本。\n\n该函数的详细分析和描述如下：\n该函数首先通过调用query函数来查询消息列表的摘要节点。如果查询结果的状态码为SummarizationTreeQueryResult.have_summary，则断言失败。\n如果递归模式为True，则再次调用query函数查询消息列表去掉最后一条消息的结果。如果查询结果的状态码为SummarizationTreeQueryResult.have_summary，则断言成功。\n然后，通过调用get_summarzation_message_recursive函数或get_summarzation_message_all函数来获取摘要消息列表。\n如果递归模式为False，并且查询结果的状态码为SummarizationTreeQueryResult.not_in_tree，则调用insert函数将消息列表插入到摘要树中。\n最后，通过调用agent_dispatcher的dispatch函数来获取与摘要相关的agent，并调用agent的parse函数来解析摘要内容。\n将解析结果中的新摘要赋值给summarize_node的summarization_from_root_to_here属性，并返回新摘要。\n\n**注意**：关于代码使用的注意事项\n\n**输出示例**：模拟代码返回值的可能外观。",
            "code_start_line": 176,
            "code_end_line": 217,
            "parent": "SummarizationTrieTree",
            "have_return": true,
            "code_content": "    def generate_summary(self, message_list, recursive_mode=True, agent_dispatcher=None):\n        \"\"\"Generates a summary for the given list of messages.\n\n        Args:\n            message_list (List[Message]): List of messages to be summarized.\n            recursive_mode (bool): Flag indicating if recursive mode summarization is required.\n            \n        Returns:\n            str: The new summarized content text.\n        \"\"\"\n        status_code, summarize_node = self.query(message_list)\n        assert status_code != SummarizationTreeQueryResult.have_summary\n        if recursive_mode:\n            status_code, summarize_node = self.query(message_list[:-1])\n            assert status_code == SummarizationTreeQueryResult.have_summary\n\n            summarize_message_list = self.get_summarzation_message_recursive(summarize_node, message_list[-1])\n        else:\n            \n            if status_code == SummarizationTreeQueryResult.not_in_tree:\n                summarize_node = self.insert(message_list)\n            summarize_message_list = self.get_summarzation_message_all( summarize_node, message_list)\n\n\n        # print(summarize_message_list)\n        agent = agent_dispatcher.dispatch(\n            RequiredAbilities.summarization, \n            \"Summarize the given content\"\n        )\n\n        _, new_message, _ = agent.parse(placeholders={\n            \"system\": {\n                \"running_summary\": summarize_node.summarization_from_root_to_here,\n                \"new_message\": [message.content for message in message_list] or \"Nothing new happened.\"\n            }\n        })\n\n        new_summary = new_message[\"content\"]\n\n        summarize_node.summarization_from_root_to_here = new_summary\n\n        return new_summary\n",
            "name_column": 8
        }
    },
    "XAgent/__init__.py": {},
    "XAgent/core.py": {
        "XAgentParam": {
            "type": "ClassDef",
            "name": "XAgentParam",
            "md_content": "**XAgentParam函数**: 这个类的功能是XAgent参数。\n\nXAgentParam是一个抽象基类，用于定义XAgent的参数。它具有以下属性和方法：\n\n- 属性：\n  - config：XAgent的配置信息。\n  - query：XAgent的查询对象。\n  - newly_created：一个布尔值，表示是否是新创建的XAgent。\n\n- 方法：\n  - `__init__(self, config=None, query: BaseQuery = None, newly_created: bool = True) -> None`：初始化XAgentParam对象。可以传入config、query和newly_created参数，分别用于设置XAgent的配置信息、查询对象和新创建标志。\n\n  - `build_query(self, query: dict)`：构建查询对象。接受一个字典作为参数，用于构建AutoGPTQuery对象，并将其赋值给query属性。\n\n  - `build_config(self, config)`：构建配置信息。接受一个config对象作为参数，并将其赋值给config属性。\n\n**注意**：在使用XAgentParam类时，可以通过传入config、query和newly_created参数来初始化对象，并使用build_query和build_config方法来构建查询对象和配置信息。",
            "code_start_line": 25,
            "code_end_line": 48,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentParam(metaclass=abc.ABCMeta):\n    \"\"\"\n    XAgent Param\n    \"\"\"\n\n    def __init__(self,\n                 config=None,\n                 query: BaseQuery = None,\n                 newly_created: bool = True) -> None:\n        self.config = config\n        self.query = query\n        self.newly_created = newly_created\n\n    def build_query(self, query: dict):\n        \"\"\"\n        build query\n        \"\"\"\n        self.query = AutoGPTQuery(**query)\n\n    def build_config(self, config):\n        \"\"\"\n        build config\n        \"\"\"\n        self.config = config\n",
            "name_column": 6
        },
        "XAgentCoreComponents": {
            "type": "ClassDef",
            "name": "XAgentCoreComponents",
            "md_content": "**XAgentCoreComponents函数**: 这个类的功能是XAgent核心组件集，它包含了XAgent的核心组件，用于处理交互、记录运行记录、与工具服务接口通信、处理功能、管理工作记忆、调度代理、与向量数据库接口通信等。\n\n该类的构造函数初始化了所有的组件，并提供了注册和启动这些组件的方法。以下是该类的主要方法和功能：\n\n- `register_interaction(interaction: XAgentInteraction)`: 注册一个交互对象到核心组件中。\n- `register_logger()`: 注册一个日志记录器到核心组件中。\n- `resister_recorder(param: XAgentParam)`: 注册一个运行记录器到核心组件中。\n- `register_toolserver_interface(param: XAgentParam)`: 注册一个工具服务接口到核心组件中。\n- `register_function_handler(config)`: 注册一个功能处理器到核心组件中。\n- `register_working_memory_function()`: 注册一个工作记忆代理到核心组件中。\n- `register_agent_dispatcher(param: XAgentParam)`: 注册一个代理调度器到核心组件中。\n- `register_vector_db_interface()`: 注册一个向量数据库接口到核心组件中。\n- `register_all(param: XAgentParam, interaction: XAgentInteraction)`: 注册所有组件到核心组件中。\n- `build(param: XAgentParam, interaction: XAgentInteraction)`: 构建所有组件。\n- `start()`: 启动所有组件。\n- `close()`: 关闭所有组件。\n- `print_task_save_items(item: TaskSaveItem)`: 打印任务保存项的信息。\n- `print_assistant_thoughts(assistant_reply_json_valid: object, speak_mode: bool = False)`: 打印助手的思考信息。\n\n**注意**: \n- 该类的所有组件在组件集中是全局唯一的。\n- 注册方法用于将各个组件注册到核心组件中，构建方法用于初始化所有组件，启动方法用于启动所有组件，关闭方法用于关闭所有组件。\n- `print_task_save_items`方法用于打印任务保存项的详细信息，包括任务名称、目标、前期批评、后期批评、里程碑等。\n- `print_assistant_thoughts`方法用于打印助手的思考信息，包括思考、推理、计划、批评等。\n\n**输出示例**:\n```\nXAgentCoreComponents函数: 这个类的功能是XAgent核心组件集，它包含了XAgent的核心组件，用于处理交互、记录运行记录、与工具服务接口通信、处理功能、管理工作记忆、调度代理、与向量数据库接口通信等。\n\n该类的构造函数初始化了所有的组件，并提供了注册和启动这些组件的方法。以下是该类的主要方法和功能：\n\n- register_interaction(interaction: XAgentInteraction): 注册一个交互对象到核心组件中。\n- register_logger(): 注册一个日志记录器到核心组件中。\n- resister_recorder(param: XAgentParam): 注册一个运行记录器到核心组件中。\n- register_toolserver_interface(param: XAgentParam): 注册一个工具服务接口到核心组件中。\n- register_function_handler(config): 注册一个功能处理器到核心组件中。\n- register_working_memory_function(): 注册一个工作记忆代理到核心组件中。\n- register_agent_dispatcher(param: XAgentParam): 注册一个代理调度器到核心组件中。\n- register_vector_db_interface(): 注册一个向量数据库接口到核心组件中。\n- register_all(param: XAgentParam, interaction: XAgentInteraction): 注册所有组件到核心组件中。\n- build(param: XAgentParam, interaction: XAgentInteraction): 构建所有组件。\n- start(): 启动所有组件。\n- close(): 关闭所有组件。\n- print_task_save_items(item: TaskSaveItem): 打印任务保存项的信息。\n- print_assistant_thoughts(assistant_reply_json_valid: object, speak_mode: bool = False): 打印助手的思考信息。\n\n注意: \n- 该类的所有组件在组件集中是全局唯一的。\n- 注册方法用于将各个组件注册到核心组件中，构建方法用于初始化所有组件，启动方法用于启动所有组件，关闭方法用于关闭所有组件。\n- print_task_save_items方法用于打印任务保存项的详细信息，包括任务名称、目标、前期批评、后期批评、里程碑等。\n- print_assistant_thoughts方法用于打印助手的思考信息，包括思考、推理、计划、批评等。\n```",
            "code_start_line": 51,
            "code_end_line": 326,
            "parent": null,
            "have_return": true,
            "code_content": "class XAgentCoreComponents(metaclass=abc.ABCMeta):\n    \"\"\"\n    XAgent 核心组件集 / XAgent Core Components\n    Components:\n        logger: 日志 / logger\n        recorder: 运行记录 / running recorder\n        toolserver_interface: 工具服务接口 / tool server interface\n        function_handler: 功能处理器 / function handler\n        working_memory_function: 工作记忆 / working memory\n        agent_dispatcher: 代理调度器 / agent dispatcher\n        vector_db_interface: 向量数据库接口 / vector db interface\n        interaction: 交互 / interaction\n\n\n    组件集中的所有组件全局唯一 / all components in the component set are globally unique\n\n    \"\"\"\n\n    global_recorder = None\n\n    def __init__(self) -> None:\n        self.interaction = None\n        self.logger = None\n        self.recorder = None\n        self.toolserver_interface = None\n        self.function_handler = None\n        self.tool_functions_description_list = []\n        self.function_list = []\n        self.working_memory_function = None\n        self.agent_dispatcher = None\n        self.vector_db_interface = None\n        self.base_dir = \"\"\n        self.extract_dir = \"\"\n        self.available_agents = [\n            PlanGenerateAgent,\n            PlanRefineAgent,\n            ToolAgent,\n            ReflectAgent,\n        ]\n\n    def register_interaction(self,\n                             interaction: XAgentInteraction):\n        \"\"\"\n        register an interaction to the core components\n        \"\"\"\n        self.interaction = interaction\n\n    def register_logger(self):\n        \"\"\"\n        register a logger to the core components\n        \"\"\"\n        self.base_dir = os.path.join(\n            os.path.join(XAgentServerEnv.base_dir,\n                         \"localstorage\",\n                         \"interact_records\"),\n            datetime.now().strftime(\"%Y-%m-%d\"),\n            self.interaction.base.interaction_id)\n        if not os.path.exists(self.base_dir):\n            os.makedirs(self.base_dir, exist_ok=True)\n\n        self.extract_dir = os.path.join(self.base_dir, \"workspace\")\n        if not os.path.exists(self.extract_dir):\n            os.makedirs(self.extract_dir, exist_ok=True)\n        self.logger = self.interaction.logger\n\n    def resister_recorder(self, param: XAgentParam):\n        \"\"\"\n        register a recorder to the core components\n        \"\"\"\n        self.recorder = RunningRecoder(\n            record_id=self.interaction.base.interaction_id,\n            newly_start=param.newly_created,\n            root_dir=self.base_dir,\n            logger=self.logger\n        )\n        if param.newly_created:\n            self.recorder.regist_query(param.query)\n            self.recorder.regist_config(param.config)\n        else:\n            self.recorder.load_from_db(self.interaction.base.recorder_root_dir)\n            self.recorder.regist_query(param.query)\n            self.recorder.regist_config(param.config)\n\n        XAgentCoreComponents.global_recorder = self.recorder\n\n    def register_toolserver_interface(self, param: XAgentParam):\n        \"\"\"\n        register a tool server interface to the core components\n        \"\"\"\n        self.logger.info(\"register tool server interface\")\n        self.toolserver_interface = ToolServerInterface(\n            self.recorder, logger=self.logger)\n        self.logger.info(\"lazy init tool server interface\")\n        self.toolserver_interface.lazy_init(config=param.config)\n        # to download all files\n        self.interaction.register_toolserver_interface(\n            self.toolserver_interface)\n\n    def register_function_handler(self, config):\n        \"\"\"\n        register a function handler to the core components\n        \"\"\"\n        self.logger.info(\"register function handler\")\n        self.function_handler = FunctionHandler(\n            toolserver_interface=self.toolserver_interface,\n            config=config,\n            interaction=self.interaction,\n            recorder=self.recorder,\n            logger=self.logger)\n\n    def register_working_memory_function(self):\n        \"\"\"\n        register a working memory agent to the core components\n        \"\"\"\n        # working memory function is used for\n        # communication between different agents that handle different subtasks\n        self.logger.info(\"register working memory function\")\n        self.working_memory_agent = WorkingMemoryAgent(logger=self.logger)\n        self.working_memory_function = WorkingMemoryAgent.get_working_memory_function()\n\n    def register_agent_dispatcher(self, param: XAgentParam):\n        \"\"\"\n        register a agent dispatcher to the core components\n        \"\"\"\n        self.logger.info(\"register agent dispatcher\")\n        self.agent_dispatcher = XAgentDispatcher(param.config,\n                                                 enable=False,\n                                                 logger=self.logger)\n        for agent in self.available_agents:\n            self.agent_dispatcher.regist_agent(agent)\n\n    def register_vector_db_interface(self):\n        \"\"\"\n        register a vector db interface to the core components\n        \"\"\"\n        # self.vector_db_interface = VectorDBInterface()\n        pass\n\n    def register_all(self, param: XAgentParam, interaction: XAgentInteraction):\n        \"\"\"\n        register all components to the core components\n        \"\"\"\n        self.register_interaction(interaction)\n        self.register_logger()\n        self.resister_recorder(param)\n        self.register_toolserver_interface(param)\n        self.register_function_handler(param.config)\n        self.register_working_memory_function()\n        self.register_agent_dispatcher(param=param)\n        self.register_vector_db_interface()\n\n    def build(self, param: XAgentParam, interaction: XAgentInteraction):\n        \"\"\"\n        start all components\n        \"\"\"\n        self.register_all(param, interaction)\n        self.logger.info(\"build all components, done!\")\n\n        subtask_functions, self.tool_functions_description_list = self.function_handler.get_functions(\n            param.config)\n        self.function_list = subtask_functions + self.working_memory_function\n\n    def start(self):\n        \"\"\"\n        start all components\n        \"\"\"\n        self.logger.info(\"start all components\")\n\n    def close(self):\n        \"\"\"\n        close all components\n        \"\"\"\n        self.toolserver_interface.download_all_files()\n        self.toolserver_interface.close()\n\n    def print_task_save_items(self,\n                              item: TaskSaveItem,\n                              ) -> None:\n\n        self.logger.typewriter_log(\n            f\"Task Name:\", Fore.YELLOW, f\"{item.name}\"\n        )\n        self.logger.typewriter_log(\n            f\"Task Goal:\", Fore.YELLOW, f\"{item.goal}\"\n        )\n        self.logger.typewriter_log(\n            f\"Task Prior-Criticism:\", Fore.YELLOW, f\"{item.prior_plan_criticism}\"\n        )\n        if len(item.posterior_plan_reflection) > 0:\n            self.logger.typewriter_log(\n                f\"Task Posterior-Criticism:\", Fore.YELLOW\n            )\n            for line in item.posterior_plan_reflection:\n                line = line.lstrip(\"- \")\n                self.logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n        if len(item.milestones) > 0:\n            self.logger.typewriter_log(\n                f\"Task Milestones:\", Fore.YELLOW,\n            )\n            for line in item.milestones:\n                line = line.lstrip(\"- \")\n                self.logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n        # if len(item.expected_tools) > 0:\n        #     logger.typewriter_log(\n        #         f\"Expected Tools:\", Fore.YELLOW,\n        #     )\n        #     for line in item.expected_tools:\n        #         line = f\"{line['tool_name']}: {line['reason']}\".lstrip(\"- \")\n        #         logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n        if len(item.tool_reflection) > 0:\n            self.logger.typewriter_log(\n                f\"Posterior Tool Reflections:\", Fore.YELLOW,\n            )\n            for line in item.tool_reflection:\n                line = f\"{line['target_tool_name']}: {line['reflection']}\".lstrip(\n                    \"- \")\n                self.logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n\n        self.logger.typewriter_log(\n            f\"Task Status:\", Fore.YELLOW, f\"{item.status.name}\"\n        )\n        if item.action_list_summary != \"\":\n            self.logger.typewriter_log(\n                f\"Action Summary:\", Fore.YELLOW, f\"{item.action_list_summary}\"\n            )\n\n    def print_assistant_thoughts(\n        self,\n        # ai_name: object,\n        assistant_reply_json_valid: object,\n        speak_mode: bool = False,\n    ) -> None:\n        assistant_thoughts_reasoning = None\n        assistant_thoughts_plan = None\n        assistant_thoughts_speak = None\n        assistant_thoughts_criticism = None\n\n        assistant_thoughts = assistant_reply_json_valid.get(\"thoughts\", {})\n        assistant_thoughts = assistant_thoughts.get(\"properties\", {})\n        assistant_thoughts_text = assistant_thoughts.get(\"thought\")\n        if assistant_thoughts:\n            assistant_thoughts_reasoning = assistant_thoughts.get(\"reasoning\")\n            assistant_thoughts_plan = assistant_thoughts.get(\"plan\")\n            assistant_thoughts_criticism = assistant_thoughts.get(\"criticism\")\n        if assistant_thoughts_text is not None and assistant_thoughts_text != \"\":\n            self.logger.typewriter_log(\n                f\"THOUGHTS:\", Fore.YELLOW, f\"{assistant_thoughts_text}\"\n            )\n        if assistant_thoughts_reasoning is not None and assistant_thoughts_reasoning != \"\":\n            self.logger.typewriter_log(\n                \"REASONING:\", Fore.YELLOW, f\"{assistant_thoughts_reasoning}\")\n\n        if assistant_thoughts_plan is not None and len(assistant_thoughts_plan) > 0:\n            self.logger.typewriter_log(\"PLAN:\", Fore.YELLOW, \"\")\n            # If it's a list, join it into a string\n            if isinstance(assistant_thoughts_plan, list):\n                assistant_thoughts_plan = \"\\n\".join(assistant_thoughts_plan)\n            elif isinstance(assistant_thoughts_plan, dict):\n                assistant_thoughts_plan = str(assistant_thoughts_plan)\n\n            # Split the input_string using the newline character and dashes\n            lines = assistant_thoughts_plan.split(\"\\n\")\n            for line in lines:\n                line = line.lstrip(\"- \")\n                self.logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n\n        if assistant_thoughts_criticism is not None and assistant_thoughts_criticism != \"\":\n            self.logger.typewriter_log(\n                \"CRITICISM:\", Fore.YELLOW, f\"{assistant_thoughts_criticism}\")\n        return {\n            \"thoughts\": assistant_thoughts_text,\n            \"reasoning\": assistant_thoughts_reasoning,\n            \"plan\": assistant_thoughts_plan,\n            \"criticism\": assistant_thoughts_criticism,\n            \"node_id\": uuid.uuid4().hex\n        }\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__函数**：这个函数的作用是初始化一个对象。\n\n在这个函数中，有以下几个属性被初始化：\n- interaction：用于与用户进行交互的对象。\n- logger：用于记录日志的对象。\n- recorder：用于记录用户操作的对象。\n- toolserver_interface：与工具服务器进行通信的接口对象。\n- function_handler：用于处理函数的对象。\n- tool_functions_description_list：工具函数的描述列表。\n- function_list：函数列表。\n- working_memory_function：工作内存函数。\n- agent_dispatcher：用于分发代理的对象。\n- vector_db_interface：与向量数据库进行通信的接口对象。\n- base_dir：基础目录。\n- extract_dir：提取目录。\n- available_agents：可用的代理列表，包括PlanGenerateAgent、PlanRefineAgent、ToolAgent和ReflectAgent。\n\n**注意**：在使用这段代码时需要注意以下几点：\n- 在使用这个对象之前，需要先对其进行初始化，即调用`__init__`函数。\n- 在初始化对象时，可以根据需要设置各个属性的值。\n- 可以根据需要对属性进行修改或访问。\n\n以上是对该对象的详细解释和说明。",
            "code_start_line": 71,
            "code_end_line": 89,
            "parent": "XAgentCoreComponents",
            "have_return": false,
            "code_content": "    def __init__(self) -> None:\n        self.interaction = None\n        self.logger = None\n        self.recorder = None\n        self.toolserver_interface = None\n        self.function_handler = None\n        self.tool_functions_description_list = []\n        self.function_list = []\n        self.working_memory_function = None\n        self.agent_dispatcher = None\n        self.vector_db_interface = None\n        self.base_dir = \"\"\n        self.extract_dir = \"\"\n        self.available_agents = [\n            PlanGenerateAgent,\n            PlanRefineAgent,\n            ToolAgent,\n            ReflectAgent,\n        ]\n",
            "name_column": 8
        },
        "build_query": {
            "type": "FunctionDef",
            "name": "build_query",
            "md_content": "**build_query函数**：此函数的功能是构建查询。\n\n该函数接受一个名为query的字典作为参数，并使用该参数构建一个AutoGPTQuery对象，并将其赋值给self.query属性。\n\n**注意**：在使用此代码时需要注意以下几点：\n- query参数必须是一个字典类型。\n- 构建的AutoGPTQuery对象将被赋值给self.query属性，可以在函数外部访问该属性。",
            "code_start_line": 38,
            "code_end_line": 42,
            "parent": "XAgentParam",
            "have_return": false,
            "code_content": "    def build_query(self, query: dict):\n        \"\"\"\n        build query\n        \"\"\"\n        self.query = AutoGPTQuery(**query)\n",
            "name_column": 8
        },
        "build_config": {
            "type": "FunctionDef",
            "name": "build_config",
            "md_content": "**build_config函数**：这个函数的功能是构建配置。\n\n该函数接受一个config参数，并将其赋值给self.config。这个函数没有返回值。\n\n在XAgentServer/server.py文件中的interact函数中调用了build_config函数。在调用之前，先重新加载配置文件，然后根据传入的参数args构建查询参数xagent_param，并调用xagent_param的build_config方法将config配置传入。最后，通过XAgentCoreComponents类的实例xagent_core调用build方法，将xagent_param和interaction作为参数传入，构建XAgent核心组件。\n\n需要注意的是，build_config函数没有返回值。\n\n**注意**：在使用该函数时需要注意以下几点：\n- 该函数需要传入一个config参数，确保参数的正确性和完整性。\n- 该函数没有返回值，只是将传入的config参数赋值给self.config属性。",
            "code_start_line": 44,
            "code_end_line": 48,
            "parent": "XAgentParam",
            "have_return": false,
            "code_content": "    def build_config(self, config):\n        \"\"\"\n        build config\n        \"\"\"\n        self.config = config\n",
            "name_column": 8
        },
        "register_interaction": {
            "type": "FunctionDef",
            "name": "register_interaction",
            "md_content": "**register_interaction函数**：此函数的功能是将一个interaction对象注册到核心组件中。\n\n该函数接受一个interaction参数，该参数是一个XAgentInteraction对象，用于表示一个交互。\n\n在XAgent/core.py文件中的register_all函数中，调用了register_interaction函数。register_all函数用于将所有组件注册到核心组件中。在register_all函数中，首先调用了register_interaction函数，将interaction对象注册到核心组件中。\n\n**注意**：使用此代码时需要注意以下几点：\n- 确保传入的interaction参数是一个有效的XAgentInteraction对象。\n- 注册interaction对象后，可以在核心组件中使用该对象进行后续操作。",
            "code_start_line": 91,
            "code_end_line": 96,
            "parent": "XAgentCoreComponents",
            "have_return": false,
            "code_content": "    def register_interaction(self,\n                             interaction: XAgentInteraction):\n        \"\"\"\n        register an interaction to the core components\n        \"\"\"\n        self.interaction = interaction\n",
            "name_column": 8
        },
        "register_logger": {
            "type": "FunctionDef",
            "name": "register_logger",
            "md_content": "**register_logger函数**：该函数的功能是将一个日志记录器注册到核心组件中。\n\n该函数的详细代码分析和描述如下：\n- 首先，通过拼接路径的方式创建一个基础目录base_dir，该目录用于存储交互记录。拼接路径的方式是将XAgentServerEnv.base_dir、\"localstorage\"、\"interact_records\"、当前日期和交互记录的ID依次拼接而成。其中，XAgentServerEnv.base_dir是一个全局变量，表示XAgentServer的基础目录；\"localstorage\"和\"interact_records\"是两个子目录；当前日期通过datetime.now().strftime(\"%Y-%m-%d\")获取；交互记录的ID通过self.interaction.base.interaction_id获取。如果base_dir目录不存在，则会创建该目录。\n- 然后，通过拼接路径的方式创建一个提取目录extract_dir，该目录用于存储工作空间。拼接路径的方式是将base_dir和\"workspace\"依次拼接而成。如果extract_dir目录不存在，则会创建该目录。\n- 最后，将self.interaction.logger赋值给self.logger，将交互记录的日志记录器注册到核心组件中。\n\n**注意**：使用该代码需要注意以下几点：\n- 该函数依赖于XAgentServerEnv.base_dir、datetime.now().strftime(\"%Y-%m-%d\")和self.interaction.base.interaction_id等变量的值，需要确保这些变量的值正确且已经初始化。\n- 该函数会在指定路径下创建目录，需要确保对应的文件系统权限和目录结构正确。\n- 该函数会将交互记录的日志记录器注册到核心组件中，需要确保核心组件已经初始化并正确运行。\n\n以上是对register_logger函数的详细分析和描述，希望能帮助您理解该函数的功能和使用方式。",
            "code_start_line": 98,
            "code_end_line": 114,
            "parent": "XAgentCoreComponents",
            "have_return": false,
            "code_content": "    def register_logger(self):\n        \"\"\"\n        register a logger to the core components\n        \"\"\"\n        self.base_dir = os.path.join(\n            os.path.join(XAgentServerEnv.base_dir,\n                         \"localstorage\",\n                         \"interact_records\"),\n            datetime.now().strftime(\"%Y-%m-%d\"),\n            self.interaction.base.interaction_id)\n        if not os.path.exists(self.base_dir):\n            os.makedirs(self.base_dir, exist_ok=True)\n\n        self.extract_dir = os.path.join(self.base_dir, \"workspace\")\n        if not os.path.exists(self.extract_dir):\n            os.makedirs(self.extract_dir, exist_ok=True)\n        self.logger = self.interaction.logger\n",
            "name_column": 8
        },
        "resister_recorder": {
            "type": "FunctionDef",
            "name": "resister_recorder",
            "md_content": "**resister_recorder函数**：该函数的功能是将一个记录器注册到核心组件中。\n\n该函数接受一个参数param，类型为XAgentParam。函数内部首先创建一个RunningRecoder对象，并将其赋值给self.recorder属性。RunningRecoder对象的构造函数接受以下参数：\n- record_id：交互的唯一标识符，即interaction_id。\n- newly_start：一个布尔值，表示是否是新创建的交互。\n- root_dir：记录器的根目录，即base_dir。\n- logger：日志记录器。\n\n接下来，根据param.newly_created的值，分别执行不同的逻辑：\n- 如果param.newly_created为True，表示是新创建的交互，那么调用self.recorder的regist_query方法，将param.query注册到记录器中；调用self.recorder的regist_config方法，将param.config注册到记录器中。\n- 如果param.newly_created为False，表示不是新创建的交互，那么调用self.recorder的load_from_db方法，从数据库中加载记录器；然后调用self.recorder的regist_query方法，将param.query注册到记录器中；调用self.recorder的regist_config方法，将param.config注册到记录器中。\n\n最后，将self.recorder赋值给XAgentCoreComponents类的global_recorder属性。\n\n**注意**：使用该代码时需要注意以下几点：\n- 该函数需要一个XAgentParam类型的参数param，确保传入正确的参数类型。\n- 在调用该函数之前，需要先调用register_all函数，将param和interaction参数传入。",
            "code_start_line": 116,
            "code_end_line": 134,
            "parent": "XAgentCoreComponents",
            "have_return": false,
            "code_content": "    def resister_recorder(self, param: XAgentParam):\n        \"\"\"\n        register a recorder to the core components\n        \"\"\"\n        self.recorder = RunningRecoder(\n            record_id=self.interaction.base.interaction_id,\n            newly_start=param.newly_created,\n            root_dir=self.base_dir,\n            logger=self.logger\n        )\n        if param.newly_created:\n            self.recorder.regist_query(param.query)\n            self.recorder.regist_config(param.config)\n        else:\n            self.recorder.load_from_db(self.interaction.base.recorder_root_dir)\n            self.recorder.regist_query(param.query)\n            self.recorder.regist_config(param.config)\n\n        XAgentCoreComponents.global_recorder = self.recorder\n",
            "name_column": 8
        },
        "register_toolserver_interface": {
            "type": "FunctionDef",
            "name": "register_toolserver_interface",
            "md_content": "**register_toolserver_interface函数**：该函数的功能是将一个工具服务器接口注册到核心组件中。\n\n该函数的详细代码分析和描述如下：\n- 首先，函数使用self.logger.info()方法记录一条日志，表示正在注册工具服务器接口。\n- 然后，创建一个ToolServerInterface对象，并将其赋值给self.toolserver_interface属性。在创建对象时，传入self.recorder和self.logger作为参数。\n- 接着，使用self.logger.info()方法记录一条日志，表示正在延迟初始化工具服务器接口。\n- 调用self.toolserver_interface的lazy_init()方法，传入param.config作为参数，完成工具服务器接口的延迟初始化。\n- 最后，调用self.interaction的register_toolserver_interface()方法，将self.toolserver_interface作为参数，注册工具服务器接口。\n\n**注意**：使用该代码时需要注意以下几点：\n- 在调用register_toolserver_interface()函数之前，需要先调用register_interaction()、register_logger()、resister_recorder()等函数，确保相关组件已经注册。\n- 在调用register_toolserver_interface()函数之前，需要传入一个XAgentParam对象和一个XAgentInteraction对象作为参数。\n- 在调用register_toolserver_interface()函数之前，需要确保param对象中的config属性已经设置。\n\n该函数在以下文件中被调用：\n- 文件路径：XAgent/core.py\n- 调用代码：\n  ```\n  def register_all(self, param: XAgentParam, interaction: XAgentInteraction):\n      \"\"\"\n      register all components to the core components\n      \"\"\"\n      self.register_interaction(interaction)\n      self.register_logger()\n      self.resister_recorder(param)\n      self.register_toolserver_interface(param)\n      self.register_function_handler(param.config)\n      self.register_working_memory_function()\n      self.register_agent_dispatcher(param=param)\n      self.register_vector_db_interface()\n  ```\n  在register_all()函数中，先调用了register_interaction()、register_logger()、resister_recorder()等函数，然后调用了register_toolserver_interface()函数。在调用register_toolserver_interface()函数时，传入了param作为参数。",
            "code_start_line": 136,
            "code_end_line": 147,
            "parent": "XAgentCoreComponents",
            "have_return": false,
            "code_content": "    def register_toolserver_interface(self, param: XAgentParam):\n        \"\"\"\n        register a tool server interface to the core components\n        \"\"\"\n        self.logger.info(\"register tool server interface\")\n        self.toolserver_interface = ToolServerInterface(\n            self.recorder, logger=self.logger)\n        self.logger.info(\"lazy init tool server interface\")\n        self.toolserver_interface.lazy_init(config=param.config)\n        # to download all files\n        self.interaction.register_toolserver_interface(\n            self.toolserver_interface)\n",
            "name_column": 8
        },
        "register_function_handler": {
            "type": "FunctionDef",
            "name": "register_function_handler",
            "md_content": "**register_function_handler函数**：此函数的功能是将一个函数处理程序注册到核心组件中。\n\n该函数用于将一个函数处理程序注册到核心组件中。函数处理程序负责处理来自工具服务器的请求，并将结果返回给工具服务器。注册函数处理程序需要传入以下参数：\n- toolserver_interface：工具服务器接口，用于与工具服务器进行通信。\n- config：配置信息，包含函数处理程序的相关配置。\n- interaction：交互对象，用于与用户进行交互。\n- recorder：记录器，用于记录交互过程和结果。\n- logger：日志记录器，用于记录日志信息。\n\n在函数内部，首先使用日志记录器记录一条信息，表示正在注册函数处理程序。然后，创建一个FunctionHandler对象，并将上述参数传递给它进行初始化。\n\n需要注意的是：\n- 函数处理程序负责处理来自工具服务器的请求，并将结果返回给工具服务器，因此在注册函数处理程序之前，需要确保已经注册了与工具服务器的接口。\n- 注册函数处理程序需要传入合适的配置信息，以确保函数处理程序能够正常运行。\n- 函数处理程序需要与交互对象和记录器进行交互，因此在注册函数处理程序之前，需要确保已经注册了交互对象和记录器。\n- 注册函数处理程序需要使用日志记录器进行日志记录，因此在注册函数处理程序之前，需要确保已经注册了日志记录器。",
            "code_start_line": 149,
            "code_end_line": 159,
            "parent": "XAgentCoreComponents",
            "have_return": false,
            "code_content": "    def register_function_handler(self, config):\n        \"\"\"\n        register a function handler to the core components\n        \"\"\"\n        self.logger.info(\"register function handler\")\n        self.function_handler = FunctionHandler(\n            toolserver_interface=self.toolserver_interface,\n            config=config,\n            interaction=self.interaction,\n            recorder=self.recorder,\n            logger=self.logger)\n",
            "name_column": 8
        },
        "register_working_memory_function": {
            "type": "FunctionDef",
            "name": "register_working_memory_function",
            "md_content": "**register_working_memory_function函数**：该函数的功能是注册一个工作内存代理到核心组件中。\n\n该函数用于将一个工作内存代理注册到核心组件中，以便于不同处理不同子任务的代理之间进行通信。\n\n在函数内部，首先通过日志记录器记录一条信息，表示正在注册工作内存函数。然后创建一个工作内存代理对象，并将其赋值给self.working_memory_agent。接着调用WorkingMemoryAgent类的get_working_memory_function方法，将返回的工作内存函数赋值给self.working_memory_function。\n\n需要注意的是，该函数在XAgent/core.py文件中被调用，具体调用位置为register_all函数中的self.register_working_memory_function()。\n\n**注意**：使用该代码时需要注意以下几点：\n- 该函数用于注册工作内存代理到核心组件中，确保在需要使用工作内存的场景中调用该函数。\n- 在调用该函数之前，需要确保已经注册了其他必要的组件，如交互对象、日志记录器、录制器等。\n- 该函数会创建一个工作内存代理对象，并将其赋值给self.working_memory_agent，因此在使用工作内存代理对象时，可以通过self.working_memory_agent进行访问。",
            "code_start_line": 161,
            "code_end_line": 169,
            "parent": "XAgentCoreComponents",
            "have_return": false,
            "code_content": "    def register_working_memory_function(self):\n        \"\"\"\n        register a working memory agent to the core components\n        \"\"\"\n        # working memory function is used for\n        # communication between different agents that handle different subtasks\n        self.logger.info(\"register working memory function\")\n        self.working_memory_agent = WorkingMemoryAgent(logger=self.logger)\n        self.working_memory_function = WorkingMemoryAgent.get_working_memory_function()\n",
            "name_column": 8
        },
        "register_agent_dispatcher": {
            "type": "FunctionDef",
            "name": "register_agent_dispatcher",
            "md_content": "**register_agent_dispatcher函数**：这个函数的作用是将一个代理调度器注册到核心组件中。\n\n该函数接受一个参数param，类型为XAgentParam。函数内部首先打印日志信息\"register agent dispatcher\"，然后创建一个XAgentDispatcher对象，并将其赋值给self.agent_dispatcher。创建XAgentDispatcher对象时，传入了param.config、enable=False和self.logger作为参数。接下来，通过循环遍历self.available_agents列表，将每个代理(agent)注册到agent_dispatcher中。\n\n在项目中，该函数被以下文件调用：\n文件路径：XAgent/core.py\n调用代码如下：\n```python\ndef register_all(self, param: XAgentParam, interaction: XAgentInteraction):\n    \"\"\"\n    register all components to the core components\n    \"\"\"\n    self.register_interaction(interaction)\n    self.register_logger()\n    self.resister_recorder(param)\n    self.register_toolserver_interface(param)\n    self.register_function_handler(param.config)\n    self.register_working_memory_function()\n    self.register_agent_dispatcher(param=param)\n    self.register_vector_db_interface()\n```\n\n**注意**：使用该代码时需要注意以下几点：\n- 在调用register_agent_dispatcher函数之前，需要先调用其他相关函数，如register_interaction、register_logger等，以确保所需的组件已经注册到核心组件中。\n- 通过传入不同的参数，可以控制代理调度器的配置和启用状态。",
            "code_start_line": 171,
            "code_end_line": 180,
            "parent": "XAgentCoreComponents",
            "have_return": false,
            "code_content": "    def register_agent_dispatcher(self, param: XAgentParam):\n        \"\"\"\n        register a agent dispatcher to the core components\n        \"\"\"\n        self.logger.info(\"register agent dispatcher\")\n        self.agent_dispatcher = XAgentDispatcher(param.config,\n                                                 enable=False,\n                                                 logger=self.logger)\n        for agent in self.available_agents:\n            self.agent_dispatcher.regist_agent(agent)\n",
            "name_column": 8
        },
        "register_vector_db_interface": {
            "type": "FunctionDef",
            "name": "register_vector_db_interface",
            "md_content": "**register_vector_db_interface函数**：此函数的功能是将一个向量数据库接口注册到核心组件中。\n\n该函数没有具体的实现代码，只有一个占位符的pass语句。这意味着该函数目前没有实际的功能代码，只是一个空函数。\n\n该函数被调用的地方是在XAgent/core.py文件中的register_all函数中。在register_all函数中，register_vector_db_interface函数被调用以注册向量数据库接口到核心组件中。\n\n**注意**：目前register_vector_db_interface函数没有实际的功能代码，需要根据实际需求进行具体的实现。",
            "code_start_line": 182,
            "code_end_line": 187,
            "parent": "XAgentCoreComponents",
            "have_return": false,
            "code_content": "    def register_vector_db_interface(self):\n        \"\"\"\n        register a vector db interface to the core components\n        \"\"\"\n        # self.vector_db_interface = VectorDBInterface()\n        pass\n",
            "name_column": 8
        },
        "register_all": {
            "type": "FunctionDef",
            "name": "register_all",
            "md_content": "**register_all函数**：该函数的功能是将所有组件注册到核心组件中。\n\n在XAgent/core.py文件中，register_all函数被build函数调用。build函数的作用是启动所有组件。在register_all函数中，首先调用self.register_interaction方法将interaction注册到核心组件中，然后调用self.register_logger方法注册日志记录器，接着调用self.resister_recorder方法注册记录器，再调用self.register_toolserver_interface方法注册ToolServer接口，然后调用self.register_function_handler方法注册函数处理器，接着调用self.register_working_memory_function方法注册工作内存函数，然后调用self.register_agent_dispatcher方法注册代理调度器，最后调用self.register_vector_db_interface方法注册向量数据库接口。\n\n在register_all函数中，通过调用各个注册方法，将不同的组件注册到核心组件中，以便后续使用。这些组件包括interaction、日志记录器、记录器、ToolServer接口、函数处理器、工作内存函数、代理调度器和向量数据库接口。\n\n**注意**：在使用该代码时需要注意以下几点：\n- 确保在调用register_all函数之前已经初始化了param和interaction参数。\n- 确保在调用register_all函数之前已经初始化了self.register_interaction、self.register_logger、self.resister_recorder、self.register_toolserver_interface、self.register_function_handler、self.register_working_memory_function、self.register_agent_dispatcher和self.register_vector_db_interface等方法。\n- 确保在调用register_all函数之前已经初始化了self.function_handler、self.working_memory_function和self.logger等属性。",
            "code_start_line": 189,
            "code_end_line": 200,
            "parent": "XAgentCoreComponents",
            "have_return": false,
            "code_content": "    def register_all(self, param: XAgentParam, interaction: XAgentInteraction):\n        \"\"\"\n        register all components to the core components\n        \"\"\"\n        self.register_interaction(interaction)\n        self.register_logger()\n        self.resister_recorder(param)\n        self.register_toolserver_interface(param)\n        self.register_function_handler(param.config)\n        self.register_working_memory_function()\n        self.register_agent_dispatcher(param=param)\n        self.register_vector_db_interface()\n",
            "name_column": 8
        },
        "build": {
            "type": "FunctionDef",
            "name": "build",
            "md_content": "**build函数**：该函数的功能是启动所有组件。\n\n在该函数中，首先调用了`register_all`函数，该函数用于注册所有组件。然后，通过日志记录了\"build all components, done!\"的信息。\n\n接下来，通过调用`function_handler`对象的`get_functions`函数，获取了子任务函数列表`subtask_functions`和工作内存函数列表`self.working_memory_function`。同时，将工具函数的描述信息保存在`self.tool_functions_description_list`中。\n\n**注意**：在使用该函数时需要注意以下几点：\n- 在调用`build`函数之前，需要先调用`register_all`函数进行组件的注册。\n- 在调用`build`函数之后，可以通过`self.tool_functions_description_list`获取工具函数的描述信息。",
            "code_start_line": 202,
            "code_end_line": 211,
            "parent": "XAgentCoreComponents",
            "have_return": false,
            "code_content": "    def build(self, param: XAgentParam, interaction: XAgentInteraction):\n        \"\"\"\n        start all components\n        \"\"\"\n        self.register_all(param, interaction)\n        self.logger.info(\"build all components, done!\")\n\n        subtask_functions, self.tool_functions_description_list = self.function_handler.get_functions(\n            param.config)\n        self.function_list = subtask_functions + self.working_memory_function\n",
            "name_column": 8
        },
        "start": {
            "type": "FunctionDef",
            "name": "start",
            "md_content": "**start函数**：该函数的功能是启动所有组件。\n\n该函数用于启动所有组件，并在日志中记录“start all components”。\n\n**注意**：无特殊注意事项。",
            "code_start_line": 213,
            "code_end_line": 217,
            "parent": "XAgentCoreComponents",
            "have_return": false,
            "code_content": "    def start(self):\n        \"\"\"\n        start all components\n        \"\"\"\n        self.logger.info(\"start all components\")\n",
            "name_column": 8
        },
        "close": {
            "type": "FunctionDef",
            "name": "close",
            "md_content": "**close函数**：该函数的功能是关闭所有组件。\n\n该函数主要有两个步骤：\n1. 调用toolserver_interface的download_all_files方法，下载所有文件。\n2. 调用toolserver_interface的close方法，关闭组件。\n\n在项目中，该函数被以下文件调用：\n文件路径：XAgentServer/server.py\n调用代码如下：\n```python\ndef interact(self, interaction: XAgentInteraction):\n    # query = message\n    \"\"\"\n    XAgent Server Start Function\n    \"\"\"\n    from XAgent.config import CONFIG as config\n    xagent_core = None\n    try:\n        config.reload()\n        args = {}\n        # args\n        args = interaction.parameter.args\n\n        self.logger.info(\n            f\"server is running, the start query is {args.get('goal', '')}\")\n        xagent_param = XAgentParam()\n\n        # build query\n        xagent_param.build_query({\n            \"role_name\": \"Assistant\",\n            \"task\": args.get(\"goal\", \"\"),\n            \"plan\": args.get(\"plan\", [\"Pay attention to the language in initial goal, always answer with the same language of the initial goal given.\"]),\n        })\n        xagent_param.build_config(config)\n        xagent_core = XAgentCoreComponents()\n        # build XAgent Core Components\n        xagent_core.build(xagent_param, interaction=interaction)\n        json_str = json.dumps(\n            xagent_param.config.to_dict(), indent=2)\n        json_str=re.sub(r'\"api_key\": \"(.+?)\"', r'\"api_key\": \"**\"', json_str)\n        self.logger.info(json_str)\n        self.logger.typewriter_log(\n            \"Human-In-The-Loop\",\n            Fore.RED,\n            str(xagent_param.config.enable_ask_human_for_help),\n        )\n\n        file_list = interaction.base.file_list\n        for file in file_list:\n            file_uuid = file.get(\"uuid\", \"\")\n            file_name = file.get(\"name\", \"\")\n            if file_uuid.startswith(\"/\"):\n                file_path = file_uuid\n            else:\n                file_path = os.path.join(XAgentServerEnv.Upload.upload_dir,\n                                         interaction.base.user_id, file_uuid)\n\n            upload_dir = os.path.join(\n                xagent_core.base_dir, \"upload\")\n            if not os.path.exists(upload_dir):\n                os.makedirs(upload_dir)\n            # 拷贝到workspace\n            if interaction.call_method == \"web\":\n                shutil.copy(file_path, os.path.join(upload_dir, file_name))\n            else:\n                if os.path.exists(file_path):\n                    if os.path.samefile(file_path, os.path.join(upload_dir, file_name)):\n                        # 文件路径相同,跳过复制\n                        pass\n                    else:\n                        shutil.copy(file_path, os.path.join(upload_dir, file_name))\n                    # shutil.copy(file_path, os.path.join(upload_dir, file_name))\n\n            new_file = os.path.join(upload_dir, file_name)\n            try:\n                xagent_core.toolserver_interface.upload_file(new_file)\n            except Exception as e:\n                self.logger.typewriter_log(\n                    \"Error happens when uploading file\",\n                    Fore.RED,\n                    f\"{new_file}\\n{e}\",\n                )\n                raise XAgentUploadFileError(str(e)) from e\n\n        task_handler = TaskHandler(xagent_core=xagent_core,\n                                   xagent_param=xagent_param)\n        self.logger.info(\"Start outer loop async\")\n        task_handler.outer_loop()\n    except Exception as e:\n        raise XAgentRunningError(str(e)) from e\n    finally:\n        if xagent_core is not None:\n            xagent_core.close()\n```\n\n**注意**：使用该代码时需要注意以下几点：\n- 在调用close函数之前，需要先调用download_all_files方法下载所有文件。\n- 该函数需要在XAgent Server的交互函数interact中调用，用于启动XAgent Server。",
            "code_start_line": 219,
            "code_end_line": 224,
            "parent": "XAgentCoreComponents",
            "have_return": false,
            "code_content": "    def close(self):\n        \"\"\"\n        close all components\n        \"\"\"\n        self.toolserver_interface.download_all_files()\n        self.toolserver_interface.close()\n",
            "name_column": 8
        },
        "print_task_save_items": {
            "type": "FunctionDef",
            "name": "print_task_save_items",
            "md_content": "**print_task_save_items函数**: 这个函数的功能是打印任务的保存项。\n\n该函数用于打印任务的保存项，包括任务名称、任务目标、任务前期批评、任务后期批评、任务里程碑、后续工具反思、任务状态和动作摘要。函数接受一个TaskSaveItem对象作为参数，该对象包含了任务的各个属性。\n\n函数首先使用logger.typewriter_log方法打印任务名称和任务目标，并使用不同的颜色进行标记。然后，如果任务的后期批评不为空，函数会遍历后期批评列表，并使用logger.typewriter_log方法打印每一行。类似地，如果任务的里程碑不为空，函数会遍历里程碑列表，并使用logger.typewriter_log方法打印每一行。接下来，函数会判断任务的预期工具列表是否为空，如果不为空，则遍历预期工具列表，并使用logger.typewriter_log方法打印每个工具的名称和原因。最后，如果任务的工具反思列表不为空，函数会遍历工具反思列表，并使用logger.typewriter_log方法打印每个工具的名称和反思。\n\n在打印完任务的保存项后，函数会使用logger.typewriter_log方法打印任务的状态和动作摘要。\n\n**注意**: 在使用该函数时，需要将一个TaskSaveItem对象作为参数传入。该对象应包含任务的各个属性，并且属性的值应符合预期的格式。",
            "code_start_line": 226,
            "code_end_line": 275,
            "parent": "XAgentCoreComponents",
            "have_return": false,
            "code_content": "    def print_task_save_items(self,\n                              item: TaskSaveItem,\n                              ) -> None:\n\n        self.logger.typewriter_log(\n            f\"Task Name:\", Fore.YELLOW, f\"{item.name}\"\n        )\n        self.logger.typewriter_log(\n            f\"Task Goal:\", Fore.YELLOW, f\"{item.goal}\"\n        )\n        self.logger.typewriter_log(\n            f\"Task Prior-Criticism:\", Fore.YELLOW, f\"{item.prior_plan_criticism}\"\n        )\n        if len(item.posterior_plan_reflection) > 0:\n            self.logger.typewriter_log(\n                f\"Task Posterior-Criticism:\", Fore.YELLOW\n            )\n            for line in item.posterior_plan_reflection:\n                line = line.lstrip(\"- \")\n                self.logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n        if len(item.milestones) > 0:\n            self.logger.typewriter_log(\n                f\"Task Milestones:\", Fore.YELLOW,\n            )\n            for line in item.milestones:\n                line = line.lstrip(\"- \")\n                self.logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n        # if len(item.expected_tools) > 0:\n        #     logger.typewriter_log(\n        #         f\"Expected Tools:\", Fore.YELLOW,\n        #     )\n        #     for line in item.expected_tools:\n        #         line = f\"{line['tool_name']}: {line['reason']}\".lstrip(\"- \")\n        #         logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n        if len(item.tool_reflection) > 0:\n            self.logger.typewriter_log(\n                f\"Posterior Tool Reflections:\", Fore.YELLOW,\n            )\n            for line in item.tool_reflection:\n                line = f\"{line['target_tool_name']}: {line['reflection']}\".lstrip(\n                    \"- \")\n                self.logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n\n        self.logger.typewriter_log(\n            f\"Task Status:\", Fore.YELLOW, f\"{item.status.name}\"\n        )\n        if item.action_list_summary != \"\":\n            self.logger.typewriter_log(\n                f\"Action Summary:\", Fore.YELLOW, f\"{item.action_list_summary}\"\n            )\n",
            "name_column": 8
        },
        "print_assistant_thoughts": {
            "type": "FunctionDef",
            "name": "print_assistant_thoughts",
            "md_content": "**print_assistant_thoughts函数**：该函数的功能是打印助手的思考。\n\n该函数接受三个参数：assistant_reply_json_valid（助手回复的有效JSON对象）、speak_mode（是否为语音模式，默认为False）。该函数没有返回值。\n\n函数内部首先初始化了四个变量：assistant_thoughts_reasoning、assistant_thoughts_plan、assistant_thoughts_speak和assistant_thoughts_criticism，它们的初始值都为None。\n\n接下来，函数从assistant_reply_json_valid中获取助手的思考内容，并将其存储在assistant_thoughts变量中。然后，函数从assistant_thoughts中获取具体的思考属性，并将其存储在assistant_thoughts_reasoning、assistant_thoughts_plan和assistant_thoughts_criticism变量中。\n\n如果assistant_thoughts_text不为None且不为空字符串，则函数使用logger.typewriter_log方法打印出\"THOUGHTS\"和助手的思考内容。\n\n如果assistant_thoughts_reasoning不为None且不为空字符串，则函数使用logger.typewriter_log方法打印出\"REASONING\"和助手的推理内容。\n\n如果assistant_thoughts_plan不为None且长度大于0，则函数使用logger.typewriter_log方法打印出\"PLAN\"和助手的计划内容。如果assistant_thoughts_plan是一个列表，则将其转换为字符串；如果是一个字典，则将其转换为字符串。然后，函数使用换行符将计划内容拆分成多行，并使用logger.typewriter_log方法逐行打印。\n\n如果assistant_thoughts_criticism不为None且不为空字符串，则函数使用logger.typewriter_log方法打印出\"CRITICISM\"和助手的批评内容。\n\n最后，函数返回一个字典，包含助手的思考内容、推理内容、计划内容、批评内容和一个随机生成的node_id。\n\n**注意**：该函数依赖于logger.typewriter_log方法和assistant_reply_json_valid对象的结构。\n\n**输出示例**：假设助手的思考内容为\"这是一个测试\"，推理内容为\"这是一个推理\"，计划内容为[\"步骤1\", \"步骤2\"]，批评内容为\"这是一个批评\"，则函数的返回值为：\n{\n  \"thoughts\": \"这是一个测试\",\n  \"reasoning\": \"这是一个推理\",\n  \"plan\": \"步骤1\\n步骤2\",\n  \"criticism\": \"这是一个批评\",\n  \"node_id\": \"随机生成的node_id\"\n}",
            "code_start_line": 277,
            "code_end_line": 326,
            "parent": "XAgentCoreComponents",
            "have_return": true,
            "code_content": "    def print_assistant_thoughts(\n        self,\n        # ai_name: object,\n        assistant_reply_json_valid: object,\n        speak_mode: bool = False,\n    ) -> None:\n        assistant_thoughts_reasoning = None\n        assistant_thoughts_plan = None\n        assistant_thoughts_speak = None\n        assistant_thoughts_criticism = None\n\n        assistant_thoughts = assistant_reply_json_valid.get(\"thoughts\", {})\n        assistant_thoughts = assistant_thoughts.get(\"properties\", {})\n        assistant_thoughts_text = assistant_thoughts.get(\"thought\")\n        if assistant_thoughts:\n            assistant_thoughts_reasoning = assistant_thoughts.get(\"reasoning\")\n            assistant_thoughts_plan = assistant_thoughts.get(\"plan\")\n            assistant_thoughts_criticism = assistant_thoughts.get(\"criticism\")\n        if assistant_thoughts_text is not None and assistant_thoughts_text != \"\":\n            self.logger.typewriter_log(\n                f\"THOUGHTS:\", Fore.YELLOW, f\"{assistant_thoughts_text}\"\n            )\n        if assistant_thoughts_reasoning is not None and assistant_thoughts_reasoning != \"\":\n            self.logger.typewriter_log(\n                \"REASONING:\", Fore.YELLOW, f\"{assistant_thoughts_reasoning}\")\n\n        if assistant_thoughts_plan is not None and len(assistant_thoughts_plan) > 0:\n            self.logger.typewriter_log(\"PLAN:\", Fore.YELLOW, \"\")\n            # If it's a list, join it into a string\n            if isinstance(assistant_thoughts_plan, list):\n                assistant_thoughts_plan = \"\\n\".join(assistant_thoughts_plan)\n            elif isinstance(assistant_thoughts_plan, dict):\n                assistant_thoughts_plan = str(assistant_thoughts_plan)\n\n            # Split the input_string using the newline character and dashes\n            lines = assistant_thoughts_plan.split(\"\\n\")\n            for line in lines:\n                line = line.lstrip(\"- \")\n                self.logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n\n        if assistant_thoughts_criticism is not None and assistant_thoughts_criticism != \"\":\n            self.logger.typewriter_log(\n                \"CRITICISM:\", Fore.YELLOW, f\"{assistant_thoughts_criticism}\")\n        return {\n            \"thoughts\": assistant_thoughts_text,\n            \"reasoning\": assistant_thoughts_reasoning,\n            \"plan\": assistant_thoughts_plan,\n            \"criticism\": assistant_thoughts_criticism,\n            \"node_id\": uuid.uuid4().hex\n        }\n",
            "name_column": 8
        }
    },
    "XAgent/vector_db.py": {
        "VectorDBInterface": {
            "type": "ClassDef",
            "name": "VectorDBInterface",
            "md_content": "**VectorDBInterface函数**: 这个类用于使用Pinecone API管理向量数据库。\n\n这个类有以下属性：\n- task_index: 一个表示向量数据库的Pinecone索引对象。\n- turbo_keys: 用于验证与数据库连接的密钥列表。\n- vector_count: 数据库中向量的数量。\n\n**__init__函数**: VectorDBInterface类的构造函数。\n\n这个函数初始化了Pinecone API，并创建了一个Pinecone索引对象。\n\n**get_keys函数**: 获取密钥的函数。\n\n这个函数从密钥池中获取密钥，并将它们存储在turbo_keys列表中。\n\n**get_info函数**: 获取数据库信息的函数。\n\n这个函数获取数据库的统计信息，如总向量数量和维度，并将总向量数量存储在vector_count属性中。\n\n**generate_embedding函数**: 生成输入文本的嵌入向量的函数。\n\n这个函数使用OpenAI API生成输入文本的嵌入向量。\n\n**delete_sentence函数**: 从数据库中删除句子的函数。\n\n这个函数从数据库中删除指定的句子。\n\n**insert_sentence函数**: 将句子及其嵌入向量插入数据库的函数。\n\n这个函数生成句子的嵌入向量，并将句子及其嵌入向量插入数据库。\n\n**search_similar_sentences函数**: 搜索与查询句子相似的句子的函数。\n\n这个函数使用查询句子的嵌入向量在数据库中搜索相似的句子。\n\n**注意**: 使用这个类之前需要先安装Pinecone和OpenAI的Python库，并且需要提供正确的API密钥和环境变量。\n\n**输出示例**:\n```\n{\n    \"total_vector_count\": 1000,\n    \"dimension\": 512\n}\nVector Dim 512\nVector Number 1000\n```",
            "code_start_line": 7,
            "code_end_line": 187,
            "parent": null,
            "have_return": true,
            "code_content": "class VectorDBInterface():\n    \"\"\"\n    A class for managing vector databases using the Pinecone API.\n\n    Attributes:\n    task_index : object\n        A Pinecone index object that represents the vector database.\n    turbo_keys : list\n        A list of secret keys used to validate the connection with the database.\n    vector_count : int\n        The number of vectors present in the database.\n\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        The constructor for VectorDBInterface class.\n\n        \"\"\"\n\n        pinecone.init(api_key=\"{API_KEY}\", environment=\"{ENV}\")\n        self.task_index = pinecone.Index(\"{INDEX}\")\n\n        self.get_info()\n        self.get_keys()\n        \n    def get_keys(self):\n        \"\"\"\n        The function to get the secret keys.\n\n        Retrieves the secret keys from the pool and store them in the list turbo_keys.\n\n        \"\"\"\n\n        self.turbo_keys = []\n        lines = pool.split(\"\\n\")\n        for line in lines:\n            striped = line.strip()\n            if striped == \"\":\n                continue\n            contents = striped.split(\"|\")\n            for cont in contents:\n                if cont.startswith(\"sk-\"):\n                    self.turbo_keys.append(cont)\n    \n    def get_info(self):\n        \"\"\"\n        The function to get the information about the database.\n\n        Retrieves the statistics of the database such as total vector count and dimension, \n        and store the total vector count in the vector_count attribute.\n\n        Raises:\n        Exception: An error occured accessing the database.\n\n        \"\"\"\n        \n        try:\n            info = self.task_index.describe_index_stats()\n            self.vector_count = info[\"total_vector_count\"]\n            dimension = info['dimension']\n            print(info)\n            print(\"Vector Dim\", dimension)\n            print(\"Vector Number\", self.vector_count)\n        except:\n            print(\"Warning: Failed to obtain vector information\")\n\n\n    def generate_embedding(self, text:str):\n        \"\"\"\n        The function to generate an embedding for the input text.\n\n        Args:\n        text (str): The input text.\n\n        Returns:\n        list: The embedding of the input text.\n\n        \"\"\"\n        \n        url = \"https://api.openai.com/v1/embeddings\"\n        payload = {\n            \"model\": \"text-embedding-ada-002\",\n            \"input\": text\n        }\n        for key in self.turbo_keys:\n            headers = {\n                \"Content-Type\": \"application/json\",\n                \"Authorization\": f\"Bearer {key}\"\n            }\n            response = requests.post(url, json=payload, headers=headers, timeout=10)\n            try:\n                res = json.loads(response.text)\n                embedding = res['data'][0]['embedding']\n                return embedding\n            except:\n                pass\n\n    def delete_sentence(self, sentence:str):\n        \"\"\"\n        The function to delete a sentence from the database.\n\n        Args:\n        sentence (str): The sentence to be deleted.\n\n        Raises:\n        Exception: An error occured deleting the sentence.\n\n        \"\"\"\n        \n        try:\n            self.task_index.delete(sentence)\n            print(\"Success delete sentence:\", sentence)\n        except:\n            print(\"Warning: Fail to delete sentence\", sentence)\n\n    def insert_sentence(self, vec_sentence:str, sentence:str, namespace=\"\"):\n        \"\"\"\n        The function to insert a sentence with its embedding into the database.\n\n        Args:\n        vec_sentence (str): The sentence to generate the embedding.\n        sentence (str): The sentence to be inserted.\n        namespace (str, optional): The namespace of the vector. Defaults to \"\".\n\n        Raises:\n        Exception: An error occured inserting the sentence.\n\n        \"\"\"\n        \n        embedding = self.generate_embedding(vec_sentence)\n        if embedding:\n            try:\n                self.task_index.upsert(\n                    [(str(self.vector_count),\n                    embedding,\n                    {\"text\":sentence, \"type\":namespace})],\n                )\n                self.vector_count += 1\n            except Exception as e:\n                print(e)\n                print(\"Warning: Fail to insert\", sentence)\n        else:\n            print(\"Warning: Failed to generate embedding for \", sentence)\n\n    def search_similar_sentences(self, query_sentence:str, namespace=\"\", top_k=1):\n        \"\"\"\n        The function to search the database for sentences similar to the query sentence.\n\n        Args:\n        query_sentence (str): The query sentence.\n        namespace (str, optional): The namespace of the vectors. Defaults to \"\".\n        top_k (int, optional): The number of most similar sentences to return. \n            Defaults to 1.\n\n        Returns:\n        object: The most similar sentences.\n\n        Raises:\n        Exception: An error occured searching the database.\n\n        \"\"\"\n        \n        embedding = self.generate_embedding(query_sentence)\n        if embedding:\n            try:\n                res = self.task_index.query(\n                    embedding,\n                    top_k=top_k,\n                    include_metadata=True,\n                    include_values=False,\n                    filter={\n                        \"type\": {\"$eq\": namespace},\n                    },)\n                print(res)\n                return res\n            except Exception as e:\n                print(e)\n                print(\"Warning: Fail to search similar sentences\")\n        else:\n            print(\"Warning: Fail to generate embedding\")\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__函数**：这个函数的功能是初始化VectorDBInterface类。\n\n在这个函数中，首先调用pinecone.init()函数来初始化Pinecone库，传入API_KEY和ENV参数。然后，创建一个pinecone.Index对象，用于与Pinecone索引进行交互，传入INDEX参数。\n\n接下来，调用self.get_info()函数和self.get_keys()函数，分别用于获取索引的信息和键的列表。\n\n**注意**：在使用这段代码时需要注意以下几点：\n- 需要替换\"{API_KEY}\"、\"{ENV}\"和\"{INDEX}\"为实际的值。\n- 在调用pinecone.init()函数之前，需要先安装Pinecone库。",
            "code_start_line": 21,
            "code_end_line": 31,
            "parent": "VectorDBInterface",
            "have_return": false,
            "code_content": "    def __init__(self):\n        \"\"\"\n        The constructor for VectorDBInterface class.\n\n        \"\"\"\n\n        pinecone.init(api_key=\"{API_KEY}\", environment=\"{ENV}\")\n        self.task_index = pinecone.Index(\"{INDEX}\")\n\n        self.get_info()\n        self.get_keys()\n",
            "name_column": 8
        },
        "get_keys": {
            "type": "FunctionDef",
            "name": "get_keys",
            "md_content": "**get_keys函数**：该函数用于获取秘钥。\n\n从池中检索秘钥，并将其存储在turbo_keys列表中。\n\n该函数首先将pool字符串按行分割为列表lines。然后对于lines中的每一行，去除首尾的空格并赋值给striped变量。如果striped为空字符串，则跳过当前循环。接下来，将striped按照\"|\"进行分割，并将分割后的内容存储在列表contents中。然后对于contents中的每一个元素cont，如果cont以\"sk-\"开头，则将cont添加到turbo_keys列表中。\n\n**注意**：使用该代码时需要注意以下几点：\n- 在调用该函数之前，需要先调用get_info函数，确保获取到了必要的信息。\n- 在调用该函数之前，需要先调用pinecone.init函数进行初始化操作，确保可以正常使用pinecone库。\n- 在调用该函数之前，需要先调用pinecone.Index函数创建索引，确保可以正常使用索引操作。",
            "code_start_line": 33,
            "code_end_line": 50,
            "parent": "VectorDBInterface",
            "have_return": false,
            "code_content": "    def get_keys(self):\n        \"\"\"\n        The function to get the secret keys.\n\n        Retrieves the secret keys from the pool and store them in the list turbo_keys.\n\n        \"\"\"\n\n        self.turbo_keys = []\n        lines = pool.split(\"\\n\")\n        for line in lines:\n            striped = line.strip()\n            if striped == \"\":\n                continue\n            contents = striped.split(\"|\")\n            for cont in contents:\n                if cont.startswith(\"sk-\"):\n                    self.turbo_keys.append(cont)\n",
            "name_column": 8
        },
        "get_info": {
            "type": "FunctionDef",
            "name": "get_info",
            "md_content": "**get_info函数**：该函数用于获取数据库的信息。\n\n该函数用于检索数据库的统计信息，例如总向量数量和维度，并将总向量数量存储在vector_count属性中。\n\n**代码分析和描述**：\n- 首先，函数通过调用`self.task_index.describe_index_stats()`获取数据库的统计信息，并将结果存储在变量`info`中。\n- 接下来，函数将`info[\"total_vector_count\"]`赋值给`self.vector_count`，表示数据库中的总向量数量。\n- 然后，函数将`info['dimension']`赋值给`dimension`，表示数据库中向量的维度。\n- 最后，函数打印出`info`、`dimension`和`self.vector_count`的值。\n\n**注意**：使用该代码时需要注意以下几点：\n- 如果访问数据库时出现错误，会抛出异常。\n- 如果无法获取向量信息，会打印警告信息。\n\n该函数在以下文件中被调用：\n文件路径：XAgent/vector_db.py\n调用代码如下：\n```python\ndef __init__(self):\n    \"\"\"\n    VectorDBInterface类的构造函数。\n    \"\"\"\n    pinecone.init(api_key=\"{API_KEY}\", environment=\"{ENV}\")\n    self.task_index = pinecone.Index(\"{INDEX}\")\n\n    self.get_info()\n    self.get_keys()\n```\n\n[代码片段结束]\n[XAgent/vector_db.py结束]",
            "code_start_line": 52,
            "code_end_line": 72,
            "parent": "VectorDBInterface",
            "have_return": false,
            "code_content": "    def get_info(self):\n        \"\"\"\n        The function to get the information about the database.\n\n        Retrieves the statistics of the database such as total vector count and dimension, \n        and store the total vector count in the vector_count attribute.\n\n        Raises:\n        Exception: An error occured accessing the database.\n\n        \"\"\"\n        \n        try:\n            info = self.task_index.describe_index_stats()\n            self.vector_count = info[\"total_vector_count\"]\n            dimension = info['dimension']\n            print(info)\n            print(\"Vector Dim\", dimension)\n            print(\"Vector Number\", self.vector_count)\n        except:\n            print(\"Warning: Failed to obtain vector information\")\n",
            "name_column": 8
        },
        "generate_embedding": {
            "type": "FunctionDef",
            "name": "generate_embedding",
            "md_content": "**generate_embedding函数**：该函数用于为输入文本生成嵌入向量。\n\n该函数接受一个字符串类型的文本作为输入。\n\n函数返回一个列表，表示输入文本的嵌入向量。\n\n该函数的具体实现如下：\n\n```python\ndef generate_embedding(self, text:str):\n    \"\"\"\n    The function to generate an embedding for the input text.\n\n    Args:\n    text (str): The input text.\n\n    Returns:\n    list: The embedding of the input text.\n\n    \"\"\"\n    \n    url = \"https://api.openai.com/v1/embeddings\"\n    payload = {\n        \"model\": \"text-embedding-ada-002\",\n        \"input\": text\n    }\n    for key in self.turbo_keys:\n        headers = {\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": f\"Bearer {key}\"\n        }\n        response = requests.post(url, json=payload, headers=headers, timeout=10)\n        try:\n            res = json.loads(response.text)\n            embedding = res['data'][0]['embedding']\n            return embedding\n        except:\n            pass\n```\n\n**generate_embedding函数**的作用是使用OpenAI API为输入文本生成嵌入向量。该函数首先构造了一个API请求的URL和payload，其中URL为\"https://api.openai.com/v1/embeddings\"，payload包含了模型名称和输入文本。然后，函数通过循环遍历self.turbo_keys列表中的API密钥，使用requests库向API发送POST请求。请求头中包含了Content-Type和Authorization信息。函数将API的响应解析为JSON格式，并提取出嵌入向量。最后，函数返回嵌入向量。\n\n**注意**：使用该函数前需要确保已经获取到了有效的API密钥，并将其存储在self.turbo_keys列表中。\n\n**输出示例**：假设输入文本为\"Hello, world!\"，则函数可能返回的嵌入向量为[0.123, 0.456, 0.789]。",
            "code_start_line": 75,
            "code_end_line": 103,
            "parent": "VectorDBInterface",
            "have_return": true,
            "code_content": "    def generate_embedding(self, text:str):\n        \"\"\"\n        The function to generate an embedding for the input text.\n\n        Args:\n        text (str): The input text.\n\n        Returns:\n        list: The embedding of the input text.\n\n        \"\"\"\n        \n        url = \"https://api.openai.com/v1/embeddings\"\n        payload = {\n            \"model\": \"text-embedding-ada-002\",\n            \"input\": text\n        }\n        for key in self.turbo_keys:\n            headers = {\n                \"Content-Type\": \"application/json\",\n                \"Authorization\": f\"Bearer {key}\"\n            }\n            response = requests.post(url, json=payload, headers=headers, timeout=10)\n            try:\n                res = json.loads(response.text)\n                embedding = res['data'][0]['embedding']\n                return embedding\n            except:\n                pass\n",
            "name_column": 8
        },
        "delete_sentence": {
            "type": "FunctionDef",
            "name": "delete_sentence",
            "md_content": "**delete_sentence函数**：这个函数的作用是从数据库中删除一个句子。\n\n该函数接受一个参数：\n- sentence (str): 要删除的句子。\n\n该函数可能会引发异常：\n- Exception: 删除句子时发生错误。\n\n在函数内部，首先尝试使用self.task_index.delete()方法删除给定的句子。如果删除成功，则打印\"Success delete sentence:\"和句子内容。如果删除失败，则打印\"Warning: Fail to delete sentence\"和句子内容。\n\n**注意**：使用该代码时需要注意以下几点：\n- 确保传入的句子参数是字符串类型。\n- 如果删除句子时发生错误，会引发异常，需要进行异常处理。",
            "code_start_line": 105,
            "code_end_line": 121,
            "parent": "VectorDBInterface",
            "have_return": false,
            "code_content": "    def delete_sentence(self, sentence:str):\n        \"\"\"\n        The function to delete a sentence from the database.\n\n        Args:\n        sentence (str): The sentence to be deleted.\n\n        Raises:\n        Exception: An error occured deleting the sentence.\n\n        \"\"\"\n        \n        try:\n            self.task_index.delete(sentence)\n            print(\"Success delete sentence:\", sentence)\n        except:\n            print(\"Warning: Fail to delete sentence\", sentence)\n",
            "name_column": 8
        },
        "insert_sentence": {
            "type": "FunctionDef",
            "name": "insert_sentence",
            "md_content": "**insert_sentence函数**: 这个函数的作用是将带有嵌入的句子插入到数据库中。\n\n该函数接受以下参数：\n- vec_sentence (str): 用于生成嵌入的句子。\n- sentence (str): 要插入的句子。\n- namespace (str, 可选): 向量的命名空间。默认为空字符串。\n\n该函数可能会引发以下异常：\n- Exception: 插入句子时发生错误。\n\n该函数首先使用generate_embedding函数生成句子的嵌入。如果成功生成嵌入，则尝试使用task_index的upsert方法将嵌入的句子插入到数据库中。插入成功后，向量计数器vector_count加1。如果插入过程中发生异常，则打印异常信息并提示插入失败。如果无法生成嵌入，则打印警告信息提示生成嵌入失败。\n\n**注意**: 使用该代码时需要注意以下几点：\n- 需要确保vec_sentence参数是一个字符串类型的句子。\n- 需要确保sentence参数是一个字符串类型的句子。\n- 可以选择指定namespace参数来为向量命名空间提供一个自定义的值。如果不指定，则默认为空字符串。",
            "code_start_line": 123,
            "code_end_line": 150,
            "parent": "VectorDBInterface",
            "have_return": false,
            "code_content": "    def insert_sentence(self, vec_sentence:str, sentence:str, namespace=\"\"):\n        \"\"\"\n        The function to insert a sentence with its embedding into the database.\n\n        Args:\n        vec_sentence (str): The sentence to generate the embedding.\n        sentence (str): The sentence to be inserted.\n        namespace (str, optional): The namespace of the vector. Defaults to \"\".\n\n        Raises:\n        Exception: An error occured inserting the sentence.\n\n        \"\"\"\n        \n        embedding = self.generate_embedding(vec_sentence)\n        if embedding:\n            try:\n                self.task_index.upsert(\n                    [(str(self.vector_count),\n                    embedding,\n                    {\"text\":sentence, \"type\":namespace})],\n                )\n                self.vector_count += 1\n            except Exception as e:\n                print(e)\n                print(\"Warning: Fail to insert\", sentence)\n        else:\n            print(\"Warning: Failed to generate embedding for \", sentence)\n",
            "name_column": 8
        },
        "search_similar_sentences": {
            "type": "FunctionDef",
            "name": "search_similar_sentences",
            "md_content": "**search_similar_sentences函数**：该函数用于在数据库中搜索与查询句子相似的句子。\n\n参数：\n- query_sentence (str)：查询句子。\n- namespace (str, 可选)：向量的命名空间。默认为空字符串。\n- top_k (int, 可选)：返回最相似句子的数量。默认为1。\n\n返回值：\n- object：最相似的句子。\n\n异常：\n- Exception：搜索数据库时发生错误。\n\n该函数首先使用generate_embedding函数生成查询句子的嵌入向量。如果生成成功，则使用task_index对象的query方法来查询与查询句子最相似的句子。查询时可以指定命名空间，并设置返回结果的数量、是否包含元数据和值的信息。查询结果将被打印并返回。\n\n如果生成嵌入向量失败，则打印警告信息\"Warning: Fail to generate embedding\"。\n\n如果查询过程中出现异常，则打印异常信息并打印警告信息\"Warning: Fail to search similar sentences\"。\n\n**注意**：使用该代码的注意事项。\n\n**输出示例**：模拟代码返回值的可能外观。",
            "code_start_line": 152,
            "code_end_line": 187,
            "parent": "VectorDBInterface",
            "have_return": true,
            "code_content": "    def search_similar_sentences(self, query_sentence:str, namespace=\"\", top_k=1):\n        \"\"\"\n        The function to search the database for sentences similar to the query sentence.\n\n        Args:\n        query_sentence (str): The query sentence.\n        namespace (str, optional): The namespace of the vectors. Defaults to \"\".\n        top_k (int, optional): The number of most similar sentences to return. \n            Defaults to 1.\n\n        Returns:\n        object: The most similar sentences.\n\n        Raises:\n        Exception: An error occured searching the database.\n\n        \"\"\"\n        \n        embedding = self.generate_embedding(query_sentence)\n        if embedding:\n            try:\n                res = self.task_index.query(\n                    embedding,\n                    top_k=top_k,\n                    include_metadata=True,\n                    include_values=False,\n                    filter={\n                        \"type\": {\"$eq\": namespace},\n                    },)\n                print(res)\n                return res\n            except Exception as e:\n                print(e)\n                print(\"Warning: Fail to search similar sentences\")\n        else:\n            print(\"Warning: Fail to generate embedding\")\n",
            "name_column": 8
        }
    },
    "XAgent/utils.py": {
        "get_token_nums": {
            "type": "FunctionDef",
            "name": "get_token_nums",
            "md_content": "**get_token_nums函数**: 该函数的功能是计算给定文本中的标记数量。\n\n该函数接受一个字符串类型的参数text，表示需要计算标记数量的文本。\n\n函数返回一个整数，表示文本中的标记数量。\n\n该函数的实现逻辑如下：\n- 使用encoding.encode函数将文本转换为标记列表。\n- 使用len函数计算标记列表的长度，即为标记数量。\n\n注意事项：\n- 该函数依赖于encoding模块中的encode函数，请确保该函数已正确导入。\n- 参数text应为有效的字符串类型。\n\n输出示例：\n假设text为\"Hello, world!\"，则函数返回的标记数量为3。",
            "code_start_line": 16,
            "code_end_line": 26,
            "parent": null,
            "have_return": true,
            "code_content": "def get_token_nums(text:str)->int:\n    \"\"\"\n    Calculate the number of tokens in the given text.\n    \n    Args:\n        text (str): The text whose tokens need to be counted.\n        \n    Returns:\n        int: The number of tokens in the text.\n    \"\"\"\n    return len(encoding.encode(text))\n",
            "name_column": 4
        },
        "clip_text": {
            "type": "FunctionDef",
            "name": "clip_text",
            "md_content": "**clip_text函数**：clip_text函数的功能是截取给定文本的指定数量的标记。如果原始文本和截取后的文本长度不一致，则在截取后的文本的开头或结尾添加\"`wrapped`\"。\n\n该函数接受以下参数：\n- text (str)：需要截取的文本。\n- max_tokens (int, 可选)：最大的标记数量。文本将被截取为不超过该数量的标记。\n- clip_end (bool, 可选)：如果为True，则从文本的末尾开始截取。如果为False，则从文本的开头开始截取。\n\n该函数返回截取后的文本和原始文本中的标记总数。\n\n该函数在以下文件中被调用：\n- XAgent/agent/summarize.py\n- XAgent/inner_loop_search_algorithms/ReACT.py\n- XAgent/workflow/plan_exec.py\n\n在XAgent/agent/summarize.py文件中，该函数被generate_func_args函数调用，用于生成函数参数的字符串形式。\n\n在XAgent/inner_loop_search_algorithms/ReACT.py文件中，该函数被generate_chain函数调用，用于截取文件系统环境的输出。\n\n在XAgent/workflow/plan_exec.py文件中，该函数被plan_refine_mode函数调用，用于截取工作空间文件系统的输出。\n\n请注意：\n- 该函数的返回值示例是根据代码逻辑进行的模拟，实际返回值可能会有所不同。",
            "code_start_line": 28,
            "code_end_line": 45,
            "parent": null,
            "have_return": true,
            "code_content": "def clip_text(text:str,max_tokens:int=None,clip_end=False)->str|int:\n    \"\"\"\n    Truncate the given text to the specified number of tokens.\n    If the original text and the clipped text are not of the same length, '`wrapped`' is added to the beginning or the end of the clipped text.\n    \n    Args:\n        text (str): The text to be clipped.\n        max_tokens (int, optional): Maximum number of tokens. The text will be clipped to contain not more than this number of tokens.\n        clip_end (bool, optional): If True, text will be clipped from the end. If False, text will be clipped from the beginning.\n        \n    Returns:\n        str, int: The clipped text, and the total number of tokens in the original text.\n    \"\"\"\n    encoded = encoding.encode(text)\n    decoded = encoding.decode(encoded[:max_tokens] if clip_end else encoded[-max_tokens:])\n    if len(decoded) != len(text):\n        decoded = decoded + '`wrapped`' if clip_end else '`wrapped`' + decoded\n    return decoded, len(encoded)\n",
            "name_column": 4
        },
        "LLMStatusCode": {
            "type": "ClassDef",
            "name": "LLMStatusCode",
            "md_content": "**LLMStatusCode类的功能**：该类是一个枚举类，用于描述LLM的不同状态码。\n\n该类定义了以下状态码：\n- SUCCESS：表示成功，对应的值为0。\n- ERROR：表示错误，对应的值为1。\n\n该类没有任何方法，只是用于定义状态码。\n\n**注意**：在使用该类时，可以通过LLMStatusCode.SUCCESS和LLMStatusCode.ERROR来获取对应的状态码值。",
            "code_start_line": 48,
            "code_end_line": 51,
            "parent": null,
            "have_return": false,
            "code_content": "class LLMStatusCode(Enum):\n    \"\"\"Enumeration describing different status codes for LLM.\"\"\"\n    SUCCESS = 0\n    ERROR = 1\n",
            "name_column": 6
        },
        "ToolCallStatusCode": {
            "type": "ClassDef",
            "name": "ToolCallStatusCode",
            "md_content": "**ToolCallStatusCode函数**：这个类的功能是描述工具调用的不同状态码。\n\n枚举类型ToolCallStatusCode描述了工具调用的不同状态码。\n\n状态码包括：\n- TOOL_CALL_FAILED：工具调用失败\n- TOOL_CALL_SUCCESS：工具调用成功\n- FORMAT_ERROR：格式错误\n- HALLUCINATE_NAME：幻觉名称\n- OTHER_ERROR：其他错误\n- TIMEOUT_ERROR：超时错误\n- TIME_LIMIT_EXCEEDED：超出时间限制\n- SERVER_ERROR：服务器错误\n- SUBMIT_AS_SUCCESS：提交成功\n- SUBMIT_AS_FAILED：提交失败\n\n这个类还重写了__str__方法，用于返回类名和状态码名称的字符串表示。\n\n**注意**：使用这段代码时需要注意以下几点：\n- 可以通过ToolCallStatusCode.TOOL_CALL_FAILED等方式来访问不同的状态码。\n- 可以通过str()方法将状态码转换为字符串表示。\n\n**输出示例**：假设代码的返回值如下所示：\nToolCallStatusCode: TOOL_CALL_FAILED",
            "code_start_line": 54,
            "code_end_line": 82,
            "parent": null,
            "have_return": true,
            "code_content": "class ToolCallStatusCode(Enum):\n    \"\"\"\n    Enumeration descsribing different status codes for tool calls.\n    \n    The status codes are:\n    - TOOL_CALL_FAILED\n    - TOOL_CALL_SUCCESS\n    - FORMAT_ERROR\n    - HALLUCINATE_NAME\n    - OTHER_ERROR\n    - TIMEOUT_ERROR\n    - TIME_LIMIT_EXCEEDED\n    - SERVER_ERROR\n    - SUBMIT_AS_SUCCESS\n    - SUBMIT_AS_FAILED\n    \"\"\"\n    TOOL_CALL_FAILED = -1\n    TOOL_CALL_SUCCESS = 0\n    FORMAT_ERROR = 1\n    HALLUCINATE_NAME = 2 \n    OTHER_ERROR = 3 \n    TIMEOUT_ERROR = 4\n    TIME_LIMIT_EXCEEDED = 5\n    SERVER_ERROR = 6\n    \n    SUBMIT_AS_SUCCESS = 7\n    SUBMIT_AS_FAILED = 8\n    def __str__(self):\n        return self.__class__.__name__ + \": \" + self.name\n",
            "name_column": 6
        },
        "PlanOperationStatusCode": {
            "type": "ClassDef",
            "name": "PlanOperationStatusCode",
            "md_content": "**PlanOperationStatusCode类的功能**：该类是一个枚举类，用于描述计划操作的不同状态码。\n\n枚举类是一种特殊的数据类型，它定义了一组具名的值，这些值可以作为常量在程序中使用。在这个类中，我们定义了以下几个状态码：\n\n- MODIFY_SUCCESS（修改成功）：表示计划操作修改成功。\n- MODIFY_FORMER_PLAN（修改前序计划）：表示修改的计划是前序计划。\n- PLAN_OPERATION_NOT_FOUND（找不到计划操作）：表示找不到对应的计划操作。\n- TARGET_SUBTASK_NOT_FOUND（找不到目标子任务）：表示找不到目标子任务。\n- PLAN_REFINE_EXIT（计划细化退出）：表示计划细化操作退出。\n- OTHER_ERROR（其他错误）：表示其他未知错误。\n\n**注意**：在使用该枚举类时，可以根据具体的情况选择合适的状态码进行使用。",
            "code_start_line": 85,
            "code_end_line": 94,
            "parent": null,
            "have_return": false,
            "code_content": "class PlanOperationStatusCode(Enum):\n    \"\"\"\n    Enumeration descsribing different status codes for plan operations. \n    \"\"\"\n    MODIFY_SUCCESS = 0\n    MODIFY_FORMER_PLAN = 1\n    PLAN_OPERATION_NOT_FOUND = 2\n    TARGET_SUBTASK_NOT_FOUND = 3\n    PLAN_REFINE_EXIT = 4\n    OTHER_ERROR = 5\n",
            "name_column": 6
        },
        "SearchMethodStatusCode": {
            "type": "ClassDef",
            "name": "SearchMethodStatusCode",
            "md_content": "**SearchMethodStatusCode函数**: 这个类的功能是描述搜索方法的不同状态码。\n\n这个类是一个枚举类，用于描述搜索方法的不同状态码。它定义了以下几个状态码：\n- DOING：表示搜索正在进行中。\n- SUCCESS：表示搜索成功。\n- FAIL：表示搜索失败。\n- HAVE_AT_LEAST_ONE_ANSWER：表示搜索至少有一个答案。\n\n这个类没有任何方法，只定义了不同的状态码常量。\n\n这个类在项目中的使用情况如下：\n- 在XAgent/inner_loop_search_algorithms/ReACT.py文件中，它被用于表示搜索方法的状态。在run方法中，根据搜索结果将其状态设置为SUCCESS或FAIL。\n- 在XAgent/inner_loop_search_algorithms/base_search.py文件中，它被用于初始化搜索方法实例的状态。\n- 在XAgent/workflow/task_handler.py文件中，它被用于表示搜索方法的状态。在inner_loop方法中，根据搜索结果将任务的状态设置为SUCCESS或FAIL。\n\n**注意**: 这个类只是用于表示搜索方法的状态码，没有具体的方法可调用。",
            "code_start_line": 97,
            "code_end_line": 104,
            "parent": null,
            "have_return": false,
            "code_content": "class SearchMethodStatusCode(Enum):\n    \"\"\"\n    Enumeration descsribing different status codes for search methods.\n    \"\"\"\n    DOING = 0\n    SUCCESS = 1\n    FAIL = 2\n    HAVE_AT_LEAST_ONE_ANSWER = 3 \n",
            "name_column": 6
        },
        "TaskStatusCode": {
            "type": "ClassDef",
            "name": "TaskStatusCode",
            "md_content": "**TaskStatusCode类的功能**: 该类是一个枚举类，用于描述任务的不同状态码。\n\n该类定义了以下状态码：\n- TODO：表示任务待办状态，即任务尚未开始。\n- DOING：表示任务进行中状态，即任务正在进行中。\n- SUCCESS：表示任务成功完成状态，即任务已成功完成。\n- FAIL：表示任务失败状态，即任务未能成功完成。\n- SPLIT：表示任务拆分状态，即任务被拆分为多个子任务。\n\n该类的状态码用于表示任务的不同状态，开发人员可以根据任务的状态来进行相应的处理和判断。例如，在任务执行过程中，可以根据任务的状态来确定下一个要处理的子任务。\n\n**注意**: \n- 该类是一个枚举类，用于表示任务的不同状态码。\n- 开发人员可以根据任务的状态码来进行相应的处理和判断。",
            "code_start_line": 107,
            "code_end_line": 115,
            "parent": null,
            "have_return": false,
            "code_content": "class TaskStatusCode(Enum):\n    \"\"\"\n    Enumeration descsribing different status codes for tasks.\n    \"\"\"\n    TODO = 0\n    DOING = 1\n    SUCCESS = 2\n    FAIL = 3\n    SPLIT = 4 \n",
            "name_column": 6
        },
        "RequiredAbilities": {
            "type": "ClassDef",
            "name": "RequiredAbilities",
            "md_content": "**RequiredAbilities类的功能**：该类是一个枚举类，用于描述所需的不同能力。\n\n该类定义了以下几个枚举值：\n- tool_tree_search（工具树搜索）：值为0，表示需要进行工具树搜索的能力。\n- plan_generation（计划生成）：值为1，表示需要进行计划生成的能力。\n- plan_refinement（计划细化）：值为2，表示需要进行计划细化的能力。\n- task_evaluator（任务评估）：值为3，表示需要进行任务评估的能力。\n- summarization（总结）：值为4，表示需要进行总结的能力。\n- reflection（反思）：值为5，表示需要进行反思的能力。\n\n**注意**：在使用该类时需要注意以下几点：\n- 该类是一个枚举类，用于描述所需的不同能力。\n- 每个枚举值都有一个对应的整数值，可以通过枚举值的名称或整数值来访问。\n- 可以根据具体需求选择所需的能力。",
            "code_start_line": 118,
            "code_end_line": 127,
            "parent": null,
            "have_return": false,
            "code_content": "class RequiredAbilities(Enum):\n    \"\"\"\n    Enumeration descsribing different abilities required.\n    \"\"\"\n    tool_tree_search = 0\n    plan_generation = 1\n    plan_refinement = 2\n    task_evaluator = 3\n    summarization = 4\n    reflection = 5\n",
            "name_column": 6
        },
        "AgentRole": {
            "type": "ClassDef",
            "name": "AgentRole",
            "md_content": "**AgentRole函数**: 这个类表示对话中ChatGPT代理的角色。\n\n**属性**:\n- name (str): 代理的名称。\n- prefix (str): 代理角色的描述。\n\n**AgentRole函数**: 这个类的功能是创建一个ChatGPT代理的角色。\n\n**代码分析和描述**:\nAgentRole类是一个简单的类，用于表示ChatGPT代理在对话中的角色。它具有两个属性，name和prefix，分别表示代理的名称和角色的描述。\n\n- name属性是一个字符串类型，表示代理的名称。默认值为\"Auto-GPT\"。\n- prefix属性是一个字符串类型，表示代理角色的描述。默认值为\"You are an expert of using multiple tools to handle diverse real-world user queries.\"。\n\n这个类没有任何方法或功能，只是用于表示代理的角色。\n\n**注意**: 在使用AgentRole类时，可以根据需要修改name和prefix属性的值来适应具体的应用场景。",
            "code_start_line": 130,
            "code_end_line": 139,
            "parent": null,
            "have_return": false,
            "code_content": "class AgentRole:\n    \"\"\"\n    This class represents the role of a ChatGPT agent in a conversation.\n\n    Attributes:\n        name (str): The name of the agent.\n        prefix (str): The description of agent's role.\n    \"\"\"\n    name: str = \"Auto-GPT\"\n    prefix: str = \"You are an expert of using multiple tools to handle diverse real-world user queries.\"\n",
            "name_column": 6
        },
        "TaskSaveItem": {
            "type": "ClassDef",
            "name": "TaskSaveItem",
            "md_content": "**TaskSaveItem函数**：这个类表示保存任务的结构。\n\n**属性**：\n- name (str): 任务的名称。\n- goal (str): 任务的目标。\n- milestones (List[str]): 完成任务所需的步骤。\n- prior_plan_criticism (str): 对任务初始计划的任何批评。\n- status (TaskStatusCode): 任务的当前状态。\n- action_list_summary (str): 对完成任务的所有操作的摘要。\n- posterior_plan_reflection (List[str]): 包含最终决定计划的反思的列表。\n- tool_reflection (List[Dict[str,str]]): 包含每个工具反思的字典列表。\n\n**load_from_json方法**：从json表示中加载数据。\n- 参数：\n  - function_output_item: json表示的数据。\n- 返回值：无\n- 注意：该方法根据json数据的键来加载数据，并将其赋值给相应的属性。\n\n**to_json方法**：将对象转换为json表示。\n- 参数：\n  - posterior (bool): 是否包含后续计划的信息，默认为False。\n- 返回值：json表示的数据。\n- 注意：该方法将对象的属性转换为json数据，并返回该数据。\n\n**raw属性**：将对象转换为原始的json字符串。\n- 返回值：原始的json字符串。\n\n**print_task_save_items函数**：打印任务保存项的详细信息。\n- 参数：\n  - item: TaskSaveItem对象。\n- 返回值：无\n- 注意：该函数将任务保存项的各个属性打印出来，包括任务名称、目标、批评、里程碑、状态等。\n\n**plan_function_output_parser函数**：将函数输出项解析为Plan对象。\n- 参数：\n  - function_output_item: 表示函数输出项的字典。\n- 返回值：解析后的Plan对象。\n- 注意：该函数根据函数输出项创建一个Plan对象，并返回该对象。\n\n**PlanAgent类**：计划代理类，用于生成计划。\n- 参数：\n  - config: 计划代理的配置。\n  - query (BaseQuery): 用于生成计划的基本查询。\n  - avaliable_tools_description_list (List[dict]): 可用工具的描述列表。\n- 注意：该类用于生成计划，包括任务名称、目标、里程碑等，并提供了一些方法用于操作计划。",
            "code_start_line": 143,
            "code_end_line": 223,
            "parent": null,
            "have_return": true,
            "code_content": "class TaskSaveItem:\n    \"\"\"\n    This class represents the structure of saved tasks.\n    \n    Attributes:\n        name (str): The name of the task.\n        goal (str): The objective of the task.\n        milestones (List[str]): The steps involved to achieve the task.\n        prior_plan_criticism (str): Any criticism on the initial plan of the task.\n        status (TaskStatusCode): The current status of the task.\n        action_list_summary (str): A summary of all the actions done to achieve the task.\n        posterior_plan_reflection (List[str]): A list containing reflection of the finally decided plan.\n        tool_reflection (List[Dict[str,str]]): A list of dictionaries where each dictionary holds reflection of a tool.\n    \"\"\"\n    \n    name: str = \"\"\n    goal: str = \"\"\n    milestones: List[str] = field(default_factory=lambda: [])\n    prior_plan_criticism: str = \"\"\n    status: TaskStatusCode = TaskStatusCode.TODO\n    action_list_summary: str = \"\"\n    posterior_plan_reflection: List[str] = field(default_factory=lambda: [])\n    tool_reflection: List[Dict[str,str]] = field(default_factory=lambda: [])\n\n    def load_from_json(self, function_output_item):\n        \"\"\"Load data from the json representation\"\"\"\n        if \"subtask name\" in function_output_item.keys():\n            self.name = function_output_item[\"subtask name\"]\n        else:\n            print(f\"field subtask name not exist\")\n            \n        if \"goal\" in function_output_item.keys() and \"goal\" in function_output_item[\"goal\"].keys():\n            self.goal=function_output_item[\"goal\"][\"goal\"]\n        else:\n            print(f\"field goal.goal not exist\")\n\n        if \"goal\" in function_output_item.keys() and \"criticism\" in function_output_item[\"goal\"].keys():\n            self.prior_plan_criticism=function_output_item[\"goal\"][\"criticism\"]\n        else:\n            print(f\"field goal.criticism not exist\")\n        \n        # if \"handler\" in function_output_item.keys():\n        #     self.handler=function_output_item[\"handler\"]\n        # else:\n        #     print(f\"field handler not exist\")\n\n        # if \"tool_budget\" in function_output_item.keys():\n        #     self.tool_budget=function_output_item[\"tool_budget\"]\n        # else:\n        #     print(f\"field tool_budget not exist\")\n\n        if \"milestones\" in function_output_item.keys():\n            self.milestones = function_output_item[\"milestones\"]\n        # if \"expected_tools\" in function_output_item.keys():\n        #     self.expected_tools = function_output_item[\"expected_tools\"]\n\n    def to_json(self, posterior=False):\n        \"\"\"Convert the object to json representation.\"\"\"\n        json_data = {\n            \"name\": self.name,\n            \"goal\": self.goal,\n            # \"handler\": self.handler,\n            # \"tool_budget\": self.tool_budget,\n            \"prior_plan_criticsim\": self.prior_plan_criticism,\n            \"milestones\": self.milestones,\n            # \"expected_tools\": self.expected_tools,\n            \"exceute_status\": self.status.name,\n        }\n        if posterior:\n            if self.action_list_summary != \"\":\n                json_data[\"action_list_summary\"] =  self.action_list_summary\n            # if self.posterior_plan_reflection != []:\n            #     json_data[\"posterior_plan_reflection\"] = self.posterior_plan_reflection\n            # if self.tool_reflection != []:\n            #     json_data[\"tool_reflection\"] = self.tool_reflection\n        return json_data\n\n    @property\n    def raw(self) -> str:\n        \"\"\"Convert the object to a raw json string\"\"\"\n        return json.dumps(self.to_json(posterior=True), indent=2, ensure_ascii=False)\n",
            "name_column": 6
        },
        "Singleton": {
            "type": "ClassDef",
            "name": "Singleton",
            "md_content": "**Singleton函数**: 这个类的功能是确保一个类只有一个实例。\n\n这个Singleton类是一个元类，它继承了`abc.ABCMeta`和`type`，用于确保一个类只有一个实例。它通过维护一个字典`_instances`来保存每个类的实例。当调用一个类时，会首先检查该类是否已经存在实例，如果不存在则创建一个新的实例并保存在`_instances`字典中，然后返回该实例。如果已经存在实例，则直接返回该实例。\n\n这个Singleton类的作用是为了确保一个类只有一个实例，这在某些情况下非常有用。例如，在日志记录器中，我们希望只有一个实例来处理日志记录，这样可以确保日志记录的一致性和避免冲突。\n\n**注意**: 在使用这个Singleton类时，需要注意以下几点:\n- Singleton类是一个元类，它需要作为其他类的元类来使用。\n- 使用Singleton类时，需要将它作为元类传递给其他类的`metaclass`参数。\n\n**输出示例**:\n```\nclass Logger(metaclass=Singleton):\n    # Logger类的定义\n    ...\n```\n\n```\nclass AbstractSingleton(abc.ABC, metaclass=Singleton):\n    # AbstractSingleton类的定义\n    ...\n```",
            "code_start_line": 227,
            "code_end_line": 238,
            "parent": null,
            "have_return": true,
            "code_content": "class Singleton(abc.ABCMeta, type):\n    \"\"\"\n    Singleton metaclass for ensuring only one instance of a class.\n    \"\"\"\n\n    _instances = {}\n\n    def __call__(cls, *args, **kwargs):\n        \"\"\"Call method for the singleton metaclass.\"\"\"\n        if cls not in cls._instances:\n            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)\n        return cls._instances[cls]\n",
            "name_column": 6
        },
        "AbstractSingleton": {
            "type": "ClassDef",
            "name": "AbstractSingleton",
            "md_content": "**AbstractSingleton函数**: 这个类的功能是实现一个抽象的单例基类。继承自这个类的类只能有一个实例。\n\n这个类使用了一个元类来实现确保类只有一个实例的机制。\n\n**详细分析和描述**:\n抽象单例（AbstractSingleton）是一个抽象基类（ABC），它使用了一个元类（metaclass）Singleton来确保继承自该类的类只有一个实例。元类是用来创建类的类，它可以控制类的创建过程。通过将Singleton设置为元类，我们可以在创建继承自AbstractSingleton的类时，确保只有一个实例存在。\n\nAbstractSingleton继承自abc.ABC，这意味着它是一个抽象基类。抽象基类是一种特殊的类，它不能被实例化，只能被继承。它的主要作用是定义一组接口或规范，供子类实现。\n\nAbstractSingleton还使用了metaclass=Singleton来指定元类为Singleton。Singleton是一个自定义的元类，它控制了继承自AbstractSingleton的类的创建过程。在创建继承自AbstractSingleton的类时，Singleton会检查是否已经存在一个实例，如果存在则返回该实例，如果不存在则创建一个新的实例。这样就确保了继承自AbstractSingleton的类只有一个实例。\n\n**注意**: 使用AbstractSingleton作为基类时，继承的类只能有一个实例。这可以确保在整个程序中只有一个特定的对象存在，避免了重复创建对象的开销和可能引发的问题。",
            "code_start_line": 240,
            "code_end_line": 245,
            "parent": null,
            "have_return": false,
            "code_content": "class AbstractSingleton(abc.ABC, metaclass=Singleton):\n    \"\"\"\n    An abstract Singleton base class. Classes that inherit from this class can have only one instance.\n\n    Implements mechanism to ensure that only one instance of the class exists by using a metaclass.\n    \"\"\"",
            "name_column": 6
        },
        "__str__": {
            "type": "FunctionDef",
            "name": "__str__",
            "md_content": "**__str__函数**：这个函数的作用是返回一个字符串，该字符串由该对象的类名和名称组成。\n\n该函数是一个特殊方法，用于将对象转换为字符串形式。在Python中，当我们使用print函数或str()函数打印对象时，实际上是调用了该对象的__str__方法来获取对象的字符串表示。\n\n在这个具体的代码中，__str__函数返回了一个由该对象的类名和名称组成的字符串。首先，使用self.__class__.__name__获取该对象的类名，然后使用加号连接字符串，再加上该对象的名称。\n\n**注意**：该函数返回的字符串表示了该对象的类名和名称，可以用于打印对象或将对象转换为字符串。\n\n**输出示例**：ToolServer: toolserver1",
            "code_start_line": 81,
            "code_end_line": 82,
            "parent": "ToolCallStatusCode",
            "have_return": true,
            "code_content": "    def __str__(self):\n        return self.__class__.__name__ + \": \" + self.name\n",
            "name_column": 8
        },
        "load_from_json": {
            "type": "FunctionDef",
            "name": "load_from_json",
            "md_content": "**load_from_json函数**: 该函数的功能是从json表示中加载数据。\n\n该函数接受一个名为function_output_item的参数，该参数是一个字典，表示函数的输出项。函数首先检查function_output_item中是否存在\"subtask name\"字段，如果存在，则将其赋值给self.name属性；否则，打印\"field subtask name not exist\"。接下来，函数检查function_output_item中是否存在\"goal\"字段以及\"goal\"字段中是否存在\"goal\"字段，如果存在，则将其赋值给self.goal属性；否则，打印\"field goal.goal not exist\"。然后，函数检查function_output_item中是否存在\"goal\"字段以及\"goal\"字段中是否存在\"criticism\"字段，如果存在，则将其赋值给self.prior_plan_criticism属性；否则，打印\"field goal.criticism not exist\"。最后，函数检查function_output_item中是否存在\"milestones\"字段，如果存在，则将其赋值给self.milestones属性。\n\n**注意**: 使用该代码时需要注意以下几点：\n- 确保function_output_item参数是一个字典类型。\n- 确保function_output_item字典中的字段名和属性名一致，否则无法正确加载数据。\n- 如果function_output_item中的某些字段缺失，会打印相应的错误信息。\n\n该函数在以下文件中被调用：\n文件路径：XAgent/workflow/plan_exec.py\n调用代码如下：\n```python\ndef plan_function_output_parser(function_output_item: dict) -> Plan:\n    \"\"\"将函数输出项解析为Plan对象。\n\n    Args:\n        function_output_item (dict): 表示函数输出项的字典。\n\n    Returns:\n        Plan: 解析后的Plan对象。\n    \"\"\"\n    subtask_node = TaskSaveItem()\n    subtask_node.load_from_json(function_output_item=function_output_item)\n    subplan = Plan(subtask_node)\n    return subplan\n```\n在该文件中，load_from_json函数被调用来加载function_output_item的数据，并将其作为参数传递给TaskSaveItem对象的load_from_json方法。然后，使用加载后的数据创建一个Plan对象并返回。\n\n另外，在该文件中还有一个deal_subtask_modify方法，该方法也调用了load_from_json函数。在deal_subtask_modify方法中，load_from_json函数被用来加载function_input中的new_data字段的数据。\n\n**注意**: 在调用load_from_json函数之前，需要确保function_output_item参数是一个合法的字典对象。",
            "code_start_line": 167,
            "code_end_line": 195,
            "parent": "TaskSaveItem",
            "have_return": false,
            "code_content": "    def load_from_json(self, function_output_item):\n        \"\"\"Load data from the json representation\"\"\"\n        if \"subtask name\" in function_output_item.keys():\n            self.name = function_output_item[\"subtask name\"]\n        else:\n            print(f\"field subtask name not exist\")\n            \n        if \"goal\" in function_output_item.keys() and \"goal\" in function_output_item[\"goal\"].keys():\n            self.goal=function_output_item[\"goal\"][\"goal\"]\n        else:\n            print(f\"field goal.goal not exist\")\n\n        if \"goal\" in function_output_item.keys() and \"criticism\" in function_output_item[\"goal\"].keys():\n            self.prior_plan_criticism=function_output_item[\"goal\"][\"criticism\"]\n        else:\n            print(f\"field goal.criticism not exist\")\n        \n        # if \"handler\" in function_output_item.keys():\n        #     self.handler=function_output_item[\"handler\"]\n        # else:\n        #     print(f\"field handler not exist\")\n\n        # if \"tool_budget\" in function_output_item.keys():\n        #     self.tool_budget=function_output_item[\"tool_budget\"]\n        # else:\n        #     print(f\"field tool_budget not exist\")\n\n        if \"milestones\" in function_output_item.keys():\n            self.milestones = function_output_item[\"milestones\"]\n",
            "name_column": 8
        },
        "to_json": {
            "type": "FunctionDef",
            "name": "to_json",
            "md_content": "**to_json函数**：该函数的功能是将对象转换为json表示形式。\n\n该函数接受一个参数posterior，用于确定是否返回任务的后续数据。函数首先创建一个名为json_data的字典对象，将对象的属性以键值对的形式存储在其中。其中包括\"name\"、\"goal\"、\"prior_plan_criticsim\"、\"milestones\"和\"exceute_status\"等属性。如果posterior为True，则进一步判断是否存在action_list_summary属性，如果存在则将其添加到json_data中。\n\n最后，函数返回json_data作为结果。\n\n**注意**：该函数的参数posterior默认为False，如果需要返回后续数据，则需要将posterior设置为True。\n\n**输出示例**：假设对象的属性值如下所示：\n```\nname = \"XAgent\"\ngoal = \"Perform various tasks\"\nprior_plan_criticsim = True\nmilestones = [\"Task1\", \"Task2\", \"Task3\"]\nstatus = \"DOING\"\naction_list_summary = \"Summary of action list\"\n\n则函数的返回值为：\n{\n    \"name\": \"XAgent\",\n    \"goal\": \"Perform various tasks\",\n    \"prior_plan_criticsim\": True,\n    \"milestones\": [\"Task1\", \"Task2\", \"Task3\"],\n    \"exceute_status\": \"DOING\",\n    \"action_list_summary\": \"Summary of action list\"\n}\n```",
            "code_start_line": 199,
            "code_end_line": 218,
            "parent": "TaskSaveItem",
            "have_return": true,
            "code_content": "    def to_json(self, posterior=False):\n        \"\"\"Convert the object to json representation.\"\"\"\n        json_data = {\n            \"name\": self.name,\n            \"goal\": self.goal,\n            # \"handler\": self.handler,\n            # \"tool_budget\": self.tool_budget,\n            \"prior_plan_criticsim\": self.prior_plan_criticism,\n            \"milestones\": self.milestones,\n            # \"expected_tools\": self.expected_tools,\n            \"exceute_status\": self.status.name,\n        }\n        if posterior:\n            if self.action_list_summary != \"\":\n                json_data[\"action_list_summary\"] =  self.action_list_summary\n            # if self.posterior_plan_reflection != []:\n            #     json_data[\"posterior_plan_reflection\"] = self.posterior_plan_reflection\n            # if self.tool_reflection != []:\n            #     json_data[\"tool_reflection\"] = self.tool_reflection\n        return json_data\n",
            "name_column": 8
        },
        "raw": {
            "type": "FunctionDef",
            "name": "raw",
            "md_content": "**raw函数**：该函数的功能是将对象转换为原始的JSON字符串。\n\n该函数使用`json.dumps()`方法将对象转换为原始的JSON字符串，并返回该字符串。\n\n**注意**：使用该代码时需要注意以下几点：\n- 该函数需要对象具有`to_json()`方法，以将对象转换为JSON格式。\n- 该函数返回的是一个字符串，表示对象的原始JSON字符串。\n\n**输出示例**：假设对象的`to_json()`方法返回的JSON格式如下所示：\n```json\n{\n  \"name\": \"John\",\n  \"age\": 30,\n  \"city\": \"New York\"\n}\n```\n那么调用`raw()`函数后的返回值为：\n```json\n{\n  \"name\": \"John\",\n  \"age\": 30,\n  \"city\": \"New York\"\n}\n```",
            "code_start_line": 221,
            "code_end_line": 223,
            "parent": "TaskSaveItem",
            "have_return": true,
            "code_content": "    def raw(self) -> str:\n        \"\"\"Convert the object to a raw json string\"\"\"\n        return json.dumps(self.to_json(posterior=True), indent=2, ensure_ascii=False)\n",
            "name_column": 8
        },
        "__call__": {
            "type": "FunctionDef",
            "name": "__call__",
            "md_content": "**__call__函数**：这个函数的作用是创建一个单例类的实例。\n\n在这段代码中，__call__函数是一个特殊的方法，它定义了当一个对象被调用时应该执行的操作。在这个函数中，它首先检查类是否已经存在实例，如果不存在，则通过调用父类的__call__方法创建一个新的实例，并将其存储在类的_instances属性中。最后，它返回类的实例。\n\n**注意**：使用这个函数时需要注意以下几点：\n- 这个函数应该在一个单例类的元类中定义。\n- 这个函数确保一个类只有一个实例，并提供了一个全局访问点来获取该实例。\n\n**输出示例**：假设代码的返回值可能如下所示：\n```\n<__main__.Singleton object at 0x7f9b8c6a2a90>\n```",
            "code_start_line": 234,
            "code_end_line": 238,
            "parent": "Singleton",
            "have_return": true,
            "code_content": "    def __call__(cls, *args, **kwargs):\n        \"\"\"Call method for the singleton metaclass.\"\"\"\n        if cls not in cls._instances:\n            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)\n        return cls._instances[cls]\n",
            "name_column": 8
        }
    },
    "XAgent/logs.py": {
        "JsonFileHandler": {
            "type": "ClassDef",
            "name": "JsonFileHandler",
            "md_content": "**JsonFileHandler函数**: 这个类的功能是处理JSON文件的日志记录。\n\nJsonFileHandler是logging.FileHandler的子类，它用于将日志记录以JSON格式写入文件。它具有以下方法：\n\n- `__init__(self, filename, mode=\"a\", encoding=None, delay=False)`: 构造函数，用于初始化JsonFileHandler对象。它接受以下参数：\n  - `filename`：要写入的文件名。\n  - `mode`：文件打开模式，默认为追加模式（\"a\"）。\n  - `encoding`：文件编码，默认为None。\n  - `delay`：是否延迟打开文件，默认为False。\n\n- `emit(self, record)`: 重写父类的emit方法，用于将日志记录以JSON格式写入文件。它接受以下参数：\n  - `record`：日志记录对象。\n\n在emit方法中，首先将日志记录格式化为JSON数据，然后使用`open`函数打开文件，并以UTF-8编码写入JSON数据。在写入过程中，使用`json.dump`方法将JSON数据写入文件，并设置`ensure_ascii=False`以支持非ASCII字符，设置`indent=4`以使JSON数据更易读。\n\n在项目中，JsonFileHandler类被用于记录JSON数据。在XAgent/logs.py文件中的`log_json`方法中，首先定义了日志目录，然后创建了一个JsonFileHandler对象，将其设置为自定义的JsonFormatter格式化器，并将其添加到json_logger中。然后使用json_logger的debug方法记录JSON数据，最后从json_logger中移除JsonFileHandler对象。\n\n**注意**：在使用JsonFileHandler时，需要确保传入正确的文件名和路径，并且要注意文件的打开模式和编码方式。此外，JsonFileHandler会覆盖原有的文件内容，因此在使用时要注意不要覆盖重要的数据。",
            "code_start_line": 17,
            "code_end_line": 24,
            "parent": null,
            "have_return": false,
            "code_content": "class JsonFileHandler(logging.FileHandler):\n    def __init__(self, filename, mode=\"a\", encoding=None, delay=False):\n        super().__init__(filename, mode, encoding, delay)\n\n    def emit(self, record):\n        json_data = json.loads(self.format(record))\n        with open(self.baseFilename, \"w\", encoding=\"utf-8\") as f:\n            json.dump(json_data, f, ensure_ascii=False, indent=4)\n",
            "name_column": 6
        },
        "JsonFormatter": {
            "type": "ClassDef",
            "name": "JsonFormatter",
            "md_content": "**JsonFormatter函数**: 这个类的功能是将日志记录格式化为JSON格式。\n\nJsonFormatter类是logging.Formatter类的子类，它重写了format方法。format方法接收一个记录对象record作为参数，并返回格式化后的记录消息。\n\n在format方法中，JsonFormatter类将记录消息record.msg直接作为返回值，不做任何格式化处理。\n\n在项目中，JsonFormatter类被用于创建一个自定义的日志处理器JsonFileHandler的格式化器。具体调用代码如下：\n\n```python\ndef log_json(self, data: Any, file_name: str) -> None:\n    # 定义日志目录\n    this_files_dir_path = os.path.dirname(__file__)\n    log_dir = os.path.join(this_files_dir_path, \"../logs\")\n\n    # 创建一个JSON文件处理器\n    json_file_path = os.path.join(log_dir, file_name)\n    json_data_handler = JsonFileHandler(json_file_path)\n    json_data_handler.setFormatter(JsonFormatter())\n\n    # 使用自定义的文件处理器记录JSON数据\n    self.json_logger.addHandler(json_data_handler)\n    self.json_logger.debug(data)\n    self.json_logger.removeHandler(json_data_handler)\n```\n\n在上述代码中，首先定义了日志目录log_dir，然后根据给定的文件名file_name拼接出JSON文件的路径json_file_path。接下来，创建了一个JsonFileHandler对象json_data_handler，并将其设置的格式化器设置为JsonFormatter()。然后，将json_data_handler添加到self.json_logger的处理器列表中，使用debug级别记录数据data，最后从处理器列表中移除json_data_handler。\n\n**注意**: 使用JsonFormatter类时需要注意以下几点：\n- JsonFormatter类仅将记录消息作为JSON格式返回，不做其他格式化处理。\n- JsonFormatter类需要配合JsonFileHandler类使用，用于将日志记录以JSON格式写入文件。\n\n**输出示例**:\n假设记录消息为\"Hello, world!\"，使用JsonFormatter类格式化后的输出结果为\"Hello, world!\"。",
            "code_start_line": 27,
            "code_end_line": 29,
            "parent": null,
            "have_return": true,
            "code_content": "class JsonFormatter(logging.Formatter):\n    def format(self, record):\n        return record.msg\n",
            "name_column": 6
        },
        "Logger": {
            "type": "ClassDef",
            "name": "Logger",
            "md_content": "**Logger类的功能**: Logger类是一个单例类，用于处理不同颜色的标题。它将日志输出到控制台、activity.log和errors.log文件中。对于控制台处理程序，它模拟打字的效果。\n\n该类的构造函数__init__首先创建一个日志目录，如果该目录不存在的话。然后，它定义了一些日志文件的名称和路径。\n\n接下来，它创建了一个用于控制台的处理程序self.typing_console_handler，该处理程序模拟打字的效果。它设置了处理程序的日志级别为INFO，并使用RecordFormatter格式化日志消息。\n\n然后，它创建了另一个用于控制台的处理程序self.console_handler，该处理程序没有打字模拟效果。它设置了处理程序的日志级别为DEBUG，并使用RecordFormatter格式化日志消息。\n\n接下来，它创建了一个用于记录INFO级别日志的文件处理程序self.file_handler，并设置了处理程序的日志级别为DEBUG。它使用RecordFormatter格式化日志消息。\n\n然后，它创建了一个用于记录ERROR级别日志的文件处理程序error_handler，并设置了处理程序的日志级别为ERROR。它使用RecordFormatter格式化日志消息。\n\n接下来，它创建了三个日志记录器self.typing_logger、self.logger和self.json_logger，并将相应的处理程序添加到每个记录器中。它们分别设置了记录器的日志级别为DEBUG。\n\n最后，它定义了一些其他属性，如self.speak_mode、self.chat_plugins和self.log_lock。\n\n**注意**: 使用该代码时需要注意以下几点：\n- Logger类是一个单例类，只能创建一个实例。\n- Logger类的日志输出包括控制台输出、activity.log文件和errors.log文件。\n- 控制台处理程序self.typing_console_handler模拟打字的效果，而self.console_handler没有模拟效果。\n- 日志文件的路径和名称可以根据需要进行修改。\n- Logger类提供了一些日志记录方法，如debug、info、warn和error，可以根据需要选择合适的方法进行日志记录。\n\n**输出示例**:\n```\n2021-01-01 12:00:00 INFO Title Message\n2021-01-01 12:00:01 DEBUG Title Message\n2021-01-01 12:00:02 WARNING Title Message\n2021-01-01 12:00:03 ERROR Title Message\n```",
            "code_start_line": 32,
            "code_end_line": 200,
            "parent": null,
            "have_return": true,
            "code_content": "class Logger(metaclass=Singleton):\n    \"\"\"\n    Logger that handle titles in different colors.\n    Outputs logs in console, activity.log, and errors.log\n    For console handler: simulates typing\n    \"\"\"\n\n    def __init__(self):\n        # create log directory if it doesn't exist\n        this_files_dir_path = os.path.dirname(__file__)\n        log_dir = os.path.join(this_files_dir_path, \"../logs\")\n        if not os.path.exists(log_dir):\n            os.makedirs(log_dir)\n\n        log_file = \"activity.log\"\n        error_file = \"error.log\"\n\n        console_formatter = RecordFormatter(\"%(title_color)s %(message)s\")\n\n        # Create a handler for console which simulate typing\n        self.typing_console_handler = TypingConsoleHandler()\n        self.typing_console_handler.setLevel(logging.INFO)\n        self.typing_console_handler.setFormatter(console_formatter)\n\n        # Create a handler for console without typing simulation\n        self.console_handler = ConsoleHandler()\n        self.console_handler.setLevel(logging.DEBUG)\n        self.console_handler.setFormatter(console_formatter)\n\n        \n        if not os.path.exists(log_dir):\n            os.makedirs(log_dir)\n        # Info handler in activity.log\n        self.file_handler = logging.FileHandler(\n            os.path.join(log_dir, log_file), \"a\", \"utf-8\"\n        )\n        self.file_handler.setLevel(logging.DEBUG)\n        info_formatter = RecordFormatter(\n            \"%(asctime)s %(levelname)s %(title)s %(message_no_color)s\"\n        )\n        self.file_handler.setFormatter(info_formatter)\n\n        # Error handler error.log\n        error_handler = logging.FileHandler(\n            os.path.join(log_dir, error_file), \"a\", \"utf-8\"\n        )\n        error_handler.setLevel(logging.ERROR)\n        error_formatter = RecordFormatter(\n            \"%(asctime)s %(levelname)s %(module)s:%(funcName)s:%(lineno)d %(title)s\"\n            \" %(message_no_color)s\"\n        )\n        error_handler.setFormatter(error_formatter)\n\n        self.typing_logger = logging.getLogger(\"TYPER\")\n        self.typing_logger.addHandler(self.typing_console_handler)\n        self.typing_logger.addHandler(self.file_handler)\n        self.typing_logger.addHandler(error_handler)\n        self.typing_logger.setLevel(logging.DEBUG)\n\n        self.logger = logging.getLogger(\"LOGGER\")\n        self.logger.addHandler(self.console_handler)\n        self.logger.addHandler(self.file_handler)\n        self.logger.addHandler(error_handler)\n        self.logger.setLevel(logging.DEBUG)\n\n        self.json_logger = logging.getLogger(\"JSON_LOGGER\")\n        self.json_logger.addHandler(self.file_handler)\n        self.json_logger.addHandler(error_handler)\n        self.json_logger.setLevel(logging.DEBUG)\n\n        self.speak_mode = False\n        self.chat_plugins = []\n        self.log_lock = Lock()\n\n\n    def typewriter_log(\n        self, title=\"\", title_color=\"\", content=\"\", speak_text=False, level=logging.INFO\n    ):\n        # if speak_text and self.speak_mode:\n        #     say_text(f\"{title}. {content}\")\n        for plugin in self.chat_plugins:\n            plugin.report(f\"{title}. {content}\")\n\n        if content:\n            if isinstance(content, list):\n                content = \" \".join(content)\n        else:\n            content = \"\"\n        self.log_lock.acquire()\n        self.typing_logger.log(\n            level, content, extra={\"title\": title, \"color\": title_color}\n        )\n        self.log_lock.release()\n\n    def debug(\n        self,\n        message,\n        title=\"\",\n        title_color=\"\",\n    ):\n        self._log(title, title_color, message, logging.DEBUG)\n\n    def info(\n        self,\n        message,\n        title=\"\",\n        title_color=\"\",\n    ):\n        self._log(title, title_color, message, logging.INFO)\n\n    def warn(\n        self,\n        message,\n        title=\"\",\n        title_color=\"\",\n    ):\n        self._log(title, title_color, message, logging.WARN)\n\n    def error(self, title, message=\"\"):\n        self._log(title, Fore.RED, message, logging.ERROR)\n\n    def _log(\n        self,\n        title: str = \"\",\n        title_color: str = \"\",\n        message: str = \"\",\n        level=logging.INFO,\n    ):\n        if message:\n            if isinstance(message, list):\n                message = \" \".join(message)\n        self.logger.log(\n            level, message, extra={\"title\": str(title), \"color\": str(title_color)}\n        )\n\n    def set_level(self, level):\n        self.logger.setLevel(level)\n        self.typing_logger.setLevel(level)\n\n    def double_check(self, additionalText=None):\n        if not additionalText:\n            additionalText = (\n                \"Please ensure you've setup and configured everything\"\n                \" correctly. Read https://github.com/Torantulino/Auto-GPT#readme to \"\n                \"double check. You can also create a github issue or join the discord\"\n                \" and ask there!\"\n            )\n\n        self.typewriter_log(\"DOUBLE CHECK CONFIGURATION\", Fore.YELLOW, additionalText)\n\n    def log_json(self, data: Any, file_name: str) -> None:\n        # Define log directory\n        this_files_dir_path = os.path.dirname(__file__)\n        log_dir = os.path.join(this_files_dir_path, \"../logs\")\n\n        # Create a handler for JSON files\n        json_file_path = os.path.join(log_dir, file_name)\n        json_data_handler = JsonFileHandler(json_file_path)\n        json_data_handler.setFormatter(JsonFormatter())\n\n        # Log the JSON data using the custom file handler\n        self.json_logger.addHandler(json_data_handler)\n        self.json_logger.debug(data)\n        self.json_logger.removeHandler(json_data_handler)\n\n    def get_log_directory(self):\n        this_files_dir_path = os.path.dirname(__file__)\n        log_dir = os.path.join(this_files_dir_path, \"../logs\")\n        return os.path.abspath(log_dir)\n",
            "name_column": 6
        },
        "TypingConsoleHandler": {
            "type": "ClassDef",
            "name": "TypingConsoleHandler",
            "md_content": "**TypingConsoleHandler函数**：这个类的功能是模拟打字的控制台处理程序。\n\n这个类继承自logging.StreamHandler类，用于处理日志记录并将其输出到控制台。它重写了emit方法，实现了模拟打字的效果。\n\n在emit方法中，首先定义了最小和最大的打字速度，分别为0.05和0.01。然后将日志消息按照空格分割成单词，并逐个打印出来。每个单词打印后，会根据最小和最大打字速度之间的随机数，暂停相应的时间，以模拟打字的效果。每打印一个单词后，最小和最大打字速度会逐渐减小，以实现逐渐加快打字的效果。最后，打印完所有单词后，会换行。\n\n如果在打印过程中出现异常，会调用self.handleError方法处理异常。\n\n**注意**：在使用这段代码时需要注意以下几点：\n- 这个类是用来模拟打字的控制台处理程序，只能用于控制台输出，不能用于其他类型的日志处理。\n- 打字速度的范围可以根据实际需求进行调整，但需要注意不要设置得过快或过慢，以免影响用户体验。\n- 在使用这个类时，需要先创建一个实例，并将其添加到相应的日志记录器中，才能生效。",
            "code_start_line": 208,
            "code_end_line": 227,
            "parent": null,
            "have_return": false,
            "code_content": "class TypingConsoleHandler(logging.StreamHandler):\n    def emit(self, record):\n        min_typing_speed = 0.05\n        max_typing_speed = 0.01\n\n        msg = self.format(record)\n        try:\n            words = msg.split()\n            for i, word in enumerate(words):\n                print(word, end=\"\", flush=True)\n                if i < len(words) - 1:\n                    print(\" \", end=\"\", flush=True)\n                typing_speed = random.uniform(min_typing_speed, max_typing_speed)\n                time.sleep(typing_speed)\n                # type faster after each word\n                min_typing_speed = min_typing_speed * 0.95\n                max_typing_speed = max_typing_speed * 0.95\n            print()\n        except Exception:\n            self.handleError(record)\n",
            "name_column": 6
        },
        "ConsoleHandler": {
            "type": "ClassDef",
            "name": "ConsoleHandler",
            "md_content": "**ConsoleHandler函数**: 这个类的功能是将日志消息输出到控制台。\n\nConsoleHandler类是logging模块中的一个处理器（Handler），用于将日志消息输出到控制台。它继承自logging.StreamHandler类，并重写了emit方法。\n\n在emit方法中，首先通过self.format(record)将日志记录格式化为字符串msg。然后尝试使用print函数将msg打印到控制台。如果打印过程中发生异常，就调用self.handleError(record)处理异常。\n\n在XAgent/logs.py文件中，ConsoleHandler类被用于创建两个日志处理器：typing_console_handler和console_handler。这两个处理器分别用于模拟打字效果的控制台输出和普通控制台输出。\n\n在初始化函数__init__中，首先创建了一个日志目录log_dir，如果该目录不存在则创建。然后创建了两个日志文件的文件名log_file和error_file。\n\n接下来，创建了一个格式化器console_formatter，用于格式化控制台输出的日志消息。\n\n然后，创建了一个TypingConsoleHandler实例typing_console_handler，设置其日志级别为INFO，并将格式化器console_formatter设置给它。\n\n接着，创建了一个ConsoleHandler实例console_handler，设置其日志级别为DEBUG，并将格式化器console_formatter设置给它。\n\n然后，创建了一个FileHandler实例file_handler，用于将日志消息写入activity.log文件。设置其日志级别为DEBUG，并将格式化器info_formatter设置给它。\n\n接着，创建了一个FileHandler实例error_handler，用于将错误日志消息写入error.log文件。设置其日志级别为ERROR，并将格式化器error_formatter设置给它。\n\n然后，分别创建了三个Logger实例：typing_logger、logger和json_logger。将typing_console_handler、file_handler和error_handler添加到这三个Logger实例中，并设置它们的日志级别。\n\n最后，设置了一些其他属性，如speak_mode、chat_plugins和log_lock。\n\n**注意**: 使用ConsoleHandler类时需要注意以下几点：\n- ConsoleHandler类是logging模块中的一个处理器，用于将日志消息输出到控制台。\n- 在使用ConsoleHandler类之前，需要先创建一个Logger实例，并将ConsoleHandler实例添加到该Logger实例中。\n- 可以通过设置ConsoleHandler实例的日志级别和格式化器来控制日志消息的输出方式和格式。\n- ConsoleHandler类的emit方法会将日志消息格式化为字符串，并尝试将其打印到控制台。如果打印过程中发生异常，会调用handleError方法处理异常。",
            "code_start_line": 230,
            "code_end_line": 236,
            "parent": null,
            "have_return": false,
            "code_content": "class ConsoleHandler(logging.StreamHandler):\n    def emit(self, record) -> None:\n        msg = self.format(record)\n        try:\n            print(msg)\n        except Exception:\n            self.handleError(record)\n",
            "name_column": 6
        },
        "RecordFormatter": {
            "type": "ClassDef",
            "name": "RecordFormatter",
            "md_content": "**RecordFormatter函数**：这个类的功能是为日志记录提供格式化的功能。\n\nRecordFormatter类继承自logging.Formatter类，它重写了format方法，用于格式化日志记录。format方法接收一个LogRecord对象作为参数，并返回一个字符串作为格式化后的日志记录。\n\n在format方法中，首先判断LogRecord对象是否具有\"color\"属性，如果有，则将\"color\"属性的值与\"title\"属性的值以及Style.RESET_ALL拼接起来，并赋值给record.title_color。如果没有\"color\"属性，则将\"record.title\"的值赋给record.title_color。\n\n接下来，判断LogRecord对象是否具有\"msg\"属性，如果有，则将\"msg\"属性的值去除颜色代码后的字符串赋给record.message_no_color。如果没有\"msg\"属性，则将空字符串赋给record.message_no_color。\n\n最后，调用父类logging.Formatter的format方法，传入record对象作为参数，并返回格式化后的字符串。\n\n这个类的作用是为日志记录提供自定义的格式化方式，可以根据具体需求对日志记录进行格式化处理。\n\n**注意**：在使用RecordFormatter类时，需要注意以下几点：\n- 需要先创建一个RecordFormatter对象，并将其作为参数传递给日志处理器（如FileHandler、ConsoleHandler等）的setFormatter方法，以设置日志记录的格式化方式。\n- 可以根据具体需求自定义format方法的实现，以满足不同的日志记录格式化需求。\n\n**输出示例**：假设有一个LogRecord对象，其属性值如下：\n- color: \"\\033[1;31m\"\n- title: \"ERROR\"\n- msg: \"An error occurred.\"\n\n经过RecordFormatter类的format方法处理后，返回的格式化后的字符串为：\n\"\\033[1;31mERROR An error occurred.\"",
            "code_start_line": 239,
            "code_end_line": 258,
            "parent": null,
            "have_return": true,
            "code_content": "class RecordFormatter(logging.Formatter):\n    def format(self, record: LogRecord) -> str:\n        if hasattr(record, \"color\"):\n            record.title_color = (\n                getattr(record, \"color\")\n                + getattr(record, \"title\", \"\")\n                + \" \"\n                + Style.RESET_ALL\n            )\n        else:\n            record.title_color = getattr(record, \"title\", \"\")\n\n        # Add this line to set 'title' to an empty string if it doesn't exist\n        record.title = getattr(record, \"title\", \"\")\n\n        if hasattr(record, \"msg\"):\n            record.message_no_color = remove_color_codes(getattr(record, \"msg\"))\n        else:\n            record.message_no_color = \"\"\n        return super().format(record)\n",
            "name_column": 6
        },
        "remove_color_codes": {
            "type": "FunctionDef",
            "name": "remove_color_codes",
            "md_content": "**remove_color_codes函数**：该函数的功能是移除字符串中的颜色代码。\n\n该函数接受一个字符串作为输入，并返回一个移除了颜色代码的新字符串。如果输入的不是字符串类型，函数会尝试将其转换为字符串类型。如果转换失败，则将其转换为字符串类型。\n\n函数内部使用正则表达式来匹配并移除字符串中的ANSI颜色代码。具体而言，函数使用了一个正则表达式对象`ansi_escape`，该对象匹配了形如`\\x1B(?:[@-Z\\\\-_]|\\[[0-?]*[ -/]*[@-~])`的字符串，即ANSI颜色代码。然后，函数使用`sub`方法将匹配到的颜色代码替换为空字符串，从而实现移除颜色代码的功能。\n\n在项目中，该函数在`XAgent/logs.py`文件中被调用。具体调用代码如下：\n```python\ndef format(self, record: LogRecord) -> str:\n    if hasattr(record, \"color\"):\n        record.title_color = (\n            getattr(record, \"color\")\n            + getattr(record, \"title\", \"\")\n            + \" \"\n            + Style.RESET_ALL\n        )\n    else:\n        record.title_color = getattr(record, \"title\", \"\")\n\n    # Add this line to set 'title' to an empty string if it doesn't exist\n    record.title = getattr(record, \"title\", \"\")\n\n    if hasattr(record, \"msg\"):\n        record.message_no_color = remove_color_codes(getattr(record, \"msg\"))\n    else:\n        record.message_no_color = \"\"\n    return super().format(record)\n```\n\n在上述代码中，`remove_color_codes`函数被用于移除`record`对象中的颜色代码。具体而言，如果`record`对象具有`msg`属性，则将`msg`属性的值传递给`remove_color_codes`函数进行处理，并将处理后的结果赋值给`record`对象的`message_no_color`属性。最后，函数返回通过调用父类的`format`方法得到的字符串。\n\n**注意**：在使用该函数时，需要注意以下几点：\n- 该函数只能处理字符串类型的输入，如果输入不是字符串类型，则会尝试将其转换为字符串类型。\n- 该函数使用正则表达式来匹配和移除颜色代码，因此只能移除ANSI颜色代码，无法处理其他类型的颜色代码。\n\n**输出示例**：假设输入字符串为\"\\x1B[31mHello World\\x1B[0m\"，则函数的返回值为\"Hello World\"，即移除了颜色代码的字符串。",
            "code_start_line": 261,
            "code_end_line": 268,
            "parent": null,
            "have_return": true,
            "code_content": "def remove_color_codes(s: str) -> str:\n    if not isinstance(s,str):\n        try:\n            s = json.dumps(s)\n        except:\n            s = str(s)\n    ansi_escape = re.compile(r\"\\x1B(?:[@-Z\\\\-_]|\\[[0-?]*[ -/]*[@-~])\")\n    return ansi_escape.sub(\"\", s)\n",
            "name_column": 4
        },
        "print_task_save_items": {
            "type": "FunctionDef",
            "name": "print_task_save_items",
            "md_content": "**print_task_save_items函数**: 该函数的功能是打印任务保存项。\n\n该函数接受一个名为item的参数，该参数是一个TaskSaveItem对象。\n\n函数内部通过logger.typewriter_log方法打印任务的各个属性。首先打印任务的名称和目标，然后打印任务的先前批评和后续批评。如果后续批评不为空，则逐行打印后续批评的内容。接下来，如果里程碑列表不为空，则逐行打印里程碑的内容。然后，如果工具反思列表不为空，则逐行打印工具反思的内容。最后，打印任务的状态和动作列表的摘要。\n\n**注意**: 使用该代码时需要注意以下几点：\n- 该函数依赖logger.typewriter_log方法进行打印，需要确保该方法的正确性和可用性。\n- 传入的item参数必须是一个TaskSaveItem对象，否则可能会导致函数执行错误。\n- 部分代码被注释掉了，如果需要使用相关功能，需要取消注释并确保相关数据结构的正确性。",
            "code_start_line": 274,
            "code_end_line": 322,
            "parent": null,
            "have_return": false,
            "code_content": "def print_task_save_items(\n    item: TaskSaveItem,\n) -> None:\n\n    logger.typewriter_log(\n        f\"Task Name:\", Fore.YELLOW, f\"{item.name}\"\n    )\n    logger.typewriter_log(\n        f\"Task Goal:\", Fore.YELLOW, f\"{item.goal}\"\n    )\n    logger.typewriter_log(\n        f\"Task Prior-Criticism:\", Fore.YELLOW, f\"{item.prior_plan_criticism}\"\n    )\n    if len(item.posterior_plan_reflection) > 0:\n        logger.typewriter_log(\n            f\"Task Posterior-Criticism:\", Fore.YELLOW\n        )\n        for line in item.posterior_plan_reflection:\n            line = line.lstrip(\"- \")\n            logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n    if len(item.milestones) > 0:\n        logger.typewriter_log(\n            f\"Task Milestones:\", Fore.YELLOW,\n        )\n        for line in item.milestones:\n            line = line.lstrip(\"- \")\n            logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n    # if len(item.expected_tools) > 0:\n    #     logger.typewriter_log(\n    #         f\"Expected Tools:\", Fore.YELLOW,\n    #     )\n    #     for line in item.expected_tools:\n    #         line = f\"{line['tool_name']}: {line['reason']}\".lstrip(\"- \")\n    #         logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n    if len(item.tool_reflection) > 0:\n        logger.typewriter_log(\n            f\"Posterior Tool Reflections:\", Fore.YELLOW,\n        )\n        for line in item.tool_reflection:\n            line = f\"{line['target_tool_name']}: {line['reflection']}\".lstrip(\"- \")\n            logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n\n    logger.typewriter_log(\n        f\"Task Status:\", Fore.YELLOW, f\"{item.status.name}\"\n    )\n    if item.action_list_summary != \"\":\n        logger.typewriter_log(\n            f\"Action Summary:\", Fore.YELLOW, f\"{item.action_list_summary}\"\n        )\n",
            "name_column": 4
        },
        "print_assistant_thoughts": {
            "type": "FunctionDef",
            "name": "print_assistant_thoughts",
            "md_content": "**print_assistant_thoughts函数**: 这个函数的功能是打印助手的思考结果。\n\n这个函数接受三个参数：\n- assistant_reply_json_valid: 一个有效的助手回复的JSON对象。\n- speak_mode: 一个布尔值，表示是否以语音模式输出。\n\n这个函数的返回值是一个字典，包含助手的思考结果、推理、计划、批评和节点ID。\n\n函数的具体实现如下：\n1. 首先，初始化助手的思考结果的各个属性为None。\n2. 然后，从助手回复的JSON对象中获取思考结果的相关信息。\n3. 如果助手的思考结果不为空，则分别获取推理、计划和批评的内容。\n4. 如果助手的思考文本不为空，则使用logger.typewriter_log函数打印出助手的思考文本。\n5. 如果助手的推理内容不为空，则使用logger.typewriter_log函数打印出推理的内容。\n6. 如果助手的计划内容不为空且长度大于0，则使用logger.typewriter_log函数打印出计划的内容。如果计划是一个列表，则将其转换为字符串；如果计划是一个字典，则将其转换为字符串。\n7. 将计划内容按照换行符和破折号进行分割，并使用logger.typewriter_log函数打印出每一行的内容。\n8. 如果助手的批评内容不为空，则使用logger.typewriter_log函数打印出批评的内容。\n9. 最后，返回一个包含助手思考结果、推理、计划、批评和节点ID的字典。\n\n**注意**: 使用该代码的一些注意事项。\n\n**输出示例**: 模拟代码返回值的可能外观。",
            "code_start_line": 324,
            "code_end_line": 370,
            "parent": null,
            "have_return": true,
            "code_content": "def print_assistant_thoughts(\n    # ai_name: object,\n    assistant_reply_json_valid: object,\n    speak_mode: bool = False,\n) -> None:\n    assistant_thoughts_reasoning = None\n    assistant_thoughts_plan = None\n    assistant_thoughts_speak = None\n    assistant_thoughts_criticism = None\n\n    assistant_thoughts = assistant_reply_json_valid.get(\"thoughts\", {})\n    assistant_thoughts = assistant_thoughts.get(\"properties\", {})\n    assistant_thoughts_text = assistant_thoughts.get(\"thought\")\n    if assistant_thoughts:\n        assistant_thoughts_reasoning = assistant_thoughts.get(\"reasoning\")\n        assistant_thoughts_plan = assistant_thoughts.get(\"plan\")\n        assistant_thoughts_criticism = assistant_thoughts.get(\"criticism\")\n    if assistant_thoughts_text is not None and assistant_thoughts_text != \"\":\n        logger.typewriter_log(\n            f\"THOUGHTS:\", Fore.YELLOW, f\"{assistant_thoughts_text}\"\n        )\n    if assistant_thoughts_reasoning is not None and assistant_thoughts_reasoning != \"\":\n        logger.typewriter_log(\"REASONING:\", Fore.YELLOW, f\"{assistant_thoughts_reasoning}\")\n        \n    if assistant_thoughts_plan is not None and len(assistant_thoughts_plan) > 0:\n        logger.typewriter_log(\"PLAN:\", Fore.YELLOW, \"\")\n        # If it's a list, join it into a string\n        if isinstance(assistant_thoughts_plan, list):\n            assistant_thoughts_plan = \"\\n\".join(assistant_thoughts_plan)\n        elif isinstance(assistant_thoughts_plan, dict):\n            assistant_thoughts_plan = str(assistant_thoughts_plan)\n\n        # Split the input_string using the newline character and dashes\n        lines = assistant_thoughts_plan.split(\"\\n\")\n        for line in lines:\n            line = line.lstrip(\"- \")\n            logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n            \n    if assistant_thoughts_criticism is not None and assistant_thoughts_criticism != \"\":\n        logger.typewriter_log(\"CRITICISM:\", Fore.YELLOW, f\"{assistant_thoughts_criticism}\")\n    return {\n        \"thoughts\": assistant_thoughts_text,\n        \"reasoning\": assistant_thoughts_reasoning,\n        \"plan\": assistant_thoughts_plan,\n        \"criticism\": assistant_thoughts_criticism,\n        \"node_id\": uuid.uuid4().hex\n    }",
            "name_column": 4
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__函数**：这个函数的作用是初始化logs.py模块的日志记录器和处理器。\n\n在这个函数中，首先会创建一个日志目录，如果该目录不存在的话。然后，定义了两个日志文件的名称：activity.log和error.log。\n\n接下来，创建了两个日志处理器：typing_console_handler和console_handler。typing_console_handler用于在控制台上模拟打字的效果，而console_handler则不模拟打字。这两个处理器都设置了日志级别和格式。\n\n然后，创建了一个文件处理器file_handler，用于将日志记录到activity.log文件中。设置了该处理器的日志级别和格式。\n\n接着，创建了一个错误处理器error_handler，用于将错误日志记录到error.log文件中。同样设置了该处理器的日志级别和格式。\n\n接下来，分别创建了三个日志记录器：typing_logger、logger和json_logger。这些记录器分别添加了不同的处理器，并设置了日志级别。\n\n最后，初始化了一些其他属性：speak_mode、chat_plugins和log_lock。\n\n**注意**：在使用该代码时需要注意以下几点：\n- 确保日志目录存在，否则会抛出异常。\n- 可以根据需要修改日志文件的名称和路径。\n- 可以根据需要修改日志的格式和级别。\n- 可以根据需要添加或删除日志处理器和记录器。",
            "code_start_line": 39,
            "code_end_line": 104,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def __init__(self):\n        # create log directory if it doesn't exist\n        this_files_dir_path = os.path.dirname(__file__)\n        log_dir = os.path.join(this_files_dir_path, \"../logs\")\n        if not os.path.exists(log_dir):\n            os.makedirs(log_dir)\n\n        log_file = \"activity.log\"\n        error_file = \"error.log\"\n\n        console_formatter = RecordFormatter(\"%(title_color)s %(message)s\")\n\n        # Create a handler for console which simulate typing\n        self.typing_console_handler = TypingConsoleHandler()\n        self.typing_console_handler.setLevel(logging.INFO)\n        self.typing_console_handler.setFormatter(console_formatter)\n\n        # Create a handler for console without typing simulation\n        self.console_handler = ConsoleHandler()\n        self.console_handler.setLevel(logging.DEBUG)\n        self.console_handler.setFormatter(console_formatter)\n\n        \n        if not os.path.exists(log_dir):\n            os.makedirs(log_dir)\n        # Info handler in activity.log\n        self.file_handler = logging.FileHandler(\n            os.path.join(log_dir, log_file), \"a\", \"utf-8\"\n        )\n        self.file_handler.setLevel(logging.DEBUG)\n        info_formatter = RecordFormatter(\n            \"%(asctime)s %(levelname)s %(title)s %(message_no_color)s\"\n        )\n        self.file_handler.setFormatter(info_formatter)\n\n        # Error handler error.log\n        error_handler = logging.FileHandler(\n            os.path.join(log_dir, error_file), \"a\", \"utf-8\"\n        )\n        error_handler.setLevel(logging.ERROR)\n        error_formatter = RecordFormatter(\n            \"%(asctime)s %(levelname)s %(module)s:%(funcName)s:%(lineno)d %(title)s\"\n            \" %(message_no_color)s\"\n        )\n        error_handler.setFormatter(error_formatter)\n\n        self.typing_logger = logging.getLogger(\"TYPER\")\n        self.typing_logger.addHandler(self.typing_console_handler)\n        self.typing_logger.addHandler(self.file_handler)\n        self.typing_logger.addHandler(error_handler)\n        self.typing_logger.setLevel(logging.DEBUG)\n\n        self.logger = logging.getLogger(\"LOGGER\")\n        self.logger.addHandler(self.console_handler)\n        self.logger.addHandler(self.file_handler)\n        self.logger.addHandler(error_handler)\n        self.logger.setLevel(logging.DEBUG)\n\n        self.json_logger = logging.getLogger(\"JSON_LOGGER\")\n        self.json_logger.addHandler(self.file_handler)\n        self.json_logger.addHandler(error_handler)\n        self.json_logger.setLevel(logging.DEBUG)\n\n        self.speak_mode = False\n        self.chat_plugins = []\n        self.log_lock = Lock()\n",
            "name_column": 8
        },
        "emit": {
            "type": "FunctionDef",
            "name": "emit",
            "md_content": "**emit函数**：这个函数的功能是将日志记录打印出来。\n\n该函数接受一个参数record，它是一个日志记录对象。首先，通过self.format(record)将记录格式化为字符串msg。然后，尝试将msg打印出来。如果打印过程中发生异常，就调用self.handleError(record)处理异常。\n\n**注意**：在使用这段代码时需要注意以下几点：\n- 该函数只是将日志记录打印出来，并没有将日志记录写入文件或发送到其他地方。\n- 如果打印过程中发生异常，会调用self.handleError(record)处理异常，可以根据实际需求自定义处理方式。",
            "code_start_line": 231,
            "code_end_line": 236,
            "parent": "ConsoleHandler",
            "have_return": false,
            "code_content": "    def emit(self, record) -> None:\n        msg = self.format(record)\n        try:\n            print(msg)\n        except Exception:\n            self.handleError(record)\n",
            "name_column": 8
        },
        "format": {
            "type": "FunctionDef",
            "name": "format",
            "md_content": "**format函数**：这个函数的作用是将LogRecord对象格式化为字符串。\n\n在这个函数中，首先判断LogRecord对象是否具有color属性，如果有，则将title_color设置为color属性值加上title属性值，并在末尾添加一个空格和Style.RESET_ALL，表示重置所有样式。如果没有color属性，则将title_color设置为title属性值。\n\n接下来，判断LogRecord对象是否具有msg属性，如果有，则将message_no_color设置为去除颜色代码后的msg属性值。如果没有msg属性，则将message_no_color设置为空字符串。\n\n最后，调用父类的format方法，将LogRecord对象传入，返回格式化后的字符串。\n\n**注意**：使用这段代码时需要注意以下几点：\n- 确保LogRecord对象具有color和msg属性，否则可能会出现错误。\n- 可以通过设置color属性来改变日志标题的颜色。\n- 可以通过设置title属性来自定义日志标题。\n\n**输出示例**：假设LogRecord对象的color属性为\"\\033[1;31m\"，title属性为\"Error\"，msg属性为\"An error occurred\"，则函数的返回值为\"\\033[1;31mError An error occurred\"。",
            "code_start_line": 240,
            "code_end_line": 258,
            "parent": "RecordFormatter",
            "have_return": true,
            "code_content": "    def format(self, record: LogRecord) -> str:\n        if hasattr(record, \"color\"):\n            record.title_color = (\n                getattr(record, \"color\")\n                + getattr(record, \"title\", \"\")\n                + \" \"\n                + Style.RESET_ALL\n            )\n        else:\n            record.title_color = getattr(record, \"title\", \"\")\n\n        # Add this line to set 'title' to an empty string if it doesn't exist\n        record.title = getattr(record, \"title\", \"\")\n\n        if hasattr(record, \"msg\"):\n            record.message_no_color = remove_color_codes(getattr(record, \"msg\"))\n        else:\n            record.message_no_color = \"\"\n        return super().format(record)\n",
            "name_column": 8
        },
        "typewriter_log": {
            "type": "FunctionDef",
            "name": "typewriter_log",
            "md_content": "**typewriter_log函数**: 这个函数的功能是将日志信息打印到控制台并记录到日志文件中。\n\n该函数接受以下参数：\n- title: 日志标题，默认为空字符串。\n- title_color: 标题颜色，默认为空字符串。\n- content: 日志内容，默认为空字符串。\n- speak_text: 是否将日志内容朗读出来，默认为False。\n- level: 日志级别，默认为logging.INFO。\n\n该函数首先遍历self.chat_plugins列表，将日志信息报告给每个插件。然后，如果content不为空，将content转换为字符串形式。接下来，使用self.log_lock.acquire()获取日志锁，以确保日志记录的线程安全性。然后，使用self.typing_logger.log()方法记录日志，其中包括日志级别、标题和颜色等额外信息。最后，使用self.log_lock.release()释放日志锁。\n\n**注意**: 使用该函数时需要注意以下几点：\n- 请确保在调用该函数之前已经初始化了self.chat_plugins和self.typing_logger。\n- 如果speak_text为True且self.speak_mode为True，则会将日志内容朗读出来。\n- 请确保在使用日志锁时正确地获取和释放锁，以避免线程安全问题。",
            "code_start_line": 107,
            "code_end_line": 124,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def typewriter_log(\n        self, title=\"\", title_color=\"\", content=\"\", speak_text=False, level=logging.INFO\n    ):\n        # if speak_text and self.speak_mode:\n        #     say_text(f\"{title}. {content}\")\n        for plugin in self.chat_plugins:\n            plugin.report(f\"{title}. {content}\")\n\n        if content:\n            if isinstance(content, list):\n                content = \" \".join(content)\n        else:\n            content = \"\"\n        self.log_lock.acquire()\n        self.typing_logger.log(\n            level, content, extra={\"title\": title, \"color\": title_color}\n        )\n        self.log_lock.release()\n",
            "name_column": 8
        },
        "debug": {
            "type": "FunctionDef",
            "name": "debug",
            "md_content": "**debug函数**：此函数的功能是将消息记录为调试级别的日志。\n\n该函数接受以下参数：\n- message：要记录的消息内容。\n- title：日志标题，默认为空字符串。\n- title_color：日志标题的颜色，默认为空字符串。\n\n该函数将调用`_log`方法，将消息记录为调试级别的日志。\n\n**注意**：在使用此函数时，可以提供消息内容、日志标题和标题颜色作为参数。调用此函数将会将消息记录为调试级别的日志。",
            "code_start_line": 126,
            "code_end_line": 132,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def debug(\n        self,\n        message,\n        title=\"\",\n        title_color=\"\",\n    ):\n        self._log(title, title_color, message, logging.DEBUG)\n",
            "name_column": 8
        },
        "info": {
            "type": "FunctionDef",
            "name": "info",
            "md_content": "**info函数**：这个函数的作用是将消息记录到日志中，以INFO级别进行记录。\n\n该函数接受以下参数：\n- message：要记录的消息内容。\n- title：消息的标题，默认为空字符串。\n- title_color：标题的颜色，默认为空字符串。\n\n该函数调用了`_log`函数，将消息、标题和标题颜色传递给`_log`函数进行记录。\n\n**注意**：使用该代码时需要注意以下几点：\n- 该函数将消息记录到日志中，以INFO级别进行记录。\n- 可以通过指定标题和标题颜色来对消息进行分类和标记。",
            "code_start_line": 134,
            "code_end_line": 140,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def info(\n        self,\n        message,\n        title=\"\",\n        title_color=\"\",\n    ):\n        self._log(title, title_color, message, logging.INFO)\n",
            "name_column": 8
        },
        "warn": {
            "type": "FunctionDef",
            "name": "warn",
            "md_content": "**warn函数**：该函数的功能是记录警告级别的日志。\n\n该函数接受以下参数：\n- message：要记录的日志消息。\n- title：日志标题，默认为空字符串。\n- title_color：日志标题的颜色，默认为空字符串。\n\n该函数调用了`_log`函数，用于记录日志。`_log`函数接受四个参数，分别是日志标题、日志标题颜色、日志消息和日志级别（`logging.WARN`）。\n\n**注意**：使用该函数时需要注意以下几点：\n- `message`参数不能为空，否则会记录一个空的日志消息。\n- `title`和`title_color`参数可选，如果不传入，则日志标题和标题颜色都为空字符串。\n- 该函数会记录一个警告级别的日志。",
            "code_start_line": 142,
            "code_end_line": 148,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def warn(\n        self,\n        message,\n        title=\"\",\n        title_color=\"\",\n    ):\n        self._log(title, title_color, message, logging.WARN)\n",
            "name_column": 8
        },
        "error": {
            "type": "FunctionDef",
            "name": "error",
            "md_content": "**error函数**：该函数用于记录错误日志。\n\n该函数接受两个参数：title和message。其中，title为错误标题，message为错误信息（可选，默认为空字符串）。函数会调用_log函数，将错误信息以红色字体的形式记录在日志中，并设置日志级别为ERROR。\n\n该函数被以下文件调用：\n1. XAgent/agent/dispatcher_agent/agent.py中的extract_prompts_from_response函数调用了error函数。在该函数中，error函数被用于在无法从dispatcher的响应消息中提取到额外提示时，记录错误日志并使用默认提示。\n\n2. XAgent/message_history.py中的update_running_summary函数调用了error函数。在该函数中，error函数被用于在无法解析JSON格式的事件内容时，记录错误日志。\n\n**注意**：在使用error函数时，需要确保传入正确的标题和错误信息，以便在日志中准确记录错误信息。",
            "code_start_line": 150,
            "code_end_line": 151,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def error(self, title, message=\"\"):\n        self._log(title, Fore.RED, message, logging.ERROR)\n",
            "name_column": 8
        },
        "_log": {
            "type": "FunctionDef",
            "name": "_log",
            "md_content": "**_log函数**: 这个函数的功能是记录日志信息。\n\n该函数接受以下参数：\n- title: 日志标题，类型为字符串，默认为空字符串。\n- title_color: 标题颜色，类型为字符串，默认为空字符串。\n- message: 日志消息，类型为字符串，默认为空字符串。\n- level: 日志级别，类型为logging模块中的常量，默认为logging.INFO。\n\n如果传入了message参数且message是一个列表类型，那么将列表中的元素用空格连接成一个字符串。\n\n然后，调用self.logger.log方法记录日志，传入的参数为level、message和extra。extra参数是一个字典，包含了title和title_color两个键值对，用于记录日志的标题和标题颜色。\n\n在项目中，_log函数被以下文件调用：\n文件路径：XAgent/logs.py\n对应代码如下：\n    def debug(\n        self,\n        message,\n        title=\"\",\n        title_color=\"\",\n    ):\n        self._log(title, title_color, message, logging.DEBUG)\n\n[代码片段结束]\n对应代码如下：\n    def info(\n        self,\n        message,\n        title=\"\",\n        title_color=\"\",\n    ):\n        self._log(title, title_color, message, logging.INFO)\n\n[代码片段结束]\n对应代码如下：\n    def warn(\n        self,\n        message,\n        title=\"\",\n        title_color=\"\",\n    ):\n        self._log(title, title_color, message, logging.WARN)\n\n[代码片段结束]\n对应代码如下：\n    def error(self, title, message=\"\"):\n        self._log(title, Fore.RED, message, logging.ERROR)\n\n[代码片段结束]\n[文件XAgent/logs.py结束]\n\n**注意**: 使用该函数时需要注意以下几点：\n- title和title_color参数用于设置日志的标题和标题颜色，可以根据需要进行设置。\n- message参数用于设置日志的消息内容，可以是字符串或字符串列表。如果是字符串列表，会将列表中的元素用空格连接成一个字符串。\n- level参数用于设置日志的级别，默认为logging.INFO。可以根据需要设置不同的级别，如DEBUG、INFO、WARN、ERROR等。\n- 通过调用self.logger.log方法记录日志，可以根据需要自定义日志的输出方式和格式。",
            "code_start_line": 153,
            "code_end_line": 165,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def _log(\n        self,\n        title: str = \"\",\n        title_color: str = \"\",\n        message: str = \"\",\n        level=logging.INFO,\n    ):\n        if message:\n            if isinstance(message, list):\n                message = \" \".join(message)\n        self.logger.log(\n            level, message, extra={\"title\": str(title), \"color\": str(title_color)}\n        )\n",
            "name_column": 8
        },
        "set_level": {
            "type": "FunctionDef",
            "name": "set_level",
            "md_content": "**set_level函数**：该函数的功能是设置日志级别。\n\n该函数接受一个参数level，用于设置日志级别。它通过调用self.logger.setLevel(level)和self.typing_logger.setLevel(level)来设置日志记录器和类型记录器的级别。\n\n**注意**：使用该代码时需要注意以下几点：\n- level参数应该是一个有效的日志级别，例如logging.DEBUG、logging.INFO等。\n- 设置日志级别会影响日志记录的详细程度，需要根据实际需求进行设置。",
            "code_start_line": 167,
            "code_end_line": 169,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def set_level(self, level):\n        self.logger.setLevel(level)\n        self.typing_logger.setLevel(level)\n",
            "name_column": 8
        },
        "double_check": {
            "type": "FunctionDef",
            "name": "double_check",
            "md_content": "**double_check函数**：该函数的功能是检查配置是否正确。\n\n该函数首先判断additionalText是否为空，如果为空，则将一个默认的additionalText赋值给它。接着，函数调用self.typewriter_log方法，将\"DOUBLE CHECK CONFIGURATION\"、Fore.YELLOW和additionalText作为参数传入，实现日志的打印。\n\n**注意**：使用该代码时需要注意以下几点：\n- 需要确保已经正确设置和配置了相关内容。\n- 可以阅读https://github.com/Torantulino/Auto-GPT#readme进行二次检查。\n- 如果有问题，可以创建一个github issue或者加入discord群组进行咨询。",
            "code_start_line": 171,
            "code_end_line": 180,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def double_check(self, additionalText=None):\n        if not additionalText:\n            additionalText = (\n                \"Please ensure you've setup and configured everything\"\n                \" correctly. Read https://github.com/Torantulino/Auto-GPT#readme to \"\n                \"double check. You can also create a github issue or join the discord\"\n                \" and ask there!\"\n            )\n\n        self.typewriter_log(\"DOUBLE CHECK CONFIGURATION\", Fore.YELLOW, additionalText)\n",
            "name_column": 8
        },
        "log_json": {
            "type": "FunctionDef",
            "name": "log_json",
            "md_content": "**log_json函数**：该函数的作用是将数据以JSON格式记录到日志文件中。\n\n该函数接受两个参数：data和file_name。data参数表示要记录的数据，可以是任意类型的数据。file_name参数表示要记录到的日志文件的文件名。\n\n函数内部首先定义了日志目录的路径，通过os模块的dirname函数获取当前文件的目录路径，然后使用os模块的join函数将日志目录路径和文件名拼接起来，得到JSON文件的路径。\n\n接下来，创建了一个JsonFileHandler对象，该对象用于处理JSON文件。通过JsonFileHandler的构造函数传入JSON文件的路径，然后调用setFormatter方法设置JsonFormatter作为日志格式化器。\n\n然后，将自定义的文件处理器添加到json_logger中，以便将日志记录到JSON文件中。调用json_logger的debug方法，将data参数作为日志内容记录到JSON文件中。\n\n最后，从json_logger中移除自定义的文件处理器，确保下一次记录日志时不会再将日志记录到JSON文件中。\n\n**注意**：使用该函数时需要注意以下几点：\n- data参数可以是任意类型的数据，但需要确保该数据可以被转换为JSON格式。\n- file_name参数应该是一个合法的文件名，且不包含路径信息。日志文件将保存在与当前文件同级的logs目录下。\n- 使用该函数前，需要确保logs目录已经存在，否则会抛出FileNotFoundError异常。",
            "code_start_line": 182,
            "code_end_line": 195,
            "parent": "Logger",
            "have_return": false,
            "code_content": "    def log_json(self, data: Any, file_name: str) -> None:\n        # Define log directory\n        this_files_dir_path = os.path.dirname(__file__)\n        log_dir = os.path.join(this_files_dir_path, \"../logs\")\n\n        # Create a handler for JSON files\n        json_file_path = os.path.join(log_dir, file_name)\n        json_data_handler = JsonFileHandler(json_file_path)\n        json_data_handler.setFormatter(JsonFormatter())\n\n        # Log the JSON data using the custom file handler\n        self.json_logger.addHandler(json_data_handler)\n        self.json_logger.debug(data)\n        self.json_logger.removeHandler(json_data_handler)\n",
            "name_column": 8
        },
        "get_log_directory": {
            "type": "FunctionDef",
            "name": "get_log_directory",
            "md_content": "**get_log_directory函数**：这个函数的功能是获取日志目录。\n\n该函数通过使用os模块中的相关方法，获取当前文件所在目录的路径，并将其与上级目录中的logs文件夹路径拼接起来，最后返回日志目录的绝对路径。\n\n**注意**：使用该代码时需要注意以下几点：\n- 该函数依赖于os模块，因此在使用之前需要确保已经导入os模块。\n- 该函数返回的是日志目录的绝对路径。\n\n**输出示例**：假设当前文件所在目录为\"/Users/logic/Documents/THUNLP/XAgent/XAgent\"，则函数返回的日志目录路径为\"/Users/logic/Documents/THUNLP/XAgent/XAgent/logs\"。",
            "code_start_line": 197,
            "code_end_line": 200,
            "parent": "Logger",
            "have_return": true,
            "code_content": "    def get_log_directory(self):\n        this_files_dir_path = os.path.dirname(__file__)\n        log_dir = os.path.join(this_files_dir_path, \"../logs\")\n        return os.path.abspath(log_dir)\n",
            "name_column": 8
        }
    },
    "XAgent/function_handler.py": {
        "FunctionHandler": {
            "type": "ClassDef",
            "name": "FunctionHandler",
            "md_content": "**FunctionHandler函数**: 这个类的功能是处理函数。\n\nFunctionHandler类是一个处理函数的类，它用于处理函数的调用和执行。它接收来自ToolServerInterface的工具调用请求，并根据请求的类型执行相应的操作。它还负责记录任务的提交和执行结果，并将结果返回给调用者。\n\n该类的构造函数接受以下参数：\n- toolserver_interface：ToolServerInterface对象，用于与工具服务器进行通信。\n- config：配置对象，包含函数处理器的配置信息。\n- interaction：XAgentInteraction对象，用于与用户进行交互。\n- recorder：RunningRecoder对象，用于记录任务的提交和执行结果。\n- logger：日志记录器对象，用于记录日志信息。\n\n该类的方法包括：\n- log_task_submit(arguments)：记录任务的提交信息。\n- change_subtask_handle_function_enum(function_name_list)：更改子任务处理函数的枚举。\n- intrinsic_tools(enable_ask_human_for_help)：获取内置工具。\n- get_functions(config)：获取函数列表。\n- long_result_summary(command, result)：对长结果进行摘要。\n- handle_tool_call(node)：处理工具调用。\n- handle_subtask_submit(arguments)：处理子任务提交。\n- handle_human_help(arguments)：处理请求人工帮助。\n\n注意事项：\n- 该类依赖于ToolServerInterface、XAgentInteraction、RunningRecoder等其他类的实例对象。\n- 在使用该类之前，需要先实例化相关的对象，并将其作为参数传递给FunctionHandler的构造函数。\n\n输出示例：\n```\nCommand subtask_submit returned: {\"content\": \"you have successfully submit the subtask as XXX\"}\nTOOL STATUS CODE: TOOL_CALL_SUCCESS\n```\n\n以上是对FunctionHandler类的详细分析和描述。该类是XAgent项目中用于处理函数调用和执行的关键组件，它负责与工具服务器进行通信，并根据请求的类型执行相应的操作。通过使用该类，开发人员可以方便地处理函数调用，并记录任务的提交和执行结果。",
            "code_start_line": 21,
            "code_end_line": 355,
            "parent": null,
            "have_return": true,
            "code_content": "class FunctionHandler():\n    \"\"\"\n    The handler for functions.\n    \"\"\"\n\n    def __init__(self,\n                 toolserver_interface: ToolServerInterface,\n                 config,\n                 interaction: XAgentInteraction,\n                 recorder: RunningRecoder,\n                 logger=None):\n        self.logger = logger\n        self.toolserver_interface = toolserver_interface\n        self.config = config\n        self.interaction = interaction\n        self.recorder = recorder\n        self.subtask_submit_function = function_manager.get_function_schema(\n            'subtask_submit')\n\n        # TODO: support more complex versions of human help, like collaborative debugging.\n        self.ask_human_for_help_function = function_manager.get_function_schema(\n            'ask_human_for_help')\n        self.human_interruption_function = function_manager.get_function_schema(\n            'human_interruption')\n\n        self.avaliable_tools_description_list = []\n\n    def log_task_submit(self, arguments):\n        \"\"\"\n        Log the task submission.\n\n        Args:\n            arguments: The arguments of the task submission.\n        \"\"\"\n        self.logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= SUBTASK SUBMITTED -=-=-=-=-=-=-=\",\n            Fore.YELLOW,\n            \"\",\n        )\n        self.logger.typewriter_log(\n            f\"submit_type:\", Fore.YELLOW, f\"{arguments['submit_type']}\"\n        )\n        self.logger.typewriter_log(\n            f\"success:\", Fore.YELLOW, f\"{arguments['result']['success']}\"\n        )\n        self.logger.typewriter_log(\n            f\"conclusion:\", Fore.YELLOW, f\"{arguments['result']['conclusion']}\"\n        )\n        if \"milestones\" in arguments[\"result\"].keys():\n            self.logger.typewriter_log(\n                f\"milestones:\", Fore.YELLOW\n            )\n            for milestone in arguments[\"result\"][\"milestones\"]:\n                line = milestone.lstrip(\"- \")\n                self.logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n        self.logger.typewriter_log(\n            f\"need_for_plan_refine:\", Fore.YELLOW, f\"{arguments['suggestions_for_latter_subtasks_plan']['need_for_plan_refine']}\"\n        )\n        self.logger.typewriter_log(\n            f\"plan_suggestions:\", Fore.YELLOW, f\"{arguments['suggestions_for_latter_subtasks_plan']['reason']}\"\n        )\n\n    def change_subtask_handle_function_enum(self, function_name_list: List[str]):\n        \"\"\"\n        Change the subtask handling function enumeration.\n\n        Args:\n            function_name_list: The list of function names.\n        \"\"\"\n        match self.config.default_request_type:\n            case 'openai':\n                self.subtask_handle_function = function_manager.get_function_schema(\n                    'subtask_handle')\n                self.subtask_handle_function[\"parameters\"][\"properties\"][\"tool_call\"][\n                    \"properties\"][\"tool_name\"][\"enum\"] = function_name_list\n            case 'xagent':\n                pass\n            case _:\n                raise NotImplementedError(\n                    f\"Request type {self.config.default_request_type} not implemented\")\n\n    def intrinsic_tools(self, enable_ask_human_for_help):\n        \"\"\"\n        Get the intrinsic tools.\n\n        Args:\n            enable_ask_human_for_help: Whether to enable the ask_human_for_help function.\n\n        Returns:\n            The intrinsic tools.\n        \"\"\"\n        tools = [self.subtask_submit_function,]\n        if enable_ask_human_for_help:\n            tools.append(self.ask_human_for_help_function)\n        tools.extend(self.avaliable_tools_description_list)\n        return tools\n\n    def get_functions(self, config):\n        \"\"\"\n        Get the functions.\n\n        Args:\n            config: The configuration for the functions.\n\n        Returns:\n            The intrinsic tools and the description of the tools.\n        \"\"\"\n        output = self.toolserver_interface.get_available_tools()\n\n        available_tools: list = output['available_tools']\n        openai_function_jsons: dict = output['tools_json']\n\n        black_list = set(config.tool_blacklist)\n        for item in black_list:\n            try:\n                available_tools.remove(item)\n            except ValueError:\n                pass\n        openai_function_jsons = [\n            openai_function_json for openai_function_json in openai_function_jsons if openai_function_json['name'] not in black_list]\n\n        self.tool_names = available_tools\n        self.change_subtask_handle_function_enum(available_tools)\n        self.avaliable_tools_description_list = openai_function_jsons\n        for tool_json in openai_function_jsons:\n            function_manager.register_function(tool_json)\n        return self.intrinsic_tools(config.enable_ask_human_for_help), self.avaliable_tools_description_list\n\n    def long_result_summary(self, command: dict, result):\n        \"\"\"\n        Summarize the long result.\n\n        Args:\n            command (dict): The command.\n            result: The result.\n\n        Returns:\n            The summarized result.\n        \"\"\"\n        if command['name'] == 'WebEnv_browse_website':\n            if not isinstance(result, str):\n                result = str(result)\n            result = function_manager(\n                'parse_web_text', webpage=result[:8096], prompt=command['arguments']['goals_to_browse'])\n            result['useful_hyperlinks'] = result['useful_hyperlinks'][:3]\n        if command['name'] == 'WebEnv_search_and_browse':\n            with ThreadPoolExecutor(max_workers=len(result)) as pool:\n                f = []\n                for ret in result:\n                    f.append(pool.submit(function_manager, 'parse_web_text',\n                             webpage=ret['page'][:8096], prompt=command['arguments']['goals_to_browse']))\n                for ret, thd in zip(result, f):\n                    ret['page'] = thd.result()\n                    ret['page']['useful_hyperlinks'] = ret['page']['useful_hyperlinks'][:3]\n\n        if isinstance(result, str) and len(result) > 2000:\n            # need to summarize\n            pass\n        return result\n\n    def handle_tool_call(self, node: ToolNode):\n        \"\"\"\n        Handle the tool call.\n\n        Args:\n            node (ToolNode): The tool node.\n\n        Returns:\n            The result, tool output status code, whether to refine the plan, and the tools used.\n        \"\"\"\n        plan_refine = False\n        command_name = node.data[\"command\"][\"properties\"][\"name\"]\n        arguments = node.data[\"command\"][\"properties\"][\"args\"]\n\n        self.logger.typewriter_log(\n            \"NEXT ACTION: \",\n            Fore.CYAN,\n            f\"COMMAND: {Fore.CYAN}{command_name}{Style.RESET_ALL}  \\n\"\n            f\"ARGUMENTS: \\n{Fore.CYAN}{arguments}{Style.RESET_ALL}\",\n        )\n\n        if command_name == \"subtask_submit\":\n            plan_refine, tool_output_status_code, command_result, = self.handle_subtask_submit(\n                arguments)\n        elif command_name == \"ask_human_for_help\":\n            plan_refine, tool_output_status_code, command_result, = self.handle_human_help(\n                arguments)\n        elif command_name == \"human_interruption\":\n            assert False, \"Never call this function\"\n        elif command_name == '' or command_name is None:\n            command_result = ''\n            tool_output_status_code = ToolCallStatusCode.TOOL_CALL_SUCCESS\n        else:\n            command_result, tool_output_status_code, = self.toolserver_interface.execute_command_client(\n                command_name,\n                arguments,\n                # input_hash_id,\n            )\n            # retry to get the result\n            MAX_RETRY = 10\n            retry_time = 0\n            while retry_time < MAX_RETRY and tool_output_status_code == ToolCallStatusCode.TIMEOUT_ERROR and isinstance(command_result['detail'], dict) and 'type' in command_result['detail'] and command_result['detail']['type'] == 'retry':\n                time.sleep(3)\n                retry_time += 1\n                command_result, tool_output_status_code, = self.toolserver_interface.execute_command_client(\n                    command_result['detail']['next_calling'],\n                    command_result['detail']['arguments'],\n                )\n\n            if tool_output_status_code == ToolCallStatusCode.TIMEOUT_ERROR and retry_time == MAX_RETRY:\n                command_result = \"Timeout and no content returned! Please check the content you submit!\"\n\n        if tool_output_status_code == ToolCallStatusCode.TOOL_CALL_SUCCESS:\n            command_result = self.long_result_summary(\n                {'name': command_name, 'arguments': arguments}, command_result)\n\n        result = f\"Command {command_name} returned: \" + f\"{command_result}\"\n\n        node.data[\"tool_output\"] = command_result\n        node.data[\"tool_status_code\"] = tool_output_status_code\n\n        # node.workspace_hash_id = output_hash_id\n        if result is not None:\n            node.history.add(\"system\", result, \"action_result\")\n            self.logger.typewriter_log(\"SYSTEM: \", Fore.YELLOW, result)\n        else:\n            node.history.add(\n                \"system\", \"Unable to execute command\", \"action_result\")\n            self.logger.typewriter_log(\n                \"SYSTEM: \", Fore.YELLOW, \"Unable to execute command\"\n            )\n\n        if tool_output_status_code == ToolCallStatusCode.TOOL_CALL_SUCCESS:\n            color = Fore.GREEN\n        elif tool_output_status_code == ToolCallStatusCode.SUBMIT_AS_SUCCESS:\n            color = Fore.YELLOW\n        elif tool_output_status_code == ToolCallStatusCode.SUBMIT_AS_FAILED:\n            color = Fore.BLUE\n        else:\n            color = Fore.RED\n\n        self.logger.typewriter_log(\n            \"TOOL STATUS CODE: \", Fore.YELLOW, f\"{color}{tool_output_status_code.name}{Style.RESET_ALL}\"\n        )\n\n        self.recorder.regist_tool_call(\n            tool_name=command_name,\n            tool_input=arguments,\n            tool_output=command_result,\n            tool_status_code=tool_output_status_code.name,\n            thought_data={\n                \"thought\": node.data[\"thoughts\"], \"content\": node.data[\"content\"]},\n        )\n\n        using_tools = {\n            \"tool_name\": command_name,\n            \"tool_input\": arguments,\n            \"tool_output\": command_result,\n            \"tool_status_code\": tool_output_status_code.name,\n            \"thought_data\": {\"thought\": node.data[\"thoughts\"], \"content\": node.data[\"content\"]}\n        }\n\n        if tool_output_status_code in [ToolCallStatusCode.SUBMIT_AS_SUCCESS, ToolCallStatusCode.SUBMIT_AS_FAILED]:\n            self.log_task_submit(arguments)\n\n        return result, tool_output_status_code, plan_refine, using_tools\n\n    def handle_subtask_submit(self, arguments):\n        \"\"\"\n        Handle the subtask submission.\n\n        Args:\n            arguments: The arguments of the subtask submission.\n\n        Returns:\n            bool: Whether to refine the plan.\n            The tool output status code.\n            The result.\n        \"\"\"\n        plan_refine = False\n        if arguments[\"result\"][\"success\"]:\n            tool_output_status_code = ToolCallStatusCode.SUBMIT_AS_SUCCESS\n        else:\n            tool_output_status_code = ToolCallStatusCode.SUBMIT_AS_FAILED\n        if arguments[\"suggestions_for_latter_subtasks_plan\"][\"need_for_plan_refine\"]:\n            plan_refine = True\n        answer = {\n            \"content\": f\"you have successfully submit the subtask as {arguments['submit_type']}\"\n        }\n        command_result = json.dumps(answer, ensure_ascii=False)\n\n        return plan_refine, tool_output_status_code, command_result\n\n    def handle_human_help(self, arguments):\n        \"\"\"\n        Handle the ask for human help.\n\n        Args:\n            arguments: The arguments for asking human help.\n\n        Returns:\n            bool: Whether to refine the plan.\n            The tool output status code.\n            The result.\n        \"\"\"\n        self.logger.typewriter_log(\n            \"ASK For Human Help\",\n            Fore.RED,\n            \"You must give some suggestions, please type in your feedback and then press 'Enter' to send and continue the loop\"\n        )\n        url = \"ask_human\"\n        payload = arguments\n        tool_cache = self.recorder.query_tool_server_cache(\n            url=url, payload=payload)\n        if tool_cache != None:\n            command_result = tool_cache[\"tool_output\"]\n            status_code = tool_cache[\"response_status_code\"]\n        else:\n            prompt = \"ASK For Human Help: \\n You must give some suggestions, \\\n                  please type in your feedback and then press 'Enter' \\\n                  to send and continue the loop.\"\n            human_suggestion = self.interaction.ask_for_human_help(\n                prompt)\n            command_result = json.dumps(\n                {\"output\": f\"{human_suggestion}\"}, ensure_ascii=False)\n            status_code = \"human has no status :)\"\n        self.recorder.regist_tool_server(\n            url=url,\n            payload=payload,\n            tool_output=command_result,\n            response_status_code=status_code,\n        )\n\n        plan_refine = False\n        return plan_refine, ToolCallStatusCode.TOOL_CALL_SUCCESS, command_result\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__函数**：这个函数的作用是初始化FunctionHandler对象。\n\n在这个函数中，有以下几个参数：\n- toolserver_interface: ToolServerInterface对象，用于与ToolServer进行交互。\n- config: 配置信息。\n- interaction: XAgentInteraction对象，用于与用户进行交互。\n- recorder: RunningRecoder对象，用于记录运行过程。\n- logger: 日志记录器。\n\n在函数体内，将传入的参数赋值给对应的成员变量。具体来说，将toolserver_interface赋值给self.toolserver_interface，将config赋值给self.config，将interaction赋值给self.interaction，将recorder赋值给self.recorder，将logger赋值给self.logger。\n\n接下来，通过function_manager.get_function_schema函数获取subtask_submit、ask_human_for_help和human_interruption三个函数的函数模式，并将其赋值给对应的成员变量。具体来说，将subtask_submit的函数模式赋值给self.subtask_submit_function，将ask_human_for_help的函数模式赋值给self.ask_human_for_help_function，将human_interruption的函数模式赋值给self.human_interruption_function。\n\n最后，初始化一个空的avaliable_tools_description_list列表，并将其赋值给self.avaliable_tools_description_list。\n\n**注意**：在使用这段代码时需要注意以下几点：\n- 需要传入正确的参数，包括toolserver_interface、config、interaction、recorder和logger。\n- 需要确保function_manager中存在subtask_submit、ask_human_for_help和human_interruption这三个函数的函数模式。",
            "code_start_line": 26,
            "code_end_line": 46,
            "parent": "FunctionHandler",
            "have_return": false,
            "code_content": "    def __init__(self,\n                 toolserver_interface: ToolServerInterface,\n                 config,\n                 interaction: XAgentInteraction,\n                 recorder: RunningRecoder,\n                 logger=None):\n        self.logger = logger\n        self.toolserver_interface = toolserver_interface\n        self.config = config\n        self.interaction = interaction\n        self.recorder = recorder\n        self.subtask_submit_function = function_manager.get_function_schema(\n            'subtask_submit')\n\n        # TODO: support more complex versions of human help, like collaborative debugging.\n        self.ask_human_for_help_function = function_manager.get_function_schema(\n            'ask_human_for_help')\n        self.human_interruption_function = function_manager.get_function_schema(\n            'human_interruption')\n\n        self.avaliable_tools_description_list = []\n",
            "name_column": 8
        },
        "log_task_submit": {
            "type": "FunctionDef",
            "name": "log_task_submit",
            "md_content": "**log_task_submit函数**: 这个函数的功能是记录任务提交。\n\n该函数用于记录任务的提交信息，包括提交类型、成功与否、结论、里程碑等信息。它接受一个参数arguments，该参数是任务提交的参数。\n\n在函数内部，首先使用logger.typewriter_log方法打印出\"-=-=-=-=-=-=-= SUBTASK SUBMITTED -=-=-=-=-=-=-=\"，并设置打印颜色为黄色。然后打印出\"submit_type:\"、\"success:\"、\"conclusion:\"等信息，并将对应的值打印出来。如果arguments[\"result\"]中存在\"milestones\"键，则打印出\"milestones:\"，并遍历arguments[\"result\"][\"milestones\"]中的每个里程碑，将其打印出来。最后打印出\"need_for_plan_refine:\"和\"plan_suggestions:\"的值。\n\n该函数在以下文件中被调用：\n- XAgent/function_handler.py\n\n在handle_tool_call函数中，根据command_name的不同，调用不同的处理函数。当command_name为\"subtask_submit\"时，调用handle_subtask_submit函数；当command_name为\"ask_human_for_help\"时，调用handle_human_help函数；当command_name为\"human_interruption\"时，抛出异常；当command_name为空或为None时，设置command_result为空字符串，tool_output_status_code为ToolCallStatusCode.TOOL_CALL_SUCCESS。对于其他情况，调用toolserver_interface.execute_command_client方法执行命令，并获取命令的结果和状态码。如果状态码为ToolCallStatusCode.TIMEOUT_ERROR且命令结果中包含\"type\"为\"retry\"的键值对，则进行重试，最多重试10次。如果重试次数达到最大值仍然超时，则将command_result设置为\"Timeout and no content returned! Please check the content you submit!\"。如果状态码为ToolCallStatusCode.TOOL_CALL_SUCCESS，则调用long_result_summary方法对结果进行摘要。最后，将结果打印出来，并将结果和状态码保存到node的data中。\n\n如果tool_output_status_code为ToolCallStatusCode.TOOL_CALL_SUCCESS，则将结果设置为绿色；如果tool_output_status_code为ToolCallStatusCode.SUBMIT_AS_SUCCESS，则将结果设置为黄色；如果tool_output_status_code为ToolCallStatusCode.SUBMIT_AS_FAILED，则将结果设置为蓝色；否则将结果设置为红色。将工具调用的相关信息注册到recorder中，并返回结果、状态码、是否需要优化计划和使用的工具。\n\n**注意**: 在调用该函数之前，需要确保参数arguments中包含必要的信息，并且已经初始化了logger和recorder对象。",
            "code_start_line": 48,
            "code_end_line": 81,
            "parent": "FunctionHandler",
            "have_return": false,
            "code_content": "    def log_task_submit(self, arguments):\n        \"\"\"\n        Log the task submission.\n\n        Args:\n            arguments: The arguments of the task submission.\n        \"\"\"\n        self.logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= SUBTASK SUBMITTED -=-=-=-=-=-=-=\",\n            Fore.YELLOW,\n            \"\",\n        )\n        self.logger.typewriter_log(\n            f\"submit_type:\", Fore.YELLOW, f\"{arguments['submit_type']}\"\n        )\n        self.logger.typewriter_log(\n            f\"success:\", Fore.YELLOW, f\"{arguments['result']['success']}\"\n        )\n        self.logger.typewriter_log(\n            f\"conclusion:\", Fore.YELLOW, f\"{arguments['result']['conclusion']}\"\n        )\n        if \"milestones\" in arguments[\"result\"].keys():\n            self.logger.typewriter_log(\n                f\"milestones:\", Fore.YELLOW\n            )\n            for milestone in arguments[\"result\"][\"milestones\"]:\n                line = milestone.lstrip(\"- \")\n                self.logger.typewriter_log(\"- \", Fore.GREEN, line.strip())\n        self.logger.typewriter_log(\n            f\"need_for_plan_refine:\", Fore.YELLOW, f\"{arguments['suggestions_for_latter_subtasks_plan']['need_for_plan_refine']}\"\n        )\n        self.logger.typewriter_log(\n            f\"plan_suggestions:\", Fore.YELLOW, f\"{arguments['suggestions_for_latter_subtasks_plan']['reason']}\"\n        )\n",
            "name_column": 8
        },
        "change_subtask_handle_function_enum": {
            "type": "FunctionDef",
            "name": "change_subtask_handle_function_enum",
            "md_content": "**change_subtask_handle_function_enum函数**：该函数用于更改子任务处理函数的枚举。\n\n该函数接受一个参数function_name_list，该参数是一个字符串列表，包含了要更改的函数名称。\n\n函数内部根据self.config.default_request_type的值进行不同的处理：\n- 当self.config.default_request_type为'openai'时，通过调用function_manager.get_function_schema('subtask_handle')获取子任务处理函数的架构，并将其中的\"tool_call\"字段中的\"tool_name\"字段的枚举值更改为function_name_list。\n- 当self.config.default_request_type为'xagent'时，不进行任何操作。\n- 当self.config.default_request_type为其他值时，抛出NotImplementedError异常，提示该请求类型尚未实现。\n\n**注意**：在使用该函数时需要注意以下几点：\n- function_name_list参数必须是一个字符串列表。\n- 调用该函数前需要确保self.config.default_request_type的值已经正确设置。\n\n该函数在以下文件中被调用：\n- 文件路径：XAgent/function_handler.py\n- 调用代码：\n```python\ndef get_functions(self, config):\n    \"\"\"\n    Get the functions.\n\n    Args:\n        config: The configuration for the functions.\n\n    Returns:\n        The intrinsic tools and the description of the tools.\n    \"\"\"\n    output = self.toolserver_interface.get_available_tools()\n\n    available_tools: list = output['available_tools']\n    openai_function_jsons: dict = output['tools_json']\n\n    black_list = set(config.tool_blacklist)\n    for item in black_list:\n        try:\n            available_tools.remove(item)\n        except ValueError:\n            pass\n    openai_function_jsons = [\n        openai_function_json for openai_function_json in openai_function_jsons if openai_function_json['name'] not in black_list]\n\n    self.tool_names = available_tools\n    self.change_subtask_handle_function_enum(available_tools)\n    self.avaliable_tools_description_list = openai_function_jsons\n    for tool_json in openai_function_jsons:\n        function_manager.register_function(tool_json)\n    return self.intrinsic_tools(config.enable_ask_human_for_help), self.avaliable_tools_description_list\n```\n- 代码分析：该函数在get_functions函数中被调用，用于根据获取到的可用工具列表来更改子任务处理函数的枚举值，以及注册工具函数。\n\n- 文件路径：XAgent/workflow/task_handler.py\n- 调用代码：\n```python\ndef inner_loop(self, plan: Plan, ):\n    \"\"\"\n    Generates search plan and process it for the current task.\n\n    Args:\n        plan (Plan): The plan to be processed.\n\n    Raises:\n        AssertionError: Raised if a not expected status is encountered while handling the plan.\n\n    Returns:\n        ReACTChainSearch: Instance of the search plan.\n    \"\"\"\n    task_ids_str = plan.get_subtask_id(to_str=True)\n    self.logger.typewriter_log(\n        f\"-=-=-=-=-=-=-= Performing Task {task_ids_str} ({plan.data.name}): Begin -=-=-=-=-=-=-=\",\n        Fore.GREEN,\n        \"\",\n    )\n    self.xagent_core.print_task_save_items(plan.data)\n\n    agent = self.agent_dispatcher.dispatch(\n        RequiredAbilities.tool_tree_search,\n        json.dumps(plan.data.to_json(), indent=2, ensure_ascii=False),\n        # avaliable_tools_description_list=self.avaliable_tools_description_list\n    )\n\n    plan.data.status = TaskStatusCode.DOING\n\n    if self.config.rapidapi_retrieve_tool_count > 0:\n        retrieve_string = summarize_plan(plan.to_json())\n        rapidapi_tool_names, rapidapi_tool_jsons = self.toolserver_interface.retrieve_rapidapi_tools(\n            retrieve_string, top_k=self.config.rapidapi_retrieve_tool_count)\n        if rapidapi_tool_names is not None:\n            self.function_handler.change_subtask_handle_function_enum(\n                self.function_handler.tool_names + rapidapi_tool_names)\n            self.function_handler.avaliable_tools_description_list += rapidapi_tool_jsons\n        else:\n            print(\"bug: no rapidapi tool retrieved, need to fix here\")\n\n    search_method = ReACTChainSearch(\n        xagent_core_components=self.xagent_core,)\n\n    arguments = function_manager.get_function_schema('action_reasoning')[\n        'parameters']\n    search_method.run(config=self.config,\n                      agent=agent,\n                      arguments=arguments,\n                      functions=self.function_handler.intrinsic_tools(\n                          self.config.enable_ask_human_for_help),\n                      task_id=task_ids_str,\n                      now_dealing_task=self.now_dealing_task,\n                      plan_agent=self.plan_agent)\n\n    if search_method.status == SearchMethodStatusCode.SUCCESS:\n        plan.data.status = TaskStatusCode.SUCCESS\n        self.logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= Task {task_ids_str} ({plan.data.name}): Solved -=-=-=-=-=-=-=\",\n            Fore.GREEN,\n            \"\",\n        )\n    elif search_method.status == SearchMethodStatusCode.FAIL:\n        plan.data.status = TaskStatusCode.FAIL\n        self.logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= Task {task_ids_str} ({plan.data.name}): Failed -=-=-=-=-=-=-=\",\n            Fore.RED,\n            \"\",\n        )\n    else:\n        assert False, f\"{plan.data.name}\"\n    return search_method\n```\n- 代码分析：该函数在inner_loop函数中被调用，用于在处理当前任务之前，根据配置中的rapidapi_retrieve_tool_count的值来获取RapidAPI工具，并将获取到的工具名称添加到子任务处理函数的枚举值中。\n\n[End of XAgent/function_handler.py]\n[End of XAgent/workflow/task_handler.py]",
            "code_start_line": 83,
            "code_end_line": 100,
            "parent": "FunctionHandler",
            "have_return": false,
            "code_content": "    def change_subtask_handle_function_enum(self, function_name_list: List[str]):\n        \"\"\"\n        Change the subtask handling function enumeration.\n\n        Args:\n            function_name_list: The list of function names.\n        \"\"\"\n        match self.config.default_request_type:\n            case 'openai':\n                self.subtask_handle_function = function_manager.get_function_schema(\n                    'subtask_handle')\n                self.subtask_handle_function[\"parameters\"][\"properties\"][\"tool_call\"][\n                    \"properties\"][\"tool_name\"][\"enum\"] = function_name_list\n            case 'xagent':\n                pass\n            case _:\n                raise NotImplementedError(\n                    f\"Request type {self.config.default_request_type} not implemented\")\n",
            "name_column": 8
        },
        "intrinsic_tools": {
            "type": "FunctionDef",
            "name": "intrinsic_tools",
            "md_content": "**intrinsic_tools函数**：该函数的作用是获取内置工具。\n\n该函数接受一个参数enable_ask_human_for_help，用于确定是否启用ask_human_for_help函数。\n\n函数返回一个包含内置工具的列表。\n\n该函数首先创建一个名为tools的列表，初始值为[self.subtask_submit_function]。\n\n如果enable_ask_human_for_help为True，则将self.ask_human_for_help_function添加到tools列表中。\n\n然后将self.avaliable_tools_description_list中的元素添加到tools列表中。\n\n最后返回tools列表作为函数的输出。\n\n**注意**：在使用该函数时需要注意以下几点：\n- enable_ask_human_for_help参数决定是否启用ask_human_for_help函数。\n- 函数的返回值是一个包含内置工具的列表。\n\n**输出示例**：假设enable_ask_human_for_help为True，self.avaliable_tools_description_list为['tool1', 'tool2']，则函数的返回值为[self.subtask_submit_function, self.ask_human_for_help_function, 'tool1', 'tool2']。",
            "code_start_line": 102,
            "code_end_line": 116,
            "parent": "FunctionHandler",
            "have_return": true,
            "code_content": "    def intrinsic_tools(self, enable_ask_human_for_help):\n        \"\"\"\n        Get the intrinsic tools.\n\n        Args:\n            enable_ask_human_for_help: Whether to enable the ask_human_for_help function.\n\n        Returns:\n            The intrinsic tools.\n        \"\"\"\n        tools = [self.subtask_submit_function,]\n        if enable_ask_human_for_help:\n            tools.append(self.ask_human_for_help_function)\n        tools.extend(self.avaliable_tools_description_list)\n        return tools\n",
            "name_column": 8
        },
        "get_functions": {
            "type": "FunctionDef",
            "name": "get_functions",
            "md_content": "**get_functions函数**：该函数的作用是获取可用的函数。\n\n该函数接受一个配置参数config作为输入，返回内置工具和工具描述的列表。\n\n具体代码分析和描述如下：\n- 首先，通过调用toolserver_interface的get_available_tools方法获取可用的工具和工具的描述信息。\n- 然后，根据配置参数中的tool_blacklist，将黑名单中的工具从可用工具列表中移除，并将不在黑名单中的工具描述信息保存在openai_function_jsons列表中。\n- 接下来，将可用工具列表保存在self.tool_names中，并根据可用工具列表更新子任务处理函数的枚举类型。\n- 将可用工具的描述信息保存在self.avaliable_tools_description_list中。\n- 遍历openai_function_jsons列表中的每个工具描述信息，通过调用function_manager的register_function方法注册工具。\n- 最后，返回内置工具和工具描述的列表。\n\n**注意**：使用该代码时需要注意以下几点：\n- 需要提供一个有效的配置参数config。\n- 需要确保toolserver_interface的get_available_tools方法能够正常返回可用的工具和工具描述信息。\n\n**输出示例**：模拟代码返回值的可能外观。\n```\n([\n    'subtask_function_1',\n    'subtask_function_2',\n    ...\n], [\n    {\n        'name': 'tool_1',\n        'description': '工具1的描述信息'\n    },\n    {\n        'name': 'tool_2',\n        'description': '工具2的描述信息'\n    },\n    ...\n])\n```",
            "code_start_line": 118,
            "code_end_line": 147,
            "parent": "FunctionHandler",
            "have_return": true,
            "code_content": "    def get_functions(self, config):\n        \"\"\"\n        Get the functions.\n\n        Args:\n            config: The configuration for the functions.\n\n        Returns:\n            The intrinsic tools and the description of the tools.\n        \"\"\"\n        output = self.toolserver_interface.get_available_tools()\n\n        available_tools: list = output['available_tools']\n        openai_function_jsons: dict = output['tools_json']\n\n        black_list = set(config.tool_blacklist)\n        for item in black_list:\n            try:\n                available_tools.remove(item)\n            except ValueError:\n                pass\n        openai_function_jsons = [\n            openai_function_json for openai_function_json in openai_function_jsons if openai_function_json['name'] not in black_list]\n\n        self.tool_names = available_tools\n        self.change_subtask_handle_function_enum(available_tools)\n        self.avaliable_tools_description_list = openai_function_jsons\n        for tool_json in openai_function_jsons:\n            function_manager.register_function(tool_json)\n        return self.intrinsic_tools(config.enable_ask_human_for_help), self.avaliable_tools_description_list\n",
            "name_column": 8
        },
        "long_result_summary": {
            "type": "FunctionDef",
            "name": "long_result_summary",
            "md_content": "**long_result_summary函数**：该函数用于对长结果进行摘要。\n\n该函数接受两个参数：command和result。其中，command是一个字典，表示命令；result是命令的执行结果。\n\n函数内部根据不同的命令类型进行不同的处理。如果命令的名称是'WebEnv_browse_website'，则将结果进行解析，并截取网页内容的前8096个字符，然后调用function_manager函数进行处理。如果命令的名称是'WebEnv_search_and_browse'，则使用线程池并发处理多个结果，同样截取网页内容的前8096个字符，并调用function_manager函数进行处理。\n\n如果结果是字符串且长度超过2000个字符，则需要进行摘要处理。\n\n最后，函数返回处理后的结果。\n\n**注意**：在使用该函数时，需要注意命令的格式和结果的类型。\n\n**输出示例**：假设命令名称为'WebEnv_browse_website'，结果为解析后的网页内容和有用的超链接。\n\n```python\n{\n    'text': '摘要后的结果',\n    'useful_hyperlinks': ['超链接1', '超链接2', '超链接3']\n}\n```",
            "code_start_line": 149,
            "code_end_line": 179,
            "parent": "FunctionHandler",
            "have_return": true,
            "code_content": "    def long_result_summary(self, command: dict, result):\n        \"\"\"\n        Summarize the long result.\n\n        Args:\n            command (dict): The command.\n            result: The result.\n\n        Returns:\n            The summarized result.\n        \"\"\"\n        if command['name'] == 'WebEnv_browse_website':\n            if not isinstance(result, str):\n                result = str(result)\n            result = function_manager(\n                'parse_web_text', webpage=result[:8096], prompt=command['arguments']['goals_to_browse'])\n            result['useful_hyperlinks'] = result['useful_hyperlinks'][:3]\n        if command['name'] == 'WebEnv_search_and_browse':\n            with ThreadPoolExecutor(max_workers=len(result)) as pool:\n                f = []\n                for ret in result:\n                    f.append(pool.submit(function_manager, 'parse_web_text',\n                             webpage=ret['page'][:8096], prompt=command['arguments']['goals_to_browse']))\n                for ret, thd in zip(result, f):\n                    ret['page'] = thd.result()\n                    ret['page']['useful_hyperlinks'] = ret['page']['useful_hyperlinks'][:3]\n\n        if isinstance(result, str) and len(result) > 2000:\n            # need to summarize\n            pass\n        return result\n",
            "name_column": 8
        },
        "handle_tool_call": {
            "type": "FunctionDef",
            "name": "handle_tool_call",
            "md_content": "**handle_tool_call函数**：此函数的功能是处理工具调用。\n\n该函数接受一个ToolNode对象作为参数，用于处理工具调用。根据传入的工具节点，函数会根据节点中的命令名称和参数执行相应的操作，并返回结果、工具输出状态码、是否需要优化计划以及使用的工具。\n\n函数首先获取工具节点中的命令名称和参数，然后根据命令名称执行相应的操作。如果命令名称为\"subtask_submit\"，则调用handle_subtask_submit函数处理子任务提交；如果命令名称为\"ask_human_for_help\"，则调用handle_human_help函数处理向人类寻求帮助；如果命令名称为\"human_interruption\"，则抛出异常，因为不应该调用该函数；如果命令名称为空或为None，则将命令结果和工具输出状态码设置为空字符串和工具调用成功状态码。\n\n如果命令名称不属于上述情况，则调用toolserver_interface的execute_command_client方法执行命令，并根据返回的结果和状态码进行处理。如果状态码为超时错误且命令结果中包含重试信息，则进行最多10次的重试，直到获取到结果或达到最大重试次数。如果状态码为超时错误且达到最大重试次数，则将命令结果设置为超时错误提示信息。\n\n如果工具调用成功，则调用long_result_summary方法对命令结果进行摘要处理。最后，将结果存储到工具节点的data属性中，并根据工具输出状态码的不同，将相应的信息记录到日志中。\n\n函数返回结果、工具输出状态码、是否需要优化计划以及使用的工具。\n\n**注意**：在使用该函数时，需要注意以下几点：\n- 函数的参数node必须是ToolNode类型的对象。\n- 函数会根据命令名称执行相应的操作，因此需要确保命令名称的准确性。\n- 函数会根据工具输出状态码的不同，记录相应的信息到日志中。\n\n**输出示例**：假设命令名称为\"subtask_submit\"，参数为{\"task_id\": 123}，工具输出状态码为TOOL_CALL_SUCCESS，结果为\"任务提交成功\"，是否需要优化计划为False，使用的工具为{\"tool_name\": \"subtask_submit\", \"tool_input\": {\"task_id\": 123}, \"tool_output\": \"任务提交成功\", \"tool_status_code\": \"TOOL_CALL_SUCCESS\", \"thought_data\": {\"thought\": \"思考内容\", \"content\": \"",
            "code_start_line": 181,
            "code_end_line": 286,
            "parent": "FunctionHandler",
            "have_return": true,
            "code_content": "    def handle_tool_call(self, node: ToolNode):\n        \"\"\"\n        Handle the tool call.\n\n        Args:\n            node (ToolNode): The tool node.\n\n        Returns:\n            The result, tool output status code, whether to refine the plan, and the tools used.\n        \"\"\"\n        plan_refine = False\n        command_name = node.data[\"command\"][\"properties\"][\"name\"]\n        arguments = node.data[\"command\"][\"properties\"][\"args\"]\n\n        self.logger.typewriter_log(\n            \"NEXT ACTION: \",\n            Fore.CYAN,\n            f\"COMMAND: {Fore.CYAN}{command_name}{Style.RESET_ALL}  \\n\"\n            f\"ARGUMENTS: \\n{Fore.CYAN}{arguments}{Style.RESET_ALL}\",\n        )\n\n        if command_name == \"subtask_submit\":\n            plan_refine, tool_output_status_code, command_result, = self.handle_subtask_submit(\n                arguments)\n        elif command_name == \"ask_human_for_help\":\n            plan_refine, tool_output_status_code, command_result, = self.handle_human_help(\n                arguments)\n        elif command_name == \"human_interruption\":\n            assert False, \"Never call this function\"\n        elif command_name == '' or command_name is None:\n            command_result = ''\n            tool_output_status_code = ToolCallStatusCode.TOOL_CALL_SUCCESS\n        else:\n            command_result, tool_output_status_code, = self.toolserver_interface.execute_command_client(\n                command_name,\n                arguments,\n                # input_hash_id,\n            )\n            # retry to get the result\n            MAX_RETRY = 10\n            retry_time = 0\n            while retry_time < MAX_RETRY and tool_output_status_code == ToolCallStatusCode.TIMEOUT_ERROR and isinstance(command_result['detail'], dict) and 'type' in command_result['detail'] and command_result['detail']['type'] == 'retry':\n                time.sleep(3)\n                retry_time += 1\n                command_result, tool_output_status_code, = self.toolserver_interface.execute_command_client(\n                    command_result['detail']['next_calling'],\n                    command_result['detail']['arguments'],\n                )\n\n            if tool_output_status_code == ToolCallStatusCode.TIMEOUT_ERROR and retry_time == MAX_RETRY:\n                command_result = \"Timeout and no content returned! Please check the content you submit!\"\n\n        if tool_output_status_code == ToolCallStatusCode.TOOL_CALL_SUCCESS:\n            command_result = self.long_result_summary(\n                {'name': command_name, 'arguments': arguments}, command_result)\n\n        result = f\"Command {command_name} returned: \" + f\"{command_result}\"\n\n        node.data[\"tool_output\"] = command_result\n        node.data[\"tool_status_code\"] = tool_output_status_code\n\n        # node.workspace_hash_id = output_hash_id\n        if result is not None:\n            node.history.add(\"system\", result, \"action_result\")\n            self.logger.typewriter_log(\"SYSTEM: \", Fore.YELLOW, result)\n        else:\n            node.history.add(\n                \"system\", \"Unable to execute command\", \"action_result\")\n            self.logger.typewriter_log(\n                \"SYSTEM: \", Fore.YELLOW, \"Unable to execute command\"\n            )\n\n        if tool_output_status_code == ToolCallStatusCode.TOOL_CALL_SUCCESS:\n            color = Fore.GREEN\n        elif tool_output_status_code == ToolCallStatusCode.SUBMIT_AS_SUCCESS:\n            color = Fore.YELLOW\n        elif tool_output_status_code == ToolCallStatusCode.SUBMIT_AS_FAILED:\n            color = Fore.BLUE\n        else:\n            color = Fore.RED\n\n        self.logger.typewriter_log(\n            \"TOOL STATUS CODE: \", Fore.YELLOW, f\"{color}{tool_output_status_code.name}{Style.RESET_ALL}\"\n        )\n\n        self.recorder.regist_tool_call(\n            tool_name=command_name,\n            tool_input=arguments,\n            tool_output=command_result,\n            tool_status_code=tool_output_status_code.name,\n            thought_data={\n                \"thought\": node.data[\"thoughts\"], \"content\": node.data[\"content\"]},\n        )\n\n        using_tools = {\n            \"tool_name\": command_name,\n            \"tool_input\": arguments,\n            \"tool_output\": command_result,\n            \"tool_status_code\": tool_output_status_code.name,\n            \"thought_data\": {\"thought\": node.data[\"thoughts\"], \"content\": node.data[\"content\"]}\n        }\n\n        if tool_output_status_code in [ToolCallStatusCode.SUBMIT_AS_SUCCESS, ToolCallStatusCode.SUBMIT_AS_FAILED]:\n            self.log_task_submit(arguments)\n\n        return result, tool_output_status_code, plan_refine, using_tools\n",
            "name_column": 8
        },
        "handle_subtask_submit": {
            "type": "FunctionDef",
            "name": "handle_subtask_submit",
            "md_content": "**handle_subtask_submit函数**：此函数的功能是处理子任务的提交。\n\n该函数接受一个参数arguments，表示子任务的提交参数。\n\n函数返回三个值：是否需要优化计划、工具输出状态码、结果。\n\n在函数内部，首先初始化plan_refine为False。然后根据arguments中的\"result\"字段判断子任务是否成功，如果成功，则将tool_output_status_code设置为ToolCallStatusCode.SUBMIT_AS_SUCCESS；否则，将tool_output_status_code设置为ToolCallStatusCode.SUBMIT_AS_FAILED。接下来，根据arguments中的\"suggestions_for_latter_subtasks_plan\"字段判断是否需要优化计划，如果需要，则将plan_refine设置为True。然后，构造一个包含成功提交信息的answer字典，并将其转换为JSON格式的字符串赋值给command_result。最后，返回plan_refine、tool_output_status_code和command_result。\n\n**注意**：在调用该函数之前，需要确保arguments参数的正确性。\n\n**输出示例**：假设arguments为{\"result\": {\"success\": True}, \"submit_type\": \"type1\"}，则函数的返回值为(False, ToolCallStatusCode.SUBMIT_AS_SUCCESS, '{\"content\": \"you have successfully submit the subtask as type1\"}')。",
            "code_start_line": 288,
            "code_end_line": 312,
            "parent": "FunctionHandler",
            "have_return": true,
            "code_content": "    def handle_subtask_submit(self, arguments):\n        \"\"\"\n        Handle the subtask submission.\n\n        Args:\n            arguments: The arguments of the subtask submission.\n\n        Returns:\n            bool: Whether to refine the plan.\n            The tool output status code.\n            The result.\n        \"\"\"\n        plan_refine = False\n        if arguments[\"result\"][\"success\"]:\n            tool_output_status_code = ToolCallStatusCode.SUBMIT_AS_SUCCESS\n        else:\n            tool_output_status_code = ToolCallStatusCode.SUBMIT_AS_FAILED\n        if arguments[\"suggestions_for_latter_subtasks_plan\"][\"need_for_plan_refine\"]:\n            plan_refine = True\n        answer = {\n            \"content\": f\"you have successfully submit the subtask as {arguments['submit_type']}\"\n        }\n        command_result = json.dumps(answer, ensure_ascii=False)\n\n        return plan_refine, tool_output_status_code, command_result\n",
            "name_column": 8
        },
        "handle_human_help": {
            "type": "FunctionDef",
            "name": "handle_human_help",
            "md_content": "**handle_human_help函数**：这个函数的功能是处理请求人工帮助。\n\n该函数接受一个参数arguments，用于请求人工帮助。\n\n函数首先通过logger.typewriter_log方法打印一条日志，提示用户输入反馈意见并按下Enter键以发送并继续循环。\n\n接下来，函数构造了一个url和payload，并通过recorder.query_tool_server_cache方法查询工具服务器缓存。如果缓存中存在对应的工具输出和响应状态码，则将其赋值给command_result和status_code变量。\n\n如果缓存中不存在对应的工具输出和响应状态码，则通过interaction.ask_for_human_help方法向用户询问反馈意见，并将用户的回答作为工具输出赋值给command_result变量。同时，将status_code赋值为\"human has no status :)\"。\n\n最后，函数通过recorder.regist_tool_server方法将url、payload、command_result和status_code注册到工具服务器。\n\n函数返回三个值：plan_refine（布尔值，表示是否需要优化计划）、ToolCallStatusCode.TOOL_CALL_SUCCESS（工具调用状态码）和command_result（工具输出结果）。\n\n**注意**：在使用该函数时需要注意以下几点：\n- 需要提供arguments参数来请求人工帮助。\n- 函数会通过logger.typewriter_log方法打印提示信息，用户需要按照提示输入反馈意见。\n\n**输出示例**：假设用户输入了反馈意见\"请提供更多示例代码\"，则函数的返回值可能如下所示：\n```\n(\n    False,\n    ToolCallStatusCode.TOOL_CALL_SUCCESS,\n    '{\"output\": \"请提供更多示例代码\"}'\n)\n```",
            "code_start_line": 314,
            "code_end_line": 355,
            "parent": "FunctionHandler",
            "have_return": true,
            "code_content": "    def handle_human_help(self, arguments):\n        \"\"\"\n        Handle the ask for human help.\n\n        Args:\n            arguments: The arguments for asking human help.\n\n        Returns:\n            bool: Whether to refine the plan.\n            The tool output status code.\n            The result.\n        \"\"\"\n        self.logger.typewriter_log(\n            \"ASK For Human Help\",\n            Fore.RED,\n            \"You must give some suggestions, please type in your feedback and then press 'Enter' to send and continue the loop\"\n        )\n        url = \"ask_human\"\n        payload = arguments\n        tool_cache = self.recorder.query_tool_server_cache(\n            url=url, payload=payload)\n        if tool_cache != None:\n            command_result = tool_cache[\"tool_output\"]\n            status_code = tool_cache[\"response_status_code\"]\n        else:\n            prompt = \"ASK For Human Help: \\n You must give some suggestions, \\\n                  please type in your feedback and then press 'Enter' \\\n                  to send and continue the loop.\"\n            human_suggestion = self.interaction.ask_for_human_help(\n                prompt)\n            command_result = json.dumps(\n                {\"output\": f\"{human_suggestion}\"}, ensure_ascii=False)\n            status_code = \"human has no status :)\"\n        self.recorder.regist_tool_server(\n            url=url,\n            payload=payload,\n            tool_output=command_result,\n            response_status_code=status_code,\n        )\n\n        plan_refine = False\n        return plan_refine, ToolCallStatusCode.TOOL_CALL_SUCCESS, command_result\n",
            "name_column": 8
        }
    },
    "XAgent/message_history.py": {
        "MessageDict": {
            "type": "ClassDef",
            "name": "MessageDict",
            "md_content": "**MessageDict类的功能**: 该类是一个TypedDict类型的字典，用于跟踪消息的属性。\n\n**属性**:\n- role (MessageRole): 消息的来源，可以是'system'、'user'、'assistant'或'function'之一。\n- content (str): 消息的内容。\n- function_call (dict): 可调用的方法。\n\n**MessageDict.raw()函数**: 该函数用于提取消息的原始内容，去除其他元数据。\n\n**返回值**:\n- MessageDict: 包含'role'和'content'的字典。\n\n**代码分析和描述**:\n该函数首先创建一个名为data的字典，其中包含了self.role和self.content的值。如果self.function_call不为None，则将其添加到data字典中。最后，将data字典作为函数的返回值。\n\n**注意**: 在使用该代码时需要注意以下几点:\n- MessageDict类用于跟踪消息的属性，可以通过role属性获取消息的来源，通过content属性获取消息的内容。\n- function_call属性是一个可调用的方法，可以通过调用该方法来执行相应的操作。\n- 在调用raw函数时，将返回一个字典，其中包含了消息的角色和内容。如果消息还包含了可调用的方法，则字典中还会包含function_call属性。\n\n以上是对MessageDict类及其相关函数的详细解释和分析。\n\n**注意**: 生成的文档中不包含Markdown的标题和分割线语法。",
            "code_start_line": 16,
            "code_end_line": 28,
            "parent": null,
            "have_return": false,
            "code_content": "class MessageDict(TypedDict):\n    \"\"\"\n    Typed dictionary to keep track of message attributes.\n\n    Attributes:\n        role (MessageRole): Source of the message. Can be either 'system', 'user', 'assistant', or 'function'.\n        content (str): The message content.\n        function_call (dict): Callable method.\n    \"\"\"\n\n    role: MessageRole\n    content: str\n    function_call: dict\n",
            "name_column": 6
        },
        "Message": {
            "type": "ClassDef",
            "name": "Message",
            "md_content": "**Message Function**: 这个类的功能是表示来自代理、用户或系统函数的消息。\n\n这个类代表了来自代理、用户或系统函数的消息。\n\n**role (MessageRole)**: 消息的来源，可以是 'system'、'user'、'assistant' 或 'function'。\n\n**content (str)**: 消息的实际内容。\n\n**type (MessageType)**: 消息的类型，可以是 'ai_response'（AI对话消息）或 'action_result'（API调用的结果）。\n\n**function_call (dict)**: 表示可编程API调用中的方法调用的字典。\n\n**raw()**: 提取消息的原始内容，去除其他元数据。\n\n**Returns**:\n    MessageDict: 包含 'role' 和 'content' 的字典。\n\n**to_json()**: 将消息转换为JSON格式。\n\n**Returns**:\n    MessageDict: 消息的JSON表示。\n\n**equal(cls, a: Message, b: Message)**: 通过比较所有属性来检查两个消息是否相等。\n\n**Args**:\n    a (Message): 要比较的第一个消息。\n    b (Message): 要比较的第二个消息。\n\n**Returns**:\n    bool: 如果两个消息在所有属性上都相等，则返回True；否则返回False。\n\n**注意**: 在使用该代码时需要注意的事项。\n\n**Output Example**: \n```python\n{\n    \"role\": \"user\",\n    \"content\": \"Hello, how are you?\"\n}\n```",
            "code_start_line": 31,
            "code_end_line": 86,
            "parent": null,
            "have_return": true,
            "code_content": "class Message:\n    \"\"\"OpenAI Message class.\n\n    A class representing a message from an agent, a user, or a system function.\n\n    Attributes:\n        role (MessageRole): Source of the message, can be either 'system', 'user', 'assistant', or 'function'.\n        content (str): The actual content of the message.\n        type (MessageType): The type of message, either 'ai_response' for AI dialogue messages or 'action_result' for results of API calls.\n        function_call (dict): A dictionary representing the method invocation in programmable API calls.\n    \"\"\"\n\n    role: MessageRole\n    content: str\n    type: MessageType | None = None\n    function_call: dict | None = None\n\n    def raw(self) -> MessageDict:\n        \"\"\"Extracts raw content of the message, stripping away other metadata.\n\n        Returns:\n            MessageDict: Dictionary containing 'role' and 'content'.\n        \"\"\"\n        data = {\"role\": self.role, \"content\": self.content}\n        if self.function_call != None:\n            data[\"function_call\"] = self.function_call\n        return data\n        \n    def to_json(self):\n        \"\"\"Convert the message into JSON format.\n\n        Returns:\n            MessageDict: JSON representation of the message.\n        \"\"\"\n        return self.raw()\n\n    @classmethod\n    def equal(cls, a: Message, b: Message):\n        \"\"\"Checks if two messages are equal by comparing all their attributes.\n\n        Args:\n            a (Message): first message to be compared.\n            b (Message): second message to be compared.\n\n        Returns:\n            bool: Returns True if both messages are equal in all their attributes; False otherwise.\n        \"\"\"\n        if a.role != b.role:\n            return False\n        if a.content != b.content:\n            return False\n        if a.type != b.type:\n            return False\n        if a.function_call != b.function_call:\n            return False\n        return True\n",
            "name_column": 6
        },
        "ModelInfo": {
            "type": "ClassDef",
            "name": "ModelInfo",
            "md_content": "**ModelInfo类的功能**: 这个类用于存储模型信息。\n\n这个类有以下属性：\n\n- name (str): 模型名称\n- prompt_token_cost (float): 每个提示的token成本\n- completion_token_cost (float): 每个生成结果的token成本\n- max_tokens (int): 可以生成的最大token数量\n\n这个类被以下文件调用：\n\n文件路径：XAgent/message_history.py\n调用部分代码如下：\nclass ChatModelInfo(ModelInfo):\n    \"\"\"用于存储聊天模型信息的数据类。\"\"\"\n\n[这部分代码的结束]\n调用部分代码如下：\nclass TextModelInfo(ModelInfo):\n    \"\"\"用于存储文本生成模型信息的数据类。\"\"\"\n\n[这部分代码的结束]\n调用部分代码如下：\nclass EmbeddingModelInfo(ModelInfo):\n    \"\"\"用于存储嵌入模型信息的数据类。\n\n    属性:\n        embedding_dimensions (int): 嵌入模型的维度数量。\n    \"\"\"\n\n    embedding_dimensions: int\n\n[这部分代码的结束]\n[End of XAgent/message_history.py]\n\n**注意**: 使用这段代码时需要注意以下几点：\n\n- 需要提供模型的名称、每个提示的token成本、每个生成结果的token成本和最大token数量。\n- 对于嵌入模型信息类，还需要提供嵌入模型的维度数量。",
            "code_start_line": 89,
            "code_end_line": 102,
            "parent": null,
            "have_return": false,
            "code_content": "class ModelInfo:\n    \"\"\"Data class to store model information.\n\n    Attributes:\n        name (str): Model name\n        prompt_token_cost (float): Token cost per prompt\n        completion_token_cost (float): Token cost per completion\n        max_tokens (int): Maximum tokens that can be generated\n    \"\"\"\n\n    name: str\n    prompt_token_cost: float\n    completion_token_cost: float\n    max_tokens: int\n",
            "name_column": 6
        },
        "ChatModelInfo": {
            "type": "ClassDef",
            "name": "ChatModelInfo",
            "md_content": "**ChatModelInfo函数**：该类的功能是存储聊天模型信息的数据类。\n\nChatModelInfo是一个继承自ModelInfo的类，用于存储聊天模型的相关信息。它是一个数据类，用于存储聊天模型的各种属性和数据。\n\n该类没有定义任何属性或方法，因此它是一个空的数据类。它的主要作用是作为一个容器，用于存储聊天模型的信息，以便在需要时进行访问和使用。\n\n**注意**：该类没有定义任何属性或方法，因此在使用时需要注意，需要在其他地方定义和设置聊天模型的相关属性和数据。",
            "code_start_line": 106,
            "code_end_line": 107,
            "parent": null,
            "have_return": false,
            "code_content": "class ChatModelInfo(ModelInfo):\n    \"\"\"Data class to store chat model information.\"\"\"\n",
            "name_column": 6
        },
        "TextModelInfo": {
            "type": "ClassDef",
            "name": "TextModelInfo",
            "md_content": "**TextModelInfo函数**：这个类的功能是存储文本生成模型的信息。\n\nTextModelInfo是一个继承自ModelInfo的数据类，用于存储文本生成模型的信息。它没有定义任何自己的属性或方法，只是继承了父类ModelInfo的属性和方法。\n\nModelInfo是一个抽象基类，用于定义模型信息的通用接口。它包含了一些常用的属性和方法，如模型名称、模型类型、模型路径等。TextModelInfo作为ModelInfo的子类，可以通过继承来共享这些属性和方法。\n\n使用TextModelInfo类时，可以通过实例化对象来存储文本生成模型的信息。可以通过访问对象的属性来获取模型的名称、类型、路径等信息。这些信息可以用于后续的模型操作和处理。\n\n**注意**：在使用TextModelInfo类时，需要确保传入正确的模型信息，并且按照规定的方式使用对象的属性。",
            "code_start_line": 111,
            "code_end_line": 112,
            "parent": null,
            "have_return": false,
            "code_content": "class TextModelInfo(ModelInfo):\n    \"\"\"Data class to store text generation model information.\"\"\"\n",
            "name_column": 6
        },
        "EmbeddingModelInfo": {
            "type": "ClassDef",
            "name": "EmbeddingModelInfo",
            "md_content": "**EmbeddingModelInfo函数**：这个类的功能是存储嵌入模型信息的数据类。\n\n这个类继承自ModelInfo类，用于存储嵌入模型的相关信息。它有一个属性embedding_dimensions，表示嵌入模型的维度数。\n\n**注意**：在使用这个类时需要注意以下几点：\n- 确保在实例化EmbeddingModelInfo对象时，传入正确的embedding_dimensions参数。\n- 可以通过访问embedding_dimensions属性来获取嵌入模型的维度数。",
            "code_start_line": 116,
            "code_end_line": 123,
            "parent": null,
            "have_return": false,
            "code_content": "class EmbeddingModelInfo(ModelInfo):\n    \"\"\"Data class to store embedding model information.\n\n    Attributes:\n        embedding_dimensions (int): Number of dimensions in the embedding model.\n    \"\"\"\n\n    embedding_dimensions: int\n",
            "name_column": 6
        },
        "MessageHistory": {
            "type": "ClassDef",
            "name": "MessageHistory",
            "md_content": "**MessageHistory函数**: 这个类的功能是存储消息历史记录的数据类。\n\n这个类包含了添加、检索和修剪存储的消息的方法。\n\n**属性**:\n- messages (list[Message]): 按创建顺序排列的消息列表。\n- summary (str): 表示对话/历史记录摘要的字符串。\n- last_trimmed_index (int): 最后一个被删除的消息在历史记录中的索引。\n\n**方法**:\n- `__getitem__(self, i: int) -> Message`: 通过索引访问消息。\n- `__iter__(self) -> iterator`: 返回一个迭代器，用于遍历消息列表。\n- `__len__(self) -> int`: 返回消息列表中的消息数量。\n- `add(self, role: MessageRole, content: str, type: MessageType | None = None, function_call: str | None = None) -> None`: 向消息列表中添加新消息。\n- `append(self, message: Message) -> None`: 将新消息追加到消息列表中。\n- `trim_messages(self, current_message_chain: list[Message]) -> tuple[Message, list[Message]]`: 修剪消息列表，返回被修剪的消息列表和新的摘要消息。\n- `per_cycle(self, messages: list[Message] | None = None) -> tuple[Message, Message, Message]`: 从对话周期中生成用户、AI和结果消息的迭代器。\n- `summary_message(self) -> Message`: 从当前摘要构建摘要消息。\n- `update_running_summary(self, new_events: list[Message]) -> Message`: 更新摘要消息，将新事件与当前摘要结合起来。\n\n**注意**: \n- `add`方法中的`role`参数应为'system'、'user'、'assistant'或'function'之一。\n- `trim_messages`方法中的`current_message_chain`参数应为当前上下文中的消息列表。\n- `per_cycle`方法中的`messages`参数可以是自定义的消息列表，如果为None，则使用`self.messages`。\n- `update_running_summary`方法中的`new_events`参数应为新事件的消息列表。\n\n**输出示例**:\n```python\nhistory = MessageHistory()\nhistory.add(MessageRole.USER, \"Hello!\")\nhistory.add(MessageRole.ASSISTANT, \"Hi there!\")\nhistory.add(MessageRole.USER, \"How are you?\")\nprint(len(history))  # Output: 3\n\nfor message in history:\n    print(message.content)\n# Output:\n# Hello!\n# Hi there!\n# How are you?\n\nsummary_message = history.summary_message()\nprint(summary_message.content)\n# Output: This reminds you of these events from your past: \\nI was created\n```",
            "code_start_line": 127,
            "code_end_line": 369,
            "parent": null,
            "have_return": true,
            "code_content": "class MessageHistory:\n    \"\"\"Data class to store the history of messages.\n\n    Contains methods to add, retrieve, trim the stored messages.\n\n    Attributes:\n        messages (list[Message]): List of messages in order of their creation.\n        summary (str): String representing the summary of the conversation/history.\n        last_trimmed_index (int): The index of the last erased message from the history.\n    \"\"\"\n\n    messages: list[Message] = field(default_factory=list)\n    summary: str = \"I was created\"\n\n    last_trimmed_index: int = 0\n\n    def __getitem__(self, i: int):\n        \"\"\"Enables accessing messages by their index.\n\n        Args:\n            i (int): Index of the message in the messages list.\n\n        Returns:\n            Message: Message at index i in the messages list.\n        \"\"\"\n        return self.messages[i]\n\n    def __iter__(self):\n        \"\"\"Returns an iterator over the messages list.\n\n        Returns:\n            iterator: An iterator over the messages list.\n        \"\"\"\n        return iter(self.messages)\n\n    def __len__(self):\n        \"\"\"Returns the count of messages in the messages list.\n\n        Returns:\n            int: Total number of messages in the messages list.\n        \"\"\"\n        return len(self.messages)\n\n    def add(\n        self,\n        role: MessageRole,\n        content: str,\n        type: MessageType | None = None,\n        function_call: str | None = None,\n    ):\n        \"\"\"Adds a new message to the messages list.\n\n        Args:\n            role (MessageRole): Source of the message, either 'system', 'user', 'assistant', or 'function'.\n            content (str): Actual content of the message.\n            type (MessageType): Type of the message, 'ai_response' for AI dialogue messages or 'action_result' for results of API calls. Default to None if not specified.\n            function_call (str): A dictionary representing the method invocation in programmable API calls. Default to None if not specified.\n\n        Returns:\n            None\n        \"\"\"\n        if function_call == None:\n            message = Message(role, content, type)\n        else:\n            message = Message(role, content, type, function_call)\n        return self.append(message)\n\n    def append(self, message: Message):\n        \"\"\"Appends a new message to the messages list.\n\n        Args:\n            message (Message): Message to append to the list.\n\n        Returns:\n            None.\n        \"\"\"\n        return self.messages.append(message)\n\n    def trim_messages(\n        self,\n        current_message_chain: list[Message],\n    ) -> tuple[Message, list[Message]]:\n        \"\"\"\n        Returns a list of trimmed messages: messages which are in the message history\n        but not in current_message_chain.\n\n        Args:\n            current_message_chain (list[Message]): The messages currently in the context.\n\n        Returns:\n            Message: A message with the new running summary after adding the trimmed messages.\n            list[Message]: A list of messages that are in full_message_history with an index higher than last_trimmed_index and absent from current_message_chain.\n        \"\"\"\n        # Select messages in full_message_history with an index higher than last_trimmed_index\n        new_messages = [\n            msg for i, msg in enumerate(self) if i > self.last_trimmed_index\n        ]\n\n        # Remove messages that are already present in current_message_chain\n        new_messages_not_in_chain = [\n            msg for msg in new_messages if msg not in current_message_chain\n        ]\n\n        if not new_messages_not_in_chain:\n            return self.summary_message(), []\n\n        new_summary_message = self.update_running_summary(\n            new_events=new_messages_not_in_chain\n        )\n\n        # Find the index of the last message processed\n        last_message = new_messages_not_in_chain[-1]\n        self.last_trimmed_index = self.messages.index(last_message)\n\n        return new_summary_message, new_messages_not_in_chain\n\n    def per_cycle(self, messages: list[Message] | None = None):\n        \"\"\"\n        This method yields user, ai, and result messages from the conversation cycle.\n\n        Args:\n            messages (list[Message]): The messages currently in the context. If None, uses self.messages.\n\n        Yields:\n            tuple: A tuple containing:\n                - user_message (Message): a message containing user input\n                - ai_message (Message): a message from the AI containing a proposed action\n                - result_message (Message): the message containing the result of the AI's proposed action\n        \"\"\"\n        messages = messages or self.messages\n        for i in range(0, len(messages) - 1):\n\n            ai_message = messages[i]\n\n            if ai_message.type != \"ai_response\":\n                continue\n\n            user_message = (\n                messages[i - 1] if i > 0 and messages[i - 1].role == \"user\" else None\n            )\n            result_message = messages[i + 1]\n            try:\n                assert result_message.type == \"action_result\"\n\n                yield user_message, ai_message, result_message\n            except AssertionError as err:\n                logger.debug(\n                    f\"Invalid item in message history: {err}; Messages: {messages[i-1:i+2]}\"\n                )\n\n    def summary_message(self) -> Message:\n        \"\"\"Build summary message from the current summary.\n\n        Returns:\n            Message: A system message containing the current summary\n        \"\"\"\n        return Message(\n            \"system\",\n            f\"This reminds you of these events from your past: \\n{self.summary}\",\n        )\n\n    def update_running_summary(self, new_events: list[Message]) -> Message:\n        \"\"\"\n        This function takes a list of dictionaries representing new events and combines them with the current summary,\n        focusing on key and potentially important information to remember. The updated summary is returned in a message\n        formatted in the 1st person past tense.\n\n        Args:\n            new_events (List[Dict]): A list of dictionaries containing the latest events to be added to the summary.\n\n        Returns:\n            str: A message containing the updated summary of actions, formatted in the 1st person past tense.\n\n        Example:\n            new_events = [{\"event\": \"entered the kitchen.\"}, {\"event\": \"found a scrawled note with the number 7\"}]\n            update_running_summary(new_events)\n            # Returns: \"This reminds you of these events from your past: \\nI entered the kitchen and found a scrawled note saying 7.\"\n        \"\"\"\n        cfg = Config()\n\n        if not new_events:\n            return self.summary_message()\n\n        # Create a copy of the new_events list to prevent modifying the original list\n        new_events = copy.deepcopy(new_events)\n\n        # Replace \"assistant\" with \"you\". This produces much better first person past tense results.\n        for event in new_events:\n            if event.role.lower() == \"assistant\":\n                event.role = \"you\"\n\n                # Remove \"thoughts\" dictionary from \"content\"\n                try:\n                    content_dict = json.loads(event.content)\n                    if \"thoughts\" in content_dict:\n                        del content_dict[\"thoughts\"]\n                    event.content = json.dumps(content_dict)\n                except json.decoder.JSONDecodeError:\n                    if cfg.debug_mode:\n                        logger.error(f\"Error: Invalid JSON: {event.content}\\n\")\n\n            elif event.role.lower() == \"system\":\n                event.role = \"your computer\"\n\n            # Delete all user messages\n            elif event.role == \"user\":\n                new_events.remove(event)\n\n        prompt = f'''Your task is to create a concise running summary of actions and information results in the provided text, focusing on key and potentially important information to remember.\n\nYou will receive the current summary and the your latest actions. Combine them, adding relevant key information from the latest development in 1st person past tense and keeping the summary concise.\n\nSummary So Far:\n\"\"\"\n{self.summary}\n\"\"\"\n\nLatest Development:\n\"\"\"\n{new_events or \"Nothing new happened.\"}\n\"\"\"\n'''\n\n        prompt = ChatSequence.for_model(cfg.fast_llm_model, [Message(\"user\", prompt)])\n        self.agent.log_cycle_handler.log_cycle(\n            self.agent.config.ai_name,\n            self.agent.created_at,\n            self.agent.cycle_count,\n            prompt.raw(),\n            PROMPT_SUMMARY_FILE_NAME,\n        )\n\n        self.summary = create_chat_completion(prompt)\n\n        self.agent.log_cycle_handler.log_cycle(\n            self.agent.config.ai_name,\n            self.agent.created_at,\n            self.agent.cycle_count,\n            self.summary,\n            SUMMARY_FILE_NAME,\n        )\n\n        return self.summary_message()",
            "name_column": 6
        },
        "raw": {
            "type": "FunctionDef",
            "name": "raw",
            "md_content": "**raw函数**：该函数用于提取消息的原始内容，去除其他元数据。\n\n该函数返回一个包含'role'和'content'的字典。\n\n**代码分析和描述**：\n该函数接收一个Message对象的实例作为参数，然后将消息的角色和内容提取出来，存储在一个字典中。如果消息中存在函数调用(function_call)，则将其也添加到字典中。最后返回该字典。\n\n该函数的作用是提取消息的原始内容，去除其他元数据，只保留角色和内容信息。这在处理消息历史记录时非常有用，可以方便地获取消息的核心信息。\n\n**注意**：在调用该函数时，需要传入一个Message对象的实例作为参数。\n\n**输出示例**：\n```\n{\n    \"role\": \"user\",\n    \"content\": \"Hello, how are you?\"\n}\n```",
            "code_start_line": 48,
            "code_end_line": 57,
            "parent": "Message",
            "have_return": true,
            "code_content": "    def raw(self) -> MessageDict:\n        \"\"\"Extracts raw content of the message, stripping away other metadata.\n\n        Returns:\n            MessageDict: Dictionary containing 'role' and 'content'.\n        \"\"\"\n        data = {\"role\": self.role, \"content\": self.content}\n        if self.function_call != None:\n            data[\"function_call\"] = self.function_call\n        return data\n",
            "name_column": 8
        },
        "to_json": {
            "type": "FunctionDef",
            "name": "to_json",
            "md_content": "**to_json函数**：该函数的功能是将消息转换为JSON格式。\n\n该函数将消息对象转换为JSON格式，并返回表示消息的字典。它首先调用self.raw()函数获取消息的原始内容，然后将其转换为JSON格式。\n\n**注意**：使用该代码时需要注意以下几点：\n- 该函数需要在MessageHistory类的实例上调用。\n\n**输出示例**：以下是该函数可能返回值的示例：\n```\n{\n    \"id\": 1,\n    \"timestamp\": \"2022-01-01 12:00:00\",\n    \"sender\": \"user\",\n    \"content\": \"Hello\",\n    \"metadata\": {}\n}\n```",
            "code_start_line": 59,
            "code_end_line": 65,
            "parent": "Message",
            "have_return": true,
            "code_content": "    def to_json(self):\n        \"\"\"Convert the message into JSON format.\n\n        Returns:\n            MessageDict: JSON representation of the message.\n        \"\"\"\n        return self.raw()\n",
            "name_column": 8
        },
        "equal": {
            "type": "FunctionDef",
            "name": "equal",
            "md_content": "**equal函数**：该函数的功能是比较两个消息对象的所有属性，判断它们是否相等。\n\n该函数接受两个参数a和b，分别表示要比较的两个消息对象。\n\n如果两个消息对象的角色、内容、类型和函数调用都相等，则返回True，否则返回False。\n\n该函数主要用于判断两个消息对象是否相等。\n\n**注意**：在使用该函数时，需要确保传入的参数是Message对象。\n\n**输出示例**：假设a和b是两个消息对象，如果a和b的所有属性都相等，则返回True，否则返回False。",
            "code_start_line": 68,
            "code_end_line": 86,
            "parent": "Message",
            "have_return": true,
            "code_content": "    def equal(cls, a: Message, b: Message):\n        \"\"\"Checks if two messages are equal by comparing all their attributes.\n\n        Args:\n            a (Message): first message to be compared.\n            b (Message): second message to be compared.\n\n        Returns:\n            bool: Returns True if both messages are equal in all their attributes; False otherwise.\n        \"\"\"\n        if a.role != b.role:\n            return False\n        if a.content != b.content:\n            return False\n        if a.type != b.type:\n            return False\n        if a.function_call != b.function_call:\n            return False\n        return True\n",
            "name_column": 8
        },
        "__getitem__": {
            "type": "FunctionDef",
            "name": "__getitem__",
            "md_content": "**__getitem__函数**：这个函数的作用是通过索引访问消息。\n\n该函数接受一个参数i，表示消息在消息列表中的索引。\n\n返回值是消息列表中索引为i的消息。\n\n**注意**：使用该代码时需要注意以下几点：\n- 确保索引i在有效范围内，即不超过消息列表的长度。\n- 确保消息列表不为空。\n\n**输出示例**：假设消息列表中有三个消息，分别为\"Hello\", \"World\", \"!\"，当调用`__getitem__(1)`时，返回值为\"World\"。",
            "code_start_line": 143,
            "code_end_line": 152,
            "parent": "MessageHistory",
            "have_return": true,
            "code_content": "    def __getitem__(self, i: int):\n        \"\"\"Enables accessing messages by their index.\n\n        Args:\n            i (int): Index of the message in the messages list.\n\n        Returns:\n            Message: Message at index i in the messages list.\n        \"\"\"\n        return self.messages[i]\n",
            "name_column": 8
        },
        "__iter__": {
            "type": "FunctionDef",
            "name": "__iter__",
            "md_content": "**__iter__函数**：该函数的功能是返回一个迭代器，用于遍历消息列表。\n\n该函数是一个特殊的函数，用于定义一个对象的迭代行为。在这个函数中，通过调用内置函数iter()，将消息列表self.messages转换为一个迭代器，并返回该迭代器。\n\n**注意**：使用该函数时需要注意以下几点：\n- 该函数只能在支持迭代的对象上使用，例如列表、元组、字典等。\n- 迭代器是一种能够逐个访问元素的对象，可以通过for循环或next()函数来遍历迭代器中的元素。\n\n**输出示例**：假设messages列表中有3个元素['Hello', 'World', '!']，则调用__iter__函数后返回的迭代器可以按照以下方式遍历：\n```python\nmessages = ['Hello', 'World', '!']\niterator = messages.__iter__()\nfor message in iterator:\n    print(message)\n```\n输出结果：\n```\nHello\nWorld\n!\n```",
            "code_start_line": 154,
            "code_end_line": 160,
            "parent": "MessageHistory",
            "have_return": true,
            "code_content": "    def __iter__(self):\n        \"\"\"Returns an iterator over the messages list.\n\n        Returns:\n            iterator: An iterator over the messages list.\n        \"\"\"\n        return iter(self.messages)\n",
            "name_column": 8
        },
        "__len__": {
            "type": "FunctionDef",
            "name": "__len__",
            "md_content": "**__len__函数**：这个函数的作用是返回消息列表中的消息数量。\n\n该函数通过调用内置的len函数来计算消息列表中的消息数量，并将结果返回。\n\n**注意**：使用该代码时需要注意以下几点：\n- 该函数只能用于消息历史记录对象。\n- 返回值为整数类型。\n\n**输出示例**：假设消息列表中有5条消息，则返回值为5。",
            "code_start_line": 162,
            "code_end_line": 168,
            "parent": "MessageHistory",
            "have_return": true,
            "code_content": "    def __len__(self):\n        \"\"\"Returns the count of messages in the messages list.\n\n        Returns:\n            int: Total number of messages in the messages list.\n        \"\"\"\n        return len(self.messages)\n",
            "name_column": 8
        },
        "add": {
            "type": "FunctionDef",
            "name": "add",
            "md_content": "**add函数**: 这个函数的作用是将新的消息添加到消息列表中。\n\n该函数接受以下参数：\n- role (MessageRole): 消息的来源，可以是'system'、'user'、'assistant'或'function'。\n- content (str): 消息的实际内容。\n- type (MessageType): 消息的类型，可以是'ai_response'表示AI对话消息或'action_result'表示API调用的结果。如果未指定，默认为None。\n- function_call (str): 表示可编程API调用中的方法调用的字典。如果未指定，默认为None。\n\n该函数返回None。\n\n该函数首先根据传入的参数创建一个Message对象，然后将该对象添加到消息列表中。\n\n**注意**: \n- role参数必须是'system'、'user'、'assistant'或'function'中的一个。\n- type参数必须是MessageType枚举中的一个值。\n- function_call参数是可选的，如果不指定则默认为None。\n\n**输出示例**:\n```\nadd('user', 'Hello, how are you?', MessageType.AI_RESPONSE, 'api_call')\n```",
            "code_start_line": 170,
            "code_end_line": 192,
            "parent": "MessageHistory",
            "have_return": true,
            "code_content": "    def add(\n        self,\n        role: MessageRole,\n        content: str,\n        type: MessageType | None = None,\n        function_call: str | None = None,\n    ):\n        \"\"\"Adds a new message to the messages list.\n\n        Args:\n            role (MessageRole): Source of the message, either 'system', 'user', 'assistant', or 'function'.\n            content (str): Actual content of the message.\n            type (MessageType): Type of the message, 'ai_response' for AI dialogue messages or 'action_result' for results of API calls. Default to None if not specified.\n            function_call (str): A dictionary representing the method invocation in programmable API calls. Default to None if not specified.\n\n        Returns:\n            None\n        \"\"\"\n        if function_call == None:\n            message = Message(role, content, type)\n        else:\n            message = Message(role, content, type, function_call)\n        return self.append(message)\n",
            "name_column": 8
        },
        "append": {
            "type": "FunctionDef",
            "name": "append",
            "md_content": "**append函数**：这个函数的功能是将一个新的消息添加到消息列表中。\n\n该函数接受一个名为message的参数，表示要添加到列表中的消息。\n\n该函数没有返回值。\n\n**代码分析和描述**：\n该函数使用了列表的append方法，将传入的message对象添加到messages列表中。\n\n**注意**：该函数的参数message必须是一个Message对象。\n\n**输出示例**：无返回值。",
            "code_start_line": 194,
            "code_end_line": 203,
            "parent": "MessageHistory",
            "have_return": true,
            "code_content": "    def append(self, message: Message):\n        \"\"\"Appends a new message to the messages list.\n\n        Args:\n            message (Message): Message to append to the list.\n\n        Returns:\n            None.\n        \"\"\"\n        return self.messages.append(message)\n",
            "name_column": 8
        },
        "trim_messages": {
            "type": "FunctionDef",
            "name": "trim_messages",
            "md_content": "**trim_messages函数**：该函数的功能是返回一个修剪过的消息列表，即在消息历史记录中但不在当前消息链中的消息。\n\n该函数接受两个参数：\n- current_message_chain（list[Message]）：当前上下文中的消息链。\n\n该函数的返回值为一个元组，包含两个元素：\n- Message：一个包含修剪后的消息的消息对象，用于更新运行摘要。\n- list[Message]：一个包含在full_message_history中索引大于last_trimmed_index且不在current_message_chain中的消息列表。\n\n函数的具体实现如下：\n1. 首先，从full_message_history中选择索引大于last_trimmed_index的消息，存储在new_messages列表中。\n2. 然后，从new_messages列表中移除已经存在于current_message_chain中的消息，得到new_messages_not_in_chain列表。\n3. 如果new_messages_not_in_chain列表为空，则返回当前的运行摘要消息和一个空的消息列表。\n4. 否则，调用update_running_summary函数，将new_messages_not_in_chain作为参数，更新运行摘要消息，并将返回值存储在new_summary_message中。\n5. 找到new_messages_not_in_chain列表中最后一条消息的索引，并将其赋值给self.last_trimmed_index。\n6. 最后，返回new_summary_message和new_messages_not_in_chain作为函数的返回值。\n\n**注意**：使用该代码时需要注意以下几点：\n- current_message_chain参数必须是一个包含Message对象的列表。\n- full_message_history必须是一个包含Message对象的列表。\n- last_trimmed_index必须是一个整数，表示上一次修剪的消息索引。\n\n**输出示例**：以下是函数返回值的一个示例：\n```\nnew_summary_message = Message(\"New running summary\", \"This is the updated summary.\")\nnew_messages_not_in_chain = [\n    Message(\"Message 1\", \"This is message 1.\"),\n    Message(\"Message 2\", \"This is message 2.\")\n]\n\n返回值：(new_summary_message, new_messages_not_in_chain)\n```",
            "code_start_line": 205,
            "code_end_line": 241,
            "parent": "MessageHistory",
            "have_return": true,
            "code_content": "    def trim_messages(\n        self,\n        current_message_chain: list[Message],\n    ) -> tuple[Message, list[Message]]:\n        \"\"\"\n        Returns a list of trimmed messages: messages which are in the message history\n        but not in current_message_chain.\n\n        Args:\n            current_message_chain (list[Message]): The messages currently in the context.\n\n        Returns:\n            Message: A message with the new running summary after adding the trimmed messages.\n            list[Message]: A list of messages that are in full_message_history with an index higher than last_trimmed_index and absent from current_message_chain.\n        \"\"\"\n        # Select messages in full_message_history with an index higher than last_trimmed_index\n        new_messages = [\n            msg for i, msg in enumerate(self) if i > self.last_trimmed_index\n        ]\n\n        # Remove messages that are already present in current_message_chain\n        new_messages_not_in_chain = [\n            msg for msg in new_messages if msg not in current_message_chain\n        ]\n\n        if not new_messages_not_in_chain:\n            return self.summary_message(), []\n\n        new_summary_message = self.update_running_summary(\n            new_events=new_messages_not_in_chain\n        )\n\n        # Find the index of the last message processed\n        last_message = new_messages_not_in_chain[-1]\n        self.last_trimmed_index = self.messages.index(last_message)\n\n        return new_summary_message, new_messages_not_in_chain\n",
            "name_column": 8
        },
        "per_cycle": {
            "type": "FunctionDef",
            "name": "per_cycle",
            "md_content": "**per_cycle函数**：该函数的功能是从对话周期中生成用户、AI和结果消息。\n\n该函数接受一个名为messages的参数，类型为list[Message]或None，默认值为None。该参数表示当前上下文中的消息列表。如果messages为None，则使用self.messages。\n\n该函数通过遍历messages列表，从中筛选出用户消息、AI消息和结果消息，并以元组的形式返回。\n\n具体实现如下：\n1. 首先，将messages赋值为messages参数或self.messages。\n2. 然后，通过循环遍历messages列表中的每个元素（索引从0到len(messages)-1）。\n3. 对于每个元素，将其赋值给ai_message。\n4. 如果ai_message的type不等于\"ai_response\"，则跳过当前循环，继续下一次循环。\n5. 如果ai_message的type等于\"ai_response\"，则执行以下操作：\n   - 如果i大于0且messages[i-1]的role为\"user\"，则将messages[i-1]赋值给user_message，否则将user_message赋值为None。\n   - 将messages[i+1]赋值给result_message。\n   - 使用断言语句判断result_message的type是否等于\"action_result\"，如果不等于则抛出AssertionError异常。\n   - 如果断言通过，则使用yield语句返回user_message、ai_message和result_message组成的元组。\n   - 如果断言失败，则使用logger.debug()记录错误信息。\n\n**注意**：使用该函数时需要注意以下几点：\n- 该函数需要传入一个消息列表作为参数，表示当前上下文中的消息。\n- 该函数会根据消息的type属性筛选出用户消息、AI消息和结果消息，并以元组的形式返回。\n- 如果消息列表中的某个元素不符合预期的type类型，会抛出AssertionError异常，并记录错误信息。\n- 使用yield语句返回结果，可以在循环中逐步获取生成的元组。\n\n以上是对per_cycle函数的详细分析和描述。",
            "code_start_line": 243,
            "code_end_line": 275,
            "parent": "MessageHistory",
            "have_return": false,
            "code_content": "    def per_cycle(self, messages: list[Message] | None = None):\n        \"\"\"\n        This method yields user, ai, and result messages from the conversation cycle.\n\n        Args:\n            messages (list[Message]): The messages currently in the context. If None, uses self.messages.\n\n        Yields:\n            tuple: A tuple containing:\n                - user_message (Message): a message containing user input\n                - ai_message (Message): a message from the AI containing a proposed action\n                - result_message (Message): the message containing the result of the AI's proposed action\n        \"\"\"\n        messages = messages or self.messages\n        for i in range(0, len(messages) - 1):\n\n            ai_message = messages[i]\n\n            if ai_message.type != \"ai_response\":\n                continue\n\n            user_message = (\n                messages[i - 1] if i > 0 and messages[i - 1].role == \"user\" else None\n            )\n            result_message = messages[i + 1]\n            try:\n                assert result_message.type == \"action_result\"\n\n                yield user_message, ai_message, result_message\n            except AssertionError as err:\n                logger.debug(\n                    f\"Invalid item in message history: {err}; Messages: {messages[i-1:i+2]}\"\n                )\n",
            "name_column": 8
        },
        "summary_message": {
            "type": "FunctionDef",
            "name": "summary_message",
            "md_content": "**summary_message函数**：此函数的功能是从当前摘要构建摘要消息。\n\n该函数接受当前摘要作为输入，并返回一个包含当前摘要的系统消息。\n\n**代码分析和描述**：\n该函数接受当前摘要作为输入，并使用字符串插值将其包含在系统消息中返回。系统消息的内容是一个字符串，其中包含当前摘要的文本。\n\n**注意事项**：\n- 该函数依赖于Message类和summary属性。\n- 调用该函数前，需要确保已经设置了当前摘要。\n\n**输出示例**：\n```\nMessage(\n    \"system\",\n    \"This reminds you of these events from your past: \\n{self.summary}\",\n)\n```",
            "code_start_line": 277,
            "code_end_line": 286,
            "parent": "MessageHistory",
            "have_return": true,
            "code_content": "    def summary_message(self) -> Message:\n        \"\"\"Build summary message from the current summary.\n\n        Returns:\n            Message: A system message containing the current summary\n        \"\"\"\n        return Message(\n            \"system\",\n            f\"This reminds you of these events from your past: \\n{self.summary}\",\n        )\n",
            "name_column": 8
        },
        "update_running_summary": {
            "type": "FunctionDef",
            "name": "update_running_summary",
            "md_content": "**update_running_summary函数**：该函数的功能是将一组表示新事件的字典列表与当前摘要结合起来，重点关注关键信息和可能重要的信息以供记忆。函数将返回一个以第一人称过去时格式化的消息，其中包含更新后的摘要。\n\n**参数**：\n- new_events（List[Dict]）：包含要添加到摘要中的最新事件的字典列表。\n\n**返回值**：\n- str：包含更新后的操作摘要的消息，以第一人称过去时格式化。\n\n**示例**：\n```python\nnew_events = [{\"event\": \"进入了厨房。\"}, {\"event\": \"找到了一张写着数字7的便条。\"}]\nupdate_running_summary(new_events)\n# 返回：\"这让我想起了过去发生的这些事件：\\n我进入了厨房并找到了一张写着数字7的便条。\"\n```\n\n**update_running_summary函数详细分析**：\n该函数接受一个表示新事件的字典列表new_events，并将其与当前摘要结合起来，生成更新后的摘要。函数的具体步骤如下：\n\n1. 创建一个Config对象cfg，用于获取配置信息。\n2. 如果new_events为空列表，则直接返回当前摘要的消息，即调用self.summary_message()函数。\n3. 创建new_events的副本，以防止修改原始列表。\n4. 遍历new_events列表，将其中的\"assistant\"替换为\"you\"，以便生成更好的第一人称过去时结果。同时，删除\"content\"中的\"thoughts\"字典，以保持摘要的简洁性。\n5. 如果遇到\"system\"角色的事件，将其角色替换为\"your computer\"。\n6. 删除所有用户消息，即将角色为\"user\"的事件从new_events列表中删除。\n7. 构建一个prompt字符串，用于向模型提供输入。该字符串包含了当前摘要和最新事件的信息。\n8. 调用ChatSequence.for_model方法，使用cfg.fast_llm_model模型生成一个ChatSequence对象prompt。\n9. 将prompt的原始内容记录到日志中，以便后续分析。\n10. 调用create_chat_completion函数，使用生成的prompt生成更新后的摘要。\n11. 将更新后的摘要记录到日志中。\n12. 返回更新后的摘要的消息，即调用self.summary_message()函数。\n\n**注意**：\n- 在处理new_events时，会修改原始列表，因此在函数内部创建了new_events的副本进行操作，以防止对原始列表的修改。\n- 函数内部使用了Config对象cfg，用于获取配置信息。\n- 函数内部调用了self.summary_message()函数，用于返回当前摘要的消息。\n\n**输出示例**：\n这让我想起了过去发生的这些事件：\n我进入了厨房并找到了一张写着数字7的便条。",
            "code_start_line": 288,
            "code_end_line": 369,
            "parent": "MessageHistory",
            "have_return": true,
            "code_content": "    def update_running_summary(self, new_events: list[Message]) -> Message:\n        \"\"\"\n        This function takes a list of dictionaries representing new events and combines them with the current summary,\n        focusing on key and potentially important information to remember. The updated summary is returned in a message\n        formatted in the 1st person past tense.\n\n        Args:\n            new_events (List[Dict]): A list of dictionaries containing the latest events to be added to the summary.\n\n        Returns:\n            str: A message containing the updated summary of actions, formatted in the 1st person past tense.\n\n        Example:\n            new_events = [{\"event\": \"entered the kitchen.\"}, {\"event\": \"found a scrawled note with the number 7\"}]\n            update_running_summary(new_events)\n            # Returns: \"This reminds you of these events from your past: \\nI entered the kitchen and found a scrawled note saying 7.\"\n        \"\"\"\n        cfg = Config()\n\n        if not new_events:\n            return self.summary_message()\n\n        # Create a copy of the new_events list to prevent modifying the original list\n        new_events = copy.deepcopy(new_events)\n\n        # Replace \"assistant\" with \"you\". This produces much better first person past tense results.\n        for event in new_events:\n            if event.role.lower() == \"assistant\":\n                event.role = \"you\"\n\n                # Remove \"thoughts\" dictionary from \"content\"\n                try:\n                    content_dict = json.loads(event.content)\n                    if \"thoughts\" in content_dict:\n                        del content_dict[\"thoughts\"]\n                    event.content = json.dumps(content_dict)\n                except json.decoder.JSONDecodeError:\n                    if cfg.debug_mode:\n                        logger.error(f\"Error: Invalid JSON: {event.content}\\n\")\n\n            elif event.role.lower() == \"system\":\n                event.role = \"your computer\"\n\n            # Delete all user messages\n            elif event.role == \"user\":\n                new_events.remove(event)\n\n        prompt = f'''Your task is to create a concise running summary of actions and information results in the provided text, focusing on key and potentially important information to remember.\n\nYou will receive the current summary and the your latest actions. Combine them, adding relevant key information from the latest development in 1st person past tense and keeping the summary concise.\n\nSummary So Far:\n\"\"\"\n{self.summary}\n\"\"\"\n\nLatest Development:\n\"\"\"\n{new_events or \"Nothing new happened.\"}\n\"\"\"\n'''\n\n        prompt = ChatSequence.for_model(cfg.fast_llm_model, [Message(\"user\", prompt)])\n        self.agent.log_cycle_handler.log_cycle(\n            self.agent.config.ai_name,\n            self.agent.created_at,\n            self.agent.cycle_count,\n            prompt.raw(),\n            PROMPT_SUMMARY_FILE_NAME,\n        )\n\n        self.summary = create_chat_completion(prompt)\n\n        self.agent.log_cycle_handler.log_cycle(\n            self.agent.config.ai_name,\n            self.agent.created_at,\n            self.agent.cycle_count,\n            self.summary,\n            SUMMARY_FILE_NAME,\n        )\n\n        return self.summary_message()",
            "name_column": 8
        }
    },
    "XAgent/toolserver_interface.py": {
        "is_wrapped_response": {
            "type": "FunctionDef",
            "name": "is_wrapped_response",
            "md_content": "**is_wrapped_response函数**：该函数的功能是检查响应对象是否被包装。\n\n该函数接受一个字典类型的参数obj，表示响应对象。函数返回一个布尔值，如果响应对象被包装，则返回True，否则返回False。\n\n具体而言，该函数会检查obj字典中是否包含键'type'，并且该键对应的值是['simple', 'composite', 'binary']中的一个，并且字典中还包含键'data'。如果满足这些条件，则认为响应对象被包装。\n\n在项目中，该函数被XAgent/toolserver_interface.py文件中的unwrap_tool_response函数调用。unwrap_tool_response函数用于解包工具的响应对象。在unwrap_tool_response函数中，如果传入的obj参数是一个字典类型，并且is_wrapped_response函数返回True，则根据obj字典中'type'的值进行不同的处理。如果'type'是'simple'，则返回obj字典中的'data'值；如果'type'是'binary'，则将'data'值解码为二进制数据，并根据'media_type'和'name'生成文件名，将解码后的数据写入文件，并返回包含'media_type'和'file_name'的字典；如果'type'是'composite'，则递归调用unwrap_tool_response函数对'data'中的每个元素进行解包，并返回解包后的列表。如果is_wrapped_response函数返回False，则直接返回传入的obj参数。\n\n需要注意的是，is_wrapped_response函数还会对obj参数进行类型判断，如果obj是字符串、整数、浮点数、布尔值或列表类型，则直接返回obj。如果obj是None，则返回None。如果obj是其他类型，则会打印警告信息，并返回None。\n\n**注意**：使用该代码时需要注意以下几点：\n- 传入的obj参数必须是一个字典类型。\n- obj字典中必须包含键'type'和'data'。\n- 'type'的值必须是['simple', 'composite', 'binary']中的一个。\n\n**输出示例**：模拟代码返回值的可能外观。\n```python\nTrue\n```",
            "code_start_line": 14,
            "code_end_line": 26,
            "parent": null,
            "have_return": true,
            "code_content": "def is_wrapped_response(obj: dict) -> bool:\n    \"\"\"\n    Check if the response object is wrapped.\n\n    Args:\n        obj (dict): The response object.\n\n    Returns:\n        bool: True if the response object is wrapped, False otherwise.\n    \"\"\"\n    if 'type' in obj and obj['type'] in ['simple', 'composite', 'binary'] and 'data' in obj:\n        return True\n    return False\n",
            "name_column": 4
        },
        "unwrap_tool_response": {
            "type": "FunctionDef",
            "name": "unwrap_tool_response",
            "md_content": "**unwrap_tool_response函数**：该函数的功能是解包工具响应对象。\n\n该函数接受两个参数：\n- obj：工具响应对象。\n- logger：日志记录器。\n\n该函数的返回值是解包后的工具响应对象。\n\n该函数的详细代码分析和描述如下：\n- 首先，判断obj的类型是否为字典。如果是字典类型，并且是被包装的响应对象（通过is_wrapped_response函数判断），则根据obj['type']的值进行不同的处理。\n  - 如果obj['type']的值为'simple'，则直接返回obj['data']。\n  - 如果obj['type']的值为'binary'，则根据obj中的信息生成一个文件名name，并根据obj['media_type']的值判断是否为图片类型。如果是图片类型且文件名不以'.png'结尾，则在文件名后添加'.png'后缀。然后，将obj['data']解码为二进制数据，并将其写入到本地工作空间中的文件中。最后，返回一个包含媒体类型和文件名的字典。\n  - 如果obj['type']的值为'composite'，则遍历obj['data']中的每个元素，对每个元素递归调用unwrap_tool_response函数，并将结果存入一个列表中。最后，返回该列表作为结果。\n- 如果obj的类型是字符串、整数、浮点数、布尔值或列表，则直接返回obj。\n- 如果obj为None，则返回None。\n- 如果obj的类型不在上述类型中，则使用日志记录器logger记录一条警告日志，内容为\"Unknown type {type(obj)} in unwrap_tool_response\"，并返回None作为结果。\n\n**注意**：使用该代码时需要注意以下几点：\n- 该函数依赖于is_wrapped_response函数，需要确保该函数的正确性。\n- 该函数会根据工具响应对象的类型进行不同的处理，需要根据实际情况进行调用和使用。\n\n**输出示例**：模拟该函数返回值的可能外观。\n```python\n{\n    'media_type': 'image/png',\n    'file_name': 'example.png'\n}\n```",
            "code_start_line": 29,
            "code_end_line": 66,
            "parent": null,
            "have_return": true,
            "code_content": "def unwrap_tool_response(obj, logger=None):\n    \"\"\"\n    Unwrap the tool response object.\n\n    Args:\n        obj: The tool response object.\n        logger: The logger.\n\n    Returns:\n        The unwrapped tool response object.\n    \"\"\"\n    if isinstance(obj, dict):\n        if is_wrapped_response(obj):\n            match obj['type']:\n                case 'simple':\n                    return obj['data']\n                case 'binary':\n                    name = obj.get('name', uuid.uuid4().hex)\n                    if obj['media_type'] == 'image/png' and not str(name).endswith('.png'):\n                        name += '.png'\n                    with open(os.path.join('local_workspace', name), 'wb') as f:\n                        f.write(base64.b64decode(obj['data']))\n                    return {\n                        'media_type': obj['media_type'],\n                        'file_name': name\n                    }\n                case 'composite':\n                    return [unwrap_tool_response(o, logger) for o in obj['data']]\n        else:\n            return obj\n    elif isinstance(obj, (str, int, float, bool, list)):\n        return obj\n    elif obj is None:\n        return None\n    else:\n        logger.typewriter_log(\n            f'Unknown type {type(obj)} in unwrap_tool_response', Fore.YELLOW)\n        return None\n",
            "name_column": 4
        },
        "ToolServerInterface": {
            "type": "ClassDef",
            "name": "ToolServerInterface",
            "md_content": "**ToolServerInterface函数**: 这个类的功能是与ToolServer进行通信的接口。\n\n该类的主要功能是与ToolServer进行通信，包括上传文件、下载文件、获取工作空间结构、获取可用工具等操作。它还提供了懒惰初始化和关闭ToolServer会话的方法。\n\n该类的构造函数接受一个RunningRecoder对象和一个可选的logger对象作为参数。它将RunningRecoder对象赋值给self.recorder属性，将logger对象赋值给self.logger属性。\n\nlazy_init方法是ToolServer接口的懒惰初始化方法。它接受一个config参数，用于配置ToolServer。如果config中设置了使用自托管的ToolServer，则将self.url设置为config中指定的自托管ToolServer的URL；否则，抛出NotImplementedError异常，提示使用自托管ToolServer。然后，向self.url发送一个POST请求，获取ToolServer的cookie，并将cookie保存在self.cookies属性中。\n\nclose方法用于关闭ToolServer会话。它向self.url发送一个POST请求，关闭ToolServer会话。\n\nupload_file方法用于将文件上传到ToolServer。它接受一个file_path参数，表示要上传的文件的路径。首先构造一个URL，然后使用requests库向该URL发送一个POST请求，将文件作为multipart/form-data形式的数据发送。请求中包含文件的路径和文件名。最后，将响应内容以JSON格式返回。\n\ndownload_file方法用于从ToolServer下载文件。它接受一个file_path参数，表示要下载的文件的路径。首先构造一个URL，然后构造一个payload，包含要下载的文件的路径。使用requests库向该URL发送一个POST请求，将payload作为JSON数据发送。然后将响应内容保存到本地文件中，并返回保存文件的路径。\n\nget_workspace_structure方法用于获取ToolServer的工作空间结构。它构造一个URL，使用requests库向该URL发送一个POST请求，获取工作空间的结构，并将响应内容以JSON格式返回。\n\ndownload_all_files方法用于下载ToolServer工作空间中的所有文件。它构造一个URL，使用requests库向该URL发送一个POST请求，下载工作空间的所有文件，并将响应内容保存到本地文件中，并返回保存文件的路径。\n\nget_available_tools方法用于获取ToolServer中可用的工具。它构造一个URL，使用requests库向该URL发送一个POST请求，获取可用工具的列表，并将响应内容以JSON格式返回。\n\nretrieve_rapidapi_tools方法用于从ToolServer检索RapidAPI工具。它接受一个query参数和一个可选的top_k参数，用于指定检索的查询和返回的工具数量。首先构造一个URL，然后构造一个payload，包含查询和top_k参数。使用requests库向该URL发送一个POST请求，将payload作为JSON数据发送。然后将响应内容保存到本地文件中，并返回保存文件的路径。\n\nget_json_schema_for_tools方法用于获取指定工具的JSON模式。它接受一个command_names参数，表示要获取JSON模式的工具的名称列表。首先构造一个URL，然后构造一个payload，包含要获取JSON模式的工具的名称列表。使用requests库向该URL发送一个POST请求，将payload作为JSON数据发送。然后将响应内容以JSON格式返回。\n\nexecute_command_client方法用于在ToolServer上执行命令。它接受一个command_name参数，表示要执行的命令的名称，以及一个arguments参数，表示要执行的命令的参数。首先构造一个URL，然后构造一个payload，包含要执行的命令的名称和参数。使用requests库向该URL发送一个POST请求，将payload作为JSON数据发送。然后将响应内容以JSON格式返回。\n\n**注意**: 使用该类之前，需要先进行懒惰初始化，并确保ToolServer已连接。在使用upload_file和download_file方法时，需要提供文件的路径。在使用get_available_tools和retrieve_rapidapi_tools方法时，需要提供查询参数。在使用get_json_schema_for_tools和execute_command_client方法时，需要提供工具的名称和参数。\n\n**输出示例**:\n```\n{\n    \"tool_name\": \"tool1\",\n    \"arguments\": {\n        \"arg1\": \"value1\",\n        \"arg2\": \"value2\"\n    }\n}\n```",
            "code_start_line": 69,
            "code_end_line": 364,
            "parent": null,
            "have_return": true,
            "code_content": "class ToolServerInterface():\n    \"\"\"\n    The interface to communicate with the ToolServer.\n    \"\"\"\n\n    def __init__(self, recorder: RunningRecoder, logger=None):\n        self.recorder = recorder\n        self.logger = logger\n\n    def lazy_init(self, config):\n        \"\"\"\n        Lazy initialization of the ToolServer interface.\n\n        Args:\n            config: The configuration for the ToolServer.\n\n        Raises:\n            NotImplementedError: If trying to use a non-selfhost ToolServer.\n        \"\"\"\n        self.config = config\n        if config.use_selfhost_toolserver:\n            self.url = config.selfhost_toolserver_url\n        else:\n            raise NotImplementedError('Please use selfhost toolserver')\n        self.logger.typewriter_log(\"ToolServer connected in\", Fore.RED, self.url)\n        response = requests.post(f'{self.url}/get_cookie',)\n        self.cookies = response.cookies\n\n    def close(self):\n        \"\"\"\n        Close the ToolServer session.\n        \"\"\"\n        requests.post(f'{self.url}/close_session', cookies=self.cookies)\n\n    def upload_file(self, file_path) -> str:\n        \"\"\"\n        Upload a file to the ToolServer.\n\n        Args:\n            file_path (str): The path to the file to be uploaded.\n\n        Returns:\n            str: The response from the ToolServer.\n        \"\"\"\n        url = f\"{self.url}/upload_file\"\n        response = requests.post(url, timeout=10, cookies=self.cookies,\n                                 files={'file': open(file_path, 'rb'), 'filename': os.path.basename(file_path)})\n        response.raise_for_status()\n        response = response.json()\n        return response\n\n    def download_file(self, file_path) -> str:\n        \"\"\"\n        Download a file from the ToolServer.\n\n        Args:\n            file_path (str): The path to the file to be downloaded.\n\n        Returns:\n            str: The save path of the downloaded file.\n        \"\"\"\n        url = f\"{self.url}/download_file\"\n        payload = {\n            'file_path': file_path\n        }\n        response = requests.post(\n            url, json=payload, timeout=10, cookies=self.cookies,)\n        response.raise_for_status()\n\n        save_path = os.path.join(self.recorder.record_root_dir, file_path)\n        os.makedirs(os.path.dirname(save_path), exist_ok=True)\n        with open(save_path, 'wb') as f:\n            f.write(response.content)\n        return save_path\n\n    def get_workspace_structure(self) -> dict:\n        \"\"\"\n        Get the structure of the workspace from the ToolServer.\n\n        Returns:\n            dict: The structure of the workspace.\n        \"\"\"\n        url = f\"{self.url}/get_workspace_structure\"\n        response = requests.post(url, timeout=10, cookies=self.cookies,)\n        response.raise_for_status()\n        response = response.json()\n        return response\n\n    def download_all_files(self):\n        \"\"\"\n        Download all the files in the workspace from the ToolServer.\n\n        Returns:\n            str: The save path of the downloaded workspace.\n        \"\"\"\n        url = f\"{self.url}/download_workspace\"\n        response = requests.post(url, cookies=self.cookies,)\n        response.raise_for_status()\n\n        save_path = os.path.join(\n            self.recorder.record_root_dir, 'workspace.zip')\n        os.makedirs(os.path.dirname(save_path), exist_ok=True)\n        with open(save_path, 'wb') as f:\n            f.write(response.content)\n        return save_path\n\n    def get_available_tools(self):\n        \"\"\"\n        Get the available tools from the ToolServer.\n\n        Returns:\n            The available tools.\n        \"\"\"\n        payload = {\n        }\n        url = f\"{self.url}/get_available_tools\"\n        cache_output = self.recorder.query_tool_server_cache(url, payload)\n        try:\n            if cache_output != None:\n\n                response = cache_output[\"tool_output\"]\n                status_code = cache_output[\"response_status_code\"]\n            else:\n                response = requests.post(\n                    url, json=payload, timeout=10, cookies=self.cookies)\n                status_code = response.status_code\n                response.raise_for_status()\n                response = response.json()\n                if not isinstance(response, dict):\n                    response = json.loads(response)\n\n            self.recorder.regist_tool_server(url=url,\n                                             payload=payload,\n                                             tool_output=response,\n                                             response_status_code=status_code)\n            return response\n        except Exception as e:\n            raise Exception(f\"Error when fetching available tools: {e}\")\n\n    def retrieve_rapidapi_tools(self, query: str, top_k: int = 10):\n        \"\"\"\n        Retrieve RapidAPI tools from the ToolServer.\n\n        Args:\n            query (str): The query for retrieving tools.\n            top_k (int, optional): The number of tools to retrieve. Defaults to 10.\n\n        Returns:\n            The retrieved tools and the description of the tools in JSON format.\n        \"\"\"\n        url = f\"{self.url}/retrieving_tools\"\n        payload = {\n            \"question\": query,\n            \"top_k\": top_k\n        }\n        cache_output = self.recorder.query_tool_server_cache(url, payload)\n        try:\n            if cache_output != None:\n                response = cache_output[\"tool_output\"]\n                status_code = cache_output[\"tool_output_status_code\"]\n            else:\n                response = requests.post(\n                    url, json=payload, timeout=20, cookies=self.cookies)\n                status_code = response.status_code\n                response = response.json()\n                if not isinstance(response, dict):\n                    response = json.loads(response)\n            self.recorder.regist_tool_server(url=url,\n                                             payload=payload,\n                                             tool_output=response,\n                                             response_status_code=status_code)\n            retrieved_tools = response[\"retrieved_tools\"]\n            tools_json = response[\"tools_json\"]\n            for tool_json in tools_json:\n                function_manager.register_function(tool_json)\n        except Exception as e:\n            self.logger.typewriter_log(\n                \"Tool Retrieval Failed, nothing will be retrieved, please fix here.\",\n                Fore.RED,\n            )\n            print(f\"Error when retrieving tools: {e}\")\n            print(response)\n            return None, None\n\n        return retrieved_tools, tools_json\n\n    def get_json_schema_for_tools(self, command_names):\n        \"\"\"\n        Get the JSON schema for the specified tools from the ToolServer.\n\n        Args:\n            command_names: The names of the tools.\n\n        Returns:\n            The JSON schema for the tools.\n        \"\"\"\n        url = f\"{self.url}/get_json_schema_for_tools\"\n        payload = {\n            \"tool_names\": command_names\n        }\n        cache_output = self.recorder.query_tool_server_cache(url, payload)\n        try:\n            if cache_output != None:\n                response = cache_output[\"tool_output\"]\n                status_code = cache_output[\"tool_output_status_code\"]\n            else:\n                response = requests.post(\n                    url, json=payload, timeout=10, cookies=self.cookies)\n                status_code = response.status_code\n                response = response.json()\n                if not isinstance(response, dict):\n                    try:\n                        response = json.loads(response)\n                    except:\n                        pass\n            self.recorder.regist_tool_server(url=url,\n                                             payload=payload,\n                                             tool_output=response,\n                                             response_status_code=status_code)\n            function_manager.register_function(response)\n            return response\n\n        except Exception as e:\n            print(f\"Error when fetching openai function jsons: {e}\")\n            return None\n\n    # @func_set_timeout()\n\n    def execute_command_client(\n        self,\n        command_name,\n        arguments={},\n        # input_hash_id,\n    ):\n        \"\"\"\n        Execute a command on the ToolServer.\n\n        Args:\n            command_name (str): The name of the command.\n            arguments (dict, optional): The arguments for the command. Defaults to {}.\n            input_hash_id: The hash ID of the input.\n\n        Returns:\n            mixed: The result of the command and the tool output status code.\n        \"\"\"\n        # return \"sorry, the server is not available now\", ToolCallStatusCode.SERVER_ERROR, input_hash_id\n        url = f\"{self.url}/execute_tool\"\n        if isinstance(arguments, str):\n            try:\n                arguments = json.loads(arguments)\n            except:\n                pass\n        payload = {\n            \"tool_name\": command_name,\n            \"arguments\": arguments,\n            # \"hash_id\": input_hash_id,\n        }\n\n        cache_output = self.recorder.query_tool_server_cache(url, payload)\n\n        if self.config['experiment']['redo_action'] or cache_output is None:\n            response = requests.post(url, json=payload, cookies=self.cookies)\n            response_status_code = response.status_code\n            if response.status_code == 200 or response.status_code == 450:\n                command_result = response.json()\n                command_result = unwrap_tool_response(command_result, self.logger)\n            else:\n                command_result = response.text\n\n        if cache_output != None:\n            command_result = cache_output[\"tool_output\"]\n            response_status_code = cache_output[\"response_status_code\"]\n\n        self.recorder.regist_tool_server(url=url,\n                                         payload=payload,\n                                         tool_output=command_result,\n                                         response_status_code=response_status_code)\n\n        # setting tool_output_status_code according to status_code\n        if response_status_code == 200:\n            tool_output_status_code = ToolCallStatusCode.TOOL_CALL_SUCCESS\n        elif response_status_code == 404:\n            tool_output_status_code = ToolCallStatusCode.HALLUCINATE_NAME\n        elif response_status_code == 422:\n            tool_output_status_code = ToolCallStatusCode.FORMAT_ERROR\n        elif response_status_code == 450:\n            tool_output_status_code = ToolCallStatusCode.TIMEOUT_ERROR\n        elif response_status_code == 500:\n            tool_output_status_code = ToolCallStatusCode.TOOL_CALL_FAILED\n        elif response_status_code == 503:\n            tool_output_status_code = ToolCallStatusCode.SERVER_ERROR\n            raise Exception(\"Server Error: \" + command_result)\n        else:\n            tool_output_status_code = ToolCallStatusCode.OTHER_ERROR\n\n        return command_result, tool_output_status_code",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__函数**：这个函数的作用是初始化一个ToolserverInterface对象。\n\n在这个函数中，有两个参数：recorder和logger。recorder是一个RunningRecoder对象，用于记录运行时的信息。logger是一个日志记录器对象，用于记录日志信息。\n\n在函数体内，将传入的recorder赋值给self.recorder，将传入的logger赋值给self.logger。\n\n**注意**：在使用这个函数时，需要传入一个RunningRecoder对象作为recorder参数，并且可以选择传入一个日志记录器对象作为logger参数。",
            "code_start_line": 74,
            "code_end_line": 76,
            "parent": "ToolServerInterface",
            "have_return": false,
            "code_content": "    def __init__(self, recorder: RunningRecoder, logger=None):\n        self.recorder = recorder\n        self.logger = logger\n",
            "name_column": 8
        },
        "lazy_init": {
            "type": "FunctionDef",
            "name": "lazy_init",
            "md_content": "**lazy_init函数**：该函数的功能是进行ToolServer接口的延迟初始化。\n\n该函数接受一个config参数，用于配置ToolServer。\n\n如果config中的use_selfhost_toolserver为True，则将selfhost_toolserver_url赋值给url变量；否则，抛出NotImplementedError异常，提示使用selfhost toolserver。\n\n接下来，通过requests库向self.url发送一个POST请求，路径为\"{self.url}/get_cookie\"，并将返回的cookies赋值给self.cookies。\n\n在函数执行过程中，会通过self.logger.typewriter_log方法打印出\"ToolServer connected in\"和self.url的值。\n\n**注意**：使用该代码时需要注意以下几点：\n- 需要提供正确的ToolServer配置信息，确保config参数正确设置。\n- 如果使用非selfhost ToolServer，会抛出NotImplementedError异常，需要使用selfhost ToolServer。",
            "code_start_line": 78,
            "code_end_line": 95,
            "parent": "ToolServerInterface",
            "have_return": false,
            "code_content": "    def lazy_init(self, config):\n        \"\"\"\n        Lazy initialization of the ToolServer interface.\n\n        Args:\n            config: The configuration for the ToolServer.\n\n        Raises:\n            NotImplementedError: If trying to use a non-selfhost ToolServer.\n        \"\"\"\n        self.config = config\n        if config.use_selfhost_toolserver:\n            self.url = config.selfhost_toolserver_url\n        else:\n            raise NotImplementedError('Please use selfhost toolserver')\n        self.logger.typewriter_log(\"ToolServer connected in\", Fore.RED, self.url)\n        response = requests.post(f'{self.url}/get_cookie',)\n        self.cookies = response.cookies\n",
            "name_column": 8
        },
        "close": {
            "type": "FunctionDef",
            "name": "close",
            "md_content": "**close函数**: 这个函数的功能是关闭ToolServer会话。\n\n该函数通过发送一个POST请求来关闭ToolServer会话。请求的URL是通过在self.url后面添加'/close_session'得到的。请求中还包含了cookies，这些cookies是在初始化ToolServerInterface对象时传入的。\n\n在项目中，该函数被调用的地方是XAgent/core.py文件中的close函数。在这个函数中，首先调用了toolserver_interface对象的download_all_files函数，然后再调用了toolserver_interface对象的close函数。\n\n**注意**: 使用该代码时需要注意以下几点：\n- 确保在调用close函数之前已经调用了download_all_files函数，以确保所有文件都已经下载完成。\n- 确保在初始化ToolServerInterface对象时传入了正确的URL和cookies参数。",
            "code_start_line": 97,
            "code_end_line": 101,
            "parent": "ToolServerInterface",
            "have_return": false,
            "code_content": "    def close(self):\n        \"\"\"\n        Close the ToolServer session.\n        \"\"\"\n        requests.post(f'{self.url}/close_session', cookies=self.cookies)\n",
            "name_column": 8
        },
        "upload_file": {
            "type": "FunctionDef",
            "name": "upload_file",
            "md_content": "**upload_file函数**：该函数用于将文件上传到ToolServer。\n\n该函数接受一个参数file_path，表示要上传的文件的路径。\n\n函数内部首先构建了上传文件的URL，然后使用requests库发送POST请求，将文件以二进制形式上传到ToolServer。请求中包含了文件的路径和文件名。上传成功后，函数将返回ToolServer的响应。\n\n**注意**：使用该函数前需要确保ToolServer已经启动，并且传入的file_path参数是有效的文件路径。\n\n**输出示例**：假设ToolServer返回的响应为\"Upload successful\"，则函数的返回值为\"Upload successful\"。",
            "code_start_line": 103,
            "code_end_line": 118,
            "parent": "ToolServerInterface",
            "have_return": true,
            "code_content": "    def upload_file(self, file_path) -> str:\n        \"\"\"\n        Upload a file to the ToolServer.\n\n        Args:\n            file_path (str): The path to the file to be uploaded.\n\n        Returns:\n            str: The response from the ToolServer.\n        \"\"\"\n        url = f\"{self.url}/upload_file\"\n        response = requests.post(url, timeout=10, cookies=self.cookies,\n                                 files={'file': open(file_path, 'rb'), 'filename': os.path.basename(file_path)})\n        response.raise_for_status()\n        response = response.json()\n        return response\n",
            "name_column": 8
        },
        "download_file": {
            "type": "FunctionDef",
            "name": "download_file",
            "md_content": "**download_file函数**：该函数的功能是从ToolServer下载文件。\n\n该函数接受一个参数file_path，表示要下载的文件的路径。\n\n函数内部首先构建了下载文件的URL，然后将file_path作为payload的值传递给ToolServer，使用POST请求发送下载文件的请求。请求中还包括了超时时间和cookies信息。如果请求失败，会抛出异常。\n\n接下来，函数根据下载文件的保存路径构建了保存文件的路径save_path，并创建了保存文件的目录。然后使用二进制写入的方式将下载的文件内容写入到save_path指定的文件中。\n\n最后，函数返回保存文件的路径save_path。\n\n**注意**：使用该函数时需要确保ToolServer的URL、超时时间和cookies信息已正确设置。\n\n**输出示例**：假设下载的文件保存在\"/Users/logic/Documents/THUNLP/XAgent/XAgent/recordings/file.txt\"路径下，则函数的返回值为\"/Users/logic/Documents/THUNLP/XAgent/XAgent/recordings/file.txt\"。",
            "code_start_line": 120,
            "code_end_line": 142,
            "parent": "ToolServerInterface",
            "have_return": true,
            "code_content": "    def download_file(self, file_path) -> str:\n        \"\"\"\n        Download a file from the ToolServer.\n\n        Args:\n            file_path (str): The path to the file to be downloaded.\n\n        Returns:\n            str: The save path of the downloaded file.\n        \"\"\"\n        url = f\"{self.url}/download_file\"\n        payload = {\n            'file_path': file_path\n        }\n        response = requests.post(\n            url, json=payload, timeout=10, cookies=self.cookies,)\n        response.raise_for_status()\n\n        save_path = os.path.join(self.recorder.record_root_dir, file_path)\n        os.makedirs(os.path.dirname(save_path), exist_ok=True)\n        with open(save_path, 'wb') as f:\n            f.write(response.content)\n        return save_path\n",
            "name_column": 8
        },
        "get_workspace_structure": {
            "type": "FunctionDef",
            "name": "get_workspace_structure",
            "md_content": "**get_workspace_structure函数**：该函数的功能是从ToolServer获取工作空间的结构。\n\n该函数通过向ToolServer发送POST请求，获取工作空间的结构信息。请求的URL为`{self.url}/get_workspace_structure`，超时时间为10秒，使用了之前保存的cookies进行身份验证。请求成功后，将返回的响应转换为JSON格式，并将其作为函数的返回值。\n\n**注意**：使用该代码时需要注意以下几点：\n- 需要确保ToolServer的URL正确配置，并且ToolServer已经启动。\n- 需要确保ToolServer的cookies已经保存，并且具有访问工作空间结构的权限。\n\n**输出示例**：模拟该代码返回值的可能外观。\n```python\n{\n    \"workspace\": {\n        \"name\": \"MyWorkspace\",\n        \"folders\": [\n            {\n                \"name\": \"Folder1\",\n                \"files\": [\n                    {\n                        \"name\": \"File1.txt\",\n                        \"size\": \"10KB\"\n                    },\n                    {\n                        \"name\": \"File2.txt\",\n                        \"size\": \"5KB\"\n                    }\n                ]\n            },\n            {\n                \"name\": \"Folder2\",\n                \"files\": [\n                    {\n                        \"name\": \"File3.txt\",\n                        \"size\": \"8KB\"\n                    }\n                ]\n            }\n        ]\n    }\n}\n```",
            "code_start_line": 144,
            "code_end_line": 155,
            "parent": "ToolServerInterface",
            "have_return": true,
            "code_content": "    def get_workspace_structure(self) -> dict:\n        \"\"\"\n        Get the structure of the workspace from the ToolServer.\n\n        Returns:\n            dict: The structure of the workspace.\n        \"\"\"\n        url = f\"{self.url}/get_workspace_structure\"\n        response = requests.post(url, timeout=10, cookies=self.cookies,)\n        response.raise_for_status()\n        response = response.json()\n        return response\n",
            "name_column": 8
        },
        "download_all_files": {
            "type": "FunctionDef",
            "name": "download_all_files",
            "md_content": "**download_all_files函数**：该函数的功能是从ToolServer下载工作空间中的所有文件。\n\n该函数首先构造了一个下载工作空间的URL，然后通过发送POST请求到该URL来获取响应。如果请求成功，函数将会将响应内容写入到指定的保存路径中，并返回保存路径。\n\n在函数内部，首先构造了下载工作空间的URL，URL的构造使用了self.url和/download_workspace两个部分。self.url是ToolServer的URL地址，/download_workspace是下载工作空间的接口路径。通过将这两个部分拼接在一起，得到了完整的下载工作空间的URL。\n\n然后，使用requests库发送了一个POST请求到下载工作空间的URL，并传递了cookies参数。函数使用了requests.post方法来发送POST请求，并将响应保存在response变量中。\n\n接下来，函数调用了response.raise_for_status()方法来检查请求是否成功。如果请求失败，将会抛出一个异常。\n\n然后，函数构造了保存路径save_path，使用了os.path.join方法将self.recorder.record_root_dir和'workspace.zip'拼接在一起。self.recorder.record_root_dir是工作空间的保存路径，'workspace.zip'是保存文件的文件名。\n\n接着，函数使用os.makedirs方法创建了保存路径的父目录，如果父目录不存在的话。\n\n最后，函数使用了with open语句打开保存路径的文件，并以二进制写入的方式将响应内容写入到文件中。\n\n函数最后返回保存路径save_path。\n\n**注意**：使用该函数前需要确保ToolServer的URL地址已经设置，并且需要确保已经登录并获取了cookies。\n\n**输出示例**：假设保存路径为'/path/to/workspace.zip'，则函数的返回值为'/path/to/workspace.zip'。",
            "code_start_line": 157,
            "code_end_line": 173,
            "parent": "ToolServerInterface",
            "have_return": true,
            "code_content": "    def download_all_files(self):\n        \"\"\"\n        Download all the files in the workspace from the ToolServer.\n\n        Returns:\n            str: The save path of the downloaded workspace.\n        \"\"\"\n        url = f\"{self.url}/download_workspace\"\n        response = requests.post(url, cookies=self.cookies,)\n        response.raise_for_status()\n\n        save_path = os.path.join(\n            self.recorder.record_root_dir, 'workspace.zip')\n        os.makedirs(os.path.dirname(save_path), exist_ok=True)\n        with open(save_path, 'wb') as f:\n            f.write(response.content)\n        return save_path\n",
            "name_column": 8
        },
        "get_available_tools": {
            "type": "FunctionDef",
            "name": "get_available_tools",
            "md_content": "**get_available_tools函数**：该函数的功能是从ToolServer获取可用的工具。\n\n该函数首先构造了一个空的payload字典，并根据self.url拼接出请求的url。然后通过调用self.recorder.query_tool_server_cache方法，查询ToolServer的缓存数据，传入url和payload作为参数。如果缓存数据不为空，则将缓存数据中的工具输出和响应状态码分别赋值给response和status_code变量。如果缓存数据为空，则通过requests库发送POST请求，将url、payload、timeout和cookies作为参数传入，获取响应结果。然后检查响应的状态码，如果不是200，则抛出异常。接着将响应结果转换为JSON格式，并将其赋值给response变量。如果响应结果不是字典类型，则再次将其转换为JSON格式。最后，调用self.recorder.regist_tool_server方法，将url、payload、工具输出和响应状态码注册到记录器中。最后返回响应结果。\n\n**注意**：在调用该函数之前，需要确保ToolServer的URL、payload和cookies已经设置好。\n\n**输出示例**：假设响应结果为以下格式：\n```\n{\n    \"available_tools\": [\"tool1\", \"tool2\", \"tool3\"],\n    \"tools_json\": {\n        \"tool1\": {\n            \"name\": \"tool1\",\n            \"description\": \"This is tool1\"\n        },\n        \"tool2\": {\n            \"name\": \"tool2\",\n            \"description\": \"This is tool2\"\n        },\n        \"tool3\": {\n            \"name\": \"tool3\",\n            \"description\": \"This is tool3\"\n        }\n    }\n}\n```\n则函数返回的结果为以上示例的字典形式。",
            "code_start_line": 175,
            "code_end_line": 206,
            "parent": "ToolServerInterface",
            "have_return": true,
            "code_content": "    def get_available_tools(self):\n        \"\"\"\n        Get the available tools from the ToolServer.\n\n        Returns:\n            The available tools.\n        \"\"\"\n        payload = {\n        }\n        url = f\"{self.url}/get_available_tools\"\n        cache_output = self.recorder.query_tool_server_cache(url, payload)\n        try:\n            if cache_output != None:\n\n                response = cache_output[\"tool_output\"]\n                status_code = cache_output[\"response_status_code\"]\n            else:\n                response = requests.post(\n                    url, json=payload, timeout=10, cookies=self.cookies)\n                status_code = response.status_code\n                response.raise_for_status()\n                response = response.json()\n                if not isinstance(response, dict):\n                    response = json.loads(response)\n\n            self.recorder.regist_tool_server(url=url,\n                                             payload=payload,\n                                             tool_output=response,\n                                             response_status_code=status_code)\n            return response\n        except Exception as e:\n            raise Exception(f\"Error when fetching available tools: {e}\")\n",
            "name_column": 8
        },
        "retrieve_rapidapi_tools": {
            "type": "FunctionDef",
            "name": "retrieve_rapidapi_tools",
            "md_content": "**retrieve_rapidapi_tools函数**：该函数用于从ToolServer检索RapidAPI工具。\n\n该函数接受以下参数：\n- query（str）：用于检索工具的查询字符串。\n- top_k（int，可选）：要检索的工具数量，默认为10。\n\n该函数返回以JSON格式表示的检索到的工具及其描述。\n\n该函数的具体代码分析和描述如下：\n- 首先，根据传入的查询字符串和检索数量，构造了用于检索工具的URL和payload。\n- 然后，通过调用self.recorder.query_tool_server_cache函数，从缓存中获取工具的输出结果。\n- 如果缓存中存在输出结果，则将结果赋值给response和status_code变量。\n- 如果缓存中不存在输出结果，则通过发送POST请求到ToolServer，获取工具的输出结果，并将结果赋值给response变量。\n- 接着，将工具的输出结果和状态码注册到self.recorder中。\n- 最后，从输出结果中提取检索到的工具和工具的描述，并将每个工具的描述注册到function_manager中。\n\n注意事项：\n- 如果在检索工具的过程中出现异常，将会打印错误信息并返回None。\n\n输出示例：\n```\nretrieved_tools = [\"Tool1\", \"Tool2\", \"Tool3\"]\ntools_json = [\n    {\n        \"name\": \"Tool1\",\n        \"description\": \"This is Tool1\"\n    },\n    {\n        \"name\": \"Tool2\",\n        \"description\": \"This is Tool2\"\n    },\n    {\n        \"name\": \"Tool3\",\n        \"description\": \"This is Tool3\"\n    }\n]\n```",
            "code_start_line": 208,
            "code_end_line": 253,
            "parent": "ToolServerInterface",
            "have_return": true,
            "code_content": "    def retrieve_rapidapi_tools(self, query: str, top_k: int = 10):\n        \"\"\"\n        Retrieve RapidAPI tools from the ToolServer.\n\n        Args:\n            query (str): The query for retrieving tools.\n            top_k (int, optional): The number of tools to retrieve. Defaults to 10.\n\n        Returns:\n            The retrieved tools and the description of the tools in JSON format.\n        \"\"\"\n        url = f\"{self.url}/retrieving_tools\"\n        payload = {\n            \"question\": query,\n            \"top_k\": top_k\n        }\n        cache_output = self.recorder.query_tool_server_cache(url, payload)\n        try:\n            if cache_output != None:\n                response = cache_output[\"tool_output\"]\n                status_code = cache_output[\"tool_output_status_code\"]\n            else:\n                response = requests.post(\n                    url, json=payload, timeout=20, cookies=self.cookies)\n                status_code = response.status_code\n                response = response.json()\n                if not isinstance(response, dict):\n                    response = json.loads(response)\n            self.recorder.regist_tool_server(url=url,\n                                             payload=payload,\n                                             tool_output=response,\n                                             response_status_code=status_code)\n            retrieved_tools = response[\"retrieved_tools\"]\n            tools_json = response[\"tools_json\"]\n            for tool_json in tools_json:\n                function_manager.register_function(tool_json)\n        except Exception as e:\n            self.logger.typewriter_log(\n                \"Tool Retrieval Failed, nothing will be retrieved, please fix here.\",\n                Fore.RED,\n            )\n            print(f\"Error when retrieving tools: {e}\")\n            print(response)\n            return None, None\n\n        return retrieved_tools, tools_json\n",
            "name_column": 8
        },
        "get_json_schema_for_tools": {
            "type": "FunctionDef",
            "name": "get_json_schema_for_tools",
            "md_content": "**get_json_schema_for_tools函数**: 该函数的作用是从ToolServer获取指定工具的JSON模式。\n\n该函数接受一个参数command_names，用于指定工具的名称。\n\n函数内部首先构建了请求的URL，并创建了payload参数，其中包含了工具的名称。\n\n接下来，函数通过调用recorder对象的query_tool_server_cache方法，从缓存中查询是否存在该URL和payload的缓存结果。如果存在缓存结果，则直接返回缓存的工具输出和状态码；否则，函数会发送一个POST请求到指定的URL，并将payload以JSON格式发送。函数还设置了超时时间为10秒，并携带了cookies信息。\n\n在获取到响应后，函数首先获取响应的状态码，并将响应内容解析为JSON格式。如果响应内容不是一个字典类型，则函数尝试将其解析为JSON格式。如果解析失败，则不进行处理。\n\n接下来，函数调用recorder对象的regist_tool_server方法，将URL、payload、工具输出和响应状态码注册到recorder中。\n\n然后，函数调用function_manager对象的register_function方法，将工具输出注册到function_manager中。\n\n最后，函数返回工具输出作为结果。\n\n如果在执行过程中出现异常，函数会打印错误信息，并返回None。\n\n**注意**: 使用该代码时需要注意以下几点：\n- 需要确保ToolServer的URL正确配置。\n- 需要确保ToolServer的cookies信息正确配置。\n- 需要确保ToolServer的响应是一个有效的JSON格式。\n\n**输出示例**：模拟代码返回值的可能外观。\n\n```python\n{\n    \"tool1\": {\n        \"input\": {\n            \"type\": \"string\",\n            \"description\": \"Input string\"\n        },\n        \"output\": {\n            \"type\": \"string\",\n            \"description\": \"Output string\"\n        }\n    },\n    \"tool2\": {\n        \"input\": {\n            \"type\": \"number\",\n            \"description\": \"Input number\"\n        },\n        \"output\": {\n            \"type\": \"number\",\n            \"description\": \"Output number\"\n        }\n    }\n}\n```",
            "code_start_line": 255,
            "code_end_line": 293,
            "parent": "ToolServerInterface",
            "have_return": true,
            "code_content": "    def get_json_schema_for_tools(self, command_names):\n        \"\"\"\n        Get the JSON schema for the specified tools from the ToolServer.\n\n        Args:\n            command_names: The names of the tools.\n\n        Returns:\n            The JSON schema for the tools.\n        \"\"\"\n        url = f\"{self.url}/get_json_schema_for_tools\"\n        payload = {\n            \"tool_names\": command_names\n        }\n        cache_output = self.recorder.query_tool_server_cache(url, payload)\n        try:\n            if cache_output != None:\n                response = cache_output[\"tool_output\"]\n                status_code = cache_output[\"tool_output_status_code\"]\n            else:\n                response = requests.post(\n                    url, json=payload, timeout=10, cookies=self.cookies)\n                status_code = response.status_code\n                response = response.json()\n                if not isinstance(response, dict):\n                    try:\n                        response = json.loads(response)\n                    except:\n                        pass\n            self.recorder.regist_tool_server(url=url,\n                                             payload=payload,\n                                             tool_output=response,\n                                             response_status_code=status_code)\n            function_manager.register_function(response)\n            return response\n\n        except Exception as e:\n            print(f\"Error when fetching openai function jsons: {e}\")\n            return None\n",
            "name_column": 8
        },
        "execute_command_client": {
            "type": "FunctionDef",
            "name": "execute_command_client",
            "md_content": "**execute_command_client函数**：此函数的功能是在ToolServer上执行命令。\n\n该函数接受以下参数：\n- command_name（str）：命令的名称。\n- arguments（dict，可选）：命令的参数。默认为{}。\n- input_hash_id：输入的哈希ID。\n\n该函数返回以下结果：\n- mixed：命令的结果和工具输出的状态码。\n\n该函数的详细分析和描述如下：\n- 首先，根据传入的参数构造URL。\n- 然后，将arguments参数转换为JSON格式。\n- 接下来，构造payload，包括tool_name和arguments。\n- 调用self.recorder.query_tool_server_cache函数查询缓存的输出结果。\n- 如果self.config['experiment']['redo_action']为True或者缓存输出为空，则发送POST请求到ToolServer，并获取响应。\n- 根据响应的状态码进行不同的处理：\n  - 如果状态码为200或450，则将响应的JSON结果进行解析。\n  - 否则，将响应的文本结果作为命令的结果。\n- 如果缓存输出不为空，则使用缓存的输出结果和响应的状态码作为命令的结果和工具输出的状态码。\n- 调用self.recorder.regist_tool_server函数将URL、payload、命令的结果和响应的状态码注册到记录器中。\n- 根据响应的状态码设置工具输出的状态码。\n- 返回命令的结果和工具输出的状态码。\n\n**注意**：在使用该函数时，需要注意以下几点：\n- 需要提供正确的command_name和arguments参数。\n- 可能会出现网络请求失败或超时的情况，需要进行错误处理。\n\n**输出示例**：可能的返回值示例为(\"Command result\", ToolCallStatusCode.TOOL_CALL_SUCCESS)。",
            "code_start_line": 297,
            "code_end_line": 364,
            "parent": "ToolServerInterface",
            "have_return": true,
            "code_content": "    def execute_command_client(\n        self,\n        command_name,\n        arguments={},\n        # input_hash_id,\n    ):\n        \"\"\"\n        Execute a command on the ToolServer.\n\n        Args:\n            command_name (str): The name of the command.\n            arguments (dict, optional): The arguments for the command. Defaults to {}.\n            input_hash_id: The hash ID of the input.\n\n        Returns:\n            mixed: The result of the command and the tool output status code.\n        \"\"\"\n        # return \"sorry, the server is not available now\", ToolCallStatusCode.SERVER_ERROR, input_hash_id\n        url = f\"{self.url}/execute_tool\"\n        if isinstance(arguments, str):\n            try:\n                arguments = json.loads(arguments)\n            except:\n                pass\n        payload = {\n            \"tool_name\": command_name,\n            \"arguments\": arguments,\n            # \"hash_id\": input_hash_id,\n        }\n\n        cache_output = self.recorder.query_tool_server_cache(url, payload)\n\n        if self.config['experiment']['redo_action'] or cache_output is None:\n            response = requests.post(url, json=payload, cookies=self.cookies)\n            response_status_code = response.status_code\n            if response.status_code == 200 or response.status_code == 450:\n                command_result = response.json()\n                command_result = unwrap_tool_response(command_result, self.logger)\n            else:\n                command_result = response.text\n\n        if cache_output != None:\n            command_result = cache_output[\"tool_output\"]\n            response_status_code = cache_output[\"response_status_code\"]\n\n        self.recorder.regist_tool_server(url=url,\n                                         payload=payload,\n                                         tool_output=command_result,\n                                         response_status_code=response_status_code)\n\n        # setting tool_output_status_code according to status_code\n        if response_status_code == 200:\n            tool_output_status_code = ToolCallStatusCode.TOOL_CALL_SUCCESS\n        elif response_status_code == 404:\n            tool_output_status_code = ToolCallStatusCode.HALLUCINATE_NAME\n        elif response_status_code == 422:\n            tool_output_status_code = ToolCallStatusCode.FORMAT_ERROR\n        elif response_status_code == 450:\n            tool_output_status_code = ToolCallStatusCode.TIMEOUT_ERROR\n        elif response_status_code == 500:\n            tool_output_status_code = ToolCallStatusCode.TOOL_CALL_FAILED\n        elif response_status_code == 503:\n            tool_output_status_code = ToolCallStatusCode.SERVER_ERROR\n            raise Exception(\"Server Error: \" + command_result)\n        else:\n            tool_output_status_code = ToolCallStatusCode.OTHER_ERROR\n\n        return command_result, tool_output_status_code",
            "name_column": 8
        }
    },
    "XAgent/spinner.py": {
        "Spinner": {
            "type": "ClassDef",
            "name": "Spinner",
            "md_content": "**Spinner类的功能**: 这个类用于实现一个旋转器功能。它在初始化时启动一个新的线程，并可以在with语句中使用。\n\n这个类具有以下属性:\n- delay (float): 每次旋转更新之间的延迟时间。\n- message (str): 与旋转器一起显示的消息。\n- plain_output (bool): 是否显示旋转器。\n- running (bool): 表示旋转器当前是否正在运行。\n- spinner (iter): 一个无限循环迭代器，循环遍历旋转器字符。\n- spinner_thread (Thread): 运行旋转器的线程。\n\n**注意**: 使用代码时需要注意的事项\n\n**输出示例**: 模拟代码返回值的可能外观。\n\nSpinner类的功能是实现一个旋转器，用于在命令行界面中显示一个旋转的图标，表示正在进行某个操作。它可以在初始化时设置旋转器的消息、延迟时间和输出类型。默认情况下，消息为\"Loading...\"，延迟时间为0.1秒，输出类型为False。\n\n该类有以下方法:\n\n- `__init__(self, message: str = \"Loading...\", delay: float = 0.1, plain_output: bool = False) -> None`: 初始化旋转器对象。可以设置消息、延迟时间和输出类型。\n\n- `spin(self) -> None`: 运行旋转器，直到标记为停止。如果输出类型为True，则只打印消息并返回。\n\n- `print_message(self)`: 打印带有旋转器符号的消息，并在之后擦除。\n\n- `__enter__(self)`: 设置运行标记为True，并启动旋转器线程。\n\n- `__exit__(self, exc_type, exc_value, exc_traceback) -> None`: 停止旋转器。参数为异常类型、异常值和异常回溯。\n\n- `update_message(self, new_message, delay=0.1)`: 更新旋转器的消息和延迟时间。\n\n使用示例:\n```python\nwith Spinner(\"Loading...\", 0.1, False) as spinner:\n    # 执行一些操作\n    spinner.update_message(\"Processing...\", 0.2)\n    # 继续执行其他操作\n```\n\n**注意**: 在使用Spinner类时，可以通过调用`update_message`方法来更新旋转器的消息和延迟时间。在使用完毕后，应该使用`with`语句来确保旋转器能够正确停止，并清除旋转器的输出。\n\n**输出示例**:\n```\n- Loading...\n/ Loading...\n| Loading...\n\\ Loading...\n```\n\n这是一个旋转器的示例输出，表示正在进行某个操作。旋转器会不断地显示不同的符号，以模拟旋转的效果。",
            "code_start_line": 8,
            "code_end_line": 96,
            "parent": null,
            "have_return": true,
            "code_content": "class Spinner:\n    \"\"\"\n    A simple class for implementing a spinner functionality. It starts a new\n    thread on initialization and can be used in with statement.\n    \n    Attributes:\n        delay (float): The delay between each spinner update.\n        message (str): The message to display along with the spinner.\n        plain_output (bool): Whether to display the spinner or not.\n        running (bool): Indicates whether the spinner is currently running.\n        spinner (iter): An infinite iterator cycling over spinner characters.\n        spinner_thread (Thread): The thread on which the spinner is running.\n    \"\"\"\n\n    def __init__(\n        self,\n        message: str = \"Loading...\",\n        delay: float = 0.1,\n        plain_output: bool = False,\n    ) -> None:\n        \"\"\"Initializes the spinner with the given message, delay, and output type.\n\n        Args:\n            message (str): The message to display. Defaults to 'Loading...'.\n            delay (float): The delay in seconds between each spinner update. Defaults to 0.1.\n            plain_output (bool): If True, the spinner will not be displayed.\n                                  Defaults to False.\n        \"\"\"\n        self.plain_output = plain_output\n        self.spinner = itertools.cycle([\"-\", \"/\", \"|\", \"\\\\\"])\n        self.delay = delay\n        self.message = message\n        self.running = False\n        self.spinner_thread = None\n\n    def spin(self) -> None:\n        \"\"\"Runs the spinner while it is marked as running.\n\n        If plain_output is set to True, it will only print the message and return.\n        \"\"\"\n        if self.plain_output:\n            self.print_message()\n            return\n        while self.running:\n            self.print_message()\n            time.sleep(self.delay)\n\n    def print_message(self):\n        \"\"\"\n        Prints the message with spinner symbol at the beginning and then erases it.\n        \"\"\"\n        sys.stdout.write(f\"\\r{' ' * (len(self.message) + 2)}\\r\")\n        sys.stdout.write(f\"{next(self.spinner)} {self.message}\\r\")\n        sys.stdout.flush()\n\n    def __enter__(self):\n        \"\"\"Sets the running marker to True and starts the spinner thread.\"\"\"\n        self.running = True\n        self.spinner_thread = threading.Thread(target=self.spin)\n        self.spinner_thread.start()\n\n        return self\n\n    def __exit__(self, exc_type, exc_value, exc_traceback) -> None:\n        \"\"\"Stops the spinner.\n\n        Args:\n            exc_type (Exception): The exception type.\n            exc_value (Exception): The exception value.\n            exc_traceback (Exception): The exception traceback.\n        \"\"\"\n        self.running = False\n        if self.spinner_thread is not None:\n            self.spinner_thread.join()\n        sys.stdout.write(f\"\\r{' ' * (len(self.message) + 2)}\\r\")\n        sys.stdout.flush()\n\n    def update_message(self, new_message, delay=0.1):\n        \"\"\"Updates the message and the delay for the spinner.\n\n        Args:\n            new_message (str): New message to display.\n            delay (float): The delay in seconds between each spinner update.\n                           Defaults to 0.1.\n        \"\"\"\n        self.delay = delay\n        self.message = new_message\n        if self.plain_output:\n            self.print_message()",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__函数**：该函数的功能是初始化Spinner，设置消息、延迟和输出类型。\n\n该函数接受以下参数：\n- message (str)：要显示的消息，默认为'Loading...'。\n- delay (float)：每次Spinner更新之间的延迟时间，以秒为单位，默认为0.1。\n- plain_output (bool)：如果为True，则不显示Spinner，默认为False。\n\n在函数内部，将传入的参数赋值给相应的实例变量。具体来说：\n- self.plain_output：用于存储是否显示Spinner的标志，将传入的plain_output参数赋值给该变量。\n- self.spinner：用于存储Spinner的可迭代对象，通过itertools.cycle方法创建一个包含\"-\", \"/\", \"|\", \"\\\\\"的循环迭代器。\n- self.delay：用于存储每次Spinner更新之间的延迟时间，将传入的delay参数赋值给该变量。\n- self.message：用于存储要显示的消息，将传入的message参数赋值给该变量。\n- self.running：用于存储Spinner的运行状态，初始值为False。\n- self.spinner_thread：用于存储Spinner的线程对象，初始值为None。\n\n**注意**：使用该代码时需要注意以下几点：\n- 可以通过修改message参数来自定义要显示的消息。\n- 可以通过修改delay参数来调整Spinner更新的延迟时间。\n- 可以通过修改plain_output参数来控制是否显示Spinner。如果设置为True，则不会显示Spinner。",
            "code_start_line": 22,
            "code_end_line": 41,
            "parent": "Spinner",
            "have_return": false,
            "code_content": "    def __init__(\n        self,\n        message: str = \"Loading...\",\n        delay: float = 0.1,\n        plain_output: bool = False,\n    ) -> None:\n        \"\"\"Initializes the spinner with the given message, delay, and output type.\n\n        Args:\n            message (str): The message to display. Defaults to 'Loading...'.\n            delay (float): The delay in seconds between each spinner update. Defaults to 0.1.\n            plain_output (bool): If True, the spinner will not be displayed.\n                                  Defaults to False.\n        \"\"\"\n        self.plain_output = plain_output\n        self.spinner = itertools.cycle([\"-\", \"/\", \"|\", \"\\\\\"])\n        self.delay = delay\n        self.message = message\n        self.running = False\n        self.spinner_thread = None\n",
            "name_column": 8
        },
        "spin": {
            "type": "FunctionDef",
            "name": "spin",
            "md_content": "**spin函数**：该函数的功能是在标记为运行状态时运行旋转器。\n\n如果plain_output设置为True，则只会打印消息并返回。\n\n该函数被调用时，会在一个循环中不断打印消息，并通过time.sleep函数来控制打印消息的间隔时间。\n\n**注意**：使用该代码需要注意以下几点：\n- 如果plain_output设置为True，则只会打印消息并返回，不会执行循环打印消息的操作。\n- 通过修改delay参数可以控制打印消息的间隔时间。\n\n**输出示例**：以下是该函数的一个可能的返回值的模拟样式：\n```\n[INFO] 正在运行...\n[INFO] 正在运行...\n[INFO] 正在运行...\n...\n```",
            "code_start_line": 43,
            "code_end_line": 53,
            "parent": "Spinner",
            "have_return": true,
            "code_content": "    def spin(self) -> None:\n        \"\"\"Runs the spinner while it is marked as running.\n\n        If plain_output is set to True, it will only print the message and return.\n        \"\"\"\n        if self.plain_output:\n            self.print_message()\n            return\n        while self.running:\n            self.print_message()\n            time.sleep(self.delay)\n",
            "name_column": 8
        },
        "print_message": {
            "type": "FunctionDef",
            "name": "print_message",
            "md_content": "**print_message函数**：该函数的功能是在消息前面打印旋转符号，然后将其擦除。\n\n该函数用于在控制台打印消息，并在消息前面添加旋转符号。首先，通过sys.stdout.write函数将光标移动到消息的开头，并将旋转符号和消息一起打印出来。然后，通过sys.stdout.flush函数刷新输出，使消息立即显示在控制台上。接下来，通过再次调用sys.stdout.write函数将光标移动到消息的开头，并使用空格将旋转符号和消息擦除。最后，通过再次调用sys.stdout.flush函数刷新输出，将擦除的消息从控制台上移除。\n\n在该项目中，该函数被以下文件调用：\n文件路径：XAgent/spinner.py\n调用代码如下：\n```python\ndef spin(self) -> None:\n    \"\"\"当标记为运行时运行旋转符号。\n\n    如果plain_output设置为True，则只打印消息并返回。\n    \"\"\"\n    if self.plain_output:\n        self.print_message()\n        return\n    while self.running:\n        self.print_message()\n        time.sleep(self.delay)\n```\n在spin函数中，如果plain_output为True，则直接调用print_message函数打印消息并返回。否则，通过while循环不断调用print_message函数打印消息，并通过time.sleep函数控制每次打印的时间间隔。\n\n```python\ndef update_message(self, new_message, delay=0.1):\n    \"\"\"更新旋转符号的消息和延迟时间。\n\n    Args:\n        new_message (str): 要显示的新消息。\n        delay (float): 每次旋转符号更新之间的延迟时间，单位为秒，默认为0.1。\n    \"\"\"\n    self.delay = delay\n    self.message = new_message\n    if self.plain_output:\n        self.print_message()\n```\n在update_message函数中，通过传入的参数更新旋转符号的消息和延迟时间。首先，将delay参数赋值给self.delay属性，将new_message参数赋值给self.message属性。然后，如果plain_output为True，则直接调用print_message函数打印消息。\n\n**注意**：在使用该代码时需要注意以下几点：\n- 该函数用于在控制台打印消息，并在消息前面添加旋转符号。\n- 如果需要实时更新消息，可以调用update_message函数更新消息内容。\n- 如果需要停止打印旋转符号的消息，可以将running属性设置为False。\n- 如果需要更改旋转符号的延迟时间，可以调用update_message函数更新delay参数的值。",
            "code_start_line": 55,
            "code_end_line": 61,
            "parent": "Spinner",
            "have_return": false,
            "code_content": "    def print_message(self):\n        \"\"\"\n        Prints the message with spinner symbol at the beginning and then erases it.\n        \"\"\"\n        sys.stdout.write(f\"\\r{' ' * (len(self.message) + 2)}\\r\")\n        sys.stdout.write(f\"{next(self.spinner)} {self.message}\\r\")\n        sys.stdout.flush()\n",
            "name_column": 8
        },
        "__enter__": {
            "type": "FunctionDef",
            "name": "__enter__",
            "md_content": "**__enter__函数**：该函数的功能是设置运行标记为True，并启动旋转线程。\n\n该函数是一个特殊的函数，用于实现上下文管理器。上下文管理器是一种用于管理资源的对象，它定义了在进入和退出特定代码块时要执行的操作。在Python中，上下文管理器通过实现`__enter__`和`__exit__`方法来实现。\n\n在这个函数中，首先将`running`标记设置为True，表示正在运行。然后创建一个线程，目标是调用`spin`方法，即旋转线程。最后，启动线程。\n\n该函数没有参数，返回值是`self`，即上下文管理器对象本身。\n\n**注意**：使用该代码时需要注意以下几点：\n- 该函数应该在上下文管理器对象中被调用，以便正确设置运行标记和启动旋转线程。\n- 在使用上下文管理器时，应该在代码块结束后调用`__exit__`方法，以便进行资源的清理和释放。\n\n**输出示例**：模拟代码返回值的可能外观。\n```python\n<spinner.Spinner object at 0x7f9a2e9d3a90>\n```",
            "code_start_line": 63,
            "code_end_line": 69,
            "parent": "Spinner",
            "have_return": true,
            "code_content": "    def __enter__(self):\n        \"\"\"Sets the running marker to True and starts the spinner thread.\"\"\"\n        self.running = True\n        self.spinner_thread = threading.Thread(target=self.spin)\n        self.spinner_thread.start()\n\n        return self\n",
            "name_column": 8
        },
        "__exit__": {
            "type": "FunctionDef",
            "name": "__exit__",
            "md_content": "**__exit__函数**：这个函数的作用是停止旋转器。\n\n在Python中，`__exit__`函数是一个特殊的方法，用于定义一个对象在退出上下文管理器时的行为。上下文管理器是一种用于管理资源的机制，它确保在使用完资源后能够正确地释放它们。\n\n该函数接受三个参数：`exc_type`、`exc_value`和`exc_traceback`，它们分别表示异常的类型、异常的值和异常的追踪信息。这些参数用于处理在上下文管理器中发生的异常情况。\n\n在函数体内，首先将`running`属性设置为False，以停止旋转器的运行。然后，通过调用`join()`方法等待`spinner_thread`线程的结束，以确保旋转器线程的正常退出。接下来，使用`sys.stdout.write()`函数将光标移动到行首，并使用`sys.stdout.flush()`函数刷新输出缓冲区，以清除旋转器的输出信息。\n\n**注意**：在使用该函数时，需要注意以下几点：\n- 该函数通常作为上下文管理器的一部分使用，用于定义资源的释放行为。\n- 在使用完资源后，应该调用`with`语句来确保正确地退出上下文管理器。\n- 如果在上下文管理器中发生异常，`__exit__`函数会接收到异常信息，并可以根据需要进行处理。\n\n希望这个文档能够帮助你理解`__exit__`函数的作用和用法。如果有任何疑问，请随时向我提问。",
            "code_start_line": 71,
            "code_end_line": 83,
            "parent": "Spinner",
            "have_return": false,
            "code_content": "    def __exit__(self, exc_type, exc_value, exc_traceback) -> None:\n        \"\"\"Stops the spinner.\n\n        Args:\n            exc_type (Exception): The exception type.\n            exc_value (Exception): The exception value.\n            exc_traceback (Exception): The exception traceback.\n        \"\"\"\n        self.running = False\n        if self.spinner_thread is not None:\n            self.spinner_thread.join()\n        sys.stdout.write(f\"\\r{' ' * (len(self.message) + 2)}\\r\")\n        sys.stdout.flush()\n",
            "name_column": 8
        },
        "update_message": {
            "type": "FunctionDef",
            "name": "update_message",
            "md_content": "**update_message函数**：此函数的功能是更新旋转器的消息和延迟。\n\n参数：\n- new_message (str)：要显示的新消息。\n- delay (float)：每次旋转器更新之间的延迟时间，以秒为单位。默认为0.1。\n\n该函数通过将delay和message属性更新为新的值来更新旋转器的消息和延迟时间。如果plain_output属性为True，则调用print_message()函数打印消息。\n\n**注意**：使用此代码时需要注意以下几点：\n- 调用update_message函数时，需要提供新的消息和可选的延迟时间。\n- 如果不提供延迟时间，默认延迟时间为0.1秒。\n- 如果plain_output属性为True，则会调用print_message()函数打印消息。",
            "code_start_line": 85,
            "code_end_line": 96,
            "parent": "Spinner",
            "have_return": false,
            "code_content": "    def update_message(self, new_message, delay=0.1):\n        \"\"\"Updates the message and the delay for the spinner.\n\n        Args:\n            new_message (str): New message to display.\n            delay (float): The delay in seconds between each spinner update.\n                           Defaults to 0.1.\n        \"\"\"\n        self.delay = delay\n        self.message = new_message\n        if self.plain_output:\n            self.print_message()",
            "name_column": 8
        }
    },
    "XAgent/global_vars.py": {},
    "XAgent/data_structure/tree.py": {
        "TaskSearchTree": {
            "type": "ClassDef",
            "name": "TaskSearchTree",
            "md_content": "**TaskSearchTree函数**: TaskSearchTree类的功能是表示具有特定任务搜索行为的树数据结构。\n\nTaskSearchTree类具有以下属性：\n- root (ToolNode): 树的根节点。\n- now_expand_num (int): 在遍历过程中维护节点的当前扩展编号。\n\nTaskSearchTree类具有以下方法：\n\n1. \\_\\_init\\_\\_()\n   - 描述：使用根节点和默认扩展编号初始化TaskSearchTree对象。\n   - 参数：无\n   - 返回值：无\n   - 异常：无\n\n2. get_depth()\n   - 描述：获取从当前根节点到树的深度。\n   - 参数：无\n   - 返回值：int类型，树的深度\n   - 异常：无\n\n3. get_subtree_size()\n   - 描述：获取从当前根节点开始的子树的节点数（或大小）。\n   - 参数：无\n   - 返回值：int类型，子树中的节点数\n   - 异常：无\n\n4. make_father_relation(father, child)\n   - 描述：在两个给定节点之间建立父子关系。\n   - 参数：\n     - father (ToolNode): 父节点。\n     - child (ToolNode): 子节点。\n   - 返回值：无\n   - 异常：\n     - TypeError: 如果father或child不是ToolNode实例。\n\n**注意**：\n- 父节点和子节点都需要是ToolNode的实例。\n\n**示例输出**：\n```python\ntree = TaskSearchTree()\ndepth = tree.get_depth()\nsubtree_size = tree.get_subtree_size()\nfather = ToolNode()\nchild = ToolNode()\ntree.make_father_relation(father, child)\n```",
            "code_start_line": 4,
            "code_end_line": 55,
            "parent": null,
            "have_return": true,
            "code_content": "class TaskSearchTree:\n    \"\"\"\n    TaskSearchTree represents a tree data structure with specific task searching behavior. \n\n    Attributes:\n        root (ToolNode): Root node of the tree.\n        now_expand_num (int): Maintains current expanding number for nodes during traversal.\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Initializes TaskSearchTree with a root ToolNode and default expanding number.\"\"\"\n        self.root: ToolNode = ToolNode()\n        self.root.expand_num = 0\n        self.now_expand_num = 1\n\n    def get_depth(self):\n        \"\"\"\n        Gets the depth of the tree from the current root node.\n\n        Returns:\n            int: The depth of the tree\n        \"\"\"\n        return self.root.get_depth()\n    \n    def get_subtree_size(self):\n        \"\"\"\n        Gets the number of nodes (or size) of the subtree from the current root node.\n\n        Returns:\n            int: The number of nodes in the subtree\n        \"\"\"\n        return self.root.get_subtree_size()\n    \n    def make_father_relation(self, father, child):\n        \"\"\"\n        Establishes a parent-child relationship between two given nodes.\n\n        Args:\n            father (ToolNode): The parent node in the relation.\n            child (ToolNode): The child node in the relation.\n\n        Raises:\n            TypeError: If the father or child is not a ToolNode instance.\n        \"\"\"\n        if not (isinstance(father, ToolNode) and isinstance(child, ToolNode)):\n            raise TypeError(\"Father and child both need to be instances of ToolNode.\")\n\n        child.expand_num = self.now_expand_num\n        self.now_expand_num += 1\n\n        child.father = father\n        father.children.append(child)",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__函数**：该函数的功能是初始化TaskSearchTree对象，包括创建一个根节点ToolNode和设置默认的扩展数量。\n\n在代码中，我们可以看到__init__函数没有任何参数，它是TaskSearchTree类的构造函数。在函数内部，首先创建了一个根节点ToolNode，并将其赋值给self.root。然后，将根节点的扩展数量设置为0，表示根节点不会被扩展。接着，将当前的扩展数量设置为1，表示当前已经扩展了一个节点。\n\n这个函数的作用是在创建TaskSearchTree对象时，初始化根节点和扩展数量的相关属性。\n\n**注意**：在使用该代码时需要注意以下几点：\n- 该函数没有参数，直接调用即可。\n- 初始化的根节点默认不会被扩展，如果需要扩展根节点，可以通过修改expand_num属性来实现。\n- 当前的扩展数量表示已经扩展的节点数量，可以根据需要进行修改。",
            "code_start_line": 13,
            "code_end_line": 17,
            "parent": "TaskSearchTree",
            "have_return": false,
            "code_content": "    def __init__(self):\n        \"\"\"Initializes TaskSearchTree with a root ToolNode and default expanding number.\"\"\"\n        self.root: ToolNode = ToolNode()\n        self.root.expand_num = 0\n        self.now_expand_num = 1\n",
            "name_column": 8
        },
        "get_depth": {
            "type": "FunctionDef",
            "name": "get_depth",
            "md_content": "**get_depth函数**：该函数的功能是获取当前根节点的树的深度。\n\n该函数通过调用根节点的get_depth方法来获取树的深度。\n\n**注意**：使用该代码时需要注意以下几点：\n- 该函数需要在Tree对象上调用。\n- 该函数返回一个整数，表示树的深度。\n\n**输出示例**：假设树的深度为3，则函数返回值为3。",
            "code_start_line": 19,
            "code_end_line": 26,
            "parent": "TaskSearchTree",
            "have_return": true,
            "code_content": "    def get_depth(self):\n        \"\"\"\n        Gets the depth of the tree from the current root node.\n\n        Returns:\n            int: The depth of the tree\n        \"\"\"\n        return self.root.get_depth()\n",
            "name_column": 8
        },
        "get_subtree_size": {
            "type": "FunctionDef",
            "name": "get_subtree_size",
            "md_content": "**get_subtree_size函数**：该函数的功能是获取当前根节点的子树中的节点数（或大小）。\n\n该函数通过调用根节点的get_subtree_size方法来获取子树的节点数。\n\n**注意**：使用该代码时需要注意以下几点：\n- 该函数只能在已经创建了根节点的情况下调用，否则会抛出异常。\n- 子树的节点数不包括根节点本身。\n\n**输出示例**：假设当前根节点的子树中有5个节点，则函数返回值为5。",
            "code_start_line": 28,
            "code_end_line": 35,
            "parent": "TaskSearchTree",
            "have_return": true,
            "code_content": "    def get_subtree_size(self):\n        \"\"\"\n        Gets the number of nodes (or size) of the subtree from the current root node.\n\n        Returns:\n            int: The number of nodes in the subtree\n        \"\"\"\n        return self.root.get_subtree_size()\n",
            "name_column": 8
        },
        "make_father_relation": {
            "type": "FunctionDef",
            "name": "make_father_relation",
            "md_content": "**make_father_relation函数**：该函数的功能是在两个给定的节点之间建立父子关系。\n\n该函数接受两个参数：\n- father（ToolNode类型）：关系中的父节点。\n- child（ToolNode类型）：关系中的子节点。\n\n如果father或child不是ToolNode的实例，则会引发TypeError异常。\n\n在函数内部，首先通过判断father和child是否为ToolNode的实例，如果不是，则抛出TypeError异常，提示father和child都需要是ToolNode的实例。\n\n然后，将child的expand_num属性设置为当前的expand_num值，并将expand_num值加1，用于标识节点的扩展顺序。\n\n接下来，将child的father属性设置为father节点，并将child添加到father的children列表中。\n\n**注意**：使用该代码需要注意以下几点：\n- father和child参数必须是ToolNode的实例。\n- 使用该函数时，需要确保father和child节点已经创建，并且已经在树中存在。",
            "code_start_line": 37,
            "code_end_line": 55,
            "parent": "TaskSearchTree",
            "have_return": false,
            "code_content": "    def make_father_relation(self, father, child):\n        \"\"\"\n        Establishes a parent-child relationship between two given nodes.\n\n        Args:\n            father (ToolNode): The parent node in the relation.\n            child (ToolNode): The child node in the relation.\n\n        Raises:\n            TypeError: If the father or child is not a ToolNode instance.\n        \"\"\"\n        if not (isinstance(father, ToolNode) and isinstance(child, ToolNode)):\n            raise TypeError(\"Father and child both need to be instances of ToolNode.\")\n\n        child.expand_num = self.now_expand_num\n        self.now_expand_num += 1\n\n        child.father = father\n        father.children.append(child)",
            "name_column": 8
        }
    },
    "XAgent/data_structure/plan.py": {
        "Plan": {
            "type": "ClassDef",
            "name": "Plan",
            "md_content": "**Plan类**\n\nPlan类表示一个任务计划。\n\n属性:\n- father (Optional[Plan]): 父任务计划。\n- children (List[Plan]): 子任务计划列表。\n- data (TaskSaveItem): 与任务计划相关的数据项。\n- process_node (ToolNode): 负责任务计划处理的节点。\n\n方法:\n- `__init__(self, data: TaskSaveItem)`: 初始化一个Plan对象。\n- `to_json(self, posterior=True) -> dict`: 将Plan对象转换为JSON格式。\n- `get_subtask_id(self, to_str=False) -> Union[list, str]`: 获取子任务ID。\n- `get_subtask_id_list(self) -> List[int]`: 获取子任务ID列表。\n- `get_root(self) -> Plan`: 获取Plan树的根节点。\n- `get_depth(self) -> int`: 获取Plan树的深度。\n- `get_inorder_travel(cls, now_plan) -> List[Plan]`: 对Plan树进行中序遍历。\n- `pop_next_subtask(cls, now_plan) -> Optional[Plan]`: 获取队列中的下一个子任务。\n- `get_remaining_subtask(cls, now_plan) -> List[Plan]`: 从给定点获取所有剩余的子任务。\n- `make_relation(cls, father, child)`: 在两个计划之间建立父子关系。\n\n**注意**: Plan类用于表示任务计划，包含了任务计划的各种属性和方法。可以通过to_json方法将Plan对象转换为JSON格式，通过get_subtask_id方法获取子任务ID，通过get_root方法获取Plan树的根节点，通过get_depth方法获取Plan树的深度，通过get_inorder_travel方法对Plan树进行中序遍历等。\n\n**输出示例**:\n```\n{\n  \"father\": null,\n  \"children\": [],\n  \"data\": {\n    \"name\": \"task1\",\n    \"goal\": \"complete task1\",\n    ...\n  },\n  \"process_node\": null\n}\n```\n\n**注意**: 以上示例为Plan对象的JSON格式表示。",
            "code_start_line": 5,
            "code_end_line": 152,
            "parent": null,
            "have_return": true,
            "code_content": "class Plan():\n    \"\"\"Class representing a task plan.\n\n    Attributes:\n        father (Optional[Plan]): Parent task plan.\n        children (List[Plan]): List of child task plans.\n        data (TaskSaveItem): Data items related to the task plan.\n        process_node (ToolNode): Node responsible for the task plan processing.\n    \"\"\"\n    \n    def __init__(self, data: TaskSaveItem):\n        \"\"\"Initialises a Plan object.\n\n        Args:\n            data (TaskSaveItem): Data related to the task plan.\n        \"\"\"\n        self.father: Optional[Plan] = None\n        self.children: List[Plan] = []\n        self.data: TaskSaveItem = data\n        self.process_node: ToolNode = None \n    \n    def to_json(self, posterior=True):\n        \"\"\"Converts Plan object to JSON.\n\n        Args:\n            posterior (bool): Determines whether the task's posterior data \n                              is also returned.\n\n        Returns:\n            root_json (dict): JSON format representation of the Plan object.\n        \"\"\"\n        root_json = self.data.to_json(posterior=posterior)\n        if self.process_node:\n            root_json[\"submit_result\"] = self.process_node.data[\"command\"][\"properties\"]\n\n        # if self.father != None:\n        root_json[\"task_id\"] = self.get_subtask_id(to_str=True)\n        if len(self.children) > 0:\n            root_json[\"subtask\"] = [ subtask.to_json() for subtask in self.children]\n        return root_json\n    \n    def get_subtask_id(self, to_str=False):\n        \"\"\"Gets the subtask ID.\n\n        Args:\n            to_str (bool): Determines if returned ID is string.\n\n        Returns:\n            subtask_id_list (list): List of subtask IDs.\n        \"\"\"\n        subtask_id_list = self.get_subtask_id_list()\n        if to_str:\n            subtask_id_list = [str(cont) for cont in subtask_id_list]\n            return \".\".join(subtask_id_list)\n        else:\n            return subtask_id_list\n\n    def get_subtask_id_list(self):\n        \"\"\"Gets the subtask ID list.\n\n        Returns:\n            Array of subtask IDs if father is not none else [1].\n        \"\"\"\n        if self.father == None:\n            return [1]\n        father_subtask_id = self.father.get_subtask_id()\n        child_id = self.father.children.index(self) + 1\n        father_subtask_id.append(child_id)\n        return father_subtask_id\n    \n    @classmethod\n    def make_relation(cls, father, child):\n        \"\"\"Establishes a parent-child relationship between two plans.\n\n        Args:\n            father: Parent plan.\n            child: Child plan.\n        \"\"\"\n        father.children.append(child)\n        child.father = father\n\n    def get_root(self):\n        \"\"\"Fetches the root of the Plan tree.\n\n        Returns:\n            Root Plan object.\n        \"\"\"\n        if self.father == None:\n            return self\n        return self.father.get_root()\n\n    def get_depth(self):\n        \"\"\"Returns the depth of the Plan tree.\n\n        Returns:\n            Tree depth as an integer.\n        \"\"\"\n        if self.father == None:\n            return 1\n        return 1 + self.father.get_depth()\n\n    @classmethod\n    def get_inorder_travel(cls, now_plan):\n        \"\"\"Performs an inorder traversal of the plan tree.\n\n        Args:\n            now_plan: Current plan in the tree.\n\n        Returns:\n            All plans in the tree in inorder.\n        \"\"\"\n        result_list = [now_plan]\n        for child in now_plan.children:\n            result_list.extend(Plan.get_inorder_travel(child))\n        return result_list\n\n    @classmethod\n    def pop_next_subtask(cls, now_plan):\n        \"\"\"Fetches the next subtask in the queue.\n\n        Args:\n            now_plan: Current plan in the tree.\n\n        Returns:\n            Next subtask in the queue.\n        \"\"\"\n        root_plan = now_plan.get_root()\n        all_plans = Plan.get_inorder_travel(root_plan)\n        order_id = all_plans.index(now_plan)\n        for subtask in all_plans[order_id + 1:]:\n            if subtask.data.status == TaskStatusCode.TODO:\n                return subtask\n        return None\n\n    @classmethod\n    def get_remaining_subtask(cls, now_plan):\n        \"\"\"Gets all remaining subtasks from a given point.\n\n        Args:\n            now_plan: Current plan in the tree.\n\n        Returns:\n            Array of all remaining subtasks.\n        \"\"\"\n        root_plan = now_plan.get_root()\n        all_plans = Plan.get_inorder_travel(root_plan)\n        order_id = all_plans.index(now_plan)\n        return all_plans[order_id:]",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__函数**：这个函数的作用是初始化一个Plan对象。\n\n该函数接受一个TaskSaveItem类型的参数data，用于保存与任务计划相关的数据。\n\n在函数体内部，首先初始化了father属性，它是一个可选的Plan对象，用于保存父节点。然后初始化了children属性，它是一个Plan对象的列表，用于保存子节点。接下来初始化了data属性，它保存了TaskSaveItem类型的数据。最后，初始化了process_node属性，它是一个ToolNode对象，用于保存处理节点。\n\n**注意**：使用该代码时需要注意以下几点：\n- 参数data必须是TaskSaveItem类型的对象。\n- father属性和children属性可以为空，但需要在后续操作中进行正确的赋值。\n- process_node属性可以为空，需要根据具体情况进行赋值。",
            "code_start_line": 15,
            "code_end_line": 24,
            "parent": "Plan",
            "have_return": false,
            "code_content": "    def __init__(self, data: TaskSaveItem):\n        \"\"\"Initialises a Plan object.\n\n        Args:\n            data (TaskSaveItem): Data related to the task plan.\n        \"\"\"\n        self.father: Optional[Plan] = None\n        self.children: List[Plan] = []\n        self.data: TaskSaveItem = data\n        self.process_node: ToolNode = None \n",
            "name_column": 8
        },
        "to_json": {
            "type": "FunctionDef",
            "name": "to_json",
            "md_content": "**to_json函数**: 这个函数的功能是将Plan对象转换为JSON格式。\n\n该函数接受一个参数posterior，用于确定是否返回任务的后验数据。\n\n返回一个root_json字典，它是Plan对象的JSON格式表示。\n\n该函数首先调用self.data.to_json(posterior=posterior)将Plan对象的data属性转换为JSON格式，并将结果赋值给root_json。\n\n如果self.process_node存在，将self.process_node.data[\"command\"][\"properties\"]赋值给root_json的\"submit_result\"键。\n\n然后，将self.get_subtask_id(to_str=True)的返回值赋值给root_json的\"task_id\"键。\n\n如果self.children的长度大于0，将遍历self.children列表，将每个子任务的to_json()结果添加到root_json的\"subtask\"键下。\n\n最后，返回root_json。\n\n**注意**: \n- 参数posterior是一个布尔值，用于确定是否返回任务的后验数据。\n- 如果self.process_node存在，将self.process_node.data[\"command\"][\"properties\"]添加到root_json中的\"submit_result\"键下。\n- 如果self.father不为None，将self.get_subtask_id(to_str=True)的返回值添加到root_json中的\"task_id\"键下。\n- 如果self.children的长度大于0，将遍历self.children列表，并将每个子任务的to_json()结果添加到root_json的\"subtask\"键下。\n\n**输出示例**:\n```\n{\n  \"task_id\": \"123456\",\n  \"subtask\": [\n    {\n      \"task_id\": \"123456-1\",\n      \"name\": \"子任务1\",\n      \"goal\": \"完成子任务1\",\n      \"handler\": \"处理子任务1\",\n      \"tool_budget\": 100,\n      \"subtask\": []\n    },\n    {\n      \"task_id\": \"123456-2\",\n      \"name\": \"子任务2\",\n      \"goal\": \"完成子任务2\",\n      \"handler\": \"处理子任务2\",\n      \"tool_budget\": 200,\n      \"subtask\": []\n    }\n  ]\n}\n```",
            "code_start_line": 26,
            "code_end_line": 44,
            "parent": "Plan",
            "have_return": true,
            "code_content": "    def to_json(self, posterior=True):\n        \"\"\"Converts Plan object to JSON.\n\n        Args:\n            posterior (bool): Determines whether the task's posterior data \n                              is also returned.\n\n        Returns:\n            root_json (dict): JSON format representation of the Plan object.\n        \"\"\"\n        root_json = self.data.to_json(posterior=posterior)\n        if self.process_node:\n            root_json[\"submit_result\"] = self.process_node.data[\"command\"][\"properties\"]\n\n        # if self.father != None:\n        root_json[\"task_id\"] = self.get_subtask_id(to_str=True)\n        if len(self.children) > 0:\n            root_json[\"subtask\"] = [ subtask.to_json() for subtask in self.children]\n        return root_json\n",
            "name_column": 8
        },
        "get_subtask_id": {
            "type": "FunctionDef",
            "name": "get_subtask_id",
            "md_content": "**get_subtask_id函数**：该函数用于获取子任务的ID。\n\n该函数接受一个布尔值参数`to_str`，用于确定返回的ID是否为字符串类型。\n\n返回值为一个列表，包含子任务的ID。\n\n注意：如果`to_str`为True，则返回的ID为字符串类型；否则返回的ID为整数类型。\n\n**输出示例**：假设`to_str`为False，子任务的ID列表为[1, 2, 3]，则函数的返回值为[1, 2, 3]。\n\n该函数在以下文件中被调用：\n\n文件路径：XAgent/data_structure/plan.py\n调用代码如下：\n```python\nroot_json[\"task_id\"] = self.get_subtask_id(to_str=True)\n```\n\n文件路径：XAgent/workflow/plan_exec.py\n调用代码如下：\n```python\nsubtask_id = now_dealing_task.get_subtask_id(to_str=True)\n```\n\n文件路径：XAgent/workflow/task_handler.py\n调用代码如下：\n```python\ntask_id = self.now_dealing_task.get_subtask_id(to_str=True)\n```\n\n文件路径：XAgent/workflow/working_memory.py\n调用代码如下：\n```python\nsubtask_id = terminal_plan.get_subtask_id(to_str=True)\n```\n\n请注意：\n- 生成的文档内容不应包含Markdown的标题和分隔符语法。\n- 文档主要使用中文撰写，如果需要，可以在分析和描述中使用一些英文单词以增强文档的可读性，因为不需要将函数名或变量名翻译为目标语言。",
            "code_start_line": 46,
            "code_end_line": 60,
            "parent": "Plan",
            "have_return": true,
            "code_content": "    def get_subtask_id(self, to_str=False):\n        \"\"\"Gets the subtask ID.\n\n        Args:\n            to_str (bool): Determines if returned ID is string.\n\n        Returns:\n            subtask_id_list (list): List of subtask IDs.\n        \"\"\"\n        subtask_id_list = self.get_subtask_id_list()\n        if to_str:\n            subtask_id_list = [str(cont) for cont in subtask_id_list]\n            return \".\".join(subtask_id_list)\n        else:\n            return subtask_id_list\n",
            "name_column": 8
        },
        "get_subtask_id_list": {
            "type": "FunctionDef",
            "name": "get_subtask_id_list",
            "md_content": "**get_subtask_id_list函数**：此函数的功能是获取子任务ID列表。\n\n该函数用于获取当前任务的子任务ID列表。如果当前任务没有父任务，则返回一个包含1的数组；否则，获取父任务的子任务ID列表，并将当前任务的ID添加到列表末尾。\n\n**注意**：在使用此函数时需要注意以下几点：\n- 该函数依赖于父任务的存在，如果当前任务没有父任务，则返回默认的子任务ID列表。\n- 在调用该函数之前，需要确保当前任务的父任务已经设置。\n\n**输出示例**：假设当前任务的父任务ID为2，当前任务的ID为3，则函数的返回值为[2, 3]。",
            "code_start_line": 62,
            "code_end_line": 73,
            "parent": "Plan",
            "have_return": true,
            "code_content": "    def get_subtask_id_list(self):\n        \"\"\"Gets the subtask ID list.\n\n        Returns:\n            Array of subtask IDs if father is not none else [1].\n        \"\"\"\n        if self.father == None:\n            return [1]\n        father_subtask_id = self.father.get_subtask_id()\n        child_id = self.father.children.index(self) + 1\n        father_subtask_id.append(child_id)\n        return father_subtask_id\n",
            "name_column": 8
        },
        "make_relation": {
            "type": "FunctionDef",
            "name": "make_relation",
            "md_content": "**make_relation函数**：此函数的功能是在两个计划之间建立父子关系。\n\n此函数接受两个参数：father（父计划）和child（子计划），并将child添加到father的children列表中，并将father设置为child的father。\n\n在项目中，此函数在以下文件中被调用：\n文件路径：XAgent/workflow/plan_exec.py\n对应代码如下：\n```python\ndef initial_plan_generation(self, agent_dispatcher):\n    \"\"\"生成初始计划。\n\n    通过调用计划生成代理，此方法生成初始计划。\n    \"\"\"\n    logger.typewriter_log(\n        f\"-=-=-=-=-=-=-= 生成初始计划 -=-=-=-=-=-=-=\",\n        Fore.GREEN,\n        \"\",\n    )\n\n    split_functions = deepcopy(function_manager.get_function_schema('subtask_split_operation'))\n\n    agent = agent_dispatcher.dispatch(\n        RequiredAbilities.plan_generation,\n        target_task=f\"生成完成任务的计划：{self.query.task}\",\n        # avaliable_tools_description_list=self.avaliable_tools_description_list\n    )\n\n    # TODO: not robust. dispatcher generated prompt may not contain these specified placeholders?\n    new_message , _ = agent.parse(\n        placeholders={\n            \"system\": {\n                # \"avaliable_tool_descriptions\": json.dumps(self.avaliable_tools_description_list, indent=2, ensure_ascii=False),\n                \"avaliable_tool_names\": str([cont[\"name\"] for cont in self.avaliable_tools_description_list]),\n            },\n            \"user\": {\n                \"query\": self.plan.data.raw\n            }\n        },\n        arguments=deepcopy(function_manager.get_function_schema('simple_thought')['parameters']),\n        functions=[split_functions], \n    )\n    \n    subtasks = json5.loads(new_message[\"function_call\"][\"arguments\"])\n\n    for subtask_item in subtasks[\"subtasks\"]:\n        subplan = plan_function_output_parser(subtask_item)\n        Plan.make_relation(self.plan, subplan)\n```\n对应代码如下：\n```python\ndef deal_subtask_split(self, function_input: dict, now_dealing_task: Plan) -> (str, PlanOperationStatusCode):\n    \"\"\"处理子任务拆分。\n\n    此方法处理子任务拆分。\n\n    参数：\n        function_input (dict)：函数输入。\n        now_dealing_task (Plan)：当前正在处理的任务。\n\n    返回：\n        str：函数输出。\n        PlanOperationStatusCode：状态码。\n    \"\"\"\n    print(json.dumps(function_input,indent=2,ensure_ascii=False))\n\n    inorder_subtask_stack = Plan.get_inorder_travel(self.plan)\n    target_subtask_id = function_input[\"target_subtask_id\"].strip()\n    all_subtask_ids = [cont.get_subtask_id(to_str=True) for cont in inorder_subtask_stack]\n\n    can_edit = False\n    for k, subtask in enumerate(inorder_subtask_stack):\n        if subtask.get_subtask_id(to_str=True) == now_dealing_task.get_subtask_id(to_str=True):\n            \n            can_edit = True\n\n        if subtask.get_subtask_id(to_str=True) == target_subtask_id:\n            if not can_edit:\n                return json.dumps({\"error\": f\"您只能与当前正在处理的子任务一起拆分TODO子任务计划，例如'>= {now_dealing_task.get_subtask_id(to_str=True)}'。未发生任何操作。\"}), PlanOperationStatusCode.MODIFY_FORMER_PLAN\n            \n            # if not subtask.data.status == TaskStatusCode.FAIL:\n            #     return json.dumps({\"error\": f\"You can only split the FAIL subtask plans together. This is a '{subtask.data.status.name}' Task. Nothing happended\"}), PlanOperationStatusCode.OTHER_ERROR\n\n            if subtask.get_depth() >= self.config.max_plan_tree_depth:\n                return json.dumps({\"error\": f\"计划树的最大深度为{self.config.max_plan_tree_depth}。'{subtask.data.name}'的深度已达到{subtask.get_depth()}。未发生任何操作。\"}), PlanOperationStatusCode.OTHER_ERROR\n\n            for new_subtask in function_input[\"subtasks\"]:\n                new_subplan = plan_function_output_parser(new_subtask)\n                Plan.make_relation(subtask,new_subplan)\n            subtask.data.status = TaskStatusCode.SPLIT\n            return json.dumps({\"success\": f\"子任务'{target_subtask_id}'已拆分。\"}), PlanOperationStatusCode.MODIFY_SUCCESS\n\n    return json.dumps({\"error\": f\"未找到目标子任务ID '{target_subtask_id}'。未发生任何操作。\"}), PlanOperationStatusCode.TARGET_SUBTASK_NOT_FOUND\n```\n【注意】：关于代码使用的注意事项",
            "code_start_line": 76,
            "code_end_line": 84,
            "parent": "Plan",
            "have_return": false,
            "code_content": "    def make_relation(cls, father, child):\n        \"\"\"Establishes a parent-child relationship between two plans.\n\n        Args:\n            father: Parent plan.\n            child: Child plan.\n        \"\"\"\n        father.children.append(child)\n        child.father = father\n",
            "name_column": 8
        },
        "get_root": {
            "type": "FunctionDef",
            "name": "get_root",
            "md_content": "**get_root函数**：此函数的功能是获取计划树的根节点。\n\n该函数用于获取计划树的根节点。计划树是一个层次结构，由多个计划对象组成，每个计划对象都可以有一个父节点和多个子节点。根节点是计划树的最顶层节点，它没有父节点。\n\n该函数首先判断当前计划对象是否有父节点，如果没有父节点，则说明当前计划对象就是根节点，直接返回当前计划对象。如果有父节点，则递归调用父节点的get_root函数，直到找到根节点为止。\n\n**注意**：在使用该函数时需要注意以下几点：\n- 该函数只能在计划对象中调用，不能在其他对象中调用。\n- 确保计划对象的父子关系正确设置，否则可能导致获取到错误的根节点。\n\n**输出示例**：假设当前计划对象为根节点，则返回当前计划对象本身。",
            "code_start_line": 86,
            "code_end_line": 94,
            "parent": "Plan",
            "have_return": true,
            "code_content": "    def get_root(self):\n        \"\"\"Fetches the root of the Plan tree.\n\n        Returns:\n            Root Plan object.\n        \"\"\"\n        if self.father == None:\n            return self\n        return self.father.get_root()\n",
            "name_column": 8
        },
        "get_depth": {
            "type": "FunctionDef",
            "name": "get_depth",
            "md_content": "**get_depth函数**：该函数的功能是返回计划树的深度。\n\n该函数通过递归调用父节点的get_depth函数来计算计划树的深度。如果当前节点没有父节点，则返回1，表示当前节点是根节点。否则，返回父节点的深度加1，表示当前节点的深度。\n\n**注意**：该函数依赖于父节点的get_depth函数，因此在调用该函数之前，需要确保父节点已经正确设置。\n\n**输出示例**：假设计划树的深度为3，则函数的返回值为3。",
            "code_start_line": 96,
            "code_end_line": 104,
            "parent": "Plan",
            "have_return": true,
            "code_content": "    def get_depth(self):\n        \"\"\"Returns the depth of the Plan tree.\n\n        Returns:\n            Tree depth as an integer.\n        \"\"\"\n        if self.father == None:\n            return 1\n        return 1 + self.father.get_depth()\n",
            "name_column": 8
        },
        "get_inorder_travel": {
            "type": "FunctionDef",
            "name": "get_inorder_travel",
            "md_content": "**get_inorder_travel函数**：此函数的功能是执行计划树的中序遍历。\n\n此函数接受一个参数now_plan，表示当前树中的计划。\n\n函数会返回树中所有计划的中序遍历结果。\n\n函数首先将当前计划now_plan添加到结果列表result_list中。\n\n然后对于当前计划的每个子计划，递归调用get_inorder_travel函数，并将返回的结果列表添加到result_list中。\n\n最后返回result_list作为函数的输出结果。\n\n**注意**：此函数的使用需要注意以下几点：\n- 参数now_plan必须是一个有效的计划对象。\n- 函数返回的结果是一个包含所有计划的列表。\n\n**输出示例**：假设树中有三个计划A、B、C，其中A是B的父计划，B是C的父计划。调用get_inorder_travel函数时，传入的参数为A，函数的返回结果为[A, B, C]。",
            "code_start_line": 107,
            "code_end_line": 119,
            "parent": "Plan",
            "have_return": true,
            "code_content": "    def get_inorder_travel(cls, now_plan):\n        \"\"\"Performs an inorder traversal of the plan tree.\n\n        Args:\n            now_plan: Current plan in the tree.\n\n        Returns:\n            All plans in the tree in inorder.\n        \"\"\"\n        result_list = [now_plan]\n        for child in now_plan.children:\n            result_list.extend(Plan.get_inorder_travel(child))\n        return result_list\n",
            "name_column": 8
        },
        "pop_next_subtask": {
            "type": "FunctionDef",
            "name": "pop_next_subtask",
            "md_content": "**pop_next_subtask函数**：这个函数的功能是从队列中获取下一个子任务。\n\n该函数接受一个参数now_plan，表示当前的计划。\n\n函数内部首先获取根计划root_plan，然后通过Plan类的get_inorder_travel方法获取所有计划的按顺序遍历列表all_plans。接着，通过index方法找到当前计划在列表中的位置order_id。然后，从order_id+1位置开始遍历all_plans列表，找到第一个状态为TODO的子任务subtask，并返回该子任务。\n\n如果没有找到符合条件的子任务，则返回None。\n\n**注意**：在使用该代码时需要注意以下几点：\n- 该函数需要传入一个当前计划对象now_plan。\n- 返回值为下一个子任务对象，如果没有符合条件的子任务则返回None。\n\n**输出示例**：假设队列中有多个子任务，返回下一个子任务对象。\n\n```python\nsubtask = Plan.pop_next_subtask(now_plan)\nprint(subtask)\n```\n输出：\n```\n<Plan object at 0x7f8a7b7e4af0>\n```",
            "code_start_line": 122,
            "code_end_line": 137,
            "parent": "Plan",
            "have_return": true,
            "code_content": "    def pop_next_subtask(cls, now_plan):\n        \"\"\"Fetches the next subtask in the queue.\n\n        Args:\n            now_plan: Current plan in the tree.\n\n        Returns:\n            Next subtask in the queue.\n        \"\"\"\n        root_plan = now_plan.get_root()\n        all_plans = Plan.get_inorder_travel(root_plan)\n        order_id = all_plans.index(now_plan)\n        for subtask in all_plans[order_id + 1:]:\n            if subtask.data.status == TaskStatusCode.TODO:\n                return subtask\n        return None\n",
            "name_column": 8
        },
        "get_remaining_subtask": {
            "type": "FunctionDef",
            "name": "get_remaining_subtask",
            "md_content": "**get_remaining_subtask函数**：此函数的功能是从给定的点获取所有剩余的子任务。\n\n该函数接受一个参数now_plan，表示当前的计划。\n\n函数内部首先获取当前计划的根节点root_plan，然后通过调用Plan类的get_inorder_travel方法获取所有计划的中序遍历结果all_plans。接着，函数通过调用index方法找到当前计划在中序遍历结果中的索引order_id。最后，函数返回从order_id位置开始的所有计划，即剩余的子任务。\n\n**注意**：此函数需要一个Plan对象作为输入参数。\n\n**输出示例**：假设all_plans为[plan1, plan2, plan3, plan4]，order_id为2，则函数返回[plan3, plan4]。",
            "code_start_line": 140,
            "code_end_line": 152,
            "parent": "Plan",
            "have_return": true,
            "code_content": "    def get_remaining_subtask(cls, now_plan):\n        \"\"\"Gets all remaining subtasks from a given point.\n\n        Args:\n            now_plan: Current plan in the tree.\n\n        Returns:\n            Array of all remaining subtasks.\n        \"\"\"\n        root_plan = now_plan.get_root()\n        all_plans = Plan.get_inorder_travel(root_plan)\n        order_id = all_plans.index(now_plan)\n        return all_plans[order_id:]",
            "name_column": 8
        }
    },
    "XAgent/data_structure/__init__.py": {},
    "XAgent/data_structure/node.py": {
        "Node": {
            "type": "ClassDef",
            "name": "Node",
            "md_content": "**Node类功能**：Node类是XAgent数据结构中表示通用节点的抽象类。\n\n该类使用abc模块将其标记为抽象基类。其他类应该继承自该类以实现特定类型的节点。\n\n**Node类属性**：\n- 无\n\n**Node类方法**：\n- \\_\\_init\\_\\_(self)：初始化一个新的节点。作为抽象类，Node没有任何具体的实现细节。\n\n**ToolNode类功能**：ToolNode类是XAgent数据结构中表示工具节点的类。\n\n工具节点具有“father”属性，表示其父节点；“children”属性，表示其子节点列表；“data”属性，包含有关节点状态、命令、工具输出和思考属性的元数据；还包括消息历史和工作空间哈希ID。\n\n**ToolNode类属性**：\n- father: ToolNode类型，表示父节点。\n- children: ToolNode类型的列表，表示子节点列表。\n- expand_num: 表示展开次数的整数。\n- data: 包含有关节点状态、命令、工具输出和思考属性的字典。\n- history: MessageHistory类型，表示消息历史。\n- workspace_hash_id: 表示工作空间哈希ID的字符串。\n\n**ToolNode类方法**：\n- \\_\\_init\\_\\_(self)：初始化一个新的工具节点。为实例设置father、children、expand_num、data、history和workspace_hash_id属性。\n- process(self)：生成从当前节点到根节点的数据列表。返回一个包含从当前节点到根节点的数据列表。\n- to_json(self)：将实例的data属性转换为JSON兼容格式。返回一个以JSON兼容格式表示的实例的data属性。\n- get_depth(self)：计算当前节点在树中的深度。返回节点的深度，如果节点是根节点则返回0。\n- get_subtree_size(self)：计算以当前节点为根节点的子树的大小。返回以当前节点为根节点的子树的大小。\n\n**SummarizationNode类功能**：SummarizationNode类用于表示摘要树中的节点。\n\n继承自XAgent.data_structure.node中定义的Node类。\n\n**SummarizationNode类属性**：\n- father: SummarizationNode类型，表示父节点。\n- children: SummarizationNode类型的列表，表示子节点列表。\n- message: Message类型，与该节点关联的消息。\n- summarization_from_root_to_here: 从根节点到该节点的摘要。\n\n**SummarizationNode类方法**：\n- \\_\\_init\\_\\_(self)：初始化一个新的SummarizationNode。设置father、children、message和summarization_from_root_to_here属性。\n- add_father_child_relation(cls, father, child)：添加父节点和子节点之间的关系。将子节点添加到父节点的子节点列表中。\n\n**注意**：在使用这些代码时，请注意以下几点：\n- Node类是一个抽象类，不能直接实例化。\n- ToolNode类表示工具节点，包含了工具节点的属性和方法。\n- SummarizationNode类表示摘要树中的节点，包含了摘要节点的属性和方法。",
            "code_start_line": 10,
            "code_end_line": 23,
            "parent": null,
            "have_return": false,
            "code_content": "class Node(metaclass = abc.ABCMeta):\n    \"\"\"\n    Abstract class representing a generic node in the XAgent's data structure.\n\n    This class uses the abc module to denote it as an abstract base class.\n    Other classes should inherit from this class to implement specific types of nodes.\n    \"\"\"\n    def __init__(self):\n        \"\"\"\n        Initialize a new node.\n\n        As an abstract class, Node does not have any implementation details.\n        \"\"\"\n        pass\n",
            "name_column": 6
        },
        "ToolNode": {
            "type": "ClassDef",
            "name": "ToolNode",
            "md_content": "**ToolNode类的功能**：ToolNode类是XAgent数据结构中表示工具节点的类。\n\nToolNode类表示XAgent数据结构中的工具节点。工具节点具有“father”属性，表示其父节点；“children”属性，表示其子节点；“data”属性，包含有关节点状态、命令、工具输出和思考属性的元数据；还包含消息历史和工作空间哈希ID。\n\nToolNode类具有以下方法：\n\n- `__init__(self)`: 初始化一个新的工具节点。为实例设置father、children、expand_num、data、history和workspace_hash_id属性。\n- `process(self)`: 生成从当前节点到根节点的数据列表。返回一个从当前节点到根节点的数据列表。\n- `to_json(self)`: 将实例的data属性转换为JSON兼容格式。返回实例的data属性以JSON兼容格式表示的字典。\n- `get_depth(self)`: 计算树中当前节点的深度。返回节点的深度。如果节点是根节点，则返回0。\n- `get_subtree_size(self)`: 计算以当前节点为根的子树的大小。返回以当前节点为根的子树的大小。\n\n**注意**：ToolNode类是XAgent数据结构中表示工具节点的类。它具有父节点、子节点、数据、历史记录和工作空间哈希ID等属性。它还提供了一些方法来处理节点的数据和计算节点的深度和子树大小。\n\n**示例输出**：\n```python\n# 创建一个ToolNode实例\nnode = ToolNode()\n\n# 设置节点的数据属性\nnode.data = {\n    \"content\": \"This is the content\",\n    \"thoughts\": {\n        \"properties\": {\n            \"thought\": \"This is a thought\",\n            \"reasoning\": \"This is a reasoning\",\n            \"plan\": \"This is a plan\",\n            \"criticism\": \"This is a criticism\"\n        }\n    },\n    \"command\": {\n        \"properties\": {\n            \"name\": \"command_name\",\n            \"args\": \"command_args\"\n        }\n    },\n    \"tool_output\": \"This is the tool output\",\n    \"tool_status_code\": \"TOOL_CALL_SUCCESS\"\n}\n\n# 获取节点的深度\ndepth = node.get_depth()\nprint(depth)  # 输出: 0\n\n# 获取以当前节点为根的子树的大小\nsubtree_size = node.get_subtree_size()\nprint(subtree_size)  # 输出: 1\n\n# 将节点的数据属性转换为JSON兼容格式\njson_data = node.to_json()\nprint(json_data)\n# 输出: \n# {\n#     \"content\": \"This is the content\",\n#     \"thoughts\": {\n#         \"properties\": {\n#             \"thought\": \"This is a thought\",\n#             \"reasoning\": \"This is a reasoning\",\n#             \"plan\": \"This is a plan\",\n#             \"criticism\": \"This is a criticism\"\n#         }\n#     },\n#     \"command\": {\n#         \"properties\": {\n#             \"name\": \"command_name\",\n#             \"args\": \"command_args\"\n#         }\n#     },\n#     \"tool_output\": \"This is the tool output\",\n#     \"tool_status_code\": \"TOOL_CALL_SUCCESS\"\n# }\n```",
            "code_start_line": 26,
            "code_end_line": 121,
            "parent": null,
            "have_return": true,
            "code_content": "class ToolNode(Node):\n    \"\"\"\n    Class representing a tool node in the XAgent's data structure.\n    \n    A tool node has a “father” that represents its parent node, \"children\" that represents its child nodes, \n    and “data” containing metadata about node's status, command, tool's output, and thoughts properties.\n    It also carries a message history and a workspace hash id.\n\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize a new tool node.\n\n        Setup father, children, expand_num, data, history, workspace_hash_id attributes for the instance.\n        \"\"\"\n\n        self.father: ToolNode = None\n        self.children: list[ToolNode] = []\n        self.expand_num = 0\n        self.data = {\n            \"content\": \"\",\n            \"thoughts\": {\n                \"properties\": {\n                    \"thought\": \"\",\n                    \"reasoning\": \"\",\n                    \"plan\": \"\",\n                    \"criticism\": \"\",\n                },\n            },\n            \"command\": {\n                \"properties\": {\n                    \"name\": \"\",\n                    \"args\": \"\",\n                },\n            },\n            \"tool_output\": \"\",\n            \"tool_status_code\": ToolCallStatusCode.TOOL_CALL_SUCCESS,\n        }\n        self.history: MessageHistory = MessageHistory()\n        self.workspace_hash_id = \"\"\n\n    @property\n    def process(self):\n        \"\"\"\n        Generate a list of data from current node up to root node.\n\n        Returns:\n            data (List): A list of data from current node up to root node.\n        \"\"\"\n\n        data = []\n        now_node = self\n        while now_node.father != None:\n            data = [now_node.data] + data\n            now_node = now_node.father\n        return data\n\n    def to_json(self):\n        \"\"\"\n        Convert the data attribute of the instance to a JSON-compatible format.\n\n        Returns:\n            data (Dict): The data attribute of the instance in a JSON-compatible format.\n        \"\"\"\n\n        data = deepcopy(self.data)\n        data[\"tool_status_code\"] = data[\"tool_status_code\"].name\n        return data\n\n    def get_depth(self):\n        \"\"\"\n        Calculate the depth of current node in the tree.\n\n        Returns:\n            depth (int): The depth of the node. Return 0 if the node is a root node.\n        \"\"\"\n        \n        if self.father == None:\n            return 0\n        return self.father.get_depth() + 1\n    \n    def get_subtree_size(self):\n        \"\"\"\n        Calculate the size of the subtree rooted at current node.\n\n        Returns:\n            size (int): The size of the subtree rooted at current node.\n        \"\"\"\n        \n        if self.children == []:\n            return 1\n        now_size = 1\n        for child in self.children:\n            now_size += child.get_subtree_size()\n        return now_size",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__函数**：这个函数的作用是初始化一个新的工具节点。\n\n在这个函数中，我们为实例设置了father、children、expand_num、data、history和workspace_hash_id属性。\n\n- father属性表示当前节点的父节点，它的类型是ToolNode。\n- children属性表示当前节点的子节点列表，它的类型是ToolNode的列表。\n- expand_num属性表示当前节点的展开次数，它的类型是整数。\n- data属性是一个字典，包含了节点的内容、思考、命令、工具输出和工具状态码等信息。\n  - content字段表示节点的内容，它的类型是字符串。\n  - thoughts字段是一个嵌套字典，包含了节点的思考相关属性。\n    - thought字段表示节点的思考内容，它的类型是字符串。\n    - reasoning字段表示节点的推理内容，它的类型是字符串。\n    - plan字段表示节点的计划内容，它的类型是字符串。\n    - criticism字段表示节点的批评内容，它的类型是字符串。\n  - command字段是一个嵌套字典，包含了节点的命令相关属性。\n    - name字段表示节点的命令名称，它的类型是字符串。\n    - args字段表示节点的命令参数，它的类型是字符串。\n  - tool_output字段表示工具的输出结果，它的类型是字符串。\n  - tool_status_code字段表示工具的状态码，它的类型是ToolCallStatusCode枚举值。\n- history属性表示节点的消息历史记录，它的类型是MessageHistory的实例。\n- workspace_hash_id属性表示节点的工作空间哈希ID，它的类型是字符串。\n\n**注意**：在使用这段代码时需要注意以下几点：\n- 需要确保父节点和子节点的类型都是ToolNode。\n- expand_num属性的值应该是一个非负整数。\n- data属性中的content、thoughts、command、tool_output和tool_status_code字段的值应该符合相应的数据类型要求。\n- history属性应该是MessageHistory的实例。\n- workspace_hash_id属性应该是一个字符串。",
            "code_start_line": 36,
            "code_end_line": 66,
            "parent": "ToolNode",
            "have_return": false,
            "code_content": "    def __init__(self):\n        \"\"\"\n        Initialize a new tool node.\n\n        Setup father, children, expand_num, data, history, workspace_hash_id attributes for the instance.\n        \"\"\"\n\n        self.father: ToolNode = None\n        self.children: list[ToolNode] = []\n        self.expand_num = 0\n        self.data = {\n            \"content\": \"\",\n            \"thoughts\": {\n                \"properties\": {\n                    \"thought\": \"\",\n                    \"reasoning\": \"\",\n                    \"plan\": \"\",\n                    \"criticism\": \"\",\n                },\n            },\n            \"command\": {\n                \"properties\": {\n                    \"name\": \"\",\n                    \"args\": \"\",\n                },\n            },\n            \"tool_output\": \"\",\n            \"tool_status_code\": ToolCallStatusCode.TOOL_CALL_SUCCESS,\n        }\n        self.history: MessageHistory = MessageHistory()\n        self.workspace_hash_id = \"\"\n",
            "name_column": 8
        },
        "process": {
            "type": "FunctionDef",
            "name": "process",
            "md_content": "**process函数**：该函数的功能是从当前节点到根节点生成一个数据列表。\n\n该函数通过遍历当前节点的父节点，将每个节点的数据依次添加到列表中，最终返回生成的数据列表。\n\n**注意**：该函数只能在ToolNode对象中调用。\n\n**输出示例**：假设当前节点的数据为[1, 2, 3]，父节点的数据为[4, 5, 6]，根节点的数据为[7, 8, 9]，则调用process函数后返回的数据列表为[7, 8, 9, 4, 5, 6, 1, 2, 3]。",
            "code_start_line": 69,
            "code_end_line": 82,
            "parent": "ToolNode",
            "have_return": true,
            "code_content": "    def process(self):\n        \"\"\"\n        Generate a list of data from current node up to root node.\n\n        Returns:\n            data (List): A list of data from current node up to root node.\n        \"\"\"\n\n        data = []\n        now_node = self\n        while now_node.father != None:\n            data = [now_node.data] + data\n            now_node = now_node.father\n        return data\n",
            "name_column": 8
        },
        "to_json": {
            "type": "FunctionDef",
            "name": "to_json",
            "md_content": "**to_json函数**：该函数的功能是将实例的data属性转换为JSON兼容格式。\n\n该函数首先使用深拷贝(deepcopy)创建一个data的副本，然后将副本中的tool_status_code属性的值转换为其对应的枚举名称。最后，将转换后的data返回。\n\n**注意**：使用该函数时需要注意以下几点：\n- 该函数只能用于实例对象。\n- 转换后的data中的tool_status_code属性值将会被修改为其对应的枚举名称。\n\n**输出示例**：假设实例的data属性为{\"tool_status_code\": ToolStatusCode.SUCCESS, \"data\": {\"name\": \"XAgent\"}}，经过to_json函数处理后，返回的data属性为{\"tool_status_code\": \"SUCCESS\", \"data\": {\"name\": \"XAgent\"}}。",
            "code_start_line": 84,
            "code_end_line": 94,
            "parent": "ToolNode",
            "have_return": true,
            "code_content": "    def to_json(self):\n        \"\"\"\n        Convert the data attribute of the instance to a JSON-compatible format.\n\n        Returns:\n            data (Dict): The data attribute of the instance in a JSON-compatible format.\n        \"\"\"\n\n        data = deepcopy(self.data)\n        data[\"tool_status_code\"] = data[\"tool_status_code\"].name\n        return data\n",
            "name_column": 8
        },
        "get_depth": {
            "type": "FunctionDef",
            "name": "get_depth",
            "md_content": "**get_depth函数**：该函数用于计算当前节点在树中的深度。\n\n该函数的作用是计算当前节点在树中的深度。如果节点是根节点，则返回0；否则，递归调用父节点的get_depth函数，并将结果加1作为当前节点的深度。\n\n**注意**：在使用该函数时需要注意以下几点：\n- 该函数只能在树的节点对象上调用。\n- 确保节点对象的父节点属性正确设置，否则可能导致错误的深度计算结果。\n\n**输出示例**：假设当前节点是树的根节点，则调用get_depth函数的返回值为0。",
            "code_start_line": 96,
            "code_end_line": 106,
            "parent": "ToolNode",
            "have_return": true,
            "code_content": "    def get_depth(self):\n        \"\"\"\n        Calculate the depth of current node in the tree.\n\n        Returns:\n            depth (int): The depth of the node. Return 0 if the node is a root node.\n        \"\"\"\n        \n        if self.father == None:\n            return 0\n        return self.father.get_depth() + 1\n",
            "name_column": 8
        },
        "get_subtree_size": {
            "type": "FunctionDef",
            "name": "get_subtree_size",
            "md_content": "**get_subtree_size函数**：该函数的功能是计算以当前节点为根的子树的大小。\n\n该函数通过递归的方式计算以当前节点为根的子树的大小。首先判断当前节点是否有子节点，如果没有子节点，则说明当前节点为叶子节点，子树的大小为1。如果有子节点，则遍历每个子节点，并递归调用子节点的get_subtree_size函数，将子节点的大小累加到当前节点的大小中。最后返回当前节点的大小作为子树的大小。\n\n在项目中，该函数被以下文件调用：\n文件路径：XAgent/data_structure/node.py\n对应代码如下：\n```python\ndef get_subtree_size(self):\n    \"\"\"\n    Calculate the size of the subtree rooted at current node.\n\n    Returns:\n        size (int): The size of the subtree rooted at current node.\n    \"\"\"\n    \n    if self.children == []:\n        return 1\n    now_size = 1\n    for child in self.children:\n        now_size += child.get_subtree_size()\n    return now_size\n```\n[此处为代码片段结束]\n[此处为XAgent/data_structure/node.py结束]\n文件路径：XAgent/data_structure/tree.py\n对应代码如下：\n```python\ndef get_subtree_size(self):\n    \"\"\"\n    Gets the number of nodes (or size) of the subtree from the current root node.\n\n    Returns:\n        int: The number of nodes in the subtree\n    \"\"\"\n    return self.root.get_subtree_size()\n```\n[此处为代码片段结束]\n[此处为XAgent/data_structure/tree.py结束]\n\n**注意**：在使用该代码时需要注意以下几点：\n- 该函数是一个递归函数，需要确保节点之间的关系正确，否则可能导致无限递归。\n- 该函数的返回值是以当前节点为根的子树的大小，即子节点的数量。\n\n**输出示例**：模拟代码返回值的可能外观。\n```python\nsize = node.get_subtree_size()\nprint(size)  # 输出：5\n```\n\n通过调用get_subtree_size函数，可以获取以当前节点为根的子树的大小。例如，如果当前节点有5个子节点，则子树的大小为5。",
            "code_start_line": 108,
            "code_end_line": 121,
            "parent": "ToolNode",
            "have_return": true,
            "code_content": "    def get_subtree_size(self):\n        \"\"\"\n        Calculate the size of the subtree rooted at current node.\n\n        Returns:\n            size (int): The size of the subtree rooted at current node.\n        \"\"\"\n        \n        if self.children == []:\n            return 1\n        now_size = 1\n        for child in self.children:\n            now_size += child.get_subtree_size()\n        return now_size",
            "name_column": 8
        }
    },
    "XAgent/ai_functions/function_manager.py": {
        "FunctionManager": {
            "type": "ClassDef",
            "name": "FunctionManager",
            "md_content": "**FunctionManager函数**: 这个类提供了管理函数的方法，包括函数的注册和执行。函数是从本地目录下的子目录'functions'和'pure_functions'中的YAML配置文件中定义和加载的。\n\n**function_cfg_dir (str)属性**: 存储函数配置文件所在的目录路径。\n\n**pure_function_cfg_dir (str)属性**: 存储纯函数配置文件所在的目录路径。\n\n**function_cfgs (dict)属性**: 用于存储所有加载的函数配置。\n\n**__init__方法**: 使用给定的函数配置文件目录路径初始化FunctionManager类。\n\n参数:\n- function_cfg_dir (str): 函数配置文件所在的目录路径。\n- pure_function_cfg_dir (str): 纯函数配置文件所在的目录路径。\n\n**get_function_schema方法**: 根据函数名称获取函数的模式。\n\n参数:\n- function_name (str): 函数的名称。\n\n返回值:\n- dict: 如果找到函数，则返回函数的模式。\n- None: 如果未找到函数，则返回None。\n\n**register_function方法**: 注册一个新的函数及其模式。\n\n参数:\n- function_schema (dict): 要注册的函数的模式。\n\n**execute方法**: 根据函数名称执行一个函数。\n\n参数:\n- function_name (str): 要执行的函数的名称。\n- return_generation_usage (bool, optional): 如果设置为True，则还返回函数执行的用法。\n- function_cfg (dict, optional): 函数的配置。如果未提供，则从加载的函数中检索。\n- **kwargs: 要执行的函数的参数。\n\n返回值:\n- Tuple[dict,Optional[dict]]: 包含执行结果和可选的函数执行用法的元组。\n\n抛出异常:\n- KeyError: 如果未找到函数配置。\n\n**__getitem__方法**: 允许FunctionManager实例像字典一样使用，通过键（实际上是函数名称）调用execute方法。\n\n参数:\n- function_name (str): 要执行的函数的名称。\n- return_generation_usage (bool, optional): 如果设置为True，则还返回函数执行的用法。\n- **kwargs: 要执行的函数的参数。\n\n返回值:\n- execute方法的返回值。\n\n**__call__方法**: 允许FunctionManager实例可调用，直接调用execute方法。\n\n参数:\n- function_name (str): 要执行的函数的名称。\n- return_generation_usage (bool, optional): 如果设置为True，则还返回函数执行的用法。\n- **kwargs: 要执行的函数的参数。\n\n返回值:\n- execute方法的返回值。\n\n**注意**: 使用该类时需要注意以下几点:\n- 需要在实例化FunctionManager类时提供函数配置文件的目录路径。\n- 可以通过get_function_schema方法获取函数的模式。\n- 可以通过register_function方法注册新的函数。\n- 可以通过execute方法执行函数。\n- 可以通过__getitem__方法和__call__方法以字典或可调用对象的方式执行函数。\n\n**输出示例**:\n```\n{\n  \"name\": \"add\",\n  \"parameters\": [\n    {\n      \"name\": \"a\",\n      \"type\": \"int\"\n    },\n    {\n      \"name\": \"b\",\n      \"type\": \"int\"\n    }\n  ],\n  \"return_type\": \"int\"\n}\n```",
            "code_start_line": 13,
            "code_end_line": 158,
            "parent": null,
            "have_return": true,
            "code_content": "class FunctionManager:\n    \"\"\"\n    This class provides methods to manage functions including registration and execution of functions.\n    The functions are defined and loaded from YAML configuration files located in the local directory\n    under subdirectories 'functions' and 'pure_functions'.\n\n    Attributes:\n      function_cfg_dir (str): The directory path where the function configuration files are located.\n      pure_function_cfg_dir (str): The directory path where the pure function configuration files are located.\n      function_cfgs (dict): A dictionary to store all loaded function configurations.\n    \"\"\"\n\n    def __init__(self,\n                 function_cfg_dir=os.path.join(os.path.dirname(__file__),'functions'),\n                 pure_function_cfg_dir=os.path.join(os.path.dirname(__file__),'pure_functions'),):\n        \"\"\"\n        Initializes the FunctionManager class with given directories for function configuration files.\n\n        Args:\n            function_cfg_dir (str): The directory path where the function configuration files are located.\n            pure_function_cfg_dir (str): The directory path where the pure function configuration files are located.\n        \"\"\"\n        self.function_cfg_dir = function_cfg_dir\n        self.pure_function_cfg_dir = pure_function_cfg_dir\n        self.function_cfgs = {}\n\n        for cfg_file in glob.glob(os.path.join(self.function_cfg_dir,'*.yaml')) + glob.glob(os.path.join(self.function_cfg_dir,'*.yml')):\n            with open(cfg_file,'r') as f:\n                function_cfg = yaml.load(f,Loader=yaml.FullLoader)\n            self.function_cfgs[function_cfg['function']['name']] = function_cfg\n\n        for cfg_file in glob.glob(os.path.join(self.pure_function_cfg_dir,'*.yaml')) + glob.glob(os.path.join(self.pure_function_cfg_dir,'*.yml')):\n            with open(cfg_file,'r') as f:\n                function_cfg = yaml.load(f,Loader=yaml.FullLoader)\n            for function in function_cfg['functions']:\n                self.function_cfgs[function['name']] = function\n    \n    def get_function_schema(self,function_name:str)->dict|None:\n        \"\"\"\n        Gets the schema of the function by its name.\n\n        Args:\n            function_name (str): The name of the function.\n\n        Returns:\n            dict: The schema of the function if found.\n            None: If the function is not found.\n        \"\"\"\n        return self.function_cfgs.get(function_name,None)\n    \n    def register_function(self,function_schema:dict):\n        \"\"\"\n        Registers a new function with its schema.\n\n        Args:\n            function_schema (dict): The schema of the function to register.\n        \"\"\"\n        if function_schema['name'] in self.function_cfgs:\n            return\n        self.function_cfgs[function_schema['name']] = function_schema\n        \n    def execute(self,function_name:str,return_generation_usage:bool=False,function_cfg:dict=None,**kwargs,)->Tuple[dict,Optional[dict]]:\n        \"\"\"\n        Executes a function by its name.\n\n        Args:\n            function_name (str): The name of the function to execute.\n            return_generation_usage (bool, optional): If set to True, also returns the usage of the function execution.\n            function_cfg (dict, optional): The configuration of the function. If not provided, retrieves it from the loaded functions.\n            **kwargs: The parameters of the function to execute.\n\n        Returns:\n            Tuple[dict,Optional[dict]]: A tuple containing the returns and optionally the usage of the executed function.\n\n        Raises:\n            KeyError: If the function configuration is not found.\n        \"\"\"\n        if function_cfg is None and function_name in self.function_cfgs:\n            function_cfg = self.function_cfgs.get(function_name)\n        else:\n            raise KeyError(f'Configure for function {function_name} not found.')\n        \n        \n        logger.typewriter_log(f'Executing AI Function: {function_name}', Fore.YELLOW)\n\n        completions_kwargs:dict = function_cfg.get('completions_kwargs',{})\n        if 'model' in completions_kwargs:\n            # check whether model is configured\n            try:\n                get_apiconfig_by_model(completions_kwargs['model'])\n            except:\n                logger.typewriter_log(\"Fallback\",Fore.YELLOW,f\"Model {completions_kwargs['model']} is not configured. Using default model instead.\")\n                completions_kwargs = {}\n        function_prompt = str(function_cfg['function_prompt'])\n        function_prompt = function_prompt.format(**kwargs)\n        messages = [{'role':'user','content':function_prompt}]\n        \n        match CONFIG.default_request_type:\n            case 'openai':                \n                response = objgenerator.chatcompletion(\n                    messages=messages,\n                    functions=[function_cfg['function']],\n                    function_call={'name':function_cfg['function']['name']},\n                    **completions_kwargs\n                )\n                returns = json5.loads(response['choices'][0]['message']['function_call']['arguments'])\n            case 'xagent':\n                arguments = function_cfg['function']['parameters']\n                response = objgenerator.chatcompletion(\n                    messages=messages,\n                    arguments=arguments,\n                    **completions_kwargs\n                )\n                returns = json5.loads(response['choices'][0]['message']['content'])['arguments']\n        \n        if return_generation_usage:\n            return returns, response['usage']\n        return returns\n    \n    def __getitem__(self,function_name,return_generation_usage=False,**kwargs):\n        \"\"\"\n        Allows the FunctionManager instance to behave like a dictionary, calling the execute method by key (which is actually the function name).\n\n        Args:\n            function_name (str): The name of the function to execute.\n            return_generation_usage (bool, optional): If set to True, also returns the usage of the function execution.\n            **kwargs: The parameters of the function to execute.\n\n        Returns:\n            The return of the execute method.\n        \"\"\"\n        return self.execute(function_name,return_generation_usage,**kwargs)\n\n    def __call__(self, function_name,return_generation_usage=False,**kwargs):\n        \"\"\"\n        Allows the FunctionManager instance to be callable, calling the execute method directly.\n\n        Args:\n            function_name (str): The name of the function to execute.\n            return_generation_usage (bool, optional): If set to True, also returns the usage of the function execution.\n            **kwargs: The parameters of the function to execute.\n\n        Returns:\n          The return of the execute method.\n        \"\"\"\n        return self.execute(function_name,return_generation_usage,**kwargs)\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__函数**: 这个函数的作用是初始化FunctionManager类，并设置函数配置文件的目录。\n\n详细代码分析和描述:\n- function_cfg_dir参数是函数配置文件所在的目录路径，默认为当前文件所在目录下的functions文件夹。\n- pure_function_cfg_dir参数是纯函数配置文件所在的目录路径，默认为当前文件所在目录下的pure_functions文件夹。\n- function_cfgs是一个字典，用于存储函数配置文件的内容。\n\n函数的执行流程如下：\n1. 遍历function_cfg_dir目录下的所有.yaml和.yml文件。\n2. 对于每个配置文件，使用yaml.load函数加载配置文件的内容，并将其存储在function_cfg变量中。\n3. 将function_cfg中的函数名作为键，将整个function_cfg作为值，存储在function_cfgs字典中。\n4. 遍历pure_function_cfg_dir目录下的所有.yaml和.yml文件。\n5. 对于每个配置文件，使用yaml.load函数加载配置文件的内容，并将其存储在function_cfg变量中。\n6. 遍历function_cfg中的每个函数，将函数名作为键，将整个函数配置作为值，存储在function_cfgs字典中。\n\n**注意**: 使用该代码时需要注意以下几点：\n- 需要确保function_cfg_dir和pure_function_cfg_dir参数指定的目录存在，并且目录下包含正确的函数配置文件。\n- 函数配置文件的格式必须为.yaml或.yml格式。\n- 函数配置文件中的函数名必须唯一，否则会覆盖之前同名的函数配置。\n\n以上是对该代码部分的详细解释和描述。",
            "code_start_line": 25,
            "code_end_line": 48,
            "parent": "FunctionManager",
            "have_return": false,
            "code_content": "    def __init__(self,\n                 function_cfg_dir=os.path.join(os.path.dirname(__file__),'functions'),\n                 pure_function_cfg_dir=os.path.join(os.path.dirname(__file__),'pure_functions'),):\n        \"\"\"\n        Initializes the FunctionManager class with given directories for function configuration files.\n\n        Args:\n            function_cfg_dir (str): The directory path where the function configuration files are located.\n            pure_function_cfg_dir (str): The directory path where the pure function configuration files are located.\n        \"\"\"\n        self.function_cfg_dir = function_cfg_dir\n        self.pure_function_cfg_dir = pure_function_cfg_dir\n        self.function_cfgs = {}\n\n        for cfg_file in glob.glob(os.path.join(self.function_cfg_dir,'*.yaml')) + glob.glob(os.path.join(self.function_cfg_dir,'*.yml')):\n            with open(cfg_file,'r') as f:\n                function_cfg = yaml.load(f,Loader=yaml.FullLoader)\n            self.function_cfgs[function_cfg['function']['name']] = function_cfg\n\n        for cfg_file in glob.glob(os.path.join(self.pure_function_cfg_dir,'*.yaml')) + glob.glob(os.path.join(self.pure_function_cfg_dir,'*.yml')):\n            with open(cfg_file,'r') as f:\n                function_cfg = yaml.load(f,Loader=yaml.FullLoader)\n            for function in function_cfg['functions']:\n                self.function_cfgs[function['name']] = function\n",
            "name_column": 8
        },
        "get_function_schema": {
            "type": "FunctionDef",
            "name": "get_function_schema",
            "md_content": "**get_function_schema函数**：该函数用于根据函数名称获取函数的模式。\n\n该函数接受一个字符串类型的参数function_name，表示函数的名称。函数会根据给定的名称在函数配置中查找对应的函数模式。\n\n如果找到了对应的函数模式，则返回该函数的模式字典；如果未找到对应的函数模式，则返回None。\n\n该函数的作用是根据函数名称获取函数的模式，以便后续使用。\n\n**代码分析和描述**：\n该函数首先接受一个字符串类型的参数function_name，表示函数的名称。然后，函数调用function_cfgs的get方法，传入function_name作为参数，从函数配置中获取对应的函数模式。如果找到了对应的函数模式，则返回该函数的模式字典；如果未找到对应的函数模式，则返回None。\n\n**注意**：在使用该函数时，需要确保传入的函数名称在函数配置中存在。\n\n**输出示例**：\n如果找到了对应的函数模式，则返回该函数的模式字典，例如：\n{\n    \"name\": \"function_name\",\n    \"parameters\": {\n        \"param1\": {\n            \"type\": \"string\",\n            \"description\": \"Parameter 1\"\n        },\n        \"param2\": {\n            \"type\": \"int\",\n            \"description\": \"Parameter 2\"\n        }\n    }\n}\n\n如果未找到对应的函数模式，则返回None。",
            "code_start_line": 50,
            "code_end_line": 61,
            "parent": "FunctionManager",
            "have_return": true,
            "code_content": "    def get_function_schema(self,function_name:str)->dict|None:\n        \"\"\"\n        Gets the schema of the function by its name.\n\n        Args:\n            function_name (str): The name of the function.\n\n        Returns:\n            dict: The schema of the function if found.\n            None: If the function is not found.\n        \"\"\"\n        return self.function_cfgs.get(function_name,None)\n",
            "name_column": 8
        },
        "register_function": {
            "type": "FunctionDef",
            "name": "register_function",
            "md_content": "**register_function函数**：该函数用于注册一个新的函数及其模式。\n\n该函数接受一个名为function_schema的字典作为参数，该字典包含要注册的函数的模式信息。\n\n如果function_schema中的'name'字段已经存在于self.function_cfgs中，则函数将直接返回，不进行注册操作。\n\n如果function_schema中的'name'字段不存在于self.function_cfgs中，则将该函数的模式信息添加到self.function_cfgs中。\n\n**注意**：在使用该函数时需要注意以下几点：\n- function_schema参数必须是一个字典，且必须包含'name'字段。\n- 如果要注册的函数已经存在于self.function_cfgs中，则不会进行重复注册。\n\n**输出示例**：模拟该函数返回值的可能外观。\n\n```python\n{\n    \"name\": \"function_name\",\n    \"description\": \"function_description\",\n    ...\n}\n```",
            "code_start_line": 63,
            "code_end_line": 72,
            "parent": "FunctionManager",
            "have_return": true,
            "code_content": "    def register_function(self,function_schema:dict):\n        \"\"\"\n        Registers a new function with its schema.\n\n        Args:\n            function_schema (dict): The schema of the function to register.\n        \"\"\"\n        if function_schema['name'] in self.function_cfgs:\n            return\n        self.function_cfgs[function_schema['name']] = function_schema\n",
            "name_column": 8
        },
        "execute": {
            "type": "FunctionDef",
            "name": "execute",
            "md_content": "**execute函数**：这个函数的功能是执行一个指定名称的函数。\n\n该函数接受以下参数：\n- function_name (str)：要执行的函数的名称。\n- return_generation_usage (bool, 可选)：如果设置为True，还会返回函数执行的用法。\n- function_cfg (dict, 可选)：函数的配置。如果未提供，则从加载的函数中获取。\n- **kwargs：要执行的函数的参数。\n\n该函数返回一个元组，包含执行函数的返回值和可选的函数执行用法。\n\n如果找不到函数配置，会引发KeyError异常。\n\n在函数内部，首先会检查是否提供了函数配置。如果未提供且函数名称在函数配置中存在，则从函数配置中获取函数配置。否则，会引发KeyError异常，提示找不到函数配置。\n\n接下来，会记录日志，打印出正在执行的AI函数的名称。\n\n然后，根据函数配置中的completions_kwargs参数，判断使用的是哪种请求类型。如果是'openai'，则调用objgenerator.chatcompletion函数，传入相应的参数，执行函数。如果是'xagent'，则根据函数配置中的参数arguments，调用objgenerator.chatcompletion函数，传入相应的参数，执行函数。\n\n最后，根据return_generation_usage参数的值，决定是否返回函数执行的返回值和使用情况。\n\n**注意**：使用该代码时需要注意以下几点：\n- 需要提供正确的函数名称和参数。\n- 需要确保函数配置已经加载。\n- 如果找不到函数配置，会引发KeyError异常。\n\n**输出示例**：模拟代码返回值的可能外观。\n```python\n{\n    'result': {\n        'output': 'Hello, World!',\n        'status': 'success'\n    },\n    'usage': {\n        'duration': 2.5,\n        'memory': 256\n    }\n}\n```",
            "code_start_line": 74,
            "code_end_line": 130,
            "parent": "FunctionManager",
            "have_return": true,
            "code_content": "    def execute(self,function_name:str,return_generation_usage:bool=False,function_cfg:dict=None,**kwargs,)->Tuple[dict,Optional[dict]]:\n        \"\"\"\n        Executes a function by its name.\n\n        Args:\n            function_name (str): The name of the function to execute.\n            return_generation_usage (bool, optional): If set to True, also returns the usage of the function execution.\n            function_cfg (dict, optional): The configuration of the function. If not provided, retrieves it from the loaded functions.\n            **kwargs: The parameters of the function to execute.\n\n        Returns:\n            Tuple[dict,Optional[dict]]: A tuple containing the returns and optionally the usage of the executed function.\n\n        Raises:\n            KeyError: If the function configuration is not found.\n        \"\"\"\n        if function_cfg is None and function_name in self.function_cfgs:\n            function_cfg = self.function_cfgs.get(function_name)\n        else:\n            raise KeyError(f'Configure for function {function_name} not found.')\n        \n        \n        logger.typewriter_log(f'Executing AI Function: {function_name}', Fore.YELLOW)\n\n        completions_kwargs:dict = function_cfg.get('completions_kwargs',{})\n        if 'model' in completions_kwargs:\n            # check whether model is configured\n            try:\n                get_apiconfig_by_model(completions_kwargs['model'])\n            except:\n                logger.typewriter_log(\"Fallback\",Fore.YELLOW,f\"Model {completions_kwargs['model']} is not configured. Using default model instead.\")\n                completions_kwargs = {}\n        function_prompt = str(function_cfg['function_prompt'])\n        function_prompt = function_prompt.format(**kwargs)\n        messages = [{'role':'user','content':function_prompt}]\n        \n        match CONFIG.default_request_type:\n            case 'openai':                \n                response = objgenerator.chatcompletion(\n                    messages=messages,\n                    functions=[function_cfg['function']],\n                    function_call={'name':function_cfg['function']['name']},\n                    **completions_kwargs\n                )\n                returns = json5.loads(response['choices'][0]['message']['function_call']['arguments'])\n            case 'xagent':\n                arguments = function_cfg['function']['parameters']\n                response = objgenerator.chatcompletion(\n                    messages=messages,\n                    arguments=arguments,\n                    **completions_kwargs\n                )\n                returns = json5.loads(response['choices'][0]['message']['content'])['arguments']\n        \n        if return_generation_usage:\n            return returns, response['usage']\n        return returns\n",
            "name_column": 8
        },
        "__getitem__": {
            "type": "FunctionDef",
            "name": "__getitem__",
            "md_content": "**__getitem__函数**：这个函数的作用是允许FunctionManager实例像字典一样使用，通过键（实际上是函数名）调用execute方法。\n\n该函数有以下参数：\n- function_name（str）：要执行的函数的名称。\n- return_generation_usage（bool，可选）：如果设置为True，则还返回函数执行的用法。\n- **kwargs：要执行的函数的参数。\n\n该函数返回execute方法的返回值。\n\n**代码分析和描述**：\n__getitem__函数是FunctionManager类的一个方法，用于实现实例像字典一样使用。它接受一个函数名作为参数，并可选择返回函数执行的用法。在执行过程中，它会调用execute方法来执行相应的函数。\n\n该函数的参数包括function_name、return_generation_usage和**kwargs。function_name是要执行的函数的名称，return_generation_usage是一个布尔值，用于指定是否返回函数执行的用法，**kwargs是要执行的函数的参数。\n\n在函数体内部，它调用了execute方法，并将function_name、return_generation_usage和**kwargs作为参数传递给execute方法。然后，它返回execute方法的返回值。\n\n**注意**：使用该代码时需要注意以下几点：\n- 该函数需要一个有效的函数名作为参数。\n- 可以选择返回函数执行的用法。\n\n**输出示例**：模拟代码返回值的可能外观。\n```python\n# 示例1：\nresult = function_manager_instance['function_name']\nprint(result)\n# 输出：\n# 函数执行的返回值\n\n# 示例2：\nresult, usage = function_manager_instance['function_name', True, param1='value1', param2='value2']\nprint(result)\nprint(usage)\n# 输出：\n# 函数执行的返回值\n# 函数执行的用法\n```",
            "code_start_line": 132,
            "code_end_line": 144,
            "parent": "FunctionManager",
            "have_return": true,
            "code_content": "    def __getitem__(self,function_name,return_generation_usage=False,**kwargs):\n        \"\"\"\n        Allows the FunctionManager instance to behave like a dictionary, calling the execute method by key (which is actually the function name).\n\n        Args:\n            function_name (str): The name of the function to execute.\n            return_generation_usage (bool, optional): If set to True, also returns the usage of the function execution.\n            **kwargs: The parameters of the function to execute.\n\n        Returns:\n            The return of the execute method.\n        \"\"\"\n        return self.execute(function_name,return_generation_usage,**kwargs)\n",
            "name_column": 8
        },
        "__call__": {
            "type": "FunctionDef",
            "name": "__call__",
            "md_content": "**__call__函数**：这个函数的作用是允许FunctionManager实例可调用，直接调用execute方法。\n\n该函数接受以下参数：\n- function_name（str）：要执行的函数的名称。\n- return_generation_usage（bool，可选）：如果设置为True，则还返回函数执行的用法。\n- **kwargs：要执行的函数的参数。\n\n返回值：execute方法的返回值。\n\n**详细分析和描述**：\n__call__函数是FunctionManager类的一个特殊方法，它允许我们直接调用FunctionManager实例，而不需要显式地调用execute方法。通过调用__call__函数，我们可以直接执行指定名称的函数，并将参数传递给该函数。\n\n在函数体内部，__call__函数调用了execute方法，并将传入的参数传递给execute方法。execute方法是FunctionManager类的另一个方法，用于执行具体的函数逻辑。通过调用execute方法，我们可以执行指定名称的函数，并获取其返回值。\n\n如果设置了return_generation_usage参数为True，__call__函数还会返回函数执行的用法。这对于了解函数的使用方式非常有帮助。\n\n**注意**：使用该代码时需要注意以下几点：\n- 需要确保传入的function_name参数是一个已定义的函数名称。\n- 如果需要获取函数执行的用法，需要将return_generation_usage参数设置为True。\n\n**输出示例**：假设我们调用了__call__函数，并传入了参数function_name='my_function'和return_generation_usage=True，那么函数的返回值可能是：\n```\n{\n  'result': '函数执行的结果',\n  'usage': '函数的使用方式'\n}\n```",
            "code_start_line": 146,
            "code_end_line": 158,
            "parent": "FunctionManager",
            "have_return": true,
            "code_content": "    def __call__(self, function_name,return_generation_usage=False,**kwargs):\n        \"\"\"\n        Allows the FunctionManager instance to be callable, calling the execute method directly.\n\n        Args:\n            function_name (str): The name of the function to execute.\n            return_generation_usage (bool, optional): If set to True, also returns the usage of the function execution.\n            **kwargs: The parameters of the function to execute.\n\n        Returns:\n          The return of the execute method.\n        \"\"\"\n        return self.execute(function_name,return_generation_usage,**kwargs)\n",
            "name_column": 8
        }
    },
    "XAgent/ai_functions/__init__.py": {},
    "XAgent/ai_functions/request/error.py": {
        "FunctionCallSchemaError": {
            "type": "ClassDef",
            "name": "FunctionCallSchemaError",
            "md_content": "**FunctionCallSchemaError函数**: 这个类的功能是在函数调用的结构或格式出现错误时引发异常。\n\n这个异常不接受任何参数或自定义消息。当函数调用的模式或结构出现问题时，比如传递了错误的数据类型、参数过多或过少等，就会抛出这个异常。这个错误用于停止执行并提示需要在程序继续之前修正函数调用。\n\n**注意**: 使用这段代码时需要注意以下几点：\n- 当函数调用的结构或格式出现错误时，会抛出FunctionCallSchemaError异常。\n- 这个异常不接受任何参数或自定义消息。\n- 这个异常用于停止执行并提示需要修正函数调用的结构或格式。\n- 修正函数调用后，可以继续执行程序。",
            "code_start_line": 1,
            "code_end_line": 9,
            "parent": null,
            "have_return": false,
            "code_content": "class FunctionCallSchemaError(Exception):\n    \"\"\"Exception raised when there is an error in the structure or format of a function call.\n\n    This exception does not accept any arguments or custom messages. It is thrown when there is an issue\n    with the schema or structure of a function call, such as passing the wrong data type, too many or too few\n    arguments, etc. This error is used to halt execution and signal that the function call needs to be \n    corrected before the program can continue.\n    \"\"\"\n    pass",
            "name_column": 6
        }
    },
    "XAgent/ai_functions/request/__init__.py": {},
    "XAgent/ai_functions/request/obj_generator.py": {
        "OBJGenerator": {
            "type": "ClassDef",
            "name": "OBJGenerator",
            "md_content": "**OBJGenerator函数**: 这个类的函数是处理与AI响应的交互和执行配置请求。\n\n该类具有以下属性：\n- chatcompletion_request_funcs: 一个字典，用于存储处理聊天完成请求的函数。\n\n该类具有以下方法：\n\n1. \\_\\_init\\_\\_(self)\n   - 描述：初始化函数，用于创建一个OBJGenerator对象。\n   - 参数：无\n   - 返回值：无\n   - 示例：obj = OBJGenerator()\n\n2. chatcompletion(self, \\*, schema_validation=True, **kwargs)\n   - 描述：处理聊天完成请求并获取响应。\n   - 参数：\n     - schema_validation (bool, 可选)：是否进行模式验证，默认为True。\n     - kwargs (dict)：请求数据参数。\n   - 返回值：从AI服务调用中检索到的响应的字典格式。\n   - 异常：\n     - Exception：处理请求时发生错误。\n     - NotImplementedError：接收到的请求类型目前未实现。\n   - 示例：response = obj.chatcompletion(schema_validation=True, request_type='openai')\n\n3. \\_get_chatcompletion_request_func(self, request_type:str)\n   - 描述：检索并返回特定请求类型的聊天完成函数。\n   - 参数：\n     - request_type (str)：请求生成的服务类型。\n   - 返回值：处理指定请求类型的聊天完成的函数对象。\n   - 示例：func = obj._get_chatcompletion_request_func('openai')\n\n4. dynamic_json_fixes(self, broken_json, function_schema, messages: list = [], error_message: str = None)\n   - 描述：尝试修复无效的JSON并根据函数模式进行验证。\n   - 参数：\n     - broken_json：无效的输入JSON数据。\n     - function_schema：要根据其验证JSON数据的模式。\n     - messages (list, 可选)：与JSON验证错误相关的其他消息。\n     - error_message (str, 可选)：与JSON验证错误相关的错误消息。\n   - 返回值：从AI服务调用中检索到的响应的字典格式。\n   - 示例：response = obj.dynamic_json_fixes(broken_json, function_schema, messages=[], error_message=None)\n\n5. load_args_with_schema_validation(self, function_schema:dict, args:str, messages:list=[], \\*, return_response=False, response=None)\n   - 描述：根据函数模式验证参数。\n   - 参数：\n     - function_schema (dict)：要根据其验证参数的模式。\n     - args (str)：要验证的参数数据。\n     - messages (list, 可选)：与参数验证错误相关的其他消息。\n     - return_response (bool, 可选)：是否返回响应与参数一起。\n     - response：如果return_response为True，则返回的响应数据。\n   - 返回值：模式验证后的参数数据。如果return_response设置为True，则还返回响应。\n   - 异常：Exception：验证参数时发生错误。\n   - 示例：arguments = obj.load_args_with_schema_validation(function_schema, args, messages=[], return_response=False, response=None)\n\n6. function_call_refine(self, req_kwargs, response)\n   - 描述：验证和优化函数调用的响应。\n   - 参数：\n     - req_kwargs：请求数据参数。\n     - response：从服务调用中接收到的响应。\n   - 返回值：经过优化和验证",
            "code_start_line": 20,
            "code_end_line": 222,
            "parent": null,
            "have_return": true,
            "code_content": "class OBJGenerator:\n    \"\"\"Handles interactions with AI responses and execution of configured requests.\n\n    Attributes:\n        chatcompletion_request_funcs: A dictionary to store functions processing chat completion requests.\n    \"\"\"\n    \n    def __init__(self,):        \n        self.chatcompletion_request_funcs = {}\n        \n    @retry(\n        stop=stop_after_attempt(3),\n        retry=retry_if_exception_type((\n            jsonschema.exceptions.ValidationError,\n            FunctionCallSchemaError\n            )),\n        )\n    def chatcompletion(self,*,schema_validation=True,**kwargs):\n        \"\"\"Processes chat completion requests and retrieves responses.\n\n        Args:\n            kwargs: Request data parameters.\n\n        Returns:\n            A dictionary format response retrieved from AI service call.\n\n        Raises:\n            Exception: Error occurred while processing requests.\n            NotImplementedError: Received request type is not currently implemented.\n        \"\"\"\n        \n        request_type = kwargs.pop('request_type',CONFIG.default_request_type)\n        for k in list(kwargs.keys()):\n            if kwargs[k] is None:\n                kwargs.pop(k)\n        \n        llm_query_id = recorder.get_query_id()\n        try:   \n            copyed_kwargs = deepcopy(kwargs)\n            if (response := recorder.query_llm_inout(llm_query_id = llm_query_id,**copyed_kwargs)) is None:\n                response = self._get_chatcompletion_request_func(request_type)(**kwargs)\n            recorder.regist_llm_inout(llm_query_id = llm_query_id,**copyed_kwargs,output_data = response)\n        except Exception as e:\n            traceback.print_exc()\n            logger.typewriter_log(f\"chatcompletion error: {e}\",Fore.RED)\n            recorder.decrease_query_id()\n            raise e\n\n        if schema_validation:\n            # refine the response\n            match request_type:\n                case 'openai':                \n                    response = self.function_call_refine(kwargs,response)\n                case 'xagent':\n                    pass\n                case _:\n                    raise NotImplementedError(f\"Request type {request_type} not implemented\")\n        \n        return response\n        \n    def _get_chatcompletion_request_func(self, request_type:str):\n        \"\"\"Retrieves and returns the chat completion function for a particular request type\n\n        Args:\n            request_type (str): Type of the service the request has been generated for.\n\n        Returns:\n            Function object to handle chat completion for the specified request type.\n        \"\"\"\n        \n        if request_type not in self.chatcompletion_request_funcs:\n            module = importlib.import_module(f'.{request_type}','XAgent.ai_functions.request')\n            self.chatcompletion_request_funcs[request_type] = getattr(module,'chatcompletion_request')\n        return self.chatcompletion_request_funcs[request_type]\n\n    def dynamic_json_fixes(self, broken_json, function_schema, messages: list = [], error_message: str = None):\n        \"\"\"Attempts to fix invalid json and validate it against the function schema\n\n        Args:\n            broken_json: The invalid input json data.\n            function_schema: Schema to validate the json data against.\n            messages (list, optional): Additional messages related to the json validation error.\n            error_message (str, optional): Error message related to the json validation error.\n\n        Returns:\n            A dictionary format response retrieved from AI service call.\n        \"\"\"\n        \n        logger.typewriter_log(\n            f'Schema Validation for Function call {function_schema[\"name\"]} failed, trying to fix it...', Fore.YELLOW)\n        repair_req_kwargs = deepcopy(CONFIG.default_completion_kwargs)\n        if messages[-1][\"role\"] == 'system' and 'Your last function call result in error' in messages[-1][\"content\"]:\n            messages = messages[:-1]\n        repair_req_kwargs['messages'] = [*messages,\n                                  {\n                                      'role': 'system',\n                                      'content': '\\n'.join([\n                                          'Your last function call result in error',\n                                          '--- Error ---',\n                                          error_message,\n                                          'Your task is to fix all errors exist in the Broken Json String to make the json validate for the schema in the given function, and use new string to call the function again.',\n                                          '--- Notice ---',\n                                          '- You need to carefully check the json string and fix the errors or adding missing value in it.',\n                                          '- Do not give your own opinion or imaging new info or delete exisiting info!',\n                                          '- Make sure the new function call does not contains information about this fix task!',\n                                          '--- Broken Json String ---',\n                                          broken_json,\n                                          'Start!'\n                                      ])\n                                  }]\n        repair_req_kwargs['functions'] = [function_schema]\n        repair_req_kwargs['function_call'] = {'name': function_schema['name']}\n        return self.chatcompletion(schema_validation=False,**repair_req_kwargs)\n    \n    def load_args_with_schema_validation(self,function_schema:dict,args:str,messages:list=[],*,return_response=False,response=None):\n        \"\"\"Validates arguments against the function schema.\n\n        Args:\n            function_schema (dict): Schema to validate the arguments against.\n            args (str): Arguments data to be validated.\n            messages (list, optional): Additional messages related to the arguments validation error.\n            return_response(bool, optional): Whether to return the response along with arguments.\n            response: response data to be returned if return_response is True.\n\n        Returns:\n            Arguments data after schema validation.\n            If return_response is set to True, response is also returned along with the arguments.\n\n        Raises:\n            Exception: Error occurred while validating the arguments.\n        \"\"\"\n        \n        # loading arguments\n        arguments = args\n        def validate():\n            nonlocal function_schema,arguments\n            if isinstance(arguments,str):\n                arguments = {} if arguments == '' else json5.loads(arguments)\n            jsonschema.validate(instance=arguments, schema=function_schema['parameters'])\n            \n        try:\n            validate()\n        except Exception as e:\n            if not isinstance(arguments,str):\n                arguments = json5.dumps(arguments)\n            # give one opportunity to fix the json string\n            response = self.dynamic_json_fixes(arguments,function_schema,messages,str(e))\n            arguments = response['choices'][0]['message']['function_call']['arguments']\n            validate()\n\n        if return_response:\n            return arguments,response\n        else:\n            return arguments\n        \n    def function_call_refine(self,req_kwargs,response):\n        \"\"\"Validates and refines the function call response.\n\n        Args:\n            req_kwargs: Request data parameters.\n            response: The response received from the service call.\n\n        Returns:\n            Refined and validated response.\n\n        Raises:\n            FunctionCallSchemaError: Error occurred during the schema validation of the function call.\n        \"\"\"\n        \n        if 'function_call' not in response['choices'][0]['message']:\n            logger.typewriter_log(\"FunctionCallSchemaError: No function call found in the response\", Fore.RED)\n            raise FunctionCallSchemaError(f\"No function call found in the response: {response['choices'][0]['message']} \")\n\n        # verify the schema of the function call if exists\n        function_schema = list(filter(lambda x: x['name'] == response['choices'][0]['message']['function_call']['name'],req_kwargs['functions']))\n        function_schema = None if len(function_schema) == 0 else function_schema[0]\n        \n        if function_schema is None:\n            if '\"{}\"'.format(response['choices'][0]['message']['function_call']['name']) in req_kwargs['messages'][0]['content']:\n                # Temporal fix for tool call without reasoning\n                logger.typewriter_log(\"Warning: Detect tool call without reasoning\",Fore.YELLOW)\n                response['choices'][0]['message']['function_call']['arguments'] = orjson.dumps({\n                    'tool_call':{\n                        'tool_name':response['choices'][0]['message']['function_call']['name'],\n                        'tool_input':response['choices'][0]['message']['function_call']['arguments']\n                    }\n                })\n                return response\n\n            error_message = {\n                'role':'system',\n                'content': f\"Error: Your last function calling call function {response['choices'][0]['message']['function_call']['name']} that is not in the provided functions. Make sure function name in list: {list(map(lambda x:x['name'],req_kwargs['functions']))}\"\n            }\n            \n            if req_kwargs['messages'][-1]['role'] == 'system' and 'Your last function calling call function' in req_kwargs['messages'][-1]['content']:\n                req_kwargs['messages'] = req_kwargs['messages'][:-1]\n            req_kwargs['messages'].append(error_message)\n                \n            logger.typewriter_log(f\"FunctionCallSchemaError: Function {response['choices'][0]['message']['function_call']['name']} not found in the provided functions.\",Fore.RED)\n            raise FunctionCallSchemaError(f\"Function {response['choices'][0]['message']['function_call']['name']} not found in the provided functions: {list(map(lambda x:x['name'],req_kwargs['functions']))}\")\n            \n        arguments,response = self.load_args_with_schema_validation(function_schema,response['choices'][0]['message']['function_call']['arguments'],req_kwargs['messages'],return_response=True,response=response)\n        return response\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__函数**：这个函数的功能是初始化一个对象。\n\n在这个函数中，我们可以看到它没有任何参数，只有一个空的函数体。这意味着在创建一个对象时，会调用这个函数来初始化对象的属性和状态。\n\n这个函数没有具体的实现逻辑，只是创建了一个空的字典`chatcompletion_request_funcs`，用于存储聊天完成请求的函数。\n\n**注意**：在使用这个函数时，需要注意以下几点：\n- 这个函数没有参数，所以在创建对象时不需要传入任何参数。\n- 这个函数的主要作用是初始化对象的属性和状态，可以根据具体需求在函数体中添加适当的代码来完成初始化操作。\n- `chatcompletion_request_funcs`字典用于存储聊天完成请求的函数，可以根据具体需求在其他函数中添加键值对来实现对应的功能。",
            "code_start_line": 27,
            "code_end_line": 28,
            "parent": "OBJGenerator",
            "have_return": false,
            "code_content": "    def __init__(self,):        \n        self.chatcompletion_request_funcs = {}\n",
            "name_column": 8
        },
        "chatcompletion": {
            "type": "FunctionDef",
            "name": "chatcompletion",
            "md_content": "**chatcompletion函数**：chatcompletion函数用于处理聊天完成请求并获取响应。\n\n该函数接受以下参数：\n- schema_validation（可选）：是否进行模式验证，默认为True。\n- kwargs：请求数据参数。\n\n该函数返回一个字典格式的响应，该响应是从AI服务调用中获取的。\n\n该函数可能会引发以下异常：\n- Exception：处理请求时发生错误。\n- NotImplementedError：接收到的请求类型尚未实现。\n\n该函数在以下文件中被调用：\n- XAgent/agent/base_agent.py：在generate函数中调用了chatcompletion函数。\n- XAgent/ai_functions/function_manager.py：在execute函数中调用了chatcompletion函数。\n- XAgent/ai_functions/request/obj_generator.py：在dynamic_json_fixes函数中调用了chatcompletion函数。\n\n**generate函数**：generate函数用于从AI模型生成响应，使用给定的消息、参数、函数和函数调用。\n\n该函数接受以下参数：\n- messages：与AI模型交互的消息列表。\n- arguments（可选）：包含用于AI模型响应的参数的字典。\n- functions（可选）：表示用于AI模型响应的函数的字典列表。\n- function_call（可选）：表示用于AI模型响应的函数调用的字典。\n- stop（可选）：表示何时停止与AI模型的对话的字典。\n- *args：可变数量的参数。\n- **kwargs：任意关键字参数。\n\n该函数返回一个包含AI模型生成的消息和使用的令牌数量的元组。\n\n**Note**：在调用chatcompletion函数之前，generate函数会根据配置的默认请求类型和参数对函数进行预处理。然后，根据请求类型调用chatcompletion函数，并根据返回的响应进行处理和解析。\n\n**Output Example**:\n```python\nmessage = {\n    'arguments': {\n        'property1': 'value1',\n        'property2': 'value2'\n    },\n    'function_call': {\n        'name': 'function_name',\n        'arguments': {\n            'arg1': 'value1',\n            'arg2': 'value2'\n        }\n    }\n}\ntokens = 100\n```\n\n\n**execute函数**：execute函数通过函数名执行一个函数。\n\n该函数接受以下参数：\n- function_name：要执行的函数的名称。\n- return_generation_usage（可选）：如果设置为True，则还返回函数执行的使用情况。\n- function_cfg（可选）：函数的配置。如果未提供，则从加载的函数中获取。\n- **kwargs：要执行的函数的参数。\n\n该函数返回一个包含返回值和可选的函数执行使用情况的元组。\n\n**Note**：在调用chatcompletion函数之前，execute函数会根据函数的配置和默认请求类型调用chatcompletion函数，并根据返回的响应进行处理和解析。\n\n**Output Example**:\n```python\nreturns = {\n    'property1': 'value1',\n    'property2': 'value2'\n}\nusage = 100\n```\n\n\n**dynamic_json_fixes函数**：dynamic_json_fixes函数尝试修复无效的JSON并根据函数模式对其进行验证。\n\n该函数接受以下参数：\n- broken_json：无效的输入JSON数据。\n- function_schema：要根据其验证JSON数据的模式。\n- messages（可选）：与JSON验证错误相关的其他消息。\n- error_message（可选）：与JSON验证错误相关的错误消息。\n\n该函数返回一个字典格式的响应，该响应是从AI服务调用中获取的。\n\n**Note**：如果模式验证失败，dynamic_json_fixes函数会尝试修复无效的JSON，并根据修复后的JSON再次调用chatcompletion函数。\n\n**Output Example**:\n```python\nresponse = {\n    'property1': 'value1',\n    'property2': 'value2'\n}\n```",
            "code_start_line": 37,
            "code_end_line": 78,
            "parent": "OBJGenerator",
            "have_return": true,
            "code_content": "    def chatcompletion(self,*,schema_validation=True,**kwargs):\n        \"\"\"Processes chat completion requests and retrieves responses.\n\n        Args:\n            kwargs: Request data parameters.\n\n        Returns:\n            A dictionary format response retrieved from AI service call.\n\n        Raises:\n            Exception: Error occurred while processing requests.\n            NotImplementedError: Received request type is not currently implemented.\n        \"\"\"\n        \n        request_type = kwargs.pop('request_type',CONFIG.default_request_type)\n        for k in list(kwargs.keys()):\n            if kwargs[k] is None:\n                kwargs.pop(k)\n        \n        llm_query_id = recorder.get_query_id()\n        try:   \n            copyed_kwargs = deepcopy(kwargs)\n            if (response := recorder.query_llm_inout(llm_query_id = llm_query_id,**copyed_kwargs)) is None:\n                response = self._get_chatcompletion_request_func(request_type)(**kwargs)\n            recorder.regist_llm_inout(llm_query_id = llm_query_id,**copyed_kwargs,output_data = response)\n        except Exception as e:\n            traceback.print_exc()\n            logger.typewriter_log(f\"chatcompletion error: {e}\",Fore.RED)\n            recorder.decrease_query_id()\n            raise e\n\n        if schema_validation:\n            # refine the response\n            match request_type:\n                case 'openai':                \n                    response = self.function_call_refine(kwargs,response)\n                case 'xagent':\n                    pass\n                case _:\n                    raise NotImplementedError(f\"Request type {request_type} not implemented\")\n        \n        return response\n",
            "name_column": 8
        },
        "_get_chatcompletion_request_func": {
            "type": "FunctionDef",
            "name": "_get_chatcompletion_request_func",
            "md_content": "**_get_chatcompletion_request_func函数**：该函数的功能是根据特定的请求类型检索并返回聊天完成函数。\n\n该函数接受一个参数request_type，表示生成请求的服务类型。函数首先检查request_type是否在chatcompletion_request_funcs字典中，如果不在，则通过importlib动态导入对应的模块，并获取该模块中的chatcompletion_request函数。然后将获取到的函数对象存储在chatcompletion_request_funcs字典中，以便下次使用。最后，函数返回指定请求类型的聊天完成函数。\n\n**注意**：使用该代码时需要注意以下几点：\n- request_type参数必须是已实现的请求类型，否则会抛出NotImplementedError异常。\n- chatcompletion_request_funcs字典用于存储不同请求类型对应的聊天完成函数，可以在多次调用中复用。\n\n**输出示例**：假设request_type为'openai'，则返回一个用于处理openai请求的函数对象。",
            "code_start_line": 80,
            "code_end_line": 93,
            "parent": "OBJGenerator",
            "have_return": true,
            "code_content": "    def _get_chatcompletion_request_func(self, request_type:str):\n        \"\"\"Retrieves and returns the chat completion function for a particular request type\n\n        Args:\n            request_type (str): Type of the service the request has been generated for.\n\n        Returns:\n            Function object to handle chat completion for the specified request type.\n        \"\"\"\n        \n        if request_type not in self.chatcompletion_request_funcs:\n            module = importlib.import_module(f'.{request_type}','XAgent.ai_functions.request')\n            self.chatcompletion_request_funcs[request_type] = getattr(module,'chatcompletion_request')\n        return self.chatcompletion_request_funcs[request_type]\n",
            "name_column": 8
        },
        "dynamic_json_fixes": {
            "type": "FunctionDef",
            "name": "dynamic_json_fixes",
            "md_content": "**dynamic_json_fixes函数**：该函数的功能是尝试修复无效的JSON并根据函数模式对其进行验证。\n\n该函数接受以下参数：\n- `broken_json`：无效的输入JSON数据。\n- `function_schema`：用于验证JSON数据的模式。\n- `messages`（可选）：与JSON验证错误相关的附加消息列表。\n- `error_message`（可选）：与JSON验证错误相关的错误消息。\n\n该函数的返回值是从AI服务调用中检索到的字典格式的响应。\n\n该函数首先使用日志记录器记录模式验证失败的函数调用名称，并尝试修复它。然后，它创建一个修复请求的关键字参数字典，并根据需要修改其中的消息列表。如果最后一条消息是系统消息且内容包含\"Your last function call result in error\"，则将其从消息列表中删除。接下来，将修复请求的关键字参数设置为修复后的消息列表、函数模式和函数调用。最后，调用`chatcompletion`函数，将`schema_validation`参数设置为False，并传递修复请求的关键字参数。函数将返回从AI服务调用中检索到的响应。\n\n**注意**：在使用该函数时需要注意以下几点：\n- 需要仔细检查无效的JSON字符串并修复其中的错误或添加缺失的值。\n- 确保修复后的函数调用不包含与修复任务相关的信息。\n- 修复后的函数调用需要符合函数模式的验证要求。\n\n**输出示例**：返回从AI服务调用中检索到的字典格式的响应。",
            "code_start_line": 95,
            "code_end_line": 132,
            "parent": "OBJGenerator",
            "have_return": true,
            "code_content": "    def dynamic_json_fixes(self, broken_json, function_schema, messages: list = [], error_message: str = None):\n        \"\"\"Attempts to fix invalid json and validate it against the function schema\n\n        Args:\n            broken_json: The invalid input json data.\n            function_schema: Schema to validate the json data against.\n            messages (list, optional): Additional messages related to the json validation error.\n            error_message (str, optional): Error message related to the json validation error.\n\n        Returns:\n            A dictionary format response retrieved from AI service call.\n        \"\"\"\n        \n        logger.typewriter_log(\n            f'Schema Validation for Function call {function_schema[\"name\"]} failed, trying to fix it...', Fore.YELLOW)\n        repair_req_kwargs = deepcopy(CONFIG.default_completion_kwargs)\n        if messages[-1][\"role\"] == 'system' and 'Your last function call result in error' in messages[-1][\"content\"]:\n            messages = messages[:-1]\n        repair_req_kwargs['messages'] = [*messages,\n                                  {\n                                      'role': 'system',\n                                      'content': '\\n'.join([\n                                          'Your last function call result in error',\n                                          '--- Error ---',\n                                          error_message,\n                                          'Your task is to fix all errors exist in the Broken Json String to make the json validate for the schema in the given function, and use new string to call the function again.',\n                                          '--- Notice ---',\n                                          '- You need to carefully check the json string and fix the errors or adding missing value in it.',\n                                          '- Do not give your own opinion or imaging new info or delete exisiting info!',\n                                          '- Make sure the new function call does not contains information about this fix task!',\n                                          '--- Broken Json String ---',\n                                          broken_json,\n                                          'Start!'\n                                      ])\n                                  }]\n        repair_req_kwargs['functions'] = [function_schema]\n        repair_req_kwargs['function_call'] = {'name': function_schema['name']}\n        return self.chatcompletion(schema_validation=False,**repair_req_kwargs)\n",
            "name_column": 8
        },
        "load_args_with_schema_validation": {
            "type": "FunctionDef",
            "name": "load_args_with_schema_validation",
            "md_content": "**load_args_with_schema_validation函数**：该函数的功能是验证参数与函数模式的匹配性。\n\n该函数接受以下参数：\n- function_schema（dict）：要对参数进行验证的模式。\n- args（str）：要验证的参数数据。\n- messages（list，可选）：与参数验证错误相关的附加消息。\n- return_response（bool，可选）：是否返回响应以及参数。\n- response：如果return_response为True，则返回的响应数据。\n\n该函数的返回值为：\n- 经过模式验证后的参数数据。\n- 如果return_response设置为True，则还会返回响应数据。\n\n该函数可能会引发以下异常：\n- Exception：在验证参数时发生错误。\n\n**load_args_with_schema_validation函数的详细分析**：\n该函数首先将参数数据加载到arguments变量中。然后定义了一个内部函数validate()，用于验证参数数据是否与函数模式匹配。在validate()函数中，首先判断arguments是否为字符串类型，如果是，则将其转换为空字典或使用json5.loads()方法将其转换为字典类型。然后使用jsonschema.validate()方法对参数数据进行验证，其中instance参数为arguments，schema参数为function_schema['parameters']。\n\n接下来，使用try-except语句块来捕获验证过程中可能发生的异常。如果捕获到异常，则判断arguments是否为字符串类型，如果不是，则使用json5.dumps()方法将其转换为字符串类型。然后调用self.dynamic_json_fixes()方法修复json字符串，并将修复后的参数数据赋值给arguments。最后再次调用validate()方法进行验证。\n\n如果return_response为True，则返回arguments和response两个值；否则，只返回arguments。\n\n**注意**：在使用该函数时需要注意以下几点：\n- function_schema参数必须是一个字典类型，包含了要验证的参数模式。\n- args参数必须是一个字符串类型，包含了要验证的参数数据。\n- messages参数是一个可选参数，用于提供与参数验证错误相关的附加消息。\n- return_response参数是一个可选参数，用于控制是否返回响应数据。\n- response参数是一个可选参数，用于提供响应数据。\n\n**输出示例**：假设参数数据经过模式验证后的结果为arguments，响应数据为response，则函数的返回值可能如下所示：\n```\narguments = {...}\nresponse = {...}\n```",
            "code_start_line": 134,
            "code_end_line": 173,
            "parent": "OBJGenerator",
            "have_return": true,
            "code_content": "    def load_args_with_schema_validation(self,function_schema:dict,args:str,messages:list=[],*,return_response=False,response=None):\n        \"\"\"Validates arguments against the function schema.\n\n        Args:\n            function_schema (dict): Schema to validate the arguments against.\n            args (str): Arguments data to be validated.\n            messages (list, optional): Additional messages related to the arguments validation error.\n            return_response(bool, optional): Whether to return the response along with arguments.\n            response: response data to be returned if return_response is True.\n\n        Returns:\n            Arguments data after schema validation.\n            If return_response is set to True, response is also returned along with the arguments.\n\n        Raises:\n            Exception: Error occurred while validating the arguments.\n        \"\"\"\n        \n        # loading arguments\n        arguments = args\n        def validate():\n            nonlocal function_schema,arguments\n            if isinstance(arguments,str):\n                arguments = {} if arguments == '' else json5.loads(arguments)\n            jsonschema.validate(instance=arguments, schema=function_schema['parameters'])\n            \n        try:\n            validate()\n        except Exception as e:\n            if not isinstance(arguments,str):\n                arguments = json5.dumps(arguments)\n            # give one opportunity to fix the json string\n            response = self.dynamic_json_fixes(arguments,function_schema,messages,str(e))\n            arguments = response['choices'][0]['message']['function_call']['arguments']\n            validate()\n\n        if return_response:\n            return arguments,response\n        else:\n            return arguments\n",
            "name_column": 8
        },
        "function_call_refine": {
            "type": "FunctionDef",
            "name": "function_call_refine",
            "md_content": "**function_call_refine函数**：该函数的功能是验证和完善函数调用的响应。\n\n该函数接收两个参数：\n- req_kwargs：请求数据参数。\n- response：从服务调用中接收到的响应。\n\n该函数的返回值是经过完善和验证的响应。\n\n该函数可能会抛出FunctionCallSchemaError异常，该异常表示在函数调用的模式验证过程中发生了错误。\n\n在函数的实现中，首先检查响应中是否存在函数调用。如果不存在，则抛出FunctionCallSchemaError异常。\n\n接下来，函数会根据函数调用的名称在req_kwargs['functions']中查找相应的函数模式。如果找到了对应的函数模式，则将其赋值给function_schema变量；否则，将function_schema设置为None。\n\n如果function_schema为None，则表示在提供的函数列表中找不到函数调用的名称。此时，函数会检查req_kwargs['messages']中是否包含函数调用的名称，如果包含，则说明是一个没有推理的工具调用，函数会进行临时修复，并返回修复后的响应。\n\n如果function_schema不为None，则调用load_args_with_schema_validation函数对函数调用的参数进行加载和模式验证，并返回验证后的参数和响应。\n\n最后，函数返回经过完善和验证后的响应。\n\n**注意**：使用该代码时需要注意以下几点：\n- 确保响应中包含函数调用。\n- 确保提供的函数列表中包含函数调用的名称。\n\n**输出示例**：模拟代码返回值的可能外观。\n\n请注意：\n- 生成的内容不应包含Markdown的标题和分隔符语法。\n- 主要使用中文编写，如果需要，可以在分析和描述中使用一些英文单词，以提高文档的可读性，因为不需要将函数名或变量名翻译成目标语言。",
            "code_start_line": 175,
            "code_end_line": 222,
            "parent": "OBJGenerator",
            "have_return": true,
            "code_content": "    def function_call_refine(self,req_kwargs,response):\n        \"\"\"Validates and refines the function call response.\n\n        Args:\n            req_kwargs: Request data parameters.\n            response: The response received from the service call.\n\n        Returns:\n            Refined and validated response.\n\n        Raises:\n            FunctionCallSchemaError: Error occurred during the schema validation of the function call.\n        \"\"\"\n        \n        if 'function_call' not in response['choices'][0]['message']:\n            logger.typewriter_log(\"FunctionCallSchemaError: No function call found in the response\", Fore.RED)\n            raise FunctionCallSchemaError(f\"No function call found in the response: {response['choices'][0]['message']} \")\n\n        # verify the schema of the function call if exists\n        function_schema = list(filter(lambda x: x['name'] == response['choices'][0]['message']['function_call']['name'],req_kwargs['functions']))\n        function_schema = None if len(function_schema) == 0 else function_schema[0]\n        \n        if function_schema is None:\n            if '\"{}\"'.format(response['choices'][0]['message']['function_call']['name']) in req_kwargs['messages'][0]['content']:\n                # Temporal fix for tool call without reasoning\n                logger.typewriter_log(\"Warning: Detect tool call without reasoning\",Fore.YELLOW)\n                response['choices'][0]['message']['function_call']['arguments'] = orjson.dumps({\n                    'tool_call':{\n                        'tool_name':response['choices'][0]['message']['function_call']['name'],\n                        'tool_input':response['choices'][0]['message']['function_call']['arguments']\n                    }\n                })\n                return response\n\n            error_message = {\n                'role':'system',\n                'content': f\"Error: Your last function calling call function {response['choices'][0]['message']['function_call']['name']} that is not in the provided functions. Make sure function name in list: {list(map(lambda x:x['name'],req_kwargs['functions']))}\"\n            }\n            \n            if req_kwargs['messages'][-1]['role'] == 'system' and 'Your last function calling call function' in req_kwargs['messages'][-1]['content']:\n                req_kwargs['messages'] = req_kwargs['messages'][:-1]\n            req_kwargs['messages'].append(error_message)\n                \n            logger.typewriter_log(f\"FunctionCallSchemaError: Function {response['choices'][0]['message']['function_call']['name']} not found in the provided functions.\",Fore.RED)\n            raise FunctionCallSchemaError(f\"Function {response['choices'][0]['message']['function_call']['name']} not found in the provided functions: {list(map(lambda x:x['name'],req_kwargs['functions']))}\")\n            \n        arguments,response = self.load_args_with_schema_validation(function_schema,response['choices'][0]['message']['function_call']['arguments'],req_kwargs['messages'],return_response=True,response=response)\n        return response\n",
            "name_column": 8
        },
        "validate": {
            "type": "FunctionDef",
            "name": "validate",
            "md_content": "**validate函数**：该函数的功能是对参数进行验证。\n\n该函数接受两个参数：function_schema和arguments。其中，function_schema是用于验证参数的模式，arguments是待验证的参数数据。如果arguments是一个字符串类型，则将其解析为字典类型。然后，使用jsonschema库对arguments和function_schema['parameters']进行验证。\n\n在函数内部，定义了一个名为validate的内部函数。该函数使用了nonlocal关键字，使得函数内部可以访问外部函数的局部变量function_schema和arguments。在validate函数中，首先判断arguments是否为字符串类型，如果是，则将其解析为字典类型。然后，使用jsonschema库对arguments和function_schema['parameters']进行验证。\n\n在load_args_with_schema_validation函数中，首先将args赋值给arguments。然后，尝试调用validate函数进行参数验证。如果验证失败，则捕获异常，并将arguments转换为字符串类型。接着，调用self.dynamic_json_fixes函数对arguments进行修复，并获取修复后的arguments。最后，再次调用validate函数进行参数验证。\n\n如果return_response参数为True，则返回验证后的arguments和response。否则，只返回验证后的arguments。\n\n**注意**：在使用该函数时，需要注意以下几点：\n- function_schema参数必须是一个字典类型，用于指定参数的验证模式。\n- args参数可以是一个字符串类型或字典类型。如果是字符串类型，则会被解析为字典类型进行验证。\n- 如果参数验证失败，会抛出异常，并尝试修复参数数据。\n- 如果return_response参数为True，则会返回验证后的参数数据和response数据。否则，只返回验证后的参数数据。",
            "code_start_line": 154,
            "code_end_line": 158,
            "parent": "load_args_with_schema_validation",
            "have_return": false,
            "code_content": "        def validate():\n            nonlocal function_schema,arguments\n            if isinstance(arguments,str):\n                arguments = {} if arguments == '' else json5.loads(arguments)\n            jsonschema.validate(instance=arguments, schema=function_schema['parameters'])\n",
            "name_column": 12
        }
    },
    "XAgent/ai_functions/request/openai.py": {
        "chatcompletion_request": {
            "type": "FunctionDef",
            "name": "chatcompletion_request",
            "md_content": "**chatcompletion_request函数**：该函数用于处理OpenAI v1.x.x聊天完成的操作。\n\n该函数通过提供的参数操作OpenAI v1.x.x聊天完成。它获取模型名称，并应用JSON Web令牌。如果响应表明上下文长度已超出限制，则尝试获取更高容量的语言模型（如果在配置中存在），并重新尝试操作。否则，将引发错误消息。\n\n参数：\n- **kwargs：可变长度的参数列表，包括（model:str等）。\n\n返回值：\n- response（字典）：包含来自Chat API的响应的字典。字典的结构基于API响应格式。\n\n异常：\n- BadRequestError：如果在聊天完成操作期间发生任何错误或上下文长度超过限制且没有备用模型可用。\n\n**代码分析和描述**：\n- 首先，从kwargs中获取model_name，如果没有提供model参数，则使用CONFIG.default_completion_kwargs[\"model\"]作为默认值。\n- 使用get_model_name函数获取模型名称。\n- 使用get_apiconfig_by_model函数获取chatcompletion_kwargs。\n- 从kwargs中获取request_timeout参数，如果没有提供，则使用默认值60。\n- 根据chatcompletion_kwargs中的api_version判断使用的是哪个版本的API，并根据不同的版本创建不同的client对象。\n- 使用client对象调用chat.completions.create方法创建聊天完成。\n- 获取completions的model_dump，并将其赋值给response。\n- 如果response中的finish_reason为\"length\"，则抛出BadRequestError异常，表示上下文长度超过限制。\n- 如果捕获到BadRequestError异常，并且异常消息中包含\"maximum context length\"，则尝试使用更高容量的语言模型进行重试。\n- 如果没有备用模型可用，则抛出BadRequestError异常。\n- 返回response。\n\n**注意**：在使用该函数时需要注意以下几点：\n- 需要提供model参数或在配置中设置默认的model。\n- 可以通过kwargs传递其他参数，如request_timeout等。\n\n**输出示例**：模拟代码返回值的可能外观。\n```python\n{\n    \"choices\": [\n        {\n            \"finish_reason\": \"stop\",\n            \"index\": 0,\n            \"message\": {\n                \"content\": \"Hello, World!\"\n            }\n        }\n    ]\n}\n```\n\n该函数在以下文件中被调用：\n- 文件路径：tests/test_1106_model_openai.py\n- 调用代码：\n```python\ndef test_1106_model_openai():\n    if openai_version >= \"1.0.0\":\n        # Mock the OpenAI client and response\n        with mock.patch(\"openai.OpenAI\") as mock_openai:\n            mock_client = mock_openai.return_value\n            mock_response = mock_client.chat.completions.create.return_value\n\n            # Mock the model_dump() method\n            mock_model_dump = mock_response.model_dump\n            mock_model_dump.return_value = {\n                \"choices\": [\n                    {\n                        \"finish_reason\": \"stop\",\n                        \"index\": 0,\n                        \"message\": {\"content\": \"Hello, World!\"},\n                    }\n                ]\n            }\n\n            # Call the function\n            response = chatcompletion_request(\n                model=\"gpt-4-1106-preview\", prompt=\"Hello, world\"\n            )\n\n            # Assert that the response is as expected\n            assert response[\"choices\"][0][\"finish_reason\"] == \"stop\"\n            assert response[\"choices\"][0][\"index\"] == 0\n            assert response[\"choices\"][0][\"message\"][\"content\"] == \"Hello, World!\"\n\n    else:\n        with mock.patch(\"openai.ChatCompletion\") as mock_create:\n            mock_response_data = \"\"\"{\"choices\": [{\"finish_reason\": \"stop\", \"index\": 0, \"message\": {\"content\": \"Hello, World!\"}}]}\"\"\"\n\n            mock_create.create.return_value = mock_response_data\n\n            response = chatcompletion_request(\n                model=\"gpt-4-1106-preview\", prompt=\"Hello, world\"\n            )\n            assert response[\"choices\"][0][\"message\"][\"content\"] == \"Hello, World!\"\n\n    print(f\"Your OpenAI version is {openai_version}, Successful test\")\n```\n\n- 文件路径：tests/test_model_alias.py\n- 调用代码：\n```python\ndef test_model_alias():\n    if openai_version >= \"1.0.0\":\n        # Mock the OpenAI client and response\n        with mock.patch(\"openai.OpenAI\") as mock_openai:\n            mock_client = mock_openai.return_value\n            mock_response = mock_client.chat.completions.create.return_value\n\n            # Mock the model_dump() method\n            mock_model_dump = mock_response.model_dump\n            mock_model_dump.return_value = {\n                \"choices\": [\n                    {\n                        \"finish_reason\": \"stop\",\n                        \"index\": 0,\n                        \"message\": {\"content\": \"Hello, World!\"},\n                    }\n                ]\n            }\n\n            # Call the function\n            response = chatcompletion_request(\n                model=\"gpt-4-turbo\", prompt=\"Hello, world\"\n            )\n\n            # Assert that the response is as expected\n            assert response[\"choices\"][0][\"finish_reason\"] == \"stop\"\n            assert response[\"choices\"][0][\"index\"] == 0\n            assert response[\"choices\"][0][\"message\"][\"content\"] == \"Hello, World!\"\n\n    else:\n        with mock.patch(\"openai.ChatCompletion\") as mock_create:\n            mock_response_data = \"\"\"{\"choices\": [{\"finish_reason\": \"stop\", \"index\": 0, \"message\": {\"content\": \"Hello, World!\"}}]}\"\"\"\n\n            mock_create.create.return_value = mock_response_data\n\n            response = chatcompletion_request(\n                model=\"gpt-4-turbo\", prompt=\"Hello, world\"\n            )\n            assert response[\"choices\"][0][\"message\"][\"content\"] == \"Hello, World!\"\n\n    print(f\"Your OpenAI version is {openai_version}, Successful test\")\n```",
            "code_start_line": 114,
            "code_end_line": 211,
            "parent": null,
            "have_return": true,
            "code_content": "    def chatcompletion_request(**kwargs):\n        \"\"\"Handle operation of OpenAI v1.x.x chat completion.\n\n        This function operates OpenAI v1.x.x chat completion with provided\n        arguments. It gets the model name, applies a JSON web token, if the\n        response indicates the context length has been exceeded, it attempts\n        to get a higher-capacity language model if it exists in the configuration\n        and reattempts the operation. Otherwise, it will raise an error message.\n\n        Args:\n            **kwargs: Variable length argument list including (model:str, etc.).\n\n        Returns:\n            response (dict): A dictionary containing the response from the Chat API.\n            The structure of the dictionary is based on the API response format.\n\n        Raises:\n            BadRequestError: If any error occurs during chat completion operation or\n            context length limit exceeded and no fallback models available.\n        \"\"\"\n        model_name = get_model_name(\n            kwargs.pop(\"model\", CONFIG.default_completion_kwargs[\"model\"])\n        )\n        logger.debug(\"chatcompletion: using \" + model_name)\n        chatcompletion_kwargs = get_apiconfig_by_model(model_name)\n\n        request_timeout = kwargs.pop(\"request_timeout\", 60)\n        if \"api_version\" in chatcompletion_kwargs:\n            if \"base_url\" in chatcompletion_kwargs:\n                base_url = chatcompletion_kwargs.pop(\"base_url\", None)\n            else:\n                base_url = chatcompletion_kwargs.pop(\"api_base\", None)\n            azure_endpoint = chatcompletion_kwargs.pop(\"azure_endpoint\", base_url)\n            api_version = chatcompletion_kwargs.pop(\"api_version\", None)\n            api_key = chatcompletion_kwargs.pop(\"api_key\", None)\n            chatcompletion_kwargs.pop(\"api_type\", None)\n            if \"engine\" in chatcompletion_kwargs:\n                model = chatcompletion_kwargs.pop(\"engine\", None)\n            else:\n                model = chatcompletion_kwargs.pop(\"model\", None)\n            chatcompletion_kwargs.update({\"model\": model})\n            chatcompletion_kwargs.update(kwargs)\n            client = openai.AzureOpenAI(\n                api_key=api_key,\n                azure_endpoint=azure_endpoint,\n                api_version=api_version,\n                timeout=request_timeout,\n            )\n        else:\n            if \"base_url\" in chatcompletion_kwargs:\n                base_url = chatcompletion_kwargs.pop(\"base_url\", None)\n            else:\n                base_url = chatcompletion_kwargs.pop(\"api_base\", None)\n            api_key = chatcompletion_kwargs.pop(\"api_key\", None)\n            organization = chatcompletion_kwargs.pop(\"organization\", None)\n            chatcompletion_kwargs.update(kwargs)\n            client = openai.OpenAI(\n                api_key=api_key,\n                organization=organization,\n                base_url=base_url,\n                timeout=request_timeout\n            )\n        try:\n            completions = client.chat.completions.create(**chatcompletion_kwargs)\n            response = completions.model_dump()\n            if response[\"choices\"][0][\"finish_reason\"] == \"length\":\n                raise BadRequestError(\n                    message=\"maximum context length exceeded\", response=None, body=None\n                )\n\n        except BadRequestError as e:\n            if \"maximum context length\" in e.message:\n                if model_name == \"gpt-4\" and \"gpt-4-32k\" in CONFIG.api_keys:\n                    model_name = \"gpt-4-32k\"\n                elif model_name == \"gpt-4\" and \"gpt-4-1106-preview\" in CONFIG.api_keys:\n                    model_name = \"gpt-4-1106-preview\"\n                else:\n                    if \"gpt-3.5-turbo-1106\" in CONFIG.api_keys:\n                        model_name = \"gpt-3.5-turbo-1106\"\n                    else:\n                        model_name = \"gpt-3.5-turbo-16k\"\n\n                print(f\"max context length reached, retrying with {model_name}\")\n                chatcompletion_kwargs = get_apiconfig_by_model(model_name)\n                request_timeout = kwargs.pop(\"request_timeout\", 60)\n                if \"base_url\" in chatcompletion_kwargs:\n                    base_url = chatcompletion_kwargs.pop(\"base_url\", None)\n                else:\n                    base_url = chatcompletion_kwargs.pop(\"api_base\", None)\n                api_key = chatcompletion_kwargs.pop(\"api_key\", None)\n                chatcompletion_kwargs.update(kwargs)\n                chatcompletion_kwargs.pop(\"schema_error_retry\", None)\n                completions = client.chat.completions.create(**chatcompletion_kwargs)\n                response = completions.model_dump()\n            else:\n                raise e\n\n        return response\n",
            "name_column": 8
        }
    },
    "XAgent/ai_functions/request/utils.py": {},
    "XAgent/ai_functions/request/xagent.py": {
        "chatcompletion_request": {
            "type": "FunctionDef",
            "name": "chatcompletion_request",
            "md_content": "**chatcompletion_request函数**: 这个函数的功能是进行聊天补全请求。\n\n该函数接受一个关键字参数kwargs，并执行以下操作：\n1. 获取模型名称model_name，如果没有传入model参数，则使用默认的模型名称。\n2. 根据模型名称获取API配置chatcompletion_kwargs。\n3. 将传入的kwargs更新到chatcompletion_kwargs中。\n4. 使用requests库向指定的API地址发送POST请求，请求的参数包括模型名称、重复惩罚系数、温度、top_p、频率惩罚系数、存在惩罚系数、最大token数、消息列表、参数字典、函数列表和函数调用字典。\n5. 将返回的响应转换为JSON格式，并将其作为函数的返回值。\n\n**注意**: 使用该代码时需要注意以下几点：\n- 该函数依赖requests库，请确保已经安装该库。\n- 需要提供正确的API地址和请求头信息。\n- 可以根据实际需求修改请求参数。\n\n**输出示例**：模拟代码返回值的可能外观。\n\n```python\n{\n    \"id\": \"chatcompletion_id\",\n    \"object\": \"chatcompletion\",\n    \"created\": 1638471234,\n    \"model\": \"gpt3.5-turbo\",\n    \"choices\": [\n        {\n            \"message\": {\n                \"role\": \"system\",\n                \"content\": \"You are a helpful assistant.\"\n            },\n            \"finish_reason\": \"stop\",\n            \"index\": 0\n        }\n    ]\n}\n```",
            "code_start_line": 7,
            "code_end_line": 32,
            "parent": null,
            "have_return": true,
            "code_content": "def chatcompletion_request(**kwargs):\n    # logger.info(f\"xagent received {json.dumps(kwargs)}\")\n    model_name = get_model_name(kwargs.pop('model',CONFIG.default_completion_kwargs['model']))\n    logger.debug(\"chatcompletion: using \" + model_name)\n    chatcompletion_kwargs = get_apiconfig_by_model(model_name)\n    chatcompletion_kwargs.update(kwargs)\n\n    response = requests.post(\n        chatcompletion_kwargs.get(\"api_base\",\"http://127.0.0.1:8000/chat/completions\"),\n        headers={\"accept\": \"application/json\", \"Content-Type\": \"application/json\"},\n        json={\n            \"model\": model_name,\n            \"repetition_penalty\": chatcompletion_kwargs.get(\"repetition_penalty\", 1.2),\n            \"temperature\": chatcompletion_kwargs.get(\"temperature\", 0.8),\n            \"top_p\":chatcompletion_kwargs.get(\"top_p\", 1.0),\n            \"frequency_penalty\":chatcompletion_kwargs.get(\"frequency_penalty\",0.5),\n            \"presence_penalty\":chatcompletion_kwargs.get(\"presence_penalty\", 0.0),\n            \"max_tokens\":chatcompletion_kwargs.get(\"max_tokens\", 4096),\n            \"messages\": chatcompletion_kwargs.get(\"messages\", []),\n            \"arguments\": chatcompletion_kwargs.get(\"arguments\", {}),\n            \"functions\": chatcompletion_kwargs.get(\"functions\", []),\n            \"function_call\": chatcompletion_kwargs.get(\"function_call\", {}),\n        }\n    ).json()\n\n    return response\n",
            "name_column": 4
        }
    },
    "XAgent/agent/dispatcher.py": {
        "AgentDispatcher": {
            "type": "ClassDef",
            "name": "AgentDispatcher",
            "md_content": "**AgentDispatcher函数**: 这个类的功能是Agent调度器，是一个抽象基类。\n\nAgent调度器是一个用于调度任务的基类，它负责根据任务的需求类型将任务分配给相应的Agent。Agent调度器维护了一个代理市场(agent_markets)，其中包含了各种能力类型所对应的代理。它还提供了一些方法用于注册代理、分配角色以及构建代理。\n\nAgentDispatcher类的构造函数初始化了代理市场(agent_markets)和日志记录器(logger)。代理市场是一个字典，其中的键是需求类型(RequiredAbilities)，值是一个代理列表，用于存储具有相应能力的代理。日志记录器用于记录构造AgentDispatcher对象的日志。\n\nAgentDispatcher类还定义了一个抽象方法dispatch，用于根据任务的需求类型分派任务给相应的代理。具体的分派逻辑由子类实现。此外，AgentDispatcher类还提供了dispatch_role方法用于分派角色，regist_agent方法用于注册代理。\n\nAgentDispatcher的子类AutomaticAgentDispatcher和XAgentDispatcher分别实现了dispatch方法。AutomaticAgentDispatcher类是一个自动调度器，它根据任务的需求类型自动将任务分派给代理市场中相应能力的代理。XAgentDispatcher类是一个特定的Agent调度器，它根据任务的需求类型构建代理，并对任务的提示进行细化。\n\n**注意**: 在使用AgentDispatcher类时，需要注意以下几点:\n- AgentDispatcher是一个抽象基类，不能直接实例化，需要通过继承它的子类来使用。\n- 子类需要实现dispatch方法，根据任务的需求类型来具体实现任务的分派逻辑。\n- 在使用regist_agent方法注册代理时，需要确保代理具有相应的能力。\n\n**输出示例**:\n```\n# 创建AgentDispatcher对象\ndispatcher = AgentDispatcher(logger)\n\n# 注册代理\ndispatcher.regist_agent(agent1)\ndispatcher.regist_agent(agent2)\n\n# 分派任务\nagent = dispatcher.dispatch(RequiredAbilities.plan_generation, target_task)\n```",
            "code_start_line": 12,
            "code_end_line": 67,
            "parent": null,
            "have_return": true,
            "code_content": "class AgentDispatcher(metaclass=abc.ABCMeta):\n    \"\"\"\n    Base abstract class for Agent Dispatcher.\n    \"\"\"\n    def __init__(self, logger=None):\n        \"\"\"\n        Initialize AgentDispatcher. Assign agent markets for each requirement in RequiredAbilities.\n        Agent markets are initially empty.\n        \"\"\"\n        self.agent_markets = {}\n        self.logger = logger\n        for requirement in RequiredAbilities:\n            self.agent_markets[requirement] = []\n        self.logger.typewriter_log(\n            f\"Constructing an AgentDispatcher:\",\n            Fore.YELLOW,\n            self.__class__.__name__,\n        )\n\n    @abc.abstractmethod\n    def dispatch(self, ability_type: RequiredAbilities, target_task) -> BaseAgent:\n        \"\"\"\n        Abstract dispatch method to be implemented by subclasses. Dispatches tasks based\n        on ability type.\n\n        Args:\n            ability_type (RequiredAbilities): The ability type required for the task.\n            target_task: The task which needs to be dispatched.\n\n        Returns:\n            BaseAgent: Base agent responsible for the task.\n        \"\"\"\n        pass\n\n    def dispatch_role(self, target_task: TaskSaveItem) -> AgentRole:\n        \"\"\"\n        Dispatch a role for the target task.\n\n        Args:\n            target_task (TaskSaveItem): The task for which a role needs to be dispatched.\n\n        Returns:\n            AgentRole: Returns a default AgentRole.\n        \"\"\"\n        return AgentRole()\n\n    def regist_agent(self, agent: BaseAgent):\n        \"\"\"\n        Register agent to the respective agent markets based on abilities.\n\n        Args:\n            agent (BaseAgent): The agent that needs to be registered.\n        \"\"\"\n        for requirement in RequiredAbilities:\n            if requirement in agent.abilities:\n                self.agent_markets[requirement].append(agent)\n",
            "name_column": 6
        },
        "AutomaticAgentDispatcher": {
            "type": "ClassDef",
            "name": "AutomaticAgentDispatcher",
            "md_content": "**AutomaticAgentDispatcher函数**: 这个类的功能是自动将任务分派给代理。\n\nAutomaticAgentDispatcher是AgentDispatcher的子类，它负责自动将任务分派给代理。它具有一个dispatch方法，该方法根据任务的能力类型将任务分派给市场中对应的代理。\n\n**dispatch方法**:\n这个方法接受两个参数，ability_type和target_task。ability_type是任务所需的能力类型，target_task是需要分派的任务。该方法返回一个BaseAgent对象，该对象负责执行任务。\n\n参数:\n- ability_type (RequiredAbilities): 任务所需的能力类型。\n- target_task: 需要分派的任务。\n\n返回值:\n- BaseAgent: 负责执行任务的BaseAgent对象。\n\n**注意**:\n- AutomaticAgentDispatcher类继承自AgentDispatcher类，因此它可以使用AgentDispatcher类中的方法和属性。\n- dispatch方法根据任务的能力类型从agent_markets中选择一个代理，并返回该代理的实例。\n\n**输出示例**:\n假设agent_markets中的ability_type为RequiredAbilities.ABILITY1，那么dispatch方法将返回agent_markets[ability_type][0]()的实例。",
            "code_start_line": 70,
            "code_end_line": 92,
            "parent": null,
            "have_return": true,
            "code_content": "class AutomaticAgentDispatcher(AgentDispatcher):\n    \"\"\"\n    AgentDispatcher that automatically dispatches tasks to agents.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize AutomaticAgentDispatcher.\n        \"\"\"\n        super().__init__()\n\n    def dispatch(self, ability_type: RequiredAbilities, target_task) -> BaseAgent:\n        \"\"\"\n        Dispatch task to the agent in the market corresponding to the task ability type.\n\n        Args:\n            ability_type (RequiredAbilities): The ability type required for the task.\n            target_task: The task which needs to be dispatched.\n\n        Returns:\n            BaseAgent: Base agent responsible for the task.\n        \"\"\"\n        return self.agent_markets[ability_type][0]()\n",
            "name_column": 6
        },
        "XAgentDispatcher": {
            "type": "ClassDef",
            "name": "XAgentDispatcher",
            "md_content": "**XAgentDispatcher函数**：这个类的功能是生成给定任务的提示和代理。\n\nXAgentDispatcher是AgentDispatcher的子类，用于生成给定任务的提示和代理。它包含了初始化函数、获取示例函数、构建代理函数和调度函数。\n\n**初始化函数**：\n- `__init__(self, config, enable=True, logger=None)`：初始化XAgentDispatcher对象。\n  - 参数：\n    - `config`：调度器的配置。\n    - `enable`（可选）：调度器是否激活，默认为True。\n    - `logger`（可选）：日志记录器对象。\n  - 功能：初始化XAgentDispatcher对象。\n\n**获取示例函数**：\n- `get_examples(self, ability_type: RequiredAbilities)`：根据能力类型获取示例。\n  - 参数：\n    - `ability_type`：需要示例的能力类型。\n  - 返回值：调度器的示例。\n  - 功能：根据能力类型获取示例。\n\n**构建代理函数**：\n- `build_agent(self, ability_type: RequiredAbilities, config, prompt_messages: List[Message], *args, **kwargs) -> BaseAgent`：根据能力类型构建代理。\n  - 参数：\n    - `ability_type`：代理所需的能力类型。\n    - `config`：代理的配置。\n    - `prompt_messages`：代理的提示消息列表。\n    - `*args`：其他参数。\n    - `**kwargs`：其他关键字参数。\n  - 返回值：构建的代理对象。\n  - 功能：根据能力类型构建代理对象。如果构建失败，则使用默认代理。\n\n**调度函数**：\n- `dispatch(self, ability_type: RequiredAbilities, target_task: TaskSaveItem, *args, **kwargs) -> BaseAgent`：将任务调度给与任务能力类型对应的代理。\n  - 参数：\n    - `ability_type`：任务所需的能力类型。\n    - `target_task`：需要调度的任务。\n    - `*args`：其他参数。\n    - `**kwargs`：其他关键字参数。\n  - 返回值：负责该任务的基础代理对象。\n  - 功能：将任务调度给与任务能力类型对应的代理。此外，还会对任务的提示进行优化，并构建代理对象。\n\n**注意**：在使用该代码时需要注意以下几点：\n- 需要提供调度器的配置。\n- 可以选择是否激活调度器。\n- 可以通过注册代理来扩展调度器的功能。\n\n**输出示例**：\n```python\ndispatcher = XAgentDispatcher(config, enable=True, logger=logger)\nexamples = dispatcher.get_examples(RequiredAbilities.plan_generation)\nagent = dispatcher.build_agent(RequiredAbilities.plan_generation, config, prompt_messages, *args, **kwargs)\nresult = dispatcher.dispatch(RequiredAbilities.plan_generation, target_task, *args, **kwargs)\n```",
            "code_start_line": 95,
            "code_end_line": 202,
            "parent": null,
            "have_return": true,
            "code_content": "class XAgentDispatcher(AgentDispatcher):\n    \"\"\"Generate the prompt and the agent for the given task.\"\"\"\n\n    def __init__(self, config, enable=True, logger=None):\n        \"\"\"\n        Initialize XAgentDispatcher.\n\n        Args:\n            config: Dispatcher configuration.\n            enable (bool, optional): Whether the dispatcher is active. Defaults to True.\n        \"\"\"\n        self.logger = logger\n        super().__init__(logger)\n        self.config = config\n        self.dispatcher = DispatcherAgent(config)\n        self.enable = enable\n\n    def get_examples(self, ability_type: RequiredAbilities):\n        \"\"\"\n        Get examples based on the ability type.\n\n        Args:\n            ability_type (RequiredAbilities): The ability type for which examples are needed.\n\n        Returns:\n            Returns examples for the dispatcher.\n        \"\"\"\n        if ability_type == RequiredAbilities.plan_generation:\n            from .plan_generate_agent import get_examples_for_dispatcher\n        elif ability_type == RequiredAbilities.plan_refinement:\n            from .plan_refine_agent import get_examples_for_dispatcher\n        elif ability_type == RequiredAbilities.tool_tree_search:\n            from .tool_agent import get_examples_for_dispatcher\n        elif ability_type == RequiredAbilities.reflection:\n            from .reflect_agent import get_examples_for_dispatcher\n        return get_examples_for_dispatcher()\n\n    def build_agent(\n        self,\n        ability_type: RequiredAbilities,\n        config,\n        prompt_messages: List[Message],\n        *args,\n        **kwargs,\n    ) -> BaseAgent:\n        \"\"\"\n        Build agent based on the ability type. If failed, fallback to use default agent.\n\n        Args:\n            ability_type (RequiredAbilities): Type of ability required by the agent.\n            config: Configuration for the agent.\n            prompt_messages (List[Message]): List of prompt messages for the agent.\n\n        Returns:\n            BaseAgent: The built agent.\n        \"\"\"\n        try:\n            agent = self.agent_markets[ability_type][0](\n                config, prompt_messages, *args, **kwargs\n            )\n        except:\n            # TODO: remove when all the agents can be created with dispatcher.\n            self.logger.info(\"build agent error, use default agent\")\n            agent = self.agent_markets[ability_type][0](config, *args, **kwargs)\n        return agent\n\n    def dispatch(\n        self,\n        ability_type: RequiredAbilities,\n        target_task: TaskSaveItem,\n        *args,\n        **kwargs,\n    ) -> BaseAgent:\n        \"\"\"\n        Dispatch task to the agent in the market corresponding to the task ability type.\n        Additionally refines the prompt for the task and builds the agent.\n\n        Args:\n            ability_type (RequiredAbilities): The ability type required for the task.\n            target_task (TaskSaveItem): The task which needs to be dispatched.\n\n        Returns:\n            BaseAgent: Base agent responsible for the task.\n        \"\"\"\n        example_input, example_system_prompt, example_user_prompt = self.get_examples(\n            ability_type\n        )\n        if self.enable:\n            self.logger.typewriter_log(self.__class__.__name__, Fore.GREEN, f\"Refine the prompt of a specific agent for {Fore.GREEN}RequiredAbilities.{ability_type.name}{Style.RESET_ALL}\")\n            _, prompt_messages, tokens = self.dispatcher.parse(\n                target_task, example_input, example_system_prompt, example_user_prompt\n            )\n            print(prompt_messages)\n            if prompt_messages[0].content == \"\" and prompt_messages[1].content == \"\":\n                self.logger.info(\"Dispatcher fail to follow the output format, we fallback to use the default prompt.\")\n                prompt_messages = [\n                    Message(role=\"system\", content=example_system_prompt),\n                    Message(role=\"user\", content=example_user_prompt),\n                ]\n            else:\n                self.logger.typewriter_log(self.__class__.__name__, Fore.GREEN, f\"The prompt has been refined!\")\n        else:\n            prompt_messages = [\n                Message(role=\"system\", content=example_system_prompt),\n                Message(role=\"user\", content=example_user_prompt),\n            ]\n        agent = self.build_agent(ability_type, self.config, prompt_messages, *args, **kwargs)\n        return agent\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__函数**：这个函数的功能是初始化XAgentDispatcher。\n\n在这个函数中，有以下参数：\n- config：Dispatcher的配置。\n- enable（可选参数）：指示Dispatcher是否处于活动状态，默认为True。\n\n在函数内部，首先将传入的logger赋值给self.logger。然后调用父类的__init__函数，将logger作为参数传入。接着将传入的config赋值给self.config。然后创建一个DispatcherAgent对象，并将config作为参数传入，将该对象赋值给self.dispatcher。最后将enable赋值给self.enable。\n\n**注意**：关于代码使用的注意事项",
            "code_start_line": 98,
            "code_end_line": 110,
            "parent": "XAgentDispatcher",
            "have_return": false,
            "code_content": "    def __init__(self, config, enable=True, logger=None):\n        \"\"\"\n        Initialize XAgentDispatcher.\n\n        Args:\n            config: Dispatcher configuration.\n            enable (bool, optional): Whether the dispatcher is active. Defaults to True.\n        \"\"\"\n        self.logger = logger\n        super().__init__(logger)\n        self.config = config\n        self.dispatcher = DispatcherAgent(config)\n        self.enable = enable\n",
            "name_column": 8
        },
        "dispatch": {
            "type": "FunctionDef",
            "name": "dispatch",
            "md_content": "**dispatch函数**：此函数的功能是将任务分派给与任务能力类型相对应的市场中的代理，并对任务进行进一步的提示细化和代理构建。\n\n此函数接受以下参数：\n- ability_type (RequiredAbilities)：任务所需的能力类型。\n- target_task (TaskSaveItem)：需要分派的任务。\n- *args：可变长度的位置参数。\n- **kwargs：可变长度的关键字参数。\n\n该函数的返回值为BaseAgent对象，表示负责该任务的基础代理。\n\n该函数首先调用get_examples方法获取示例输入、示例系统提示和示例用户提示。然后，如果启用了分派器（enable为True），将使用dispatcher对象的parse方法对目标任务、示例输入、示例系统提示和示例用户提示进行解析，获取解析后的提示信息。如果解析后的提示信息的内容为空，则表示分派器无法遵循输出格式，将使用默认提示。否则，将提示信息作为参数，调用build_agent方法构建代理对象。最后，返回构建的代理对象。\n\n**注意**：在调用dispatch函数之前，需要确保已经调用了get_examples方法获取示例输入、示例系统提示和示例用户提示。\n\n**输出示例**：\n```\nagent = agent_dispatcher.dispatch(RequiredAbilities.plan_generation, target_task=\"Generate a plan to accomplish the task: {self.query.task}\")\nprint(agent)\n```\n输出：\n```\n<agent.dispatcher_agent.agent.Agent object at 0x7f8a0b1f5a90>\n```",
            "code_start_line": 161,
            "code_end_line": 202,
            "parent": "XAgentDispatcher",
            "have_return": true,
            "code_content": "    def dispatch(\n        self,\n        ability_type: RequiredAbilities,\n        target_task: TaskSaveItem,\n        *args,\n        **kwargs,\n    ) -> BaseAgent:\n        \"\"\"\n        Dispatch task to the agent in the market corresponding to the task ability type.\n        Additionally refines the prompt for the task and builds the agent.\n\n        Args:\n            ability_type (RequiredAbilities): The ability type required for the task.\n            target_task (TaskSaveItem): The task which needs to be dispatched.\n\n        Returns:\n            BaseAgent: Base agent responsible for the task.\n        \"\"\"\n        example_input, example_system_prompt, example_user_prompt = self.get_examples(\n            ability_type\n        )\n        if self.enable:\n            self.logger.typewriter_log(self.__class__.__name__, Fore.GREEN, f\"Refine the prompt of a specific agent for {Fore.GREEN}RequiredAbilities.{ability_type.name}{Style.RESET_ALL}\")\n            _, prompt_messages, tokens = self.dispatcher.parse(\n                target_task, example_input, example_system_prompt, example_user_prompt\n            )\n            print(prompt_messages)\n            if prompt_messages[0].content == \"\" and prompt_messages[1].content == \"\":\n                self.logger.info(\"Dispatcher fail to follow the output format, we fallback to use the default prompt.\")\n                prompt_messages = [\n                    Message(role=\"system\", content=example_system_prompt),\n                    Message(role=\"user\", content=example_user_prompt),\n                ]\n            else:\n                self.logger.typewriter_log(self.__class__.__name__, Fore.GREEN, f\"The prompt has been refined!\")\n        else:\n            prompt_messages = [\n                Message(role=\"system\", content=example_system_prompt),\n                Message(role=\"user\", content=example_user_prompt),\n            ]\n        agent = self.build_agent(ability_type, self.config, prompt_messages, *args, **kwargs)\n        return agent\n",
            "name_column": 8
        },
        "dispatch_role": {
            "type": "FunctionDef",
            "name": "dispatch_role",
            "md_content": "**dispatch_role函数**：这个函数的作用是为目标任务分派一个角色。\n\n详细代码分析和描述：\n这个函数接受一个名为target_task的参数，它是一个TaskSaveItem类型的对象，表示需要分派角色的任务。在函数体内部，它返回一个默认的AgentRole对象。\n\n**注意**：使用这段代码时需要注意以下几点：\n- 这个函数的返回值是一个AgentRole对象。\n\n**输出示例**：模拟代码返回值的可能外观。\n```\nAgentRole()\n```",
            "code_start_line": 46,
            "code_end_line": 56,
            "parent": "AgentDispatcher",
            "have_return": true,
            "code_content": "    def dispatch_role(self, target_task: TaskSaveItem) -> AgentRole:\n        \"\"\"\n        Dispatch a role for the target task.\n\n        Args:\n            target_task (TaskSaveItem): The task for which a role needs to be dispatched.\n\n        Returns:\n            AgentRole: Returns a default AgentRole.\n        \"\"\"\n        return AgentRole()\n",
            "name_column": 8
        },
        "regist_agent": {
            "type": "FunctionDef",
            "name": "regist_agent",
            "md_content": "**regist_agent函数**：该函数的功能是将代理注册到相应的代理市场中，根据其能力。\n\n该函数接受一个参数agent，代表需要注册的代理。函数首先遍历所有的RequiredAbilities，如果某个ability在agent的abilities列表中，就将该agent添加到对应ability的代理市场中。\n\n**注意**：使用该代码时需要注意以下几点：\n- 参数agent必须是BaseAgent的实例。\n- agent的abilities属性必须包含所有的RequiredAbilities中的某个ability，否则该agent不会被注册到代理市场中。",
            "code_start_line": 58,
            "code_end_line": 67,
            "parent": "AgentDispatcher",
            "have_return": false,
            "code_content": "    def regist_agent(self, agent: BaseAgent):\n        \"\"\"\n        Register agent to the respective agent markets based on abilities.\n\n        Args:\n            agent (BaseAgent): The agent that needs to be registered.\n        \"\"\"\n        for requirement in RequiredAbilities:\n            if requirement in agent.abilities:\n                self.agent_markets[requirement].append(agent)\n",
            "name_column": 8
        },
        "get_examples": {
            "type": "FunctionDef",
            "name": "get_examples",
            "md_content": "**get_examples函数**：该函数的功能是根据能力类型获取示例。\n\n该函数根据传入的能力类型参数，返回对应能力类型的示例。示例的获取方式是通过根据能力类型导入相应的模块，并调用该模块中的get_examples_for_dispatcher函数来获取示例。\n\n参数：\n- ability_type (RequiredAbilities)：需要示例的能力类型。\n\n返回值：\n- 返回dispatcher的示例。\n\n调用情况：\n该函数在以下文件中被调用：\n文件路径：XAgent/agent/dispatcher.py\n调用代码如下：\n```python\nexample_input, example_system_prompt, example_user_prompt = self.get_examples(\n    ability_type\n)\n```\n\n代码分析和描述：\n该函数根据传入的ability_type参数，通过判断ability_type的值，来决定导入哪个模块并调用对应模块中的get_examples_for_dispatcher函数。根据不同的ability_type值，分别导入plan_generate_agent、plan_refine_agent、tool_agent和reflect_agent模块，并调用这些模块中的get_examples_for_dispatcher函数。最后，返回get_examples_for_dispatcher函数的返回值。\n\n注意事项：\n- 该函数依赖于其他模块中的get_examples_for_dispatcher函数，需要确保这些函数的正确性和可用性。\n\n输出示例：\n假设ability_type为RequiredAbilities.plan_generation，那么根据该ability_type的值，将导入plan_generate_agent模块，并调用该模块中的get_examples_for_dispatcher函数。假设get_examples_for_dispatcher函数返回的示例为example，那么函数的返回值将为example。",
            "code_start_line": 112,
            "code_end_line": 130,
            "parent": "XAgentDispatcher",
            "have_return": true,
            "code_content": "    def get_examples(self, ability_type: RequiredAbilities):\n        \"\"\"\n        Get examples based on the ability type.\n\n        Args:\n            ability_type (RequiredAbilities): The ability type for which examples are needed.\n\n        Returns:\n            Returns examples for the dispatcher.\n        \"\"\"\n        if ability_type == RequiredAbilities.plan_generation:\n            from .plan_generate_agent import get_examples_for_dispatcher\n        elif ability_type == RequiredAbilities.plan_refinement:\n            from .plan_refine_agent import get_examples_for_dispatcher\n        elif ability_type == RequiredAbilities.tool_tree_search:\n            from .tool_agent import get_examples_for_dispatcher\n        elif ability_type == RequiredAbilities.reflection:\n            from .reflect_agent import get_examples_for_dispatcher\n        return get_examples_for_dispatcher()\n",
            "name_column": 8
        },
        "build_agent": {
            "type": "FunctionDef",
            "name": "build_agent",
            "md_content": "**build_agent函数**：该函数的功能是根据所需的能力类型构建代理。如果失败，则回退到使用默认代理。\n\n该函数接受以下参数：\n- ability_type（RequiredAbilities）：代理所需的能力类型。\n- config：代理的配置。\n- prompt_messages（List[Message]）：代理的提示消息列表。\n\n该函数返回一个BaseAgent对象，表示构建的代理。\n\n该函数首先尝试使用ability_type从agent_markets字典中获取相应的代理类，并使用config、prompt_messages以及其他参数构建代理对象。如果构建失败，则捕获异常，并使用默认代理类再次尝试构建代理对象。\n\n在代码中，该函数被以下文件调用：\n文件路径：XAgent/agent/dispatcher.py\n调用代码如下：\n```\nagent = self.build_agent(ability_type, self.config, prompt_messages, *args, **kwargs)\n```\n\n**注意**：在构建代理对象时，如果能力类型对应的代理类无法创建，则会使用默认代理类进行构建。\n\n**输出示例**：假设能力类型为RequiredAbilities.A，config为{\"param1\": \"value1\"}，prompt_messages为[Message(role=\"system\", content=\"System prompt\"), Message(role=\"user\", content=\"User prompt\")]，则函数可能返回一个BaseAgent对象。",
            "code_start_line": 132,
            "code_end_line": 159,
            "parent": "XAgentDispatcher",
            "have_return": true,
            "code_content": "    def build_agent(\n        self,\n        ability_type: RequiredAbilities,\n        config,\n        prompt_messages: List[Message],\n        *args,\n        **kwargs,\n    ) -> BaseAgent:\n        \"\"\"\n        Build agent based on the ability type. If failed, fallback to use default agent.\n\n        Args:\n            ability_type (RequiredAbilities): Type of ability required by the agent.\n            config: Configuration for the agent.\n            prompt_messages (List[Message]): List of prompt messages for the agent.\n\n        Returns:\n            BaseAgent: The built agent.\n        \"\"\"\n        try:\n            agent = self.agent_markets[ability_type][0](\n                config, prompt_messages, *args, **kwargs\n            )\n        except:\n            # TODO: remove when all the agents can be created with dispatcher.\n            self.logger.info(\"build agent error, use default agent\")\n            agent = self.agent_markets[ability_type][0](config, *args, **kwargs)\n        return agent\n",
            "name_column": 8
        }
    },
    "XAgent/agent/base_agent.py": {
        "BaseAgent": {
            "type": "ClassDef",
            "name": "BaseAgent",
            "md_content": "**BaseAgent类的功能**：BaseAgent类是一个抽象基类，它为继承它的类提供了必要的属性和方法。它是Abstract Base Class (abc模块)的元类。\n\n**属性**：\n- abilities (set)：BaseAgent所需的一组RequiredAbilities，这些是BaseAgent所需的必要技能。\n\n**方法**：\n- \\_\\_init\\_\\_(self, config, prompt_messages: List[Message] = None)：构造一个具有设置的能力、配置设置和初始提示消息的代理对象。\n  - 参数：\n    - config (obj)：代理的配置设置。\n    - prompt_messages (List)：初始的提示消息列表。\n- parse(self, **args) -> (LLMStatusCode, Message, dict)：抽象方法，需要子类实现。用于解析给定的参数。\n- fill_in_placeholders(self, placeholders: dict)：用提供的值填充输入中的占位符。\n  - 参数：\n    - placeholders (dict)：包含占位符和其替换值的字典。\n  - 返回值：\n    - filled_messages：将占位符替换为相应值后的初始提示消息的副本。\n- generate(self, messages:list[dict]|list[Message], arguments:dict=None, functions:list[dict]=None, function_call:dict=None, stop:dict=None, *args,**kwargs)：使用给定的消息、参数、函数和函数调用生成AI模型的响应。\n  - 参数：\n    - messages (list[dict]|list[Message])：与AI模型交互的消息列表。\n    - arguments (dict, optional)：用于AI模型响应的参数字典。\n    - functions (list[dict], optional)：表示用于AI模型响应的函数列表。\n    - function_call (dict, optional)：表示用于AI模型响应的函数调用的字典。\n    - stop (dict, optional)：指示何时停止与AI模型的对话的字典。\n    - *args：可变长度参数列表。\n    - **kwargs：任意关键字参数。\n  - 返回值：\n    - message (dict)：AI模型生成的消息。\n    - tokens (int)：生成AI模型响应所使用的令牌数。\n\n**注意**：在使用`generate`方法时，需要根据具体情况传递不同的参数，如`messages`、`arguments`、`functions`、`function_call`和`stop`。\n\n**示例输出**：\n```python\nconfig = ...\nagent = BaseAgent(config)\nplaceholders = {\n    \"system\": {\n        \"placeholder1\": \"value1\",\n        \"placeholder2\": \"value2\"\n    },\n    \"user\": {\n        \"placeholder3\": \"value3\",\n        \"placeholder4\": \"value4\"\n    }\n}\nfilled_messages = agent.fill_in_placeholders(placeholders)\nprint(filled_messages)\n# Output:\n# [Message(role='system', content='System message with value1 and value2'),\n#  Message(role='user', content='User message with value3 and value4')]\n\nmessages = [\n    Message(role='system', content='System message'),\n    Message(role='user', content='User message')\n]\narguments = {\n    'arg1': 'value1',\n    'arg2': 'value2'\n}\nfunctions = [\n    {\n        'name': 'function1',\n        'parameters': {\n            'param1': 'value1',\n            'param2': 'value2'\n        }\n    }\n]\nfunction_call = {\n    'name': 'function1',\n    'arguments': {\n        'arg1': 'value1',\n        'arg2': 'value2'\n    }\n}\nstop = {\n    'condition': 'stop_condition'\n}\nmessage, tokens = agent.generate(messages, arguments, functions, function_call, stop)\nprint(message)\nprint(tokens)\n# Output:\n# {'content': 'Generated message', 'function_call': {'name': 'function1', 'arguments': {'arg1': 'value1', 'arg2': 'value2'}}}\n# 100\n```",
            "code_start_line": 14,
            "code_end_line": 155,
            "parent": null,
            "have_return": true,
            "code_content": "class BaseAgent(metaclass=abc.ABCMeta):\n    \"\"\"\n    The BaseAgent class abstracts the essential attributes and methods for classes,\n    which inherit it. It is a metaclass of the Abstract Base Class (abc module).\n\n    Attributes:\n        abilities (set): A set of RequiredAbilities, which are necessary skills for BaseAgent.\n    \"\"\"\n\n    abilities = set([\n        RequiredAbilities.plan_generation,\n        RequiredAbilities.plan_refinement,\n        RequiredAbilities.task_evaluator,\n        RequiredAbilities.tool_tree_search,\n        RequiredAbilities.reflection,\n        RequiredAbilities.summarization,\n    ])\n\n    def __init__(self, config, prompt_messages: List[Message] = None):\n        \"\"\"\n        Constructs an agent object with set abilities, configuration settings,\n        and initial set of prompt messages.\n\n        Args:\n            config (obj): Configuration settings for agent.\n            prompt_messages (List): Initial set of messages user gives to interact with the agent.\n        \"\"\"\n        logger.typewriter_log(\n            f\"Constructing an Agent:\",\n            Fore.YELLOW,\n            self.__class__.__name__,\n        )\n        self.config = config\n        self.prompt_messages = prompt_messages\n        self.usage = { }\n\n    @abc.abstractmethod\n    def parse(self,**args) -> (LLMStatusCode, Message, dict):\n        \"\"\"\n        Abstract method that needs to be implemented by the subclasses.\n        Required for parsing the given arguments.\n        \"\"\"\n        pass    \n\n    def fill_in_placeholders(self, placeholders: dict):\n        \"\"\"\n        Fills in placeholders defined in the input with the corresponding values.\n        \n        Args:\n            placeholders (dict): A dictionary containing keys as placeholders and values as their replacements.\n\n        Returns:\n            filled_messages: A copy of the initial prompt_messages with placeholders replaced with their corresponding values.\n        \"\"\"\n        filled_messages = deepcopy(self.prompt_messages)\n        for message in filled_messages:\n            role = message.role\n            if role in placeholders:\n                for key, value in placeholders[role].items():\n                    message.content = message.content.replace(\"{{\" + str(key) + \"}}\", str(value))\n        return filled_messages\n\n    def generate(self,\n                 messages:list[dict]|list[Message],\n                 arguments:dict=None,\n                 functions:list[dict]=None,\n                 function_call:dict=None,\n                 stop:dict=None,\n                 *args,**kwargs):\n        \"\"\"\n        Generates a response from the AI model, using the given messages, arguments, functions,\n        and a function call.\n\n        Args:\n            messages (list[dict]|list[Message]): A list of messages with which to interact with the AI model.\n            arguments (dict, optional): A dictionary containing arguments to use for AI model responses.\n            functions (list[dict], optional): A list of dictionaries representing functions to use for AI model responses.\n            function_call (dict, optional): A dictionary representing a function call to use for AI model responses.\n            stop (dict, optional): A dictionary that signifies when to stop the conversation with the AI model.\n            *args: Variable list of arguments. \n            **kwargs: Arbitrary keyword arguments.\n\n        Returns:\n            message (dict): A message generated by the AI model.\n            tokens (int): Number of tokens used in generating the AI model's response.\n        \"\"\"\n        if isinstance(messages[0],Message):\n            messages = [message.raw() for message in messages]\n        if functions is not None and len(functions) == 1 and function_call is None:\n            function_call = {'name':functions[0]['name']} # must call at least one function\n        match CONFIG.default_request_type:\n            case 'openai':\n                if arguments is not None:\n                    if functions is None or len(functions) == 0:\n                        functions = [{\n                            'name':'reasoning',\n                            'parameters':arguments\n                        }]\n                        function_call = {'name':'reasoning'}\n                    elif len(functions) == 1:\n                        for k,v in arguments['properties'].items():\n                            functions[0]['parameters']['properties'][k] = v\n                            if k in arguments['required']:\n                                functions[0]['parameters']['required'].append(k)\n                    else:\n                        raise NotImplementedError(\"Not implemented for multiple functions with arguments\")\n                    \n                response = objgenerator.chatcompletion(\n                    messages=messages,\n                    functions=functions,\n                    function_call=function_call,\n                    stop=stop,\n                    *args,**kwargs)\n                \n                message = {}\n                function_call_args:dict = json5.loads(response[\"choices\"][0][\"message\"][\"function_call\"]['arguments'])\n                \n                if arguments is not None:\n                    message['arguments'] = {\n                        k: function_call_args.pop(k)\n                        for k in arguments['properties'].keys() if k in function_call_args\n                    }\n                if len(function_call_args) > 0:\n                    message['function_call'] = {\n                        'name': response['choices'][0]['message']['function_call']['name'],\n                        'arguments': function_call_args\n                    }\n\n            case 'xagent':\n                response = objgenerator.chatcompletion(\n                    messages=messages,\n                    arguments=arguments,\n                    functions=functions,\n                    function_call=function_call,\n                    stop=stop,\n                    *args,**kwargs)\n                message = json5.loads(response[\"choices\"][0][\"message\"]['content'])\n            case _:\n                raise NotImplementedError(f\"Request type {CONFIG.default_request_type} not implemented\")\n            \n        tokens = response[\"usage\"]\n        return message, tokens\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__函数**：这个函数的作用是构建一个具有设置能力、配置设置和初始提示消息集的Agent对象。\n\n详细代码分析和描述：\n- 参数config是Agent的配置设置，它是一个对象。\n- 参数prompt_messages是Agent的初始提示消息集，它是一个消息列表，默认为None。\n- 函数内部使用logger.typewriter_log方法打印一条日志，记录正在构建Agent对象的过程。\n- 将参数config赋值给self.config，将参数prompt_messages赋值给self.prompt_messages。\n- 将self.usage初始化为空字典。\n\n**注意**：关于代码使用的注意事项",
            "code_start_line": 32,
            "code_end_line": 48,
            "parent": "BaseAgent",
            "have_return": false,
            "code_content": "    def __init__(self, config, prompt_messages: List[Message] = None):\n        \"\"\"\n        Constructs an agent object with set abilities, configuration settings,\n        and initial set of prompt messages.\n\n        Args:\n            config (obj): Configuration settings for agent.\n            prompt_messages (List): Initial set of messages user gives to interact with the agent.\n        \"\"\"\n        logger.typewriter_log(\n            f\"Constructing an Agent:\",\n            Fore.YELLOW,\n            self.__class__.__name__,\n        )\n        self.config = config\n        self.prompt_messages = prompt_messages\n        self.usage = { }\n",
            "name_column": 8
        },
        "parse": {
            "type": "FunctionDef",
            "name": "parse",
            "md_content": "**parse函数**：该函数的功能是解析给定的参数。这是一个抽象方法，需要由子类实现。用于解析给定的参数。\n\n**代码分析和描述**：\nparse函数是一个抽象方法，需要由子类实现。它接受一个名为args的关键字参数，并返回一个元组，包含LLMStatusCode、Message和dict类型的值。该函数没有具体的实现，只是一个占位符，需要在子类中进行实现。\n\n**注意**：parse函数是一个抽象方法，需要在子类中进行实现。在实现时，需要根据具体的需求解析给定的参数，并返回相应的结果。",
            "code_start_line": 51,
            "code_end_line": 56,
            "parent": "BaseAgent",
            "have_return": false,
            "code_content": "    def parse(self,**args) -> (LLMStatusCode, Message, dict):\n        \"\"\"\n        Abstract method that needs to be implemented by the subclasses.\n        Required for parsing the given arguments.\n        \"\"\"\n        pass    \n",
            "name_column": 8
        },
        "fill_in_placeholders": {
            "type": "FunctionDef",
            "name": "fill_in_placeholders",
            "md_content": "**fill_in_placeholders函数**：该函数用于填充输入中定义的占位符，将其替换为相应的值。\n\n该函数接受一个字典作为参数，其中键为占位符，值为其替换值。\n\n函数返回一个填充了占位符的初始prompt_messages的副本。\n\n该函数的具体实现如下：\n```python\ndef fill_in_placeholders(self, placeholders: dict):\n    filled_messages = deepcopy(self.prompt_messages)\n    for message in filled_messages:\n        role = message.role\n        if role in placeholders:\n            for key, value in placeholders[role].items():\n                message.content = message.content.replace(\"{{\" + str(key) + \"}}\", str(value))\n    return filled_messages\n```\n\n**注意**：在使用该函数时需要注意以下几点：\n- placeholders参数是一个字典，其中键为占位符，值为其替换值。\n- 该函数会返回一个填充了占位符的初始prompt_messages的副本。\n\n**输出示例**：一个可能的返回值示例\n```python\n[\n    Message(role='user', content='Hello, {{name}}!'),\n    Message(role='assistant', content='Hi there, {{name}}! How can I assist you?')\n]\n```\n\n该函数在以下文件中被调用：\n1. 文件路径：XAgent/agent/plan_generate_agent/agent.py\n   对应代码如下：\n   ```python\n   def parse(\n       self,\n       placeholders: dict = {},\n       arguments: dict = None,\n       functions=None,\n       function_call=None,\n       stop=None,\n       additional_messages: List[Message] = [],\n       *args,\n       **kwargs\n   ):\n       prompt_messages = self.fill_in_placeholders(placeholders)\n       messages = prompt_messages + additional_messages\n\n       return self.generate(\n           messages=messages,\n           arguments=arguments,\n           functions=functions,\n           function_call=function_call,\n           stop=stop,\n           *args, **kwargs\n       )\n   ```\n2. 文件路径：XAgent/agent/plan_refine_agent/agent.py\n   对应代码如下：\n   ```python\n   def parse(\n       self,\n       placeholders: dict = {},\n       arguments:dict = None,\n       functions=None,\n       function_call=None,\n       stop=None,\n       additional_messages: List[Message] = [],\n       additional_insert_index: int = -1,\n       *args,\n       **kwargs\n   ):\n       prompt_messages = self.fill_in_placeholders(placeholders)\n       messages =prompt_messages[:additional_insert_index] + additional_messages + prompt_messages[additional_insert_index:]\n       \n       return self.generate(\n           messages=messages,\n           arguments=arguments,\n           functions=functions,\n           function_call=function_call,\n           stop=stop,\n           *args,**kwargs\n       )\n   ```\n3. 文件路径：XAgent/agent/reflect_agent/agent.py\n   对应代码如下：\n   ```python\n   def parse(\n       self,\n       placeholders: dict = {},\n       arguments:dict = None,\n       functions=None,\n       function_call=None,\n       stop=None,\n       additional_messages: List[Message] = [],\n       *args,\n       **kwargs\n   ):\n       prompt_messages = self.fill_in_placeholders(placeholders)\n       messages = prompt_messages + additional_messages\n\n       return self.generate(\n           messages=messages,\n           arguments=arguments,\n           functions=functions,\n           function_call=function_call,\n           stop=stop,\n           *args,**kwargs\n       )\n   ```\n4. 文件路径：XAgent/agent/tool_agent/agent.py\n   对应代码如下：\n   ```python\n   def parse(\n       self,\n       placeholders: dict = {},\n       arguments:dict=None,\n       functions=None,\n       function_call=None,\n       stop=None,\n       additional_messages: List[Message] = [],\n       additional_insert_index: int = -1,\n       *args,\n       **kwargs\n   ):\n       prompt_messages = self.fill_in_placeholders(placeholders)\n       messages = prompt_messages[:additional_insert_index] + additional_messages + prompt_messages[additional_insert_index:]\n       messages = [message.raw() for message in messages]\n       \n       if self.config.default_request_type == 'openai':\n           arguments = None\n           functions = list(filter(lambda x: x['name'] not in ['subtask_submit','subtask_handle'],functions))\n           if CONFIG.enable_ask_human_for_help:\n               functions += [function_manager.get_function_schema('ask_human_for_help')]\n           messages[0]['content'] += '\\n--- Avaliable Tools ---\\nYou are allowed to use tools in the \"subtask_handle.tool_call\" function field.\\nRemember the \"subtask_handle.tool_call.tool_input\" field should always in JSON, as following described:\\n{}'.format(json.dumps(functions,indent=2))\n           \n           def change_tool_call_description(message:dict,reverse:bool=False):\n               des_pairs = [('Use tools to handle the subtask',\n                             'Use \"subtask_handle\" to make a normal tool call to handle the subtask'),\n                            ('5.1  Please remember to generate the function call field after the \"criticism\" field.\\n  5.2  Please check all content is in json format carefully.',\n                             '5.1. Please remember to generate the \"tool_call\" field after the \"criticism\" field.\\n  5.2. Please remember to generate comma if the \"tool_call\" field is after the \"criticism\" field.\\n  5.3. Please check whether the **\"tool_call\"** field is in the function call json carefully.'),\n                            ('After decide the action, use \"subtask_handle\" functions to apply action.',\n                             'After decide the action, call functions to apply action.')]\n               \n               for pair in des_pairs:\n                   message['content'] = message['content'].replace(pair[0],pair[1]) if reverse else message['content'].replace(pair[1],pair[0])\n                   \n               return message\n           \n           messages[0] = change_tool_call_description(messages[0])\n           functions = [function_manager.get_function_schema('subtask_submit'),\n                        function_manager.get_function_schema('subtask_handle')]\n\n       message,tokens = self.generate(\n           messages=messages,\n           arguments=arguments,\n           functions=functions,\n           function_call=function_call,\n           stop=stop,\n           *args,**kwargs\n       )\n\n       function_call_args:dict = message['function_call']['arguments']\n\n       if self.config.default_request_type == 'openai' and 'tool_call' in function_call_args:\n           tool_schema = function_manager.get_function_schema(function_call_args['tool_call'][\"tool_name\"])\n           assert tool_schema is not None, f\"Function {function_call_args['tool_call']['tool_name']} not found! Poential Schema Validation Error!\"\n           \n           tool_call_args = function_call_args['tool_call']['tool_input'] if 'tool_input' in function_call_args['tool_call'] else ''\n           \n           def validate():\n               nonlocal tool_schema,tool_call_args\n               if isinstance(tool_call_args,str):\n                   tool_call_args = {} if tool_call_args == '' else json5.loads(tool_call_args)\n               jsonschema.validate(instance=tool_call_args, schema=tool_schema['parameters'])\n           \n           try:\n               validate()\n           except Exception as e:  \n               messages[0] = change_tool_call_description(messages[0],reverse=True)\n               tool_call_args = objgenerator.dynamic_json_fixes(\n                   broken_json=tool_call_args,\n                   function_schema=tool_schema,\n                   messages=messages,\n                   error_message=str(e))[\"choices\"][0][\"message\"][\"function_call\"][\"arguments\"]\n               validate()\n           \n           function_call_args['tool_call']['tool_input'] = tool_call_args\n           \n           message['function_call'] = function_call_args.pop('tool_call')\n           message['function_call']['name'] = message['function_call'].pop('tool_name')\n           message['function_call']['arguments'] = message['function_call'].pop('tool_input')\n           message['arguments'] = function_call_args\n               \n       return message,tokens\n   ```",
            "code_start_line": 58,
            "code_end_line": 74,
            "parent": "BaseAgent",
            "have_return": true,
            "code_content": "    def fill_in_placeholders(self, placeholders: dict):\n        \"\"\"\n        Fills in placeholders defined in the input with the corresponding values.\n        \n        Args:\n            placeholders (dict): A dictionary containing keys as placeholders and values as their replacements.\n\n        Returns:\n            filled_messages: A copy of the initial prompt_messages with placeholders replaced with their corresponding values.\n        \"\"\"\n        filled_messages = deepcopy(self.prompt_messages)\n        for message in filled_messages:\n            role = message.role\n            if role in placeholders:\n                for key, value in placeholders[role].items():\n                    message.content = message.content.replace(\"{{\" + str(key) + \"}}\", str(value))\n        return filled_messages\n",
            "name_column": 8
        },
        "generate": {
            "type": "FunctionDef",
            "name": "generate",
            "md_content": "**generate函数**：该函数用于从AI模型生成响应，使用给定的消息、参数、函数和函数调用。\n\n该函数接受以下参数：\n- messages (list[dict]|list[Message])：与AI模型交互的消息列表。\n- arguments (dict, optional)：包含用于AI模型响应的参数的字典。\n- functions (list[dict], optional)：包含用于AI模型响应的函数的字典列表。\n- function_call (dict, optional)：表示要用于AI模型响应的函数调用的字典。\n- stop (dict, optional)：表示何时停止与AI模型的对话的字典。\n- *args：可变长度的参数列表。\n- **kwargs：任意关键字参数。\n\n该函数返回一个元组，包含生成的消息和生成AI模型响应所使用的令牌数。\n\n**代码分析和描述**：\n- 首先，函数检查messages参数的类型，如果是Message对象的列表，则将其转换为字典列表。\n- 接下来，函数根据配置文件中的默认请求类型进行处理。\n  - 如果默认请求类型是'openai'，则根据参数的情况生成相应的函数调用。\n    - 如果arguments不为None，则根据arguments生成函数调用。\n    - 如果functions为None或长度为0，则生成一个默认的函数调用。\n    - 如果functions只有一个函数，并且function_call为None，则将该函数作为默认的函数调用。\n    - 如果functions只有一个函数，并且arguments不为None，则将arguments中的属性添加到函数调用的参数中。\n    - 如果functions有多个函数，则抛出NotImplementedError。\n    - 调用objgenerator.chatcompletion函数，生成AI模型的响应。\n    - 解析响应中的函数调用参数，并将其添加到生成的消息中。\n  - 如果默认请求类型是'xagent'，则直接调用objgenerator.chatcompletion函数，生成AI模型的响应。\n  - 如果默认请求类型不在以上两种情况中，则抛出NotImplementedError。\n- 最后，函数返回生成的消息和使用的令牌数。\n\n**注意**：在使用该函数时，需要注意以下几点：\n- messages参数应为一个包含消息的列表，每个消息应为字典类型。\n- arguments参数应为一个字典，包含用于AI模型响应的参数。\n- functions参数应为一个字典列表，每个字典表示一个函数。\n- function_call参数应为一个字典，表示一个函数调用。\n- stop参数应为一个字典，表示何时停止与AI模型的对话。\n- 函数的返回值是一个包含生成的消息和使用的令牌数的元组。\n\n**输出示例**：\n```python\nmessage = {\n    'content': 'This is the generated response.',\n    'arguments': {\n        'argument1': 'value1',\n        'argument2': 'value2'\n    },\n    'function_call': {\n        'name': 'function_name',\n        'arguments': {\n            'arg1': 'value1',\n            'arg2': 'value2'\n        }\n    }\n}\ntokens = 100\n```",
            "code_start_line": 76,
            "code_end_line": 155,
            "parent": "BaseAgent",
            "have_return": true,
            "code_content": "    def generate(self,\n                 messages:list[dict]|list[Message],\n                 arguments:dict=None,\n                 functions:list[dict]=None,\n                 function_call:dict=None,\n                 stop:dict=None,\n                 *args,**kwargs):\n        \"\"\"\n        Generates a response from the AI model, using the given messages, arguments, functions,\n        and a function call.\n\n        Args:\n            messages (list[dict]|list[Message]): A list of messages with which to interact with the AI model.\n            arguments (dict, optional): A dictionary containing arguments to use for AI model responses.\n            functions (list[dict], optional): A list of dictionaries representing functions to use for AI model responses.\n            function_call (dict, optional): A dictionary representing a function call to use for AI model responses.\n            stop (dict, optional): A dictionary that signifies when to stop the conversation with the AI model.\n            *args: Variable list of arguments. \n            **kwargs: Arbitrary keyword arguments.\n\n        Returns:\n            message (dict): A message generated by the AI model.\n            tokens (int): Number of tokens used in generating the AI model's response.\n        \"\"\"\n        if isinstance(messages[0],Message):\n            messages = [message.raw() for message in messages]\n        if functions is not None and len(functions) == 1 and function_call is None:\n            function_call = {'name':functions[0]['name']} # must call at least one function\n        match CONFIG.default_request_type:\n            case 'openai':\n                if arguments is not None:\n                    if functions is None or len(functions) == 0:\n                        functions = [{\n                            'name':'reasoning',\n                            'parameters':arguments\n                        }]\n                        function_call = {'name':'reasoning'}\n                    elif len(functions) == 1:\n                        for k,v in arguments['properties'].items():\n                            functions[0]['parameters']['properties'][k] = v\n                            if k in arguments['required']:\n                                functions[0]['parameters']['required'].append(k)\n                    else:\n                        raise NotImplementedError(\"Not implemented for multiple functions with arguments\")\n                    \n                response = objgenerator.chatcompletion(\n                    messages=messages,\n                    functions=functions,\n                    function_call=function_call,\n                    stop=stop,\n                    *args,**kwargs)\n                \n                message = {}\n                function_call_args:dict = json5.loads(response[\"choices\"][0][\"message\"][\"function_call\"]['arguments'])\n                \n                if arguments is not None:\n                    message['arguments'] = {\n                        k: function_call_args.pop(k)\n                        for k in arguments['properties'].keys() if k in function_call_args\n                    }\n                if len(function_call_args) > 0:\n                    message['function_call'] = {\n                        'name': response['choices'][0]['message']['function_call']['name'],\n                        'arguments': function_call_args\n                    }\n\n            case 'xagent':\n                response = objgenerator.chatcompletion(\n                    messages=messages,\n                    arguments=arguments,\n                    functions=functions,\n                    function_call=function_call,\n                    stop=stop,\n                    *args,**kwargs)\n                message = json5.loads(response[\"choices\"][0][\"message\"]['content'])\n            case _:\n                raise NotImplementedError(f\"Request type {CONFIG.default_request_type} not implemented\")\n            \n        tokens = response[\"usage\"]\n        return message, tokens\n",
            "name_column": 8
        }
    },
    "XAgent/agent/__init__.py": {},
    "XAgent/agent/summarize.py": {
        "summarize_action": {
            "type": "FunctionDef",
            "name": "summarize_action",
            "md_content": "**summarize_action函数**：此函数的功能是生成一系列动作的摘要。\n\n该函数接受两个参数：action_process（要处理的动作列表）和task（任务名称），并返回一个包含动作摘要的字符串。\n\n函数内部首先检查action_process列表的长度，如果小于1，则返回\"未找到步骤\"。\n\n接下来，函数定义了一个内部函数generate_func_args，用于生成以字符串形式表示的函数参数。该函数接受两个参数：args（参数字典）和black_list（禁止或限制在args字典中使用的单词或键的列表）。函数通过遍历args字典中的键值对，并根据条件生成相应的字符串，最后返回生成的字符串。\n\n然后，函数对action_process列表进行遍历，根据条件对每个动作进行处理。首先判断动作的状态码，如果状态码为TOOL_CALL_SUCCESS，则将动作的命令和参数生成字符串，并将其存储在raw_action列表中的第一个位置。如果命令的名称为\"FileSystem\"，并且参数字典中包含\"filepath\"键，并且动作的状态码为TOOL_CALL_SUCCESS，则将raw_action列表中的第二个位置设置为\"`Old Content has been wrapped, check latest filesystem calling`\"，否则将其设置为动作的工具输出。最后，将raw_action添加到raw_actions字典中。\n\n接下来，函数对raw_actions字典中的键进行排序，并遍历排序后的键，生成每个动作的摘要。如果动作中不包含\"summary\"键，则将动作的描述信息和工具调用信息拼接成一个字符串，并使用function_manager函数的返回值作为动作的摘要。最后，将摘要添加到动作字典中。\n\n接下来，函数根据一定的规则对动作字典进行处理，包括添加返回值、添加失败原因等。最后，将处理后的动作字典按照键的顺序拼接成一个字符串，并返回该字符串作为函数的输出。\n\n**注意**：在使用该函数时，需要注意以下几点：\n- 函数的第一个参数action_process应为一个包含动作信息的列表。\n- 函数的第二个参数task应为一个字符串，表示任务名称。\n\n**输出示例**：假设action_process列表包含两个动作，摘要字符串的输出可能如下所示：\n```\n[0] command1(args1)\n[0][summary] summary1\n[0][description] description1\n[0][status code] TOOL_CALL_SUCCESS\n[0][return] return_value1\n[1] command2(args2)\n[1][summary] summary2\n[1][description] description2\n[1][status code] TOOL_CALL_SUCCESS\n[1][return] return_value2\n[suggestion] suggestion1\n[suggestion] suggestion2\n```",
            "code_start_line": 11,
            "code_end_line": 163,
            "parent": null,
            "have_return": true,
            "code_content": "def summarize_action(action_process:list[dict], task:str,)->(list[str],str):\n    \"\"\"\n    Generate a summarized series of actions.\n\n    Args:\n        action_process (list[dict]): The list of actions to process.\n        task (str): The task name.\n\n    Returns:\n        str: The string contains a summary of the actions.\n    \"\"\"\n    if len(action_process) < 1:\n        return \"No steps found\"\n    \n    def generate_func_args(args:dict,black_list=[])->str:\n        \"\"\"\n        Generate function arguments in the form of strings.\n\n        Args:\n            args (dict): A dictionary of arguments.\n            black_list (list): A list of forbidden or restricted words or keys in the args dictionary.\n\n        Returns:\n            str: A string that summarizes the function arguments.\n        \"\"\"\n        ret = ''\n        args_len = 0\n        for k,v in args.items():\n            if k in black_list:\n                v = '`wrapped`'\n            v_str,v_len = clip_text(str(v),SINGLE_ACTION_MAX_LENGTH-args_len,clip_end=True)\n            if v_len < SINGLE_ACTION_MAX_LENGTH-args_len:\n                ret += f'{k}=\"{v_str}\",' if isinstance(v,str) else f'{k}={v_str},'\n                args_len += v_len\n            else:\n                ret += f'{k}=\"{v_str}...\",' if isinstance(v,str) else f'{k}={v_str}...,'\n                args_len += SINGLE_ACTION_MAX_LENGTH-args_len\n                \n        return ret[:-1] # remove last comma\n    \n    # wrap old content\n    raw_actions = {}\n    accessed_files = []\n    last_successful_action_index = None\n    last_failed_action_index = None\n    for index,action in zip(range(len(action_process)-1,-1,-1),action_process[::-1]):\n        if last_successful_action_index is None and action['tool_status_code'] == ToolCallStatusCode.TOOL_CALL_SUCCESS:\n            last_successful_action_index = index\n        if last_failed_action_index is None and action['tool_status_code'] == ToolCallStatusCode.TOOL_CALL_FAILED:\n            last_failed_action_index = index\n        \n        command = action[\"command\"][\"properties\"]\n        if command['name'] == '' or not isinstance(command['args'],dict):\n            continue\n        \n        raw_action = ['`placeholder`','`placeholder`']\n        \n        if \"FileSystem\" in command[\"name\"] and \"filepath\" in command[\"args\"] and action[\"tool_status_code\"] == ToolCallStatusCode.TOOL_CALL_SUCCESS:\n            raw_action[0] = command['name']+f\"({generate_func_args(command['args'],black_list=['content','new_content'])})\"\n            if command['args']['filepath'] in accessed_files:\n                raw_action[1] = \"`Old Content has been wrapped, check latest filesystem calling`\"\n            else:\n                raw_action[1] = str(action['tool_output'])\n                accessed_files.append(command[\"args\"][\"filepath\"])\n        else:\n            raw_action[0] = command['name']+f\"({generate_func_args(command['args'])})\"\n            raw_action[1] = str(action['tool_output'])\n            \n        raw_actions[index] = raw_action\n    valid_index = list(raw_actions.keys())\n    valid_index.sort()\n    \n    ret = {}\n    for index in valid_index:\n        action = action_process[index]\n        if 'summary' not in action:\n            raw_actions_des = '\\n'.join([\n                f'[{k}] {v}' for k,v in action['thoughts']['properties'].items()\n            ] + [\n                f\"[tool_status_code] {action['tool_status_code']}\",\n                f\"[tool calling] {raw_actions[index][0]}\",\n                f\"[return] \"\n            ])\n            raw_actions_des += clip_text(raw_actions[index][1],MAX_RETURN_LENGTH-get_token_nums(raw_actions_des))[0]\n            \n            summary,tokens = function_manager('summarize_action',\n                                              action=raw_actions_des,current_task=task,\n                                              return_generation_usage=True,)\n            action['summary'] = summary\n            logger.typewriter_log(f\"Action summarized in {tokens['completion_tokens']} tokens\",Fore.YELLOW)\n        else:\n            summary = action['summary']\n        \n        act_str = '\\n'.join([\n            f'[{index}] {raw_actions[index][0]}',\n            f\"[{index}][summary] {summary['summary']}\",\n            f\"[{index}][description] {summary['description']}\",\n            f\"[{index}][status code] {action['tool_status_code']}\"\n        ])\n        if 'failed_reason_and_reflection' in summary and summary['failed_reason_and_reflection'] != '':\n            act_str += f'\\n[{index}][failed reason] {summary[\"failed_reason_and_reflection\"]}'\n        \n        # directly adding short returns\n        if len(raw_actions[index][1]) < 1000 and get_token_nums(raw_actions[index][1]) < 150:\n            act_str += f'\\n[{index}][return] {raw_actions[index][1]}'\n            \n        ret[index] = act_str\n    \n    reflection = function_manager('actions_reflection',\n                                  actions=clip_text('\\n'.join([ret[i] for i in valid_index]),MAX_RETURN_LENGTH)[0],\n                                  current_task=task)\n    \n    ret_lenght = {k:get_token_nums(v) for k,v in ret.items()}\n    total_length = sum(ret_lenght.values())\n    \n    # adding more return to last successful action\n    for i in [last_successful_action_index,last_failed_action_index]:\n        if i is not None and '[return]' not in ret[i]:\n            s = f'\\n[{i}][return] {clip_text(raw_actions[i][1],(MAX_RETURN_LENGTH-total_length)//2)[0]}'\n            return_length = get_token_nums(s)\n            ret_lenght[i] += return_length\n            total_length += return_length\n            ret[i] += s\n\n    key_actions:list = reflection['key_actions']\n    key_actions.sort(reverse=True)\n    for i in key_actions:\n        if total_length >= MAX_RETURN_LENGTH:\n            break\n        if i in ret and action_process[i][\"tool_status_code\"] == ToolCallStatusCode.TOOL_CALL_SUCCESS and '[return]' not in ret[i]:\n            s = f'\\n[{i}][return] {clip_text(raw_actions[i][1],SINGLE_ACTION_MAX_LENGTH-ret_lenght[i])[0]}'\n            if (tokens := get_token_nums(s))> MAX_RETURN_LENGTH-total_length:\n                continue\n            total_length += tokens\n            ret[i] += s\n    \n    while len(valid_index) > 0:\n        i = valid_index.pop()\n        if total_length >= MAX_RETURN_LENGTH:\n            break\n        if action_process[i][\"tool_status_code\"] == ToolCallStatusCode.TOOL_CALL_SUCCESS and '[return]' not in ret[i]:\n            s = f'\\n[{i}][return] {clip_text(raw_actions[i][1],SINGLE_ACTION_MAX_LENGTH-ret_lenght[i])[0]}'\n            if (tokens := get_token_nums(s))> MAX_RETURN_LENGTH-total_length:\n                continue\n            total_length += tokens\n            ret[i] += s\n\n\n    valid_index = list(ret.keys())\n    valid_index.sort()\n    ordered_rets = [ret[i] for i in valid_index] + [f'[suggestion] {sugg}'for sugg in reflection[\"suggestions\"]]\n    \n    return '\\n'.join(ordered_rets)\n",
            "name_column": 4
        },
        "summarize_plan": {
            "type": "FunctionDef",
            "name": "summarize_plan",
            "md_content": "**summarize_plan函数**：这个函数的功能是根据提供的计划生成一个总结的计划。\n\n该函数接受一个字典类型的参数plans，其中包含了要提供的计划信息。函数返回一个字符串，其中包含了计划的摘要信息。\n\n函数内部定义了一个嵌套函数recursive_summary，用于递归生成摘要计划。在递归过程中，函数会根据计划的不同字段生成相应的描述信息，并将其添加到summary列表中。\n\n函数还定义了一些局部变量，如summary用于存储计划的摘要信息列表，task_ids用于存储计划的任务ID列表，detailed_info用于存储详细的计划信息，current_task_id用于记录当前任务ID。\n\n在函数的最后，根据计划的长度和摘要信息的长度，生成最终的摘要计划。最后将摘要计划转换为字符串形式并返回。\n\n**注意**：该函数依赖于get_token_nums函数和MAX_PLAN_LENGTH常量。\n\n**输出示例**：\n```\n[Task ID] 1\n[Name] Task 1\n[Goal] Complete task 1\n[Status] DOING\n[Milestones]\n- Milestone 1\n- Milestone 2\n[Prior Plan Criticism] Plan criticism for task 1\n[Action Status] Success\n[Action Info]\n- [Conclusion] Action conclusion for task 1\n- [Summary] Action summary for task 1\n```\n这是一个计划的摘要信息示例，包含了任务ID、名称、目标、状态、里程碑、先前计划批评、动作状态和动作信息等信息。",
            "code_start_line": 165,
            "code_end_line": 243,
            "parent": null,
            "have_return": true,
            "code_content": "def summarize_plan(plans:dict)->str:\n    \"\"\"\n    Generate a summarized plan based on provided plans.\n\n    Args:\n        plans (dict): The plans to provide.\n\n    Returns:\n        str: The string contains a summary of the plan.\n    \"\"\"\n    summary:list[list] = []\n    task_ids = []\n    detailed_info:dict[str,list] = {}\n    current_task_id = None\n    def recursive_summary(plan:dict,):\n        \"\"\"\n        Generate a summarized plan in a recursive process.\n\n        Args:\n            plan (dict): A dictionary of plans.\n\n        Returns:\n            None\n        \"\"\"\n        nonlocal summary\n        nonlocal current_task_id\n        plan_des = [\n            f'[Task ID] {plan[\"task_id\"]}',\n            f'[Name] {plan[\"name\"]}',\n            f'[Goal] {plan[\"goal\"]}',\n            f'[Status] {plan[\"exceute_status\"]}',\n        ]\n        if current_task_id is None and plan['exceute_status'] == 'DOING':\n            current_task_id = plan['task_id']\n            \n        if 'milestones' in plan and len(plan['milestones']) > 0:\n            plan_des.extend(['[Milestones]']+['- '+milestone for milestone in plan[\"milestones\"]])\n\n        \n        if 'action_list_summary' not in plan and 'prior_plan_criticism' in plan:\n            plan_des.append(f'[Prior Plan Criticism] {plan[\"prior_plan_criticism\"]}')\n        \n        if 'submit_result' in plan and 'args' in plan['submit_result']:\n            submission = plan['submit_result']['args']\n            plan_des.append(f'[Action Status] {\"Success\" if submission[\"result\"][\"success\"] else \"Fail\"}')\n            \n            # possible too long part\n            action_des = [\n                '[Action Info]',\n                f\"- [Conclusion] {submission['result']['conclusion']}\"\n            ]\n            if 'action_list_summary' in plan:\n                action_des.append(f'- [Summary] {plan[\"action_list_summary\"]}')  \n            if submission['suggestions_for_latter_subtasks_plan']['need_for_plan_refine']:\n                if submission['suggestions_for_latter_subtasks_plan']['reason'] != '':\n                    action_des.append(f\"- [Proposal] {submission['suggestions_for_latter_subtasks_plan']['reason']}\")\n            detailed_info[plan['task_id']] = action_des\n        \n        task_ids.append(plan['task_id'])\n        summary.append(plan_des)\n        if \"subtask\" in plan:\n            for subtask in plan[\"subtask\"]:\n                recursive_summary(subtask)\n    recursive_summary(plans)\n    total_tokens = sum([get_token_nums('\\n'.join(plan)) for plan in summary])\n    if current_task_id is None:\n        current_task_id = task_ids[-1]\n    for task_id,plan in zip(task_ids[::-1],summary[::-1]):\n        if task_id <= current_task_id and task_id in detailed_info:\n            if (tokens:=get_token_nums('\\n'.join(detailed_info[task_id]))) > MAX_PLAN_LENGTH-total_tokens:\n                continue\n            else:\n                total_tokens += tokens\n                plan.extend(detailed_info[task_id])\n    # logger.typewriter_log(f'Plan summarized {total_tokens}',Fore.YELLOW)\n    ret = []\n    for plan in summary:\n        ret.append('\\n'.join(plan))\n    return '\\n'.join(ret)",
            "name_column": 4
        },
        "generate_func_args": {
            "type": "FunctionDef",
            "name": "generate_func_args",
            "md_content": "**generate_func_args函数**：该函数的功能是生成以字符串形式表示的函数参数。\n\n该函数接受两个参数：args（字典类型）和black_list（列表类型），并返回一个字符串，该字符串概括了函数的参数。\n\n参数说明：\n- args（字典类型）：一个包含参数的字典。\n- black_list（列表类型）：一个包含禁止或限制在args字典中使用的关键词或键的列表。\n\n返回值：\n- str：一个字符串，概括了函数的参数。\n\n函数内部实现逻辑如下：\n1. 初始化一个空字符串ret和一个变量args_len，用于记录已处理的参数长度。\n2. 遍历args字典中的每个键值对，其中k为键，v为值。\n3. 如果k在black_list列表中，则将v替换为\"`wrapped`\"。\n4. 使用clip_text函数将v转换为字符串，并限制其长度不超过SINGLE_ACTION_MAX_LENGTH-args_len，clip_end参数表示是否截断字符串末尾。\n5. 如果v的长度小于SINGLE_ACTION_MAX_LENGTH-args_len，则将k和v添加到ret字符串中，如果v是字符串类型，则使用双引号括起来；如果v不是字符串类型，则直接添加。\n6. 更新args_len的值。\n7. 如果v的长度超过SINGLE_ACTION_MAX_LENGTH-args_len，则将k和截断后的v添加到ret字符串中，如果v是字符串类型，则使用双引号括起来，并在末尾添加省略号；如果v不是字符串类型，则直接添加，并在末尾添加省略号。\n8. 更新args_len的值。\n9. 返回ret字符串，去除最后一个逗号。\n\n**注意**：在使用该函数时，需要注意以下几点：\n- args参数必须是一个字典类型。\n- black_list参数可以为空列表，也可以包含禁止或限制使用的关键词或键。\n- 函数返回的字符串概括了函数的参数，可以根据需要进行进一步处理或展示。\n\n**输出示例**：以下是该函数的一个可能的返回值的示例：\n```\narg1=\"value1\", arg2=\"value2\", arg3=\"value3\"...\n```",
            "code_start_line": 25,
            "code_end_line": 49,
            "parent": "summarize_action",
            "have_return": true,
            "code_content": "    def generate_func_args(args:dict,black_list=[])->str:\n        \"\"\"\n        Generate function arguments in the form of strings.\n\n        Args:\n            args (dict): A dictionary of arguments.\n            black_list (list): A list of forbidden or restricted words or keys in the args dictionary.\n\n        Returns:\n            str: A string that summarizes the function arguments.\n        \"\"\"\n        ret = ''\n        args_len = 0\n        for k,v in args.items():\n            if k in black_list:\n                v = '`wrapped`'\n            v_str,v_len = clip_text(str(v),SINGLE_ACTION_MAX_LENGTH-args_len,clip_end=True)\n            if v_len < SINGLE_ACTION_MAX_LENGTH-args_len:\n                ret += f'{k}=\"{v_str}\",' if isinstance(v,str) else f'{k}={v_str},'\n                args_len += v_len\n            else:\n                ret += f'{k}=\"{v_str}...\",' if isinstance(v,str) else f'{k}={v_str}...,'\n                args_len += SINGLE_ACTION_MAX_LENGTH-args_len\n                \n        return ret[:-1] # remove last comma\n",
            "name_column": 8
        },
        "recursive_summary": {
            "type": "FunctionDef",
            "name": "recursive_summary",
            "md_content": "**recursive_summary函数**: 这个函数的功能是生成一个递归过程中的总结计划。\n\n该函数接受一个字典类型的计划作为参数。\n\n函数内部首先定义了一些局部变量，包括summary、task_ids和detailed_info。然后通过递归的方式遍历计划的子任务，生成计划的总结描述。在生成总结描述的过程中，会根据计划的不同属性添加相应的描述信息，如任务ID、名称、目标和执行状态等。如果计划中包含里程碑，会将里程碑信息添加到总结描述中。如果计划中没有动作列表的总结描述，但存在之前计划的批评信息，会将批评信息添加到总结描述中。如果计划中存在提交结果，并且结果中包含参数信息，会将动作状态和结论信息添加到总结描述中。如果提交结果中的建议需要对后续子任务的计划进行改进，并且存在改进原因，会将改进原因添加到总结描述中。最后，将任务ID和总结描述添加到task_ids和summary列表中。\n\n在函数的最后，根据当前任务ID和总结描述的长度，对总结描述进行筛选和补充。如果总结描述的长度超过了最大计划长度限制，会跳过该计划。否则，将该计划的详细信息添加到总结描述中。最终，将所有计划的总结描述拼接成一个字符串，并返回。\n\n**注意**: 使用该函数时需要注意以下几点：\n- 该函数需要传入一个字典类型的计划作为参数。\n- 计划中的属性需要符合特定的命名规范，如task_id、name、goal、exceute_status等。\n- 计划中的子任务需要以\"subtask\"属性的形式存在，并且是一个列表类型。\n- 计划中的提交结果需要符合特定的结构，包含args属性，并且args属性中包含result和suggestions_for_latter_subtasks_plan等属性。\n- 计划的总结描述长度不能超过最大计划长度限制。",
            "code_start_line": 179,
            "code_end_line": 227,
            "parent": "summarize_plan",
            "have_return": false,
            "code_content": "    def recursive_summary(plan:dict,):\n        \"\"\"\n        Generate a summarized plan in a recursive process.\n\n        Args:\n            plan (dict): A dictionary of plans.\n\n        Returns:\n            None\n        \"\"\"\n        nonlocal summary\n        nonlocal current_task_id\n        plan_des = [\n            f'[Task ID] {plan[\"task_id\"]}',\n            f'[Name] {plan[\"name\"]}',\n            f'[Goal] {plan[\"goal\"]}',\n            f'[Status] {plan[\"exceute_status\"]}',\n        ]\n        if current_task_id is None and plan['exceute_status'] == 'DOING':\n            current_task_id = plan['task_id']\n            \n        if 'milestones' in plan and len(plan['milestones']) > 0:\n            plan_des.extend(['[Milestones]']+['- '+milestone for milestone in plan[\"milestones\"]])\n\n        \n        if 'action_list_summary' not in plan and 'prior_plan_criticism' in plan:\n            plan_des.append(f'[Prior Plan Criticism] {plan[\"prior_plan_criticism\"]}')\n        \n        if 'submit_result' in plan and 'args' in plan['submit_result']:\n            submission = plan['submit_result']['args']\n            plan_des.append(f'[Action Status] {\"Success\" if submission[\"result\"][\"success\"] else \"Fail\"}')\n            \n            # possible too long part\n            action_des = [\n                '[Action Info]',\n                f\"- [Conclusion] {submission['result']['conclusion']}\"\n            ]\n            if 'action_list_summary' in plan:\n                action_des.append(f'- [Summary] {plan[\"action_list_summary\"]}')  \n            if submission['suggestions_for_latter_subtasks_plan']['need_for_plan_refine']:\n                if submission['suggestions_for_latter_subtasks_plan']['reason'] != '':\n                    action_des.append(f\"- [Proposal] {submission['suggestions_for_latter_subtasks_plan']['reason']}\")\n            detailed_info[plan['task_id']] = action_des\n        \n        task_ids.append(plan['task_id'])\n        summary.append(plan_des)\n        if \"subtask\" in plan:\n            for subtask in plan[\"subtask\"]:\n                recursive_summary(subtask)\n",
            "name_column": 8
        }
    },
    "XAgent/agent/utils.py": {
        "get_command": {
            "type": "FunctionDef",
            "name": "get_command",
            "md_content": "**get_command函数**：该函数的作用是解析响应并返回命令名称和参数。\n\n该函数会抛出`json.decoder.JSONDecodeError`异常，如果响应不是有效的JSON格式。如果发生其他任何错误，也会捕获并返回一个带有异常消息的\"Error:\"信息。\n\n参数：\n- response_json (Dict)：以字典格式表示的AI的响应。\n\n返回值：\n- tuple：命令名称和参数，或者一些错误指示。\n  - 如果响应的JSON字典中不包含'command'键，或者'command'的值不是字典，或者'command'字典中不包含'name'键，则返回一个元组，其中第一个元素是'Error:'，第二个元素是解释问题的字符串。\n  - 如果发生错误，则返回一个元组，其中第一个元素是'Error:'，第二个元素是异常的字符串表示。\n\n抛出异常：\n- json.decoder.JSONDecodeError：如果响应不是有效的JSON格式。\n- Exception：如果发生其他任何错误。\n\n该函数首先检查响应中是否包含'command'键，如果不包含，则返回一个错误信息。然后，它检查响应是否是字典格式，如果不是，则返回一个错误信息。接下来，它获取'command'对象，并检查它是否是字典格式，如果不是，则返回一个错误信息。然后，它检查'command'对象中是否包含'name'键，如果不包含，则返回一个错误信息。最后，它获取命令名称和参数，并返回它们。\n\n如果发生`json.decoder.JSONDecodeError`异常，表示响应不是有效的JSON格式，函数会返回一个错误信息。如果发生其他任何异常，函数会返回一个带有异常消息的错误信息。\n\n**注意**：使用该代码时需要注意以下几点：\n- 确保响应是有效的JSON格式。\n- 确保响应的字典中包含'command'键，并且'command'的值是一个字典。\n- 确保'command'字典中包含'name'键。\n\n**输出示例**：\n```\ncommand_name = \"search\"\narguments = {\"query\": \"apple\", \"limit\": 10}\n```",
            "code_start_line": 4,
            "code_end_line": 49,
            "parent": null,
            "have_return": true,
            "code_content": "def get_command(response_json: Dict):\n    \"\"\"\n    Parses the response and returns the command name and arguments.\n\n    This function will raise the exception `json.decoder.JSONDecodeError` if the response is not valid JSON.\n    Any other error that occurs is also caught and the function returns an \"Error:\" message with the exception message.\n\n    Args:\n        response_json (Dict): The response from the AI in dictionary format.\n\n    Returns:\n        tuple: The command name and arguments, or some error indication.\n               If the response json dictionary does not contain the 'command' key, or the value of\n               'command' is not a dictionary, or the 'command' dictionary does not contain the 'name' key,\n               returns a tuple where the first element is 'Error:' and the second element is a string explaining the problem.\n               If some error occurs, returns a tuple where the first element is 'Error:' and the second element is the str of the exception.\n\n    Raises:\n        json.decoder.JSONDecodeError: If the response is not valid JSON.\n        Exception: If any other error occurs.\n    \"\"\"\n    try:\n        if \"command\" not in response_json:\n            return \"Error:\", \"Missing 'command' object in JSON\"\n\n        if not isinstance(response_json, dict):\n            return \"Error:\", f\"'response_json' object is not dictionary {response_json}\"\n\n        command = response_json[\"command\"]\n        if not isinstance(command, dict):\n            return \"Error:\", \"'command' object is not a dictionary\"\n\n        if \"name\" not in command:\n            return \"Error:\", \"Missing 'name' field in 'command' object\"\n\n        command_name = command[\"name\"]\n\n        # Use an empty dictionary if 'args' field is not present in 'command' object\n        arguments = command.get(\"args\", {})\n\n        return command_name, arguments\n    except json.decoder.JSONDecodeError:\n        return \"Error:\", \"Invalid JSON\"\n    # All other errors, return \"Error: + error message\"\n    except Exception as e:\n        return \"Error:\", str(e)",
            "name_column": 4
        }
    },
    "XAgent/agent/plan_refine_agent/__init__.py": {},
    "XAgent/agent/plan_refine_agent/agent.py": {
        "PlanRefineAgent": {
            "type": "ClassDef",
            "name": "PlanRefineAgent",
            "md_content": "**PlanRefineAgent功能**：PlanRefineAgent是PlanGenerateAgent的子类，用于对计划进行细化。\n\n该类利用计划细化的必要能力来解析信息并生成细化的计划。它包含占位符作为所需的表达式。\n\n**属性**：\n- abilities：Agent所需的一组必要能力。对于PlanRefineAgent，它包括计划细化。\n\n**方法**：\n- parse方法：解析信息以便细化现有计划。\n\n  该方法使用相应的表达式填充占位符，然后处理和合并提示和附加消息到最终消息中。最后，调用PlanGenerateAgent类的'generate'方法生成最终消息。\n\n  参数：\n  - placeholders（可选）：要填充部分完成的文本片段的所需表达式。\n  - arguments（可选）：函数的参数。\n  - functions（可选）：要执行的函数。\n  - function_call（可选）：用户的功能请求。\n  - stop（可选）：在某个特定点停止解析。\n  - additional_messages（可选）：要包含在最终消息中的附加消息列表。\n  - additional_insert_index（可选）：附加消息应插入到提示消息中的索引位置。\n  - *args：可变长度参数列表。\n  - **kwargs：任意关键字参数。\n\n  返回值：\n  - object：从提供的占位符、参数、函数和消息生成的细化计划。\n\n**注意**：使用该代码的注意事项\n\n**输出示例**：模拟代码返回值的可能外观。",
            "code_start_line": 6,
            "code_end_line": 60,
            "parent": null,
            "have_return": true,
            "code_content": "class PlanRefineAgent(PlanGenerateAgent):\n    \"\"\"PlanRefineAgent is a subclass of PlanGenerateAgent and is involved in refining the plan.\n\n    This class utilizes the required ability of plan refinement to parse information \n    and generate a refined plan. It includes placeholders as the desired expressions.\n\n    Attributes:\n        abilities: A set of required abilities for the Agent. For PlanRefineAgent, it includes plan refinement.\n    \"\"\"\n    abilities = set([RequiredAbilities.plan_refinement])\n\n    def parse(\n        self,\n        placeholders: dict = {},\n        arguments:dict = None,\n        functions=None,\n        function_call=None,\n        stop=None,\n        additional_messages: List[Message] = [],\n        additional_insert_index: int = -1,\n        *args,\n        **kwargs\n    ):\n        \"\"\" Parses information in order to refine the existing plan.\n\n        This method fills in placeholders with corresponding expressions, then prompts and \n        additional messages are processed and converged into final messages. Finally, the \n        'generate' method of PlanGenerateAgent class is then invoked on the final messages.\n\n        Args:\n            placeholders (dict, optional): Desired expressions to fill in partially completed text snippets.\n            arguments (dict, optional): Arguments to the function.\n            functions (optional): Functions to be carried out.\n            function_call (optional): Functional request from the user.\n            stop (optional): Stop parsing at some particular point.\n            additional_messages (List[Message], optional): Additional messages to be included in final message.\n            additional_insert_index (int, optional): Index in prompt messages where additional messages should be inserted.\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n\n        Returns:\n            object: A refined plan generated from provided placeholders, arguments, functions, and messages.\n        \"\"\"\n        \n        prompt_messages = self.fill_in_placeholders(placeholders)\n        messages =prompt_messages[:additional_insert_index] + additional_messages + prompt_messages[additional_insert_index:]\n        \n        return self.generate(\n            messages=messages,\n            arguments=arguments,\n            functions=functions,\n            function_call=function_call,\n            stop=stop,\n            *args,**kwargs\n        )",
            "name_column": 6
        },
        "parse": {
            "type": "FunctionDef",
            "name": "parse",
            "md_content": "**parse函数**：该函数的作用是解析信息以便完善现有的计划。\n\n该方法将占位符填充为相应的表达式，然后处理提示和附加消息，并将它们汇总为最终消息。最后，将在最终消息上调用PlanGenerateAgent类的'generate'方法。\n\n参数：\n- placeholders（字典，可选）：要填充部分完成的文本片段的期望表达式。\n- arguments（字典，可选）：函数的参数。\n- functions（可选）：要执行的函数。\n- function_call（可选）：用户的功能请求。\n- stop（可选）：在某个特定点停止解析。\n- additional_messages（List[Message]，可选）：要包含在最终消息中的附加消息。\n- additional_insert_index（int，可选）：附加消息应插入到提示消息中的索引。\n- *args：可变长度参数列表。\n- **kwargs：任意关键字参数。\n\n返回值：\n- object：从提供的占位符、参数、函数和消息生成的完善计划。\n\n**注意**：关于代码使用的注意事项\n\n**输出示例**：模拟代码返回值的可能外观。",
            "code_start_line": 17,
            "code_end_line": 60,
            "parent": "PlanRefineAgent",
            "have_return": true,
            "code_content": "    def parse(\n        self,\n        placeholders: dict = {},\n        arguments:dict = None,\n        functions=None,\n        function_call=None,\n        stop=None,\n        additional_messages: List[Message] = [],\n        additional_insert_index: int = -1,\n        *args,\n        **kwargs\n    ):\n        \"\"\" Parses information in order to refine the existing plan.\n\n        This method fills in placeholders with corresponding expressions, then prompts and \n        additional messages are processed and converged into final messages. Finally, the \n        'generate' method of PlanGenerateAgent class is then invoked on the final messages.\n\n        Args:\n            placeholders (dict, optional): Desired expressions to fill in partially completed text snippets.\n            arguments (dict, optional): Arguments to the function.\n            functions (optional): Functions to be carried out.\n            function_call (optional): Functional request from the user.\n            stop (optional): Stop parsing at some particular point.\n            additional_messages (List[Message], optional): Additional messages to be included in final message.\n            additional_insert_index (int, optional): Index in prompt messages where additional messages should be inserted.\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n\n        Returns:\n            object: A refined plan generated from provided placeholders, arguments, functions, and messages.\n        \"\"\"\n        \n        prompt_messages = self.fill_in_placeholders(placeholders)\n        messages =prompt_messages[:additional_insert_index] + additional_messages + prompt_messages[additional_insert_index:]\n        \n        return self.generate(\n            messages=messages,\n            arguments=arguments,\n            functions=functions,\n            function_call=function_call,\n            stop=stop,\n            *args,**kwargs\n        )",
            "name_column": 8
        }
    },
    "XAgent/agent/plan_refine_agent/prompt.py": {
        "get_examples_for_dispatcher": {
            "type": "FunctionDef",
            "name": "get_examples_for_dispatcher",
            "md_content": "**get_examples_for_dispatcher函数**：该函数的功能是为调度器提供示例。\n\n该函数返回三个变量，分别是example_input、example_system_prompt和example_user_prompt。其中example_input是用户查询或任务的示例输入，example_system_prompt是系统提示的示例，example_user_prompt是用户提示的示例。\n\n该函数没有任何参数。\n\n**注意**：无\n\n**输出示例**：\n```\n示例输入：Refine a plan for writing a Python-based calculator.\n示例系统提示：系统提示\n示例用户提示：用户提示\n```",
            "code_start_line": 72,
            "code_end_line": 83,
            "parent": null,
            "have_return": true,
            "code_content": "def get_examples_for_dispatcher():\n    \"\"\"The example that will be given to the dispatcher to generate the prompt\n\n    Returns:\n        example_input: the user query or the task\n        example_system_prompt: the system prompt\n        example_user_prompt: the user prompt\n    \"\"\"\n    example_input = \"Refine a plan for writing a Python-based calculator.\"\n    example_system_prompt = SYSTEM_PROMPT\n    example_user_prompt = USER_PROMPT\n    return example_input, example_system_prompt, example_user_prompt",
            "name_column": 4
        }
    },
    "XAgent/agent/tool_agent/__init__.py": {},
    "XAgent/agent/tool_agent/agent.py": {
        "ToolAgent": {
            "type": "ClassDef",
            "name": "ToolAgent",
            "md_content": "**ToolAgent函数**：这个类的功能是表示ToolAgent对象，它继承自BaseAgent。它主要关注工具树及其功能的操作。\n\n该类具有以下属性：\n- abilities（集合）：用于存储当前ToolAgent的能力。默认情况下，它被设置为`RequiredAbilities.tool_tree_search`。\n\n该类具有以下方法：\n\n**parse方法**：根据输入参数使用`generate()`函数生成消息列表和标记列表，根据特定条件进行修改，并返回结果。\n\n参数：\n- placeholders（字典，可选）：用于存储占位符及其映射关系的字典对象。\n- arguments（字典，可选）：用于存储参数详细信息的字典对象。\n- functions：允许插入函数的函数字段的列表。\n- function_call：表示正在处理的当前函数调用的字典。\n- stop：循环的终止条件。\n- additional_messages（列表，可选）：要附加到现有消息列表的附加消息列表。\n- additional_insert_index（整数，可选）：要插入附加消息的索引位置。\n- *args：父类`generate()`函数的可变长度参数列表。\n- **kwargs：父类`generate()`函数的任意关键字参数。\n\n返回值：\n- tuple：包含解析消息的字典和标记列表的元组。\n\n抛出异常：\n- AssertionError：如果在可能的函数列表中找不到指定的函数模式。\n- Exception：如果工具调用参数的验证失败。\n\n**message_to_tool_node方法**：将给定的消息字典转换为ToolNode对象。\n\n参数：\n- message（字典）：包含内容、函数调用和参数的消息数据的字典。\n\n返回值：\n- ToolNode：从提供的消息生成的ToolNode对象。\n\n警告：\n- 如果输入消息中缺少`function_call`字段，将记录警告消息。\n\n**注意**：在使用代码时需要注意的事项。\n\n**输出示例**：模拟代码返回值的可能外观。\n\n请注意：\n- 生成的内容中不应包含Markdown的标题和分隔符语法。\n- 主要使用中文编写，如果需要，可以在分析和描述中使用一些英文单词，以增强文档的可读性，因为不需要将函数名或变量名翻译为目标语言。",
            "code_start_line": 16,
            "code_end_line": 175,
            "parent": null,
            "have_return": true,
            "code_content": "class ToolAgent(BaseAgent):\n    \"\"\"\n    This class is used to represent the ToolAgent object, which is inherited from the BaseAgent. It mainly focuses\n    on actions around the tool tree and its functions.\n\n    Attributes:\n        abilities (set): Set to store the abilities of the current ToolAgent. By default, it is set to \n        `RequiredAbilities.tool_tree_search`.\n    \"\"\"\n    abilities = set([RequiredAbilities.tool_tree_search])\n\n    @retry(stop=stop_after_attempt(CONFIG.max_retry_times),reraise=True)\n    def parse(\n        self,\n        placeholders: dict = {},\n        arguments:dict=None,\n        functions=None,\n        function_call=None,\n        stop=None,\n        additional_messages: List[Message] = [],\n        additional_insert_index: int = -1,\n        *args,\n        **kwargs\n    ):\n        \"\"\"\n        This function generates a message list and a token list based on the input parameters using the \n        `generate()` function, modifies it as per specific conditions, and returns it.\n        \n        Args:\n            placeholders (dict, optional): Dictionary object to store the placeholders and their mappings.\n            arguments (dict, optional): Dictionary object to store argument's details.\n            functions: List of permissible functions that can be inserted in the function fields for the `openai` type.\n            function_call: A dictionary representing the current function call being processed.\n            stop: The termination condition for the loop.\n            additional_messages (list, optional): List of additional messages to be appended to the existing message list.\n            additional_insert_index (int, optional): The index position to insert the additional messages.\n            *args: Variable length argument list for the parent class's `generate()` function.\n            **kwargs: Arbitrary keyword arguments for the parent class's `generate()` function.\n            \n        Returns:\n            tuple: A tuple containing a dictionary of the parsed message and a list of tokens.\n            \n        Raises:\n            AssertionError: If the specified function schema is not found in the list of possible functions.\n            Exception: If the validation of the tool's call arguments fails.\n        \"\"\"\n        \n        prompt_messages = self.fill_in_placeholders(placeholders)\n        messages = prompt_messages[:additional_insert_index] + additional_messages + prompt_messages[additional_insert_index:]\n        messages = [message.raw() for message in messages]\n        \n        # Temporarily disable the arguments for openai\n        if self.config.default_request_type == 'openai':\n            arguments = None\n            functions = list(filter(lambda x: x['name'] not in ['subtask_submit','subtask_handle'],functions))\n            if CONFIG.enable_ask_human_for_help:\n                functions += [function_manager.get_function_schema('ask_human_for_help')]\n            messages[0]['content'] += '\\n--- Avaliable Tools ---\\nYou are allowed to use tools in the \"subtask_handle.tool_call\" function field.\\nRemember the \"subtask_handle.tool_call.tool_input\" field should always in JSON, as following described:\\n{}'.format(json.dumps(functions,indent=2))\n            \n            def change_tool_call_description(message:dict,reverse:bool=False):\n                des_pairs = [('Use tools to handle the subtask',\n                              'Use \"subtask_handle\" to make a normal tool call to handle the subtask'),\n                             ('5.1  Please remember to generate the function call field after the \"criticism\" field.\\n  5.2  Please check all content is in json format carefully.',\n                              '5.1. Please remember to generate the \"tool_call\" field after the \"criticism\" field.\\n  5.2. Please remember to generate comma if the \"tool_call\" field is after the \"criticism\" field.\\n  5.3. Please check whether the **\"tool_call\"** field is in the function call json carefully.'),\n                             ('After decide the action, use \"subtask_handle\" functions to apply action.',\n                              'After decide the action, call functions to apply action.')]\n                \n                for pair in des_pairs:\n                    message['content'] = message['content'].replace(pair[0],pair[1]) if reverse else message['content'].replace(pair[1],pair[0])\n                    \n                return message\n            \n            messages[0] = change_tool_call_description(messages[0])\n            functions = [function_manager.get_function_schema('subtask_submit'),\n                         function_manager.get_function_schema('subtask_handle')]\n\n        message,tokens = self.generate(\n            messages=messages,\n            arguments=arguments,\n            functions=functions,\n            function_call=function_call,\n            stop=stop,\n            *args,**kwargs\n        )\n\n        function_call_args:dict = message['function_call']['arguments']\n\n        # for tool_call, we need to validate the tool_call arguments if exising\n        if self.config.default_request_type == 'openai' and 'tool_call' in function_call_args:\n            tool_schema = function_manager.get_function_schema(function_call_args['tool_call'][\"tool_name\"])\n            assert tool_schema is not None, f\"Function {function_call_args['tool_call']['tool_name']} not found! Poential Schema Validation Error!\"\n            \n            tool_call_args = function_call_args['tool_call']['tool_input'] if 'tool_input' in function_call_args['tool_call'] else ''\n            \n            def validate():\n                nonlocal tool_schema,tool_call_args\n                if isinstance(tool_call_args,str):\n                    tool_call_args = {} if tool_call_args == '' else json5.loads(tool_call_args)\n                jsonschema.validate(instance=tool_call_args, schema=tool_schema['parameters'])\n            \n            try:\n                validate()\n            except Exception as e:  \n                messages[0] = change_tool_call_description(messages[0],reverse=True)\n                tool_call_args = objgenerator.dynamic_json_fixes(\n                    broken_json=tool_call_args,\n                    function_schema=tool_schema,\n                    messages=messages,\n                    error_message=str(e))[\"choices\"][0][\"message\"][\"function_call\"][\"arguments\"]\n                validate()\n            \n            function_call_args['tool_call']['tool_input'] = tool_call_args\n            \n            message['function_call'] = function_call_args.pop('tool_call')\n            message['function_call']['name'] = message['function_call'].pop('tool_name')\n            message['function_call']['arguments'] = message['function_call'].pop('tool_input')\n            message['arguments'] = function_call_args\n                \n        return message,tokens\n    \n    def message_to_tool_node(self,message) -> ToolNode:\n        \"\"\"\n        This method converts a given message dictionary to a ToolNode object.\n        \n        Args:\n            message (dict): Dictionary of message data containing content, function call and arguments.\n\n        Returns:\n            ToolNode: A ToolNode object generated from the provided message.\n            \n        Warning:\n            If the `function_call` field is missing in the input message, a warning message will be logged. \n        \"\"\"\n        \n        # assume message format\n        # {\n        #   \"content\": \"The content is useless\",\n        #   \"function_call\": {\n        #       \"name\": \"xxx\",\n        #       \"arguments\": \"xxx\"\n        #  },\n        #  \"arguments\": {\n        #      \"xxx\": \"xxx\",\n        #      \"xxx\": \"xxx\"   \n        #  },\n        # }\n        \n        new_node = ToolNode()\n        if \"content\" in message.keys():\n            print(message[\"content\"])\n            new_node.data[\"content\"] = message[\"content\"]\n        if 'arguments' in message.keys():\n            new_node.data['thoughts']['properties'] = message[\"arguments\"]\n        if \"function_call\" in message.keys():\n            new_node.data[\"command\"][\"properties\"][\"name\"] = message[\"function_call\"][\"name\"]\n            new_node.data[\"command\"][\"properties\"][\"args\"] = message[\"function_call\"][\"arguments\"]\n        else:\n            logger.typewriter_log(\"message_to_tool_node warning: no function_call in message\",Fore.RED)\n\n        return new_node",
            "name_column": 6
        },
        "parse": {
            "type": "FunctionDef",
            "name": "parse",
            "md_content": "**parse函数**：该函数的作用是根据输入参数使用`generate()`函数生成消息列表和令牌列表，根据特定条件进行修改，并返回结果。\n\n该函数接受以下参数：\n- placeholders（可选）：存储占位符及其映射关系的字典对象。\n- arguments（可选）：存储参数详细信息的字典对象。\n- functions：允许插入函数字段的函数列表，用于`openai`类型。\n- function_call：表示当前正在处理的函数调用的字典。\n- stop：循环的终止条件。\n- additional_messages（可选）：要附加到现有消息列表的附加消息列表。\n- additional_insert_index（可选）：要插入附加消息的索引位置。\n- *args：父类`generate()`函数的可变长度参数列表。\n- **kwargs：父类`generate()`函数的任意关键字参数。\n\n该函数返回一个元组，包含解析后的消息字典和令牌列表。\n\n该函数的主要功能是根据输入参数生成消息列表，并根据特定条件进行修改。首先，通过`fill_in_placeholders()`函数将占位符替换为实际值，然后将其与附加消息合并。接下来，将消息列表中的每个消息转换为原始文本，并存储在新的列表中。如果配置的默认请求类型是`openai`，则会进行一些特殊处理。首先，将arguments设置为None，并过滤掉函数列表中的特定函数。然后，根据配置文件中的设置，向消息列表的第一个消息中添加一些特定的描述信息。最后，调用父类的`generate()`函数，生成解析后的消息和令牌。\n\n在`openai`类型的请求中，对于`tool_call`字段，需要验证其参数是否符合工具的要求。如果验证失败，将进行一些修复操作，并重新验证。最后，将解析后的消息和令牌返回。\n\n**注意**：在使用该代码时需要注意以下几点：\n- 需要提供正确的输入参数，以生成正确的消息列表和令牌列表。\n- 如果使用`openai`类型的请求，需要确保工具调用的参数符合工具的要求。\n\n**输出示例**：\n```\n{\n  \"message\": {\n    \"content\": \"这是一个示例消息\",\n    \"role\": \"system\",\n    \"type\": \"text\"\n  },\n  \"tokens\": [\n    \"这是\",\n    \"一个\",\n    \"示例\",\n    \"令牌\"\n  ]\n}\n```",
            "code_start_line": 28,
            "code_end_line": 134,
            "parent": "ToolAgent",
            "have_return": true,
            "code_content": "    def parse(\n        self,\n        placeholders: dict = {},\n        arguments:dict=None,\n        functions=None,\n        function_call=None,\n        stop=None,\n        additional_messages: List[Message] = [],\n        additional_insert_index: int = -1,\n        *args,\n        **kwargs\n    ):\n        \"\"\"\n        This function generates a message list and a token list based on the input parameters using the \n        `generate()` function, modifies it as per specific conditions, and returns it.\n        \n        Args:\n            placeholders (dict, optional): Dictionary object to store the placeholders and their mappings.\n            arguments (dict, optional): Dictionary object to store argument's details.\n            functions: List of permissible functions that can be inserted in the function fields for the `openai` type.\n            function_call: A dictionary representing the current function call being processed.\n            stop: The termination condition for the loop.\n            additional_messages (list, optional): List of additional messages to be appended to the existing message list.\n            additional_insert_index (int, optional): The index position to insert the additional messages.\n            *args: Variable length argument list for the parent class's `generate()` function.\n            **kwargs: Arbitrary keyword arguments for the parent class's `generate()` function.\n            \n        Returns:\n            tuple: A tuple containing a dictionary of the parsed message and a list of tokens.\n            \n        Raises:\n            AssertionError: If the specified function schema is not found in the list of possible functions.\n            Exception: If the validation of the tool's call arguments fails.\n        \"\"\"\n        \n        prompt_messages = self.fill_in_placeholders(placeholders)\n        messages = prompt_messages[:additional_insert_index] + additional_messages + prompt_messages[additional_insert_index:]\n        messages = [message.raw() for message in messages]\n        \n        # Temporarily disable the arguments for openai\n        if self.config.default_request_type == 'openai':\n            arguments = None\n            functions = list(filter(lambda x: x['name'] not in ['subtask_submit','subtask_handle'],functions))\n            if CONFIG.enable_ask_human_for_help:\n                functions += [function_manager.get_function_schema('ask_human_for_help')]\n            messages[0]['content'] += '\\n--- Avaliable Tools ---\\nYou are allowed to use tools in the \"subtask_handle.tool_call\" function field.\\nRemember the \"subtask_handle.tool_call.tool_input\" field should always in JSON, as following described:\\n{}'.format(json.dumps(functions,indent=2))\n            \n            def change_tool_call_description(message:dict,reverse:bool=False):\n                des_pairs = [('Use tools to handle the subtask',\n                              'Use \"subtask_handle\" to make a normal tool call to handle the subtask'),\n                             ('5.1  Please remember to generate the function call field after the \"criticism\" field.\\n  5.2  Please check all content is in json format carefully.',\n                              '5.1. Please remember to generate the \"tool_call\" field after the \"criticism\" field.\\n  5.2. Please remember to generate comma if the \"tool_call\" field is after the \"criticism\" field.\\n  5.3. Please check whether the **\"tool_call\"** field is in the function call json carefully.'),\n                             ('After decide the action, use \"subtask_handle\" functions to apply action.',\n                              'After decide the action, call functions to apply action.')]\n                \n                for pair in des_pairs:\n                    message['content'] = message['content'].replace(pair[0],pair[1]) if reverse else message['content'].replace(pair[1],pair[0])\n                    \n                return message\n            \n            messages[0] = change_tool_call_description(messages[0])\n            functions = [function_manager.get_function_schema('subtask_submit'),\n                         function_manager.get_function_schema('subtask_handle')]\n\n        message,tokens = self.generate(\n            messages=messages,\n            arguments=arguments,\n            functions=functions,\n            function_call=function_call,\n            stop=stop,\n            *args,**kwargs\n        )\n\n        function_call_args:dict = message['function_call']['arguments']\n\n        # for tool_call, we need to validate the tool_call arguments if exising\n        if self.config.default_request_type == 'openai' and 'tool_call' in function_call_args:\n            tool_schema = function_manager.get_function_schema(function_call_args['tool_call'][\"tool_name\"])\n            assert tool_schema is not None, f\"Function {function_call_args['tool_call']['tool_name']} not found! Poential Schema Validation Error!\"\n            \n            tool_call_args = function_call_args['tool_call']['tool_input'] if 'tool_input' in function_call_args['tool_call'] else ''\n            \n            def validate():\n                nonlocal tool_schema,tool_call_args\n                if isinstance(tool_call_args,str):\n                    tool_call_args = {} if tool_call_args == '' else json5.loads(tool_call_args)\n                jsonschema.validate(instance=tool_call_args, schema=tool_schema['parameters'])\n            \n            try:\n                validate()\n            except Exception as e:  \n                messages[0] = change_tool_call_description(messages[0],reverse=True)\n                tool_call_args = objgenerator.dynamic_json_fixes(\n                    broken_json=tool_call_args,\n                    function_schema=tool_schema,\n                    messages=messages,\n                    error_message=str(e))[\"choices\"][0][\"message\"][\"function_call\"][\"arguments\"]\n                validate()\n            \n            function_call_args['tool_call']['tool_input'] = tool_call_args\n            \n            message['function_call'] = function_call_args.pop('tool_call')\n            message['function_call']['name'] = message['function_call'].pop('tool_name')\n            message['function_call']['arguments'] = message['function_call'].pop('tool_input')\n            message['arguments'] = function_call_args\n                \n        return message,tokens\n",
            "name_column": 8
        },
        "message_to_tool_node": {
            "type": "FunctionDef",
            "name": "message_to_tool_node",
            "md_content": "**message_to_tool_node函数**：该函数的功能是将给定的消息字典转换为ToolNode对象。\n\n该函数接受一个包含内容、函数调用和参数的消息字典作为输入，并将其转换为ToolNode对象。函数首先创建一个空的ToolNode对象new_node。然后，它检查消息字典中是否包含\"content\"、\"arguments\"和\"function_call\"字段。如果包含\"content\"字段，则将其值赋给new_node的data[\"content\"]属性。如果包含\"arguments\"字段，则将其值赋给new_node的data['thoughts']['properties']属性。如果包含\"function_call\"字段，则将其值中的\"name\"赋给new_node的data[\"command\"][\"properties\"][\"name\"]属性，将其值中的\"arguments\"赋给new_node的data[\"command\"][\"properties\"][\"args\"]属性。如果消息字典中不包含\"function_call\"字段，则会记录一个警告消息。\n\n**注意**：在使用该代码时需要注意以下几点：\n- 输入的消息字典必须包含\"content\"字段，否则将无法正确生成ToolNode对象。\n- 如果消息字典中不包含\"function_call\"字段，则会记录一个警告消息。\n\n**输出示例**：假设输入的消息字典为：\n```\n{\n  \"content\": \"The content is useless\",\n  \"function_call\": {\n    \"name\": \"xxx\",\n    \"arguments\": \"xxx\"\n  },\n  \"arguments\": {\n    \"xxx\": \"xxx\",\n    \"xxx\": \"xxx\"\n  }\n}\n```\n则函数的返回值为一个ToolNode对象，其中data属性的值为：\n```\n{\n  \"content\": \"The content is useless\",\n  \"thoughts\": {\n    \"properties\": {\n      \"xxx\": \"xxx\",\n      \"xxx\": \"xxx\"\n    }\n  },\n  \"command\": {\n    \"properties\": {\n      \"name\": \"xxx\",\n      \"args\": \"xxx\"\n    }\n  }\n}\n```",
            "code_start_line": 136,
            "code_end_line": 175,
            "parent": "ToolAgent",
            "have_return": true,
            "code_content": "    def message_to_tool_node(self,message) -> ToolNode:\n        \"\"\"\n        This method converts a given message dictionary to a ToolNode object.\n        \n        Args:\n            message (dict): Dictionary of message data containing content, function call and arguments.\n\n        Returns:\n            ToolNode: A ToolNode object generated from the provided message.\n            \n        Warning:\n            If the `function_call` field is missing in the input message, a warning message will be logged. \n        \"\"\"\n        \n        # assume message format\n        # {\n        #   \"content\": \"The content is useless\",\n        #   \"function_call\": {\n        #       \"name\": \"xxx\",\n        #       \"arguments\": \"xxx\"\n        #  },\n        #  \"arguments\": {\n        #      \"xxx\": \"xxx\",\n        #      \"xxx\": \"xxx\"   \n        #  },\n        # }\n        \n        new_node = ToolNode()\n        if \"content\" in message.keys():\n            print(message[\"content\"])\n            new_node.data[\"content\"] = message[\"content\"]\n        if 'arguments' in message.keys():\n            new_node.data['thoughts']['properties'] = message[\"arguments\"]\n        if \"function_call\" in message.keys():\n            new_node.data[\"command\"][\"properties\"][\"name\"] = message[\"function_call\"][\"name\"]\n            new_node.data[\"command\"][\"properties\"][\"args\"] = message[\"function_call\"][\"arguments\"]\n        else:\n            logger.typewriter_log(\"message_to_tool_node warning: no function_call in message\",Fore.RED)\n\n        return new_node",
            "name_column": 8
        },
        "change_tool_call_description": {
            "type": "FunctionDef",
            "name": "change_tool_call_description",
            "md_content": "**change_tool_call_description函数**：该函数的功能是修改工具调用描述。\n\n该函数接受一个字典类型的message参数和一个布尔类型的reverse参数。函数内部定义了一个包含描述对的列表des_pairs，每个对包含两个描述，分别是原始描述和修改后的描述。函数通过遍历des_pairs列表，将message中的描述进行替换，如果reverse为True，则将修改后的描述替换为原始描述，否则将原始描述替换为修改后的描述。最后，函数返回修改后的message。\n\n**注意**：该函数主要用于修改工具调用的描述内容。\n\n**输出示例**：假设输入的message为{'content': 'Use tools to handle the subtask'}，reverse为False，则函数将返回{'content': 'Use \"subtask_handle\" to make a normal tool call to handle the subtask'}。",
            "code_start_line": 75,
            "code_end_line": 86,
            "parent": null,
            "have_return": true,
            "code_content": "            def change_tool_call_description(message:dict,reverse:bool=False):\n                des_pairs = [('Use tools to handle the subtask',\n                              'Use \"subtask_handle\" to make a normal tool call to handle the subtask'),\n                             ('5.1  Please remember to generate the function call field after the \"criticism\" field.\\n  5.2  Please check all content is in json format carefully.',\n                              '5.1. Please remember to generate the \"tool_call\" field after the \"criticism\" field.\\n  5.2. Please remember to generate comma if the \"tool_call\" field is after the \"criticism\" field.\\n  5.3. Please check whether the **\"tool_call\"** field is in the function call json carefully.'),\n                             ('After decide the action, use \"subtask_handle\" functions to apply action.',\n                              'After decide the action, call functions to apply action.')]\n                \n                for pair in des_pairs:\n                    message['content'] = message['content'].replace(pair[0],pair[1]) if reverse else message['content'].replace(pair[1],pair[0])\n                    \n                return message\n",
            "name_column": 16
        },
        "validate": {
            "type": "FunctionDef",
            "name": "validate",
            "md_content": "**validate函数**：该函数的功能是验证工具调用参数的有效性。\n\n该函数接受两个非局部变量tool_schema和tool_call_args，用于验证工具调用参数的有效性。首先，函数判断tool_call_args是否为字符串类型，如果是，则将其转换为字典类型。然后，使用jsonschema库对tool_call_args进行验证，确保其符合tool_schema['parameters']所定义的参数模式。\n\n该函数主要用于在工具调用过程中对工具调用参数进行验证，以确保参数的有效性。在工具调用过程中，如果参数不符合预期的模式，将会引发异常。\n\n**注意**：在使用该函数时，需要确保传入的tool_schema和tool_call_args参数的正确性，并且在工具调用过程中，如果参数验证失败，将会引发异常。",
            "code_start_line": 110,
            "code_end_line": 114,
            "parent": null,
            "have_return": false,
            "code_content": "            def validate():\n                nonlocal tool_schema,tool_call_args\n                if isinstance(tool_call_args,str):\n                    tool_call_args = {} if tool_call_args == '' else json5.loads(tool_call_args)\n                jsonschema.validate(instance=tool_call_args, schema=tool_schema['parameters'])\n",
            "name_column": 16
        }
    },
    "XAgent/agent/tool_agent/prompt.py": {
        "get_examples_for_dispatcher": {
            "type": "FunctionDef",
            "name": "get_examples_for_dispatcher",
            "md_content": "**get_examples_for_dispatcher函数**：该函数用于为调度器生成提示的示例。\n\n该函数的作用是为调度器生成提示的示例，包括用户查询或任务的输入、系统提示和用户提示。\n\n代码分析和描述：\n该函数定义了三个变量，分别是example_input、example_system_prompt和example_user_prompt，它们分别表示用户查询或任务的输入、系统提示和用户提示。这些变量的值是预先定义好的字符串。\n\n注意事项：\n无\n\n输出示例：\nexample_input = \"\"\"{\\n  \"name\": \"Finding Feasible Examples\",\\n  \"goal\": \"Find 10 examples that can reach the target number 24 in the 24-points game.\",\\n  \"handler\": \"subtask 1\",\\n  \"tool_budget\": 50,\\n  \"prior_plan_criticsim\": \"It may be difficult to come up with examples that are all feasible.\",\\n  \"milestones\": [\\n    \"Identifying appropriate combination of numbers\",\\n    \"Applying mathematical operations\",\\n    \"Verifying the result equals to target number\",\\n    \"Recording feasible examples\"\\n  ],\\n  \"expected_tools\": [\\n    {\\n      \"tool_name\": \"analyze_code\",\\n      \"reason\": \"To ensure all feasible examples meet the rules of the 24-points game\"\\n    }\\n  ],\\n  \"exceute_status\": \"TODO\"\\n}\"\"\"\nexample_system_prompt = SYSTEM_PROMPT\nexample_user_prompt = USER_PROMPT\n\n该函数返回了三个变量的值，分别是example_input、example_system_prompt和example_user_prompt。这些值可以作为调度器生成提示的示例使用。",
            "code_start_line": 85,
            "code_end_line": 96,
            "parent": null,
            "have_return": true,
            "code_content": "def get_examples_for_dispatcher():\n    \"\"\"The example that will be given to the dispatcher to generate the prompt\n\n    Returns:\n        example_input: the user query or the task\n        example_system_prompt: the system prompt\n        example_user_prompt: the user prompt\n    \"\"\"\n    example_input = \"\"\"{\\n  \"name\": \"Finding Feasible Examples\",\\n  \"goal\": \"Find 10 examples that can reach the target number 24 in the 24-points game.\",\\n  \"handler\": \"subtask 1\",\\n  \"tool_budget\": 50,\\n  \"prior_plan_criticsim\": \"It may be difficult to come up with examples that are all feasible.\",\\n  \"milestones\": [\\n    \"Identifying appropriate combination of numbers\",\\n    \"Applying mathematical operations\",\\n    \"Verifying the result equals to target number\",\\n    \"Recording feasible examples\"\\n  ],\\n  \"expected_tools\": [\\n    {\\n      \"tool_name\": \"analyze_code\",\\n      \"reason\": \"To ensure all feasible examples meet the rules of the 24-points game\"\\n    }\\n  ],\\n  \"exceute_status\": \"TODO\"\\n}\"\"\"\n    example_system_prompt = SYSTEM_PROMPT\n    example_user_prompt = USER_PROMPT\n    return example_input, example_system_prompt, example_user_prompt\n",
            "name_column": 4
        }
    },
    "XAgent/agent/reflect_agent/__init__.py": {},
    "XAgent/agent/reflect_agent/agent.py": {
        "ReflectAgent": {
            "type": "ClassDef",
            "name": "ReflectAgent",
            "md_content": "**ReflectAgent函数**：这个类的函数是解析各种参数并调用generate函数来生成响应。\n\n**函数参数**：\n- placeholders（字典，可选）：用于代替agent的响应。\n- arguments（字典，可选）：影响agent响应的参数。\n- functions（函数，可选）：指导agent响应的函数。\n- function_call（FunctionType，可选）：调用生成agent响应的函数。\n- stop（布尔值，可选）：停止响应的标志。\n- additional_messages（列表，可选）：要包含在响应中的额外消息。\n\n**返回值**：由agent生成的响应对象。\n\n**ReflectAgent类**扩展了BaseAgent类。它主要具有反射的能力，即可以根据接收到的消息反思对话并生成响应。\n\n**属性**：\n- abilities（集合）：代理所需的能力，即反思能力。\n\n**注意事项**：在调用parse函数时，需要提供相应的参数和消息。可以使用placeholders参数来替代agent的响应，使用arguments参数来影响agent的响应，使用functions参数来指导agent的响应。函数调用function_call用于生成agent的响应。如果stop参数设置为True，则停止生成响应。可以通过additional_messages参数添加额外的消息。\n\n**输出示例**：假设调用parse函数后，返回一个生成的响应对象。",
            "code_start_line": 6,
            "code_end_line": 53,
            "parent": null,
            "have_return": true,
            "code_content": "class ReflectAgent(BaseAgent):\n    \"\"\"This ReflectAgent class extends the BaseAgent class. It primarily has the ability of reflection \n    which means it can reflect upon the chat or dialogue and generate responses based on the messages\n    received.\n\n    Attributes:\n        abilities (set): Required abilities for the agent, namely reflection in this case. \n    \"\"\"\n\n    abilities = set([RequiredAbilities.reflection])\n\n    def parse(\n        self,\n        placeholders: dict = {},\n        arguments:dict = None,\n        functions=None,\n        function_call=None,\n        stop=None,\n        additional_messages: List[Message] = [],\n        *args,\n        **kwargs\n    ):\n        \"\"\"\n        The function is used to parse various arguments and call the generate function with these parsed arguments.\n\n        Args:\n            placeholders (dict, optional): Placeholders for the agent's responses. \n            arguments(dict, optional): Argument to influence the response of the agent.\n            functions (functions, optional): Functions to guide the agent's response.\n            function_call (FunctionType, optional): Function called to generate agent's response. \n            stop (bool, optional): Flag to stop the induction of the response. \n            additional_messages (list, optional): Additional messages to be included in the response. \n\n        Returns:\n            object: Response generated by the agent. \n\n        \"\"\"\n        prompt_messages = self.fill_in_placeholders(placeholders)\n        messages = prompt_messages + additional_messages\n\n        return self.generate(\n            messages=messages,\n            arguments=arguments,\n            functions=functions,\n            function_call=function_call,\n            stop=stop,\n            *args,**kwargs\n        )",
            "name_column": 6
        },
        "parse": {
            "type": "FunctionDef",
            "name": "parse",
            "md_content": "**parse函数**：这个函数的作用是解析各种参数，并使用这些解析后的参数调用generate函数。\n\n该函数接受以下参数：\n- placeholders（字典，可选）：用于代替agent的响应的占位符。\n- arguments（字典，可选）：影响agent响应的参数。\n- functions（函数，可选）：指导agent响应的函数。\n- function_call（FunctionType，可选）：调用生成agent响应的函数。\n- stop（布尔值，可选）：停止响应的标志。\n- additional_messages（列表，可选）：要包含在响应中的附加消息。\n\n该函数首先使用placeholders填充占位符，然后将填充后的消息与additional_messages合并为messages。\n\n最后，函数调用generate函数，并传递messages、arguments、functions、function_call、stop以及其他参数。\n\n**注意**：使用该代码时需要注意以下几点：\n- placeholders参数用于替换agent的响应中的占位符。\n- arguments参数用于影响agent的响应。\n- functions参数用于指导agent的响应。\n- function_call参数用于调用生成agent响应的函数。\n- stop参数用于控制是否停止响应的生成。\n- additional_messages参数用于在响应中添加额外的消息。\n\n**输出示例**：模拟代码返回值的可能外观。\n\n请注意：\n- 生成的内容中不应包含Markdown的标题和分隔符语法。\n- 主要使用中文编写文档。如有必要，可以在分析和描述中使用一些英文单词，以增强文档的可读性，因为不需要将函数名或变量名翻译成目标语言。",
            "code_start_line": 17,
            "code_end_line": 53,
            "parent": "ReflectAgent",
            "have_return": true,
            "code_content": "    def parse(\n        self,\n        placeholders: dict = {},\n        arguments:dict = None,\n        functions=None,\n        function_call=None,\n        stop=None,\n        additional_messages: List[Message] = [],\n        *args,\n        **kwargs\n    ):\n        \"\"\"\n        The function is used to parse various arguments and call the generate function with these parsed arguments.\n\n        Args:\n            placeholders (dict, optional): Placeholders for the agent's responses. \n            arguments(dict, optional): Argument to influence the response of the agent.\n            functions (functions, optional): Functions to guide the agent's response.\n            function_call (FunctionType, optional): Function called to generate agent's response. \n            stop (bool, optional): Flag to stop the induction of the response. \n            additional_messages (list, optional): Additional messages to be included in the response. \n\n        Returns:\n            object: Response generated by the agent. \n\n        \"\"\"\n        prompt_messages = self.fill_in_placeholders(placeholders)\n        messages = prompt_messages + additional_messages\n\n        return self.generate(\n            messages=messages,\n            arguments=arguments,\n            functions=functions,\n            function_call=function_call,\n            stop=stop,\n            *args,**kwargs\n        )",
            "name_column": 8
        }
    },
    "XAgent/agent/reflect_agent/prompt.py": {
        "get_examples_for_dispatcher": {
            "type": "FunctionDef",
            "name": "get_examples_for_dispatcher",
            "md_content": "**get_examples_for_dispatcher函数**：此函数的功能是为调度器生成提示提供示例。\n\n此函数返回三个变量，分别是example_input、example_system_prompt和example_user_prompt。其中，example_input表示用户查询或任务的示例输入，example_system_prompt表示系统提示的示例，example_user_prompt表示用户提示的示例。\n\n在调用该函数的代码中，根据不同的ability_type参数值，从不同的模块中导入get_examples_for_dispatcher函数，并返回其结果。\n\n在XAgent/agent/dispatcher.py文件中，根据ability_type的不同值，分别从plan_generate_agent、plan_refine_agent、tool_agent和reflect_agent模块中导入get_examples_for_dispatcher函数，并返回其结果。\n\n在XAgent/agent/plan_generate_agent/prompt.py文件中，get_examples_for_dispatcher函数的示例输入是\"Generate a plan for writing a Python-based calculator.\"，示例系统提示和示例用户提示都是SYSTEM_PROMPT和USER_PROMPT。\n\n在XAgent/agent/plan_refine_agent/prompt.py文件中，get_examples_for_dispatcher函数的示例输入是\"Refine a plan for writing a Python-based calculator.\"，示例系统提示和示例用户提示都是SYSTEM_PROMPT和USER_PROMPT。\n\n在XAgent/agent/tool_agent/prompt.py文件中，get_examples_for_dispatcher函数的示例输入是一个JSON格式的字符串，表示一个任务的详细信息，示例系统提示和示例用户提示都是SYSTEM_PROMPT和USER_PROMPT。\n\n**注意**：使用此代码时需要注意的事项。\n\n**输出示例**：\n示例输入：Reflect on the previous actions and give the posterior knowledge\n示例系统提示：SYSTEM_PROMPT\n示例用户提示：USER_PROMPT",
            "code_start_line": 32,
            "code_end_line": 43,
            "parent": null,
            "have_return": true,
            "code_content": "def get_examples_for_dispatcher():\n    \"\"\"The example that will be given to the dispatcher to generate the prompt\n\n    Returns:\n        example_input: the user query or the task\n        example_system_prompt: the system prompt\n        example_user_prompt: the user prompt\n    \"\"\"\n    example_input = \"Reflect on the previous actions and give the posterior knowledge\"\n    example_system_prompt = SYSTEM_PROMPT\n    example_user_prompt = USER_PROMPT\n    return example_input, example_system_prompt, example_user_prompt",
            "name_column": 4
        }
    },
    "XAgent/agent/dispatcher_agent/__init__.py": {},
    "XAgent/agent/dispatcher_agent/agent.py": {
        "DispatcherAgent": {
            "type": "ClassDef",
            "name": "DispatcherAgent",
            "md_content": "",
            "code_start_line": 12,
            "code_end_line": 222,
            "parent": null,
            "have_return": true,
            "code_content": "class DispatcherAgent(BaseAgent):\n    \"\"\"\n    A subclass of BaseAgent whose primary function is to help dispatch tasks to \n    different agent handlers based on the task requirements.\n\n    Attributes:\n    ------------\n    config : object\n        The configuration settings for the agent.\n    prompt_messages : List[Message]\n        The list of prompt messages for the agent to dispatch.\n    \"\"\"\n    def __init__(self, config, prompt_messages: List[Message] = None):\n        \"\"\"\n        Initialize a DispatcherAgent instance.\n\n        Args:\n        -------\n        config : object\n            The configuration settings for the agent.\n        prompt_messages : list, optional\n            The list of prompt messages for the agent to dispatch, defaults to None.\n            If not provided, default_prompt_messages is used instead.\n        \"\"\"\n        self.config = config\n        self.prompt_messages = (\n            self.default_prompt_messages if prompt_messages is None else prompt_messages\n        )\n\n    @property\n    def default_prompt_messages(self):\n        \"\"\"\n        Returns the default system prompt messages in the form of a list of Message objects.\n\n        Returns:\n        -----------\n        list[Message] : \n            A list containing the default prompt message.\n        \"\"\"\n        return [Message(role=\"system\", content=SYSTEM_PROMPT)]\n\n    def find_all_placeholders(self, prompt):\n        \"\"\"\n        Finds all placeholders within a prompt.\n\n        Args:\n        --------\n        prompt : str\n            The string within which placeholders are to be found.\n\n        Returns:\n        --------\n        list[str] : \n            A list of all placeholders found within the prompt.\n        \"\"\"\n        return re.findall(r\"{{(.*?)}}\", prompt)\n\n    def construct_input_messages(\n        self,\n        task: str,\n        example_input: str,\n        example_system_prompt: str,\n        example_user_prompt: str,\n        retrieved_procedure: str,\n    ):\n        \"\"\"\n        Constructs input messages by replacing placeholders in the prompt_messages \n        with provided data.\n\n        Args:\n        ---------\n        task : str\n            The task to be completed.\n        example_input : str\n            An example input for the task.\n        example_system_prompt : str\n            The example system prompt for the task.\n        example_user_prompt : str\n            The example user prompt for the task.\n        retrieved_procedure : str\n            The retrieved process for the task.\n\n        Returns:\n        ---------\n        list[Message] :\n            A list containing the constructed input messages with placeholders replaced with provided data.\n        \"\"\"\n        prompt_messages = copy.deepcopy(self.prompt_messages)\n        # TODO: Make it more robust. Here we assume only the first message is system prompt\n        #       and we only update the placeholders in the first message.\n        prompt_messages[0].content = (\n            prompt_messages[0]\n            .content.replace(\"{{example_system_prompt}}\", example_system_prompt)\n            .replace(\"{{example_user_prompt}}\", example_user_prompt)\n            .replace(\"{{retrieved_procedure}}\", retrieved_procedure)\n            .replace(\"{{task}}\", task)\n        )\n        return prompt_messages  # + [Message(role=\"user\", content=task)] \n\n    def extract_prompts_from_response(self, message):\n        \"\"\"\n        Extracts additional prompts from the dispatcher's response message.\n\n        Args:\n        --------\n        message : str \n           The response message from the dispatcher.\n\n        Returns:\n        ---------\n        str : \n            The additional prompt extracted from the message; if not found, \"\" is returned.\n\n        \"\"\"\n        try:\n            additional_prompt = re.findall(r\"ADDITIONAL USER PROMPT:?\\n```(.*)```\", message['content'], re.DOTALL)[0].strip()\n        except IndexError as e:\n            logger.error(\n                f\"Failed to extract prompts from the dispatcher's response:\\n{message['content']}\"\n            )\n            logger.error(\"Fallback to use the default prompts.\")\n            additional_prompt = \"\"\n        return additional_prompt\n\n    def retrieved_procedure(self, query: str) -> str:\n        # TODO: this function should be implemented thru tool server\n\n        \"\"\"\n        Retrieves a procedure relevant to the given query from an external site.\n\n        Args:\n        --------\n        query : str\n            The query to retrieve the relevant procedure.\n\n        Returns:\n        ---------\n        str : \n            The relevant procedure retrieved; if retrieval fails, the string 'None' is returned.\n        \"\"\"\n        \n        url = \"https://open-procedures.replit.app/search/\"\n        try:\n            import requests\n            import json\n\n            relevant_procedures = requests.get(url, params={'query': query}).json()[\n                \"procedures\"\n            ][0]\n        except:\n            # For someone, this failed for a super secure SSL reason.\n            # Since it's not strictly necessary, let's worry about that another day. Should probably log this somehow though.\n            relevant_procedures = \"None\"\n\n        return relevant_procedures\n\n    def parse(\n        self,\n        task: str,\n        example_input: str,\n        example_system_prompt: str,\n        example_user_prompt: str,\n        stop=None,\n        **args,\n    ) -> List[Message]:\n        # TODO: should we consider additional messages when generating prompt?\n        # currently the plan generation and refine agent are the same since we\n        # don't consider the additional messages when generating prompt.\n\n        \"\"\"\n        Parse the task and related data to generate prompt messages.\n\n        Args:\n        ---------\n        task : str\n            The task to be processed.\n        example_input : str\n            An example input related to the task.\n        example_system_prompt : str\n            An example system prompt related to the task.\n        example_user_prompt : str\n            An example user prompt related to the task.\n        stop : str, optional\n            The stopping criterion for message generation, defaults to None.\n\n        Returns:\n        ---------\n        Tuple[List[Message], List[str]] : \n            A tuple containing a list of prompt messages and tokens.\n        \"\"\"\n        message,tokens = self.generate(\n            messages=self.construct_input_messages(\n                task,\n                example_input,\n                example_system_prompt,\n                example_user_prompt,\n                \"\"  \n            ),\n            stop=stop,\n            **args,\n        )\n\n        additional_prompt = message['arguments']['additional_prompt']\n\n        prompt_messages = []\n        if additional_prompt != \"\":\n            example_user_prompt += \"\\n\\nADDITIONAL NOTES\\n\" + additional_prompt\n        prompt_messages.append(Message(role=\"system\", content=example_system_prompt))\n        prompt_messages.append(Message(role=\"user\", content=example_user_prompt))\n\n        return prompt_messages, tokens",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "",
            "code_start_line": 24,
            "code_end_line": 39,
            "parent": "DispatcherAgent",
            "have_return": false,
            "code_content": "    def __init__(self, config, prompt_messages: List[Message] = None):\n        \"\"\"\n        Initialize a DispatcherAgent instance.\n\n        Args:\n        -------\n        config : object\n            The configuration settings for the agent.\n        prompt_messages : list, optional\n            The list of prompt messages for the agent to dispatch, defaults to None.\n            If not provided, default_prompt_messages is used instead.\n        \"\"\"\n        self.config = config\n        self.prompt_messages = (\n            self.default_prompt_messages if prompt_messages is None else prompt_messages\n        )\n",
            "name_column": 8
        },
        "default_prompt_messages": {
            "type": "FunctionDef",
            "name": "default_prompt_messages",
            "md_content": "",
            "code_start_line": 42,
            "code_end_line": 51,
            "parent": "DispatcherAgent",
            "have_return": true,
            "code_content": "    def default_prompt_messages(self):\n        \"\"\"\n        Returns the default system prompt messages in the form of a list of Message objects.\n\n        Returns:\n        -----------\n        list[Message] : \n            A list containing the default prompt message.\n        \"\"\"\n        return [Message(role=\"system\", content=SYSTEM_PROMPT)]\n",
            "name_column": 8
        },
        "find_all_placeholders": {
            "type": "FunctionDef",
            "name": "find_all_placeholders",
            "md_content": "",
            "code_start_line": 53,
            "code_end_line": 67,
            "parent": "DispatcherAgent",
            "have_return": true,
            "code_content": "    def find_all_placeholders(self, prompt):\n        \"\"\"\n        Finds all placeholders within a prompt.\n\n        Args:\n        --------\n        prompt : str\n            The string within which placeholders are to be found.\n\n        Returns:\n        --------\n        list[str] : \n            A list of all placeholders found within the prompt.\n        \"\"\"\n        return re.findall(r\"{{(.*?)}}\", prompt)\n",
            "name_column": 8
        },
        "construct_input_messages": {
            "type": "FunctionDef",
            "name": "construct_input_messages",
            "md_content": "",
            "code_start_line": 69,
            "code_end_line": 109,
            "parent": "DispatcherAgent",
            "have_return": true,
            "code_content": "    def construct_input_messages(\n        self,\n        task: str,\n        example_input: str,\n        example_system_prompt: str,\n        example_user_prompt: str,\n        retrieved_procedure: str,\n    ):\n        \"\"\"\n        Constructs input messages by replacing placeholders in the prompt_messages \n        with provided data.\n\n        Args:\n        ---------\n        task : str\n            The task to be completed.\n        example_input : str\n            An example input for the task.\n        example_system_prompt : str\n            The example system prompt for the task.\n        example_user_prompt : str\n            The example user prompt for the task.\n        retrieved_procedure : str\n            The retrieved process for the task.\n\n        Returns:\n        ---------\n        list[Message] :\n            A list containing the constructed input messages with placeholders replaced with provided data.\n        \"\"\"\n        prompt_messages = copy.deepcopy(self.prompt_messages)\n        # TODO: Make it more robust. Here we assume only the first message is system prompt\n        #       and we only update the placeholders in the first message.\n        prompt_messages[0].content = (\n            prompt_messages[0]\n            .content.replace(\"{{example_system_prompt}}\", example_system_prompt)\n            .replace(\"{{example_user_prompt}}\", example_user_prompt)\n            .replace(\"{{retrieved_procedure}}\", retrieved_procedure)\n            .replace(\"{{task}}\", task)\n        )\n        return prompt_messages  # + [Message(role=\"user\", content=task)] \n",
            "name_column": 8
        },
        "extract_prompts_from_response": {
            "type": "FunctionDef",
            "name": "extract_prompts_from_response",
            "md_content": "",
            "code_start_line": 111,
            "code_end_line": 134,
            "parent": "DispatcherAgent",
            "have_return": true,
            "code_content": "    def extract_prompts_from_response(self, message):\n        \"\"\"\n        Extracts additional prompts from the dispatcher's response message.\n\n        Args:\n        --------\n        message : str \n           The response message from the dispatcher.\n\n        Returns:\n        ---------\n        str : \n            The additional prompt extracted from the message; if not found, \"\" is returned.\n\n        \"\"\"\n        try:\n            additional_prompt = re.findall(r\"ADDITIONAL USER PROMPT:?\\n```(.*)```\", message['content'], re.DOTALL)[0].strip()\n        except IndexError as e:\n            logger.error(\n                f\"Failed to extract prompts from the dispatcher's response:\\n{message['content']}\"\n            )\n            logger.error(\"Fallback to use the default prompts.\")\n            additional_prompt = \"\"\n        return additional_prompt\n",
            "name_column": 8
        },
        "retrieved_procedure": {
            "type": "FunctionDef",
            "name": "retrieved_procedure",
            "md_content": "",
            "code_start_line": 136,
            "code_end_line": 166,
            "parent": "DispatcherAgent",
            "have_return": true,
            "code_content": "    def retrieved_procedure(self, query: str) -> str:\n        # TODO: this function should be implemented thru tool server\n\n        \"\"\"\n        Retrieves a procedure relevant to the given query from an external site.\n\n        Args:\n        --------\n        query : str\n            The query to retrieve the relevant procedure.\n\n        Returns:\n        ---------\n        str : \n            The relevant procedure retrieved; if retrieval fails, the string 'None' is returned.\n        \"\"\"\n        \n        url = \"https://open-procedures.replit.app/search/\"\n        try:\n            import requests\n            import json\n\n            relevant_procedures = requests.get(url, params={'query': query}).json()[\n                \"procedures\"\n            ][0]\n        except:\n            # For someone, this failed for a super secure SSL reason.\n            # Since it's not strictly necessary, let's worry about that another day. Should probably log this somehow though.\n            relevant_procedures = \"None\"\n\n        return relevant_procedures\n",
            "name_column": 8
        },
        "parse": {
            "type": "FunctionDef",
            "name": "parse",
            "md_content": "",
            "code_start_line": 168,
            "code_end_line": 222,
            "parent": "DispatcherAgent",
            "have_return": true,
            "code_content": "    def parse(\n        self,\n        task: str,\n        example_input: str,\n        example_system_prompt: str,\n        example_user_prompt: str,\n        stop=None,\n        **args,\n    ) -> List[Message]:\n        # TODO: should we consider additional messages when generating prompt?\n        # currently the plan generation and refine agent are the same since we\n        # don't consider the additional messages when generating prompt.\n\n        \"\"\"\n        Parse the task and related data to generate prompt messages.\n\n        Args:\n        ---------\n        task : str\n            The task to be processed.\n        example_input : str\n            An example input related to the task.\n        example_system_prompt : str\n            An example system prompt related to the task.\n        example_user_prompt : str\n            An example user prompt related to the task.\n        stop : str, optional\n            The stopping criterion for message generation, defaults to None.\n\n        Returns:\n        ---------\n        Tuple[List[Message], List[str]] : \n            A tuple containing a list of prompt messages and tokens.\n        \"\"\"\n        message,tokens = self.generate(\n            messages=self.construct_input_messages(\n                task,\n                example_input,\n                example_system_prompt,\n                example_user_prompt,\n                \"\"  \n            ),\n            stop=stop,\n            **args,\n        )\n\n        additional_prompt = message['arguments']['additional_prompt']\n\n        prompt_messages = []\n        if additional_prompt != \"\":\n            example_user_prompt += \"\\n\\nADDITIONAL NOTES\\n\" + additional_prompt\n        prompt_messages.append(Message(role=\"system\", content=example_system_prompt))\n        prompt_messages.append(Message(role=\"user\", content=example_user_prompt))\n\n        return prompt_messages, tokens",
            "name_column": 8
        }
    },
    "XAgent/agent/dispatcher_agent/prompt.py": {},
    "XAgent/agent/plan_generate_agent/__init__.py": {},
    "XAgent/agent/plan_generate_agent/agent.py": {
        "PlanGenerateAgent": {
            "type": "ClassDef",
            "name": "PlanGenerateAgent",
            "md_content": "**PlanGenerateAgent函数**: 这个类的功能是生成计划。它是BaseAgent的子类。\n\n该类具有以下属性：\n- abilities: 一个集合，表示该Agent所需的能力。\n\n该类具有以下方法：\n- parse: 解析占位符、参数、函数调用和附加消息，生成计划。\n\n**parse方法**:\n该方法用于解析占位符、参数、函数调用和附加消息，以生成计划。\n\n参数:\n- placeholders (dict, optional): 包含要填充到消息中的占位符的字典。\n- arguments (dict, optional): 包含要在函数中使用的参数的字典。\n- functions: 用于计划生成的函数。\n- function_call: 表示函数调用的对象。\n- stop: 如果指定了条件，则停止计划生成过程。\n- additional_messages (List[Message], optional): 要添加到初始提示消息中的附加消息。\n- *args: 可变长度参数列表。\n- **kwargs: 任意关键字参数。\n\n返回值:\n该方法返回由\"generate\"方法生成的计划的结果。\n\n**注意**: \n- 该类继承自BaseAgent类，因此可以使用BaseAgent类中的方法和属性。\n- 该类的abilities属性指示了该Agent所需的能力。\n- parse方法用于解析占位符、参数、函数调用和附加消息，生成计划。\n- parse方法返回计划生成方法\"generate\"的结果。\n\n**输出示例**:\n```\n# 创建PlanGenerateAgent对象\nagent = PlanGenerateAgent()\n\n# 解析占位符、参数、函数调用和附加消息，生成计划\nplan = agent.parse(\n    placeholders={\"placeholder1\": \"value1\", \"placeholder2\": \"value2\"},\n    arguments={\"arg1\": \"value1\", \"arg2\": \"value2\"},\n    functions=[function1, function2],\n    function_call=function_call,\n    stop=stop_condition,\n    additional_messages=[message1, message2]\n)\n\n# 打印计划结果\nprint(plan)\n```\n\n**注意**:\n- 在使用PlanGenerateAgent类时，可以通过设置placeholders、arguments、functions、function_call、stop和additional_messages等参数来定制计划生成的过程。\n- 可以根据具体需求对parse方法进行定制，以生成符合预期的计划。",
            "code_start_line": 8,
            "code_end_line": 56,
            "parent": null,
            "have_return": true,
            "code_content": "class PlanGenerateAgent(BaseAgent):\n    \"\"\"\n    This class is responsible for plan generation. It is a subclass of BaseAgent.\n\n    Attributes:\n        abilities: A set indicating the abilities required by this agent.\n    \"\"\"\n    abilities = set([RequiredAbilities.plan_generation])\n\n    def parse(\n        self,\n        placeholders: dict = {},\n        arguments: dict = None,\n        functions=None,\n        function_call=None,\n        stop=None,\n        additional_messages: List[Message] = [],\n        *args,\n        **kwargs\n    ):\n        \"\"\"\n        This method is used to parse placeholders, arguments, function calls, and additional messages \n        to generate a plan.\n\n        Args:\n            placeholders (dict, optional): A dictionary containing placeholders to fill in the messages.\n            arguments (dict, optional): A dictionary containing arguments to be used in the functions.\n            functions: The functions to be used during plan generation.\n            function_call: The object representing a function call.\n            stop: The condition to stop the plan generation process if specified.\n            additional_messages (List[Message], optional): A list of additional messages to be added to \n            the initial prompt messages.\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n\n        Returns:\n            This method returns the result of the plan generated by the \"generate\" method.\n        \"\"\"\n        prompt_messages = self.fill_in_placeholders(placeholders)\n        messages = prompt_messages + additional_messages\n\n        return self.generate(\n            messages=messages,\n            arguments=arguments,\n            functions=functions,\n            function_call=function_call,\n            stop=stop,\n            *args, **kwargs\n        )",
            "name_column": 6
        },
        "parse": {
            "type": "FunctionDef",
            "name": "parse",
            "md_content": "**parse函数**：该函数的作用是解析占位符、参数、函数调用和附加消息，生成一个计划。\n\n该函数接受以下参数：\n- placeholders（可选）：一个包含要填充到消息中的占位符的字典。\n- arguments（可选）：一个包含要在函数中使用的参数的字典。\n- functions：用于计划生成过程中使用的函数。\n- function_call：表示函数调用的对象。\n- stop：如果指定了条件，则停止计划生成过程。\n- additional_messages（可选）：要添加到初始提示消息中的附加消息的列表。\n- *args：可变长度参数列表。\n- **kwargs：任意关键字参数。\n\n该函数首先使用fill_in_placeholders方法填充占位符，然后将填充后的消息与附加消息合并。最后，调用generate方法生成计划，并返回计划的结果。\n\n**注意**：使用该代码的注意事项。\n\n**输出示例**：模拟代码返回值的可能外观。",
            "code_start_line": 17,
            "code_end_line": 56,
            "parent": "PlanGenerateAgent",
            "have_return": true,
            "code_content": "    def parse(\n        self,\n        placeholders: dict = {},\n        arguments: dict = None,\n        functions=None,\n        function_call=None,\n        stop=None,\n        additional_messages: List[Message] = [],\n        *args,\n        **kwargs\n    ):\n        \"\"\"\n        This method is used to parse placeholders, arguments, function calls, and additional messages \n        to generate a plan.\n\n        Args:\n            placeholders (dict, optional): A dictionary containing placeholders to fill in the messages.\n            arguments (dict, optional): A dictionary containing arguments to be used in the functions.\n            functions: The functions to be used during plan generation.\n            function_call: The object representing a function call.\n            stop: The condition to stop the plan generation process if specified.\n            additional_messages (List[Message], optional): A list of additional messages to be added to \n            the initial prompt messages.\n            *args: Variable length argument list.\n            **kwargs: Arbitrary keyword arguments.\n\n        Returns:\n            This method returns the result of the plan generated by the \"generate\" method.\n        \"\"\"\n        prompt_messages = self.fill_in_placeholders(placeholders)\n        messages = prompt_messages + additional_messages\n\n        return self.generate(\n            messages=messages,\n            arguments=arguments,\n            functions=functions,\n            function_call=function_call,\n            stop=stop,\n            *args, **kwargs\n        )",
            "name_column": 8
        }
    },
    "XAgent/agent/plan_generate_agent/prompt.py": {
        "get_examples_for_dispatcher": {
            "type": "FunctionDef",
            "name": "get_examples_for_dispatcher",
            "md_content": "**get_examples_for_dispatcher函数**：该函数的功能是为调度器生成提示提供示例。\n\n该函数返回三个值，分别是example_input、example_system_prompt和example_user_prompt。其中，example_input是用户查询或任务的示例输入，example_system_prompt是系统提示的示例，example_user_prompt是用户提示的示例。\n\n该函数在以下文件中被调用：\n- XAgent/agent/dispatcher.py\n- XAgent/agent/plan_refine_agent/prompt.py\n- XAgent/agent/reflect_agent/prompt.py\n- XAgent/agent/tool_agent/prompt.py\n\n在XAgent/agent/dispatcher.py文件中，get_examples_for_dispatcher函数根据传入的ability_type参数选择不同的模块，并调用相应模块中的get_examples_for_dispatcher函数。\n\n在XAgent/agent/plan_refine_agent/prompt.py文件中，get_examples_for_dispatcher函数返回了一个用于计划细化的示例。\n\n在XAgent/agent/reflect_agent/prompt.py文件中，get_examples_for_dispatcher函数返回了一个用于反思的示例。\n\n在XAgent/agent/tool_agent/prompt.py文件中，get_examples_for_dispatcher函数返回了一个用于工具树搜索的示例。\n\n**注意**：使用该代码时需要注意以下几点：\n- 该函数需要在调用之前导入相应的模块。\n- 该函数返回的示例可以作为调度器生成提示的输入。\n\n**输出示例**：\n```\nexample_input = \"Generate a plan for writing a Python-based calculator.\"\nexample_system_prompt = SYSTEM_PROMPT\nexample_user_prompt = USER_PROMPT\n```",
            "code_start_line": 44,
            "code_end_line": 55,
            "parent": null,
            "have_return": true,
            "code_content": "def get_examples_for_dispatcher():\n    \"\"\"The example that will be given to the dispatcher to generate the prompt\n\n    Returns:\n        example_input: the user query or the task\n        example_system_prompt: the system prompt\n        example_user_prompt: the user prompt\n    \"\"\"\n    example_input = \"Generate a plan for writing a Python-based calculator.\"\n    example_system_prompt = SYSTEM_PROMPT\n    example_user_prompt = USER_PROMPT\n    return example_input, example_system_prompt, example_user_prompt",
            "name_column": 4
        }
    },
    "XAgent/workflow/working_memory.py": {
        "WorkingMemoryAgent": {
            "type": "ClassDef",
            "name": "WorkingMemoryAgent",
            "md_content": "**WorkingMemoryAgent函数**：这个类的函数是用来表示一个agent的工作内存。\n\n工作内存是一个agent在执行任务过程中用来存储信息的地方。它包含了两个属性：subtask_handle_mapping和execute_process。\n\n- subtask_handle_mapping是一个字典，用来存储子任务的映射关系。它将子任务的id与终止计划进行映射。\n- execute_process是一个列表，用来存储待执行的进程。\n\n**构造函数**：WorkingMemoryAgent类的构造函数。\n\n参数：\n- logger（对象）：日志记录器对象。\n\n**get_working_memory_function方法**：从函数管理器中获取'chat_with_other_subtask'函数的模式。\n\n返回值：\n- 列表：包含'chat_with_other_subtask'函数模式的列表。\n\n**register_task方法**：注册一个任务，将任务的终止计划添加到执行进程中，并在subtask_handle_mapping中将子任务id与终止计划进行映射。\n\n参数：\n- terminal_plan（对象）：任务的终止计划。\n\n**handle方法**：处理名为'chat_with_other_subtask'的工具。\n\n参数：\n- tool_name（字符串）：工具的名称。\n- tool_input（字符串）：工具的输入。\n\n抛出：\n- AssertionError：如果工具名称不是'chat_with_other_subtask'。\n\n**注意**：在使用该类时需要注意以下几点：\n- WorkingMemoryAgent类用于表示一个agent的工作内存，可以用来存储任务的信息。\n- 通过调用register_task方法可以注册一个任务，并将任务的终止计划添加到执行进程中。\n- 通过调用handle方法可以处理名为'chat_with_other_subtask'的工具。\n\n**输出示例**：\n```\nWorking Memory: Register a new subtask=subtask_id Process length=finish_node.get_depth().\n```",
            "code_start_line": 6,
            "code_end_line": 78,
            "parent": null,
            "have_return": true,
            "code_content": "class WorkingMemoryAgent():\n    \"\"\"\n    A class used to represent an agent's working memory.\n\n    Attributes:\n        subtask_handle_mapping (dict): A dictionary to store the mapping of subtasks.\n        execute_process (list): A list to store the processes to be executed.\n\n    \"\"\"\n    def __init__(self, logger=None):\n        \"\"\"\n        The constructor for the WorkingMemoryAgent class.\n\n        Args:\n            logger (object): The logger object.\n        \"\"\"\n        self.logger = logger\n        self.subtask_handle_mapping = {}\n        self.execute_process: List[Dict] = []\n\n    @classmethod\n    def get_working_memory_function(cls):\n        \"\"\"\n        The method to get the 'chat_with_other_subtask' function schema from the function manager.\n\n        Returns:\n            list: A list that contains the function schema of 'chat_with_other_subtask'.\n\n        \"\"\"\n        chat_with_subtask_function = function_manager.get_function_schema('chat_with_other_subtask')\n        return [chat_with_subtask_function]\n\n    def register_task(self, terminal_plan):\n        \"\"\"\n        The method to register a task i.e., to add the terminal plan of the task to the execution process,\n        and to map the subtask id with the terminal plan in subtask_handle_mapping\n\n        Args:\n            terminal_plan (object): The terminal plan of the task.\n\n        \"\"\"\n        subtask_id = terminal_plan.get_subtask_id(to_str=True)\n        finish_node = terminal_plan.process_node\n\n        datapoint = {\n            \"plan\": terminal_plan,\n            \"task_id\": subtask_id,\n            \"qa_sequence\": [],\n        }\n\n        self.execute_process.append(datapoint)\n        self.subtask_handle_mapping[subtask_id] = datapoint\n\n        self.logger.typewriter_log(\n            \"Working Memory: \",\n            Fore.YELLOW,\n            f\"{Fore.YELLOW}Register a new subtask={Style.RESET_ALL}{subtask_id} {Fore.YELLOW}Process length={Style.RESET_ALL}{finish_node.get_depth()}.\"\n        )\n\n    def handle(self, tool_name, tool_input):\n        \"\"\"\n        The method to handle the tool named 'chat_with_other_subtask'\n\n        Args:\n            tool_name (str): The name of the tool.\n            tool_input (str): The input for the tool.\n\n        Raises:\n            AssertionError: If tool name is not 'chat_with_other_subtask'.\n\n        \"\"\"\n        assert tool_name == \"chat_with_other_subtask\"\n        self.logger.log(\"handle chat with other subtask\")",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__函数**：该函数是WorkingMemoryAgent类的构造函数。\n\n该函数接受一个logger对象作为参数，并将其赋值给self.logger属性。self.subtask_handle_mapping属性被初始化为空字典。self.execute_process属性被初始化为空列表。\n\n**注意**：在使用该代码时需要注意以下几点：\n- 该函数用于初始化WorkingMemoryAgent类的实例。\n- 可以通过传入logger对象来设置self.logger属性。\n- self.subtask_handle_mapping属性用于存储子任务的处理映射关系。\n- self.execute_process属性用于存储执行过程的列表。",
            "code_start_line": 15,
            "code_end_line": 24,
            "parent": "WorkingMemoryAgent",
            "have_return": false,
            "code_content": "    def __init__(self, logger=None):\n        \"\"\"\n        The constructor for the WorkingMemoryAgent class.\n\n        Args:\n            logger (object): The logger object.\n        \"\"\"\n        self.logger = logger\n        self.subtask_handle_mapping = {}\n        self.execute_process: List[Dict] = []\n",
            "name_column": 8
        },
        "get_working_memory_function": {
            "type": "FunctionDef",
            "name": "get_working_memory_function",
            "md_content": "**get_working_memory_function函数**：该函数用于从函数管理器中获取'chat_with_other_subtask'函数的模式。\n\n该函数的返回值是一个包含'chat_with_other_subtask'函数模式的列表。\n\n**代码分析和描述**：\n该函数通过调用函数管理器的get_function_schema方法，传入'chat_with_other_subtask'作为参数，来获取'chat_with_other_subtask'函数的模式。\n\n**注意**：使用该代码时需要注意以下几点：\n- 需要确保函数管理器中存在'chat_with_other_subtask'函数的模式。\n- 返回值是一个包含'chat_with_other_subtask'函数模式的列表。\n\n**输出示例**：假设'chat_with_other_subtask'函数的模式如下：\n```\n{\n    'name': 'chat_with_other_subtask',\n    'description': 'This function is used to chat with other subtasks.',\n    'parameters': [\n        {\n            'name': 'message',\n            'type': 'str',\n            'description': 'The message to be sent.'\n        }\n    ],\n    'return': {\n        'type': 'str',\n        'description': 'The response message.'\n    }\n}\n```\n则该函数的返回值为：\n```\n[{\n    'name': 'chat_with_other_subtask',\n    'description': 'This function is used to chat with other subtasks.',\n    'parameters': [\n        {\n            'name': 'message',\n            'type': 'str',\n            'description': 'The message to be sent.'\n        }\n    ],\n    'return': {\n        'type': 'str',\n        'description': 'The response message.'\n        }\n}]\n```",
            "code_start_line": 27,
            "code_end_line": 36,
            "parent": "WorkingMemoryAgent",
            "have_return": true,
            "code_content": "    def get_working_memory_function(cls):\n        \"\"\"\n        The method to get the 'chat_with_other_subtask' function schema from the function manager.\n\n        Returns:\n            list: A list that contains the function schema of 'chat_with_other_subtask'.\n\n        \"\"\"\n        chat_with_subtask_function = function_manager.get_function_schema('chat_with_other_subtask')\n        return [chat_with_subtask_function]\n",
            "name_column": 8
        },
        "register_task": {
            "type": "FunctionDef",
            "name": "register_task",
            "md_content": "**register_task函数**：该函数的功能是注册一个任务，即将任务的终端计划添加到执行过程中，并在subtask_handle_mapping中将子任务ID与终端计划进行映射。\n\n该函数接受一个参数terminal_plan，表示任务的终端计划。\n\n函数内部首先获取终端计划的子任务ID，并将终端计划的处理节点保存在finish_node变量中。\n\n然后创建一个名为datapoint的字典，其中包含以下键值对：\n- \"plan\"：终端计划\n- \"task_id\"：子任务ID\n- \"qa_sequence\"：空列表\n\n接着将datapoint添加到execute_process列表中，并将子任务ID与datapoint的映射关系保存在subtask_handle_mapping字典中。\n\n最后使用logger.typewriter_log方法打印一条日志，内容为\"Working Memory: Register a new subtask=xxx Process length=xxx.\"，其中xxx分别为子任务ID和finish_node的深度。\n\n**注意**：使用该代码时需要注意以下几点：\n- 参数terminal_plan必须是一个对象，表示任务的终端计划。\n- 执行过程中会修改execute_process列表和subtask_handle_mapping字典的内容。",
            "code_start_line": 38,
            "code_end_line": 63,
            "parent": "WorkingMemoryAgent",
            "have_return": false,
            "code_content": "    def register_task(self, terminal_plan):\n        \"\"\"\n        The method to register a task i.e., to add the terminal plan of the task to the execution process,\n        and to map the subtask id with the terminal plan in subtask_handle_mapping\n\n        Args:\n            terminal_plan (object): The terminal plan of the task.\n\n        \"\"\"\n        subtask_id = terminal_plan.get_subtask_id(to_str=True)\n        finish_node = terminal_plan.process_node\n\n        datapoint = {\n            \"plan\": terminal_plan,\n            \"task_id\": subtask_id,\n            \"qa_sequence\": [],\n        }\n\n        self.execute_process.append(datapoint)\n        self.subtask_handle_mapping[subtask_id] = datapoint\n\n        self.logger.typewriter_log(\n            \"Working Memory: \",\n            Fore.YELLOW,\n            f\"{Fore.YELLOW}Register a new subtask={Style.RESET_ALL}{subtask_id} {Fore.YELLOW}Process length={Style.RESET_ALL}{finish_node.get_depth()}.\"\n        )\n",
            "name_column": 8
        },
        "handle": {
            "type": "FunctionDef",
            "name": "handle",
            "md_content": "**handle函数**：这个函数的功能是处理名为'chat_with_other_subtask'的工具。\n\n这个函数有两个参数，分别是tool_name和tool_input。tool_name是工具的名称，tool_input是工具的输入。\n\n在函数内部，首先使用断言语句assert来判断tool_name是否等于\"chat_with_other_subtask\"，如果不等于，则会抛出AssertionError异常。\n\n接着，函数会调用self.logger.log方法，记录一条日志，内容为\"handle chat with other subtask\"。\n\n**注意**：使用这段代码时需要注意以下几点：\n- 调用handle函数时，需要传入正确的工具名称和工具输入。\n- 如果工具名称不是\"chat_with_other_subtask\"，会抛出AssertionError异常。",
            "code_start_line": 65,
            "code_end_line": 78,
            "parent": "WorkingMemoryAgent",
            "have_return": false,
            "code_content": "    def handle(self, tool_name, tool_input):\n        \"\"\"\n        The method to handle the tool named 'chat_with_other_subtask'\n\n        Args:\n            tool_name (str): The name of the tool.\n            tool_input (str): The input for the tool.\n\n        Raises:\n            AssertionError: If tool name is not 'chat_with_other_subtask'.\n\n        \"\"\"\n        assert tool_name == \"chat_with_other_subtask\"\n        self.logger.log(\"handle chat with other subtask\")",
            "name_column": 8
        }
    },
    "XAgent/workflow/reflection.py": {
        "get_posterior_knowledge": {
            "type": "FunctionDef",
            "name": "get_posterior_knowledge",
            "md_content": "**get_posterior_knowledge函数**：该函数的功能是根据先前的操作反思并生成后验知识。\n\n该函数接受以下参数：\n- all_plan (Plan): 所有操作的完整计划。\n- terminal_plan (Plan): 终端操作的计划。\n- finish_node (ToolNode): 表示最终工具的节点。\n- tool_functions_description_list (List[dict]): 描述工具函数的字典列表。\n- config (object): 包含设置的配置对象。\n- agent_dispatcher (AgentDispatcher): 代理调度器。\n\n该函数返回一个字典，其中包含生成的后验知识。\n\n该函数首先通过agent_dispatcher调用dispatch方法，传递了RequiredAbilities.reflection和\"Reflect on the previous actions and give the posterior knowledge\"作为参数，生成一个代理对象agent。\n\n然后，将all_plan和terminal_plan转换为JSON格式。如果config.enable_summary为True，则对terminal_plan进行summarize_plan操作，并对finish_node.process进行summarize_action操作，同时对all_plan进行summarize_plan操作。否则，直接将它们转换为JSON格式。\n\n接下来，调用agent的parse方法，传递placeholders参数和function_manager.get_function_schema('generate_posterior_knowledge')['parameters']作为参数。placeholders参数中包含了系统级别的占位符，用于替换agent中的参数。解析后的结果保存在new_message中。\n\n最后，将new_message中的arguments转换为字典类型的data，并将其作为函数的返回值。\n\n**注意**：使用该代码时需要注意以下几点：\n- 该函数依赖于agent_dispatcher和function_manager对象的正确初始化和配置。\n- 需要确保传入的参数类型和格式正确。\n\n**输出示例**：模拟代码返回值的可能外观。\n```python\n{\n    \"summary\": \"This is a summary of the action list.\",\n    \"reflection_of_plan\": \"This is a reflection of the plan.\",\n    \"reflection_of_tool\": \"This is a reflection of the tool.\"\n}\n```",
            "code_start_line": 12,
            "code_end_line": 62,
            "parent": null,
            "have_return": true,
            "code_content": "def get_posterior_knowledge(all_plan: Plan,\n                            terminal_plan: Plan,\n                            finish_node: ToolNode,\n                            tool_functions_description_list: List[dict],\n                            config,\n                            agent_dispatcher):\n    \"\"\"\n    Reflects on the previous actions and generates the posterior knowledge.\n\n    Args:\n        all_plan (Plan): The complete plan of actions.\n        terminal_plan (Plan): The plan of actions at the terminal.\n        finish_node (ToolNode): The node that represents the finishing tool.\n        tool_functions_description_list (List[dict]): A list of dictionaries that describe tool functions.\n        config (object): The configuration object with settings.\n        agent_dispatcher (AgentDispatcher): The agent dispatcher.\n\n    Returns:\n        dict: A dictionary with the generated posterior knowledge.\n\n    \"\"\"\n    agent = agent_dispatcher.dispatch(\n        RequiredAbilities.reflection,\n        \"Reflect on the previous actions and give the posterior knowledge\"\n    )\n    all_plan = all_plan.to_json()\n    terminal_plan = terminal_plan.to_json()\n    if config.enable_summary:\n        terminal_plan = summarize_plan(terminal_plan)\n        action_process = summarize_action(finish_node.process, terminal_plan)\n        all_plan = summarize_plan(all_plan)\n    else:\n        action_process = json.dumps(finish_node.process,indent=2,ensure_ascii=False)\n        all_plan = json.dumps(all_plan, indent=2, ensure_ascii=False)\n        terminal_plan = json.dumps(terminal_plan, indent=2, ensure_ascii=False)\n        \n    new_message,_ = agent.parse(\n        placeholders={\n            \"system\": {\n                \"all_plan\": all_plan,\n                \"terminal_plan\": terminal_plan,\n                \"tool_functions_description_list\": json.dumps(tool_functions_description_list, indent=2, ensure_ascii=False),\n                \"action_process\": action_process\n            }\n        },\n        arguments=function_manager.get_function_schema('generate_posterior_knowledge')['parameters']\n    )\n\n    data = json5.loads(new_message[\"arguments\"])\n\n    return data",
            "name_column": 4
        }
    },
    "XAgent/workflow/__init__.py": {},
    "XAgent/workflow/task_handler.py": {
        "TaskHandler": {
            "type": "ClassDef",
            "name": "TaskHandler",
            "md_content": "**TaskHandler函数**：TaskHandler类是XAgent系统中处理任务的主要类。\n\n该类具有以下属性：\n- config：任务处理器的配置设置。\n- function_list：当前任务可用函数的列表。\n- tool_functions_description_list：当前任务可用工具函数的描述列表。\n- query：当前任务的查询。\n- tool_call_count：用于跟踪工具调用次数的变量。\n- plan_agent：用于生成和处理当前任务计划的PlanAgent类的实例。\n- interaction：与外部世界进行交互的XAgentInteraction类的实例。\n\n该类具有以下方法：\n- \\_\\_init\\_\\_(self, xagent_core: XAgentCoreComponents, xagent_param: XAgentParam)：使用提供的输入参数初始化TaskHandler对象。\n- outer_loop(self)：执行外部循环中的主要任务序列。\n- inner_loop(self, plan: Plan)：生成搜索计划并处理当前任务的内部循环。\n- posterior_process(self, terminal_plan: Plan)：对终端计划执行后处理步骤，包括提取后知识和更新计划数据。\n\n**注意**：该类用于处理XAgent系统中的任务，包括生成和处理计划、执行搜索计划、后处理等操作。\n\n**输出示例**：\n```\n# TaskHandler对象示例\ntask_handler = TaskHandler(xagent_core, xagent_param)\n\n# 执行外部循环\ntask_handler.outer_loop()\n\n# 执行内部循环\ntask_handler.inner_loop(plan)\n\n# 执行后处理\ntask_handler.posterior_process(terminal_plan)\n```",
            "code_start_line": 17,
            "code_end_line": 300,
            "parent": null,
            "have_return": true,
            "code_content": "class TaskHandler():\n    \"\"\"\n    Main class for handling tasks within the XAgent system.\n\n    Attributes:\n        config: The configuration settings for the task handler.\n        function_list: List of available functions for the current task.\n        tool_functions_description_list: List of available tool functions description for the current task.\n        query: The current task of this agent.\n        tool_call_count: Variable for tracking the count of tool calls.\n        plan_agent: Instance of PlanAgent class which is used for generating and handling plan for the current task.\n        interaction: Instance of XAgentInteraction class for interacting with outer world.\n    \"\"\"\n\n    def __init__(self,\n                 xagent_core: XAgentCoreComponents,\n                 xagent_param: XAgentParam):\n        \"\"\"\n        Initializes TaskHandler with the provided input parameters.\n\n        Args:\n            xaagent_core (XAgentCoreComponents): Instance of XAgentCoreComponents class.\n            xaagent_param (XAgentParam): Instance of XAgentParam class.\n        \"\"\"\n        self.xagent_core = xagent_core\n        self.xagent_param = xagent_param\n        self.config = xagent_param.config\n        self.function_list = self.xagent_core.function_list\n        self.tool_functions_description_list = self.xagent_core.tool_functions_description_list\n        self.query = self.xagent_param.query\n        self.tool_call_count = 0\n        self.plan_agent = PlanAgent(\n            config=self.config,\n            query=self.query,\n            avaliable_tools_description_list=self.tool_functions_description_list,\n        )\n        self.logger = self.xagent_core.logger\n        # self.avaliable_tools_description_list = tool_functions_description_list\n\n        self.interaction = self.xagent_core.interaction\n        self.recorder = self.xagent_core.recorder\n        self.agent_dispatcher = self.xagent_core.agent_dispatcher\n        self.function_list = self.xagent_core.function_list\n        self.function_handler = self.xagent_core.function_handler\n        self.toolserver_interface = self.xagent_core.toolserver_interface\n        self.working_memory_agent = self.xagent_core.working_memory_agent\n        self.now_dealing_task = None\n\n    def outer_loop(self):\n        \"\"\"\n        Executes the main sequence of tasks in the outer loop.\n\n        Raises:\n            AssertionError: Raised if a not expected status is encountered while handling the plan.\n\n        Returns:\n            None\n        \"\"\"\n        self.logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= BEGIN QUERY SOVLING -=-=-=-=-=-=-=\",\n            Fore.YELLOW,\n            \"\",\n        )\n        self.query.log_self()\n\n        self.plan_agent.initial_plan_generation(\n            agent_dispatcher=self.agent_dispatcher)\n\n        print(summarize_plan(self.plan_agent.latest_plan.to_json()))\n\n        print_data = self.plan_agent.latest_plan.to_json()\n        self.interaction.insert_data(data={\n            \"task_id\": print_data.get(\"task_id\", \"\"),\n            \"name\": print_data.get(\"name\", \"\"),\n            \"goal\": print_data.get(\"goal\", \"\"),\n            \"handler\": print_data.get(\"handler\", \"\"),\n            \"tool_budget\": print_data.get(\"tool_budget\", \"\"),\n            \"subtasks\": [{**sub, \"inner\": []} for sub in print_data.get(\"subtask\", [])]\n        }, status=StatusEnum.START, current=print_data.get(\"task_id\", \"\"))\n\n        self.plan_agent.plan_iterate_based_on_memory_system()\n\n        def rewrite_input_func(old, new):\n            if new is None or not isinstance(new, dict):\n                return old, False\n            else:\n                goal = new.get(\"goal\", \"\")\n                if goal != \"\":\n                    old = goal\n                return old, True\n\n        self.now_dealing_task = self.plan_agent.latest_plan.children[0]\n        # workspace_hash_id = \"\"\n        while self.now_dealing_task:\n            task_id = self.now_dealing_task.get_subtask_id(to_str=True)\n            self.recorder.change_now_task(task_id)\n            if self.interaction.interrupt:\n                goal = self.now_dealing_task.data.goal\n                receive_data = self.interaction.receive(\n                    {\"args\": {\"goal\": goal}})\n                new_intput, flag = rewrite_input_func(\n                    self.now_dealing_task, receive_data)\n\n                if flag:\n                    self.logger.typewriter_log(\n                        \"-=-=-=-=-=-=-= USER INPUT -=-=-=-=-=-=-=\",\n                        Fore.GREEN,\n                        \"\",\n                    )\n                    self.logger.typewriter_log(\n                        \"goal: \",\n                        Fore.YELLOW,\n                        f\"{new_intput}\",\n                    )\n                    self.now_dealing_task.data.goal = new_intput\n                    self.logger.typewriter_log(\n                        \"-=-=-=-=-=-=-= USER INPUT -=-=-=-=-=-=-=\",\n                        Fore.GREEN,\n                        \"\",\n                    )\n\n            search_method = self.inner_loop(self.now_dealing_task)\n\n            self.now_dealing_task.process_node = search_method.get_finish_node()\n\n            self.posterior_process(self.now_dealing_task)\n\n            self.working_memory_agent.register_task(self.now_dealing_task)\n\n            self.xagent_core.print_task_save_items(self.now_dealing_task.data)\n\n            refinement_result = {\n                \"name\": self.now_dealing_task.data.name,\n                \"goal\": self.now_dealing_task.data.goal,\n                \"prior_plan_criticism\": self.now_dealing_task.data.prior_plan_criticism,\n                \"posterior_plan_reflection\": self.now_dealing_task.data.posterior_plan_reflection,\n                \"milestones\": self.now_dealing_task.data.milestones,\n                # \"expected_tools\": self.now_dealing_task.data.expected_tools,\n                \"tool_reflection\": self.now_dealing_task.data.tool_reflection,\n                \"action_list_summary\": self.now_dealing_task.data.action_list_summary,\n                \"task_id\": task_id,\n            }\n\n            self.interaction.insert_data(\n                data=refinement_result, status=StatusEnum.REFINEMENT, current=task_id)\n            if search_method.need_for_plan_refine:\n                self.plan_agent.plan_refine_mode(\n                    self.now_dealing_task, self.toolserver_interface, self.agent_dispatcher)\n            else:\n                self.logger.typewriter_log(\n                    \"subtask submitted as no need to refine the plan, continue\",\n                    Fore.BLUE,\n                )\n\n            self.now_dealing_task = Plan.pop_next_subtask(\n                self.now_dealing_task)\n\n            if self.now_dealing_task is None:\n                self.interaction.insert_data(\n                    data=[], status=StatusEnum.FINISHED, current=\"\")\n            else:\n                current_task_id = self.now_dealing_task.get_subtask_id(\n                    to_str=True)\n                remaining_subtask = Plan.get_remaining_subtask(\n                    self.now_dealing_task)\n                subtask_list = []\n                for todo_plan in remaining_subtask:\n                    raw_data = json.loads(todo_plan.data.raw)\n                    raw_data[\"task_id\"] = todo_plan.get_subtask_id(to_str=True)\n                    raw_data[\"inner\"] = []\n                    raw_data[\"node_id\"] = uuid.uuid4().hex\n                    subtask_list.append(raw_data)\n\n                self.interaction.insert_data(\n                    data=subtask_list, status=StatusEnum.SUBTASK, current=current_task_id)\n\n        self.logger.typewriter_log(\"ALL Tasks Done\", Fore.GREEN)\n        return\n\n    def inner_loop(self, plan: Plan, ):\n        \"\"\"\n        Generates search plan and process it for the current task.\n\n        Args:\n            plan (Plan): The plan to be processed.\n\n        Raises:\n            AssertionError: Raised if a not expected status is encountered while handling the plan.\n\n        Returns:\n            ReACTChainSearch: Instance of the search plan.\n        \"\"\"\n        task_ids_str = plan.get_subtask_id(to_str=True)\n        self.logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= Performing Task {task_ids_str} ({plan.data.name}): Begin -=-=-=-=-=-=-=\",\n            Fore.GREEN,\n            \"\",\n        )\n        self.xagent_core.print_task_save_items(plan.data)\n\n        agent = self.agent_dispatcher.dispatch(\n            RequiredAbilities.tool_tree_search,\n            json.dumps(plan.data.to_json(), indent=2, ensure_ascii=False),\n            # avaliable_tools_description_list=self.avaliable_tools_description_list\n        )\n\n        plan.data.status = TaskStatusCode.DOING\n\n        if self.config.rapidapi_retrieve_tool_count > 0:\n            retrieve_string = summarize_plan(plan.to_json())\n            rapidapi_tool_names, rapidapi_tool_jsons = self.toolserver_interface.retrieve_rapidapi_tools(\n                retrieve_string, top_k=self.config.rapidapi_retrieve_tool_count)\n            if rapidapi_tool_names is not None:\n                self.function_handler.change_subtask_handle_function_enum(\n                    self.function_handler.tool_names + rapidapi_tool_names)\n                self.function_handler.avaliable_tools_description_list += rapidapi_tool_jsons\n            else:\n                print(\"bug: no rapidapi tool retrieved, need to fix here\")\n\n        search_method = ReACTChainSearch(\n            xagent_core_components=self.xagent_core,)\n\n        arguments = function_manager.get_function_schema('action_reasoning')[\n            'parameters']\n        search_method.run(config=self.config,\n                          agent=agent,\n                          arguments=arguments,\n                          functions=self.function_handler.intrinsic_tools(\n                              self.config.enable_ask_human_for_help),\n                          task_id=task_ids_str,\n                          now_dealing_task=self.now_dealing_task,\n                          plan_agent=self.plan_agent)\n\n        if search_method.status == SearchMethodStatusCode.SUCCESS:\n            plan.data.status = TaskStatusCode.SUCCESS\n            self.logger.typewriter_log(\n                f\"-=-=-=-=-=-=-= Task {task_ids_str} ({plan.data.name}): Solved -=-=-=-=-=-=-=\",\n                Fore.GREEN,\n                \"\",\n            )\n        elif search_method.status == SearchMethodStatusCode.FAIL:\n            plan.data.status = TaskStatusCode.FAIL\n            self.logger.typewriter_log(\n                f\"-=-=-=-=-=-=-= Task {task_ids_str} ({plan.data.name}): Failed -=-=-=-=-=-=-=\",\n                Fore.RED,\n                \"\",\n            )\n        else:\n            assert False, f\"{plan.data.name}\"\n        return search_method\n\n    def posterior_process(self, terminal_plan: Plan):\n        \"\"\"\n        Performs the post-processing steps on the terminal plan including extraction of posterior knowledge\n        and updating the plan data.\n\n        Args:\n            terminal_plan (Plan): The terminal plan after completion of all inner loop tasks.\n\n        Returns:\n            None\n        \"\"\"\n\n        self.logger.typewriter_log(\n            \"-=-=-=-=-=-=-= POSTERIOR_PROCESS, working memory, summary, and reflection -=-=-=-=-=-=-=\",\n            Fore.BLUE,\n        )\n        posterior_data = get_posterior_knowledge(\n            all_plan=self.plan_agent.latest_plan,\n            terminal_plan=terminal_plan,\n            finish_node=terminal_plan.process_node,\n            tool_functions_description_list=self.tool_functions_description_list,\n            config=self.config,\n            agent_dispatcher=self.agent_dispatcher,\n        )\n\n        summary = posterior_data[\"summary\"]\n        terminal_plan.data.action_list_summary = summary\n\n        if \"reflection_of_plan\" in posterior_data.keys():\n            terminal_plan.data.posterior_plan_reflection = posterior_data[\"reflection_of_plan\"]\n\n        if \"reflection_of_tool\" in posterior_data.keys():\n            terminal_plan.data.tool_reflection = posterior_data[\"reflection_of_tool\"]\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__函数**：该函数的作用是初始化TaskHandler对象。\n\n该函数接受两个参数：xagent_core和xagent_param。xagent_core是XAgentCoreComponents类的实例，xagent_param是XAgentParam类的实例。\n\n函数内部将传入的参数赋值给TaskHandler对象的属性。具体赋值如下：\n- self.xagent_core = xagent_core：将xagent_core赋值给self.xagent_core。\n- self.xagent_param = xagent_param：将xagent_param赋值给self.xagent_param。\n- self.config = xagent_param.config：将xagent_param的config属性赋值给self.config。\n- self.function_list = self.xagent_core.function_list：将xagent_core的function_list属性赋值给self.function_list。\n- self.tool_functions_description_list = self.xagent_core.tool_functions_description_list：将xagent_core的tool_functions_description_list属性赋值给self.tool_functions_description_list。\n- self.query = self.xagent_param.query：将xagent_param的query属性赋值给self.query。\n- self.tool_call_count = 0：将工具调用计数器初始化为0。\n- self.plan_agent = PlanAgent(...)：创建PlanAgent对象，并将config、query和tool_functions_description_list作为参数传入。\n- self.logger = self.xagent_core.logger：将xagent_core的logger属性赋值给self.logger。\n- self.interaction = self.xagent_core.interaction：将xagent_core的interaction属性赋值给self.interaction。\n- self.recorder = self.xagent_core.recorder：将xagent_core的recorder属性赋值给self.recorder。\n- self.agent_dispatcher = self.xagent_core.agent_dispatcher：将xagent_core的agent_dispatcher属性赋值给self.agent_dispatcher。\n- self.function_handler = self.xagent_core.function_handler：将xagent_core的function_handler属性赋值给self.function_handler。\n- self.toolserver_interface = self.xagent_core.toolserver_interface：将xagent_core的toolserver_interface属性赋值给self.toolserver_interface。\n- self.working_memory_agent = self.xagent_core.working_memory_agent：将xagent_core的working_memory_agent属性赋值给self.working_memory_agent。\n- self.now_dealing_task = None：将当前正在处理的任务初始化为None。\n\n**注意**：在使用该代码时需要注意以下几点：\n- 该函数需要传入两个参数：xagent_core和xagent_param。\n- xagent_core必须是XAgentCoreComponents类的实例。\n- xagent_param必须是XAgentParam类的实例。\n- 函数内部会根据传入的参数进行属性的赋值操作，确保传入的参数类型正确。",
            "code_start_line": 31,
            "code_end_line": 63,
            "parent": "TaskHandler",
            "have_return": false,
            "code_content": "    def __init__(self,\n                 xagent_core: XAgentCoreComponents,\n                 xagent_param: XAgentParam):\n        \"\"\"\n        Initializes TaskHandler with the provided input parameters.\n\n        Args:\n            xaagent_core (XAgentCoreComponents): Instance of XAgentCoreComponents class.\n            xaagent_param (XAgentParam): Instance of XAgentParam class.\n        \"\"\"\n        self.xagent_core = xagent_core\n        self.xagent_param = xagent_param\n        self.config = xagent_param.config\n        self.function_list = self.xagent_core.function_list\n        self.tool_functions_description_list = self.xagent_core.tool_functions_description_list\n        self.query = self.xagent_param.query\n        self.tool_call_count = 0\n        self.plan_agent = PlanAgent(\n            config=self.config,\n            query=self.query,\n            avaliable_tools_description_list=self.tool_functions_description_list,\n        )\n        self.logger = self.xagent_core.logger\n        # self.avaliable_tools_description_list = tool_functions_description_list\n\n        self.interaction = self.xagent_core.interaction\n        self.recorder = self.xagent_core.recorder\n        self.agent_dispatcher = self.xagent_core.agent_dispatcher\n        self.function_list = self.xagent_core.function_list\n        self.function_handler = self.xagent_core.function_handler\n        self.toolserver_interface = self.xagent_core.toolserver_interface\n        self.working_memory_agent = self.xagent_core.working_memory_agent\n        self.now_dealing_task = None\n",
            "name_column": 8
        },
        "outer_loop": {
            "type": "FunctionDef",
            "name": "outer_loop",
            "md_content": "**outer_loop函数**：该函数的功能是执行外部循环中的主要任务序列。\n\n该函数首先打印日志，然后记录查询的详细信息。接下来，调用plan_agent的initial_plan_generation方法生成初始计划，并将agent_dispatcher作为参数传递给该方法。然后，打印最新计划的摘要信息。\n\n接着，将最新计划的JSON表示打印出来，并将其作为参数传递给interaction的insert_data方法，将计划的详细信息插入到数据库中。\n\n然后，调用plan_agent的plan_iterate_based_on_memory_system方法，根据内存系统迭代计划。\n\n接下来，定义了一个名为rewrite_input_func的内部函数，用于重写输入数据。然后，将当前处理的任务设置为最新计划的第一个子任务。\n\n在while循环中，处理当前任务，如果interaction的interrupt属性为True，则接收用户输入，并根据用户输入重写当前任务的目标。然后，调用inner_loop方法处理当前任务，并获取搜索方法的完成节点。\n\n接下来，调用posterior_process方法处理当前任务，并将当前任务注册到working_memory_agent中。\n\n然后，打印当前任务的保存项。\n\n接着，构建了一个包含当前任务信息的字典，并将其作为参数传递给interaction的insert_data方法，将任务的详细信息插入到数据库中。\n\n如果搜索方法需要进行计划细化，则调用plan_agent的plan_refine_mode方法进行计划细化。否则，打印一条消息表示不需要进行计划细化。\n\n最后，通过调用Plan类的pop_next_subtask方法获取下一个子任务，并将其设置为当前任务。如果当前任务为空，则将一个空列表插入到数据库中，表示任务已完成。否则，获取当前任务的子任务列表，并将其插入到数据库中。\n\n最后，打印一条消息表示所有任务已完成，并返回None。\n\n**注意**：在使用该代码时需要注意以下几点：\n- 该函数依赖于其他类和方法，确保在使用之前已经正确初始化和配置了这些依赖项。\n- 该函数会修改当前任务的目标和其他属性，确保在使用之前已经正确设置了这些属性。\n- 该函数会将任务的详细信息插入到数据库中，确保数据库连接正常并具有正确的权限。\n\n**输出示例**：\n```\n-=-=-=-=-=-=-= BEGIN QUERY SOVLING -=-=-=-=-=-=-=\n查询日志信息\n最新计划的摘要信息\n任务详细信息已插入到数据库中\n当前任务的保存项已打印\n任务详细信息已插入到数据库中\n计划细化完成，或者不需要细化\n当前任务的子任务列表已插入到数据库中\n...\nALL Tasks Done\n```",
            "code_start_line": 65,
            "code_end_line": 194,
            "parent": "TaskHandler",
            "have_return": true,
            "code_content": "    def outer_loop(self):\n        \"\"\"\n        Executes the main sequence of tasks in the outer loop.\n\n        Raises:\n            AssertionError: Raised if a not expected status is encountered while handling the plan.\n\n        Returns:\n            None\n        \"\"\"\n        self.logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= BEGIN QUERY SOVLING -=-=-=-=-=-=-=\",\n            Fore.YELLOW,\n            \"\",\n        )\n        self.query.log_self()\n\n        self.plan_agent.initial_plan_generation(\n            agent_dispatcher=self.agent_dispatcher)\n\n        print(summarize_plan(self.plan_agent.latest_plan.to_json()))\n\n        print_data = self.plan_agent.latest_plan.to_json()\n        self.interaction.insert_data(data={\n            \"task_id\": print_data.get(\"task_id\", \"\"),\n            \"name\": print_data.get(\"name\", \"\"),\n            \"goal\": print_data.get(\"goal\", \"\"),\n            \"handler\": print_data.get(\"handler\", \"\"),\n            \"tool_budget\": print_data.get(\"tool_budget\", \"\"),\n            \"subtasks\": [{**sub, \"inner\": []} for sub in print_data.get(\"subtask\", [])]\n        }, status=StatusEnum.START, current=print_data.get(\"task_id\", \"\"))\n\n        self.plan_agent.plan_iterate_based_on_memory_system()\n\n        def rewrite_input_func(old, new):\n            if new is None or not isinstance(new, dict):\n                return old, False\n            else:\n                goal = new.get(\"goal\", \"\")\n                if goal != \"\":\n                    old = goal\n                return old, True\n\n        self.now_dealing_task = self.plan_agent.latest_plan.children[0]\n        # workspace_hash_id = \"\"\n        while self.now_dealing_task:\n            task_id = self.now_dealing_task.get_subtask_id(to_str=True)\n            self.recorder.change_now_task(task_id)\n            if self.interaction.interrupt:\n                goal = self.now_dealing_task.data.goal\n                receive_data = self.interaction.receive(\n                    {\"args\": {\"goal\": goal}})\n                new_intput, flag = rewrite_input_func(\n                    self.now_dealing_task, receive_data)\n\n                if flag:\n                    self.logger.typewriter_log(\n                        \"-=-=-=-=-=-=-= USER INPUT -=-=-=-=-=-=-=\",\n                        Fore.GREEN,\n                        \"\",\n                    )\n                    self.logger.typewriter_log(\n                        \"goal: \",\n                        Fore.YELLOW,\n                        f\"{new_intput}\",\n                    )\n                    self.now_dealing_task.data.goal = new_intput\n                    self.logger.typewriter_log(\n                        \"-=-=-=-=-=-=-= USER INPUT -=-=-=-=-=-=-=\",\n                        Fore.GREEN,\n                        \"\",\n                    )\n\n            search_method = self.inner_loop(self.now_dealing_task)\n\n            self.now_dealing_task.process_node = search_method.get_finish_node()\n\n            self.posterior_process(self.now_dealing_task)\n\n            self.working_memory_agent.register_task(self.now_dealing_task)\n\n            self.xagent_core.print_task_save_items(self.now_dealing_task.data)\n\n            refinement_result = {\n                \"name\": self.now_dealing_task.data.name,\n                \"goal\": self.now_dealing_task.data.goal,\n                \"prior_plan_criticism\": self.now_dealing_task.data.prior_plan_criticism,\n                \"posterior_plan_reflection\": self.now_dealing_task.data.posterior_plan_reflection,\n                \"milestones\": self.now_dealing_task.data.milestones,\n                # \"expected_tools\": self.now_dealing_task.data.expected_tools,\n                \"tool_reflection\": self.now_dealing_task.data.tool_reflection,\n                \"action_list_summary\": self.now_dealing_task.data.action_list_summary,\n                \"task_id\": task_id,\n            }\n\n            self.interaction.insert_data(\n                data=refinement_result, status=StatusEnum.REFINEMENT, current=task_id)\n            if search_method.need_for_plan_refine:\n                self.plan_agent.plan_refine_mode(\n                    self.now_dealing_task, self.toolserver_interface, self.agent_dispatcher)\n            else:\n                self.logger.typewriter_log(\n                    \"subtask submitted as no need to refine the plan, continue\",\n                    Fore.BLUE,\n                )\n\n            self.now_dealing_task = Plan.pop_next_subtask(\n                self.now_dealing_task)\n\n            if self.now_dealing_task is None:\n                self.interaction.insert_data(\n                    data=[], status=StatusEnum.FINISHED, current=\"\")\n            else:\n                current_task_id = self.now_dealing_task.get_subtask_id(\n                    to_str=True)\n                remaining_subtask = Plan.get_remaining_subtask(\n                    self.now_dealing_task)\n                subtask_list = []\n                for todo_plan in remaining_subtask:\n                    raw_data = json.loads(todo_plan.data.raw)\n                    raw_data[\"task_id\"] = todo_plan.get_subtask_id(to_str=True)\n                    raw_data[\"inner\"] = []\n                    raw_data[\"node_id\"] = uuid.uuid4().hex\n                    subtask_list.append(raw_data)\n\n                self.interaction.insert_data(\n                    data=subtask_list, status=StatusEnum.SUBTASK, current=current_task_id)\n\n        self.logger.typewriter_log(\"ALL Tasks Done\", Fore.GREEN)\n        return\n",
            "name_column": 8
        },
        "inner_loop": {
            "type": "FunctionDef",
            "name": "inner_loop",
            "md_content": "**inner_loop函数**：该函数的功能是生成搜索计划并处理当前任务。\n\n该函数接受一个参数plan，表示要处理的计划。\n\n该函数首先将任务的子任务ID转换为字符串，并打印日志。然后调用xagent_core的print_task_save_items方法打印任务的保存项。\n\n接下来，通过调用agent_dispatcher的dispatch方法，根据plan的JSON表示和所需的能力生成一个代理。\n\n然后将任务的状态设置为DOING。\n\n如果配置中的rapidapi_retrieve_tool_count大于0，则调用toolserver_interface的retrieve_rapidapi_tools方法，根据计划生成一个检索字符串，并获取相应数量的rapidapi工具。如果获取到了工具，则更新function_handler的avaliable_tools_description_list和subtask_handle_function_enum。\n\n接下来，创建一个ReACTChainSearch实例，并调用其run方法，传入配置、代理、参数、函数、任务ID等参数。\n\n根据搜索方法的状态，更新任务的状态，并打印相应的日志。\n\n最后，返回search_method实例。\n\n**注意**：在调用该函数之前，需要确保已经初始化了相关的对象和参数。\n\n**输出示例**：一个可能的返回值的示例。",
            "code_start_line": 196,
            "code_end_line": 266,
            "parent": "TaskHandler",
            "have_return": true,
            "code_content": "    def inner_loop(self, plan: Plan, ):\n        \"\"\"\n        Generates search plan and process it for the current task.\n\n        Args:\n            plan (Plan): The plan to be processed.\n\n        Raises:\n            AssertionError: Raised if a not expected status is encountered while handling the plan.\n\n        Returns:\n            ReACTChainSearch: Instance of the search plan.\n        \"\"\"\n        task_ids_str = plan.get_subtask_id(to_str=True)\n        self.logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= Performing Task {task_ids_str} ({plan.data.name}): Begin -=-=-=-=-=-=-=\",\n            Fore.GREEN,\n            \"\",\n        )\n        self.xagent_core.print_task_save_items(plan.data)\n\n        agent = self.agent_dispatcher.dispatch(\n            RequiredAbilities.tool_tree_search,\n            json.dumps(plan.data.to_json(), indent=2, ensure_ascii=False),\n            # avaliable_tools_description_list=self.avaliable_tools_description_list\n        )\n\n        plan.data.status = TaskStatusCode.DOING\n\n        if self.config.rapidapi_retrieve_tool_count > 0:\n            retrieve_string = summarize_plan(plan.to_json())\n            rapidapi_tool_names, rapidapi_tool_jsons = self.toolserver_interface.retrieve_rapidapi_tools(\n                retrieve_string, top_k=self.config.rapidapi_retrieve_tool_count)\n            if rapidapi_tool_names is not None:\n                self.function_handler.change_subtask_handle_function_enum(\n                    self.function_handler.tool_names + rapidapi_tool_names)\n                self.function_handler.avaliable_tools_description_list += rapidapi_tool_jsons\n            else:\n                print(\"bug: no rapidapi tool retrieved, need to fix here\")\n\n        search_method = ReACTChainSearch(\n            xagent_core_components=self.xagent_core,)\n\n        arguments = function_manager.get_function_schema('action_reasoning')[\n            'parameters']\n        search_method.run(config=self.config,\n                          agent=agent,\n                          arguments=arguments,\n                          functions=self.function_handler.intrinsic_tools(\n                              self.config.enable_ask_human_for_help),\n                          task_id=task_ids_str,\n                          now_dealing_task=self.now_dealing_task,\n                          plan_agent=self.plan_agent)\n\n        if search_method.status == SearchMethodStatusCode.SUCCESS:\n            plan.data.status = TaskStatusCode.SUCCESS\n            self.logger.typewriter_log(\n                f\"-=-=-=-=-=-=-= Task {task_ids_str} ({plan.data.name}): Solved -=-=-=-=-=-=-=\",\n                Fore.GREEN,\n                \"\",\n            )\n        elif search_method.status == SearchMethodStatusCode.FAIL:\n            plan.data.status = TaskStatusCode.FAIL\n            self.logger.typewriter_log(\n                f\"-=-=-=-=-=-=-= Task {task_ids_str} ({plan.data.name}): Failed -=-=-=-=-=-=-=\",\n                Fore.RED,\n                \"\",\n            )\n        else:\n            assert False, f\"{plan.data.name}\"\n        return search_method\n",
            "name_column": 8
        },
        "posterior_process": {
            "type": "FunctionDef",
            "name": "posterior_process",
            "md_content": "**posterior_process函数**：此函数的功能是对终端计划执行后处理步骤，包括提取后验知识和更新计划数据。\n\n该函数接受一个参数terminal_plan，表示完成所有内循环任务后的终端计划。\n\n函数内部首先调用get_posterior_knowledge函数，传入多个参数，包括最新的计划、终端计划、完成节点、工具函数描述列表、配置和代理调度器。该函数用于获取后验知识，并将结果保存在posterior_data变量中。\n\n接下来，将posterior_data中的summary赋值给terminal_plan.data.action_list_summary，用于更新终端计划的动作列表摘要。\n\n然后，检查posterior_data中是否存在reflection_of_plan和reflection_of_tool，如果存在，则将其分别赋值给terminal_plan.data.posterior_plan_reflection和terminal_plan.data.tool_reflection。\n\n最后，函数执行完毕，返回None。\n\n**注意**：使用此代码时需要注意以下几点：\n- 函数需要一个Plan类型的参数terminal_plan作为输入。\n- 函数内部调用了get_posterior_knowledge函数，需要确保该函数已经定义并可用。\n- 函数会更新终端计划的数据，包括动作列表摘要、后验计划反思和工具反思。",
            "code_start_line": 268,
            "code_end_line": 300,
            "parent": "TaskHandler",
            "have_return": false,
            "code_content": "    def posterior_process(self, terminal_plan: Plan):\n        \"\"\"\n        Performs the post-processing steps on the terminal plan including extraction of posterior knowledge\n        and updating the plan data.\n\n        Args:\n            terminal_plan (Plan): The terminal plan after completion of all inner loop tasks.\n\n        Returns:\n            None\n        \"\"\"\n\n        self.logger.typewriter_log(\n            \"-=-=-=-=-=-=-= POSTERIOR_PROCESS, working memory, summary, and reflection -=-=-=-=-=-=-=\",\n            Fore.BLUE,\n        )\n        posterior_data = get_posterior_knowledge(\n            all_plan=self.plan_agent.latest_plan,\n            terminal_plan=terminal_plan,\n            finish_node=terminal_plan.process_node,\n            tool_functions_description_list=self.tool_functions_description_list,\n            config=self.config,\n            agent_dispatcher=self.agent_dispatcher,\n        )\n\n        summary = posterior_data[\"summary\"]\n        terminal_plan.data.action_list_summary = summary\n\n        if \"reflection_of_plan\" in posterior_data.keys():\n            terminal_plan.data.posterior_plan_reflection = posterior_data[\"reflection_of_plan\"]\n\n        if \"reflection_of_tool\" in posterior_data.keys():\n            terminal_plan.data.tool_reflection = posterior_data[\"reflection_of_tool\"]\n",
            "name_column": 8
        },
        "rewrite_input_func": {
            "type": "FunctionDef",
            "name": "rewrite_input_func",
            "md_content": "**rewrite_input_func函数**：此函数的功能是根据新的输入重写旧的输入。\n\n该函数接受两个参数，old和new。首先，它会检查new是否为None或者不是字典类型，如果是的话，它会直接返回old和False。否则，它会获取new字典中的\"goal\"键对应的值，并将其赋给old。最后，函数返回old和True。\n\n该函数主要用于重写旧的输入，以便在用户输入中更新任务的目标。如果用户提供了新的目标，那么将使用新的目标替换旧的目标，否则将保持不变。\n\n**注意**：在使用此函数时需要注意以下几点：\n- 函数的参数old和new必须符合函数的要求，old为旧的输入，new为新的输入。\n- new必须是一个字典类型，且包含\"goal\"键。\n\n**输出示例**：\n假设旧的输入为\"old_input\"，新的输入为{\"goal\": \"new_goal\"}，则函数的返回值为(\"new_goal\", True)。",
            "code_start_line": 99,
            "code_end_line": 106,
            "parent": "outer_loop",
            "have_return": true,
            "code_content": "        def rewrite_input_func(old, new):\n            if new is None or not isinstance(new, dict):\n                return old, False\n            else:\n                goal = new.get(\"goal\", \"\")\n                if goal != \"\":\n                    old = goal\n                return old, True\n",
            "name_column": 12
        }
    },
    "XAgent/workflow/plan_exec.py": {
        "plan_function_output_parser": {
            "type": "FunctionDef",
            "name": "plan_function_output_parser",
            "md_content": "**plan_function_output_parser函数**：该函数的功能是将函数输出项解析为一个Plan对象。\n\n该函数接受一个表示函数输出项的字典作为参数，并将其解析为一个Plan对象。\n\n参数：\n- function_output_item (dict): 表示函数输出项的字典。\n\n返回值：\n- Plan: 解析后的Plan对象。\n\n该函数在以下文件中被调用，文件路径和相应的调用代码如下：\n文件路径：XAgent/workflow/plan_exec.py\n相应代码如下：\n    def initial_plan_generation(self, agent_dispatcher):\n        \"\"\"生成初始计划。\n\n        该方法通过调用计划生成代理生成初始计划。\n        \"\"\"\n        logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= 生成初始计划 -=-=-=-=-=-=-=\",\n            Fore.GREEN,\n            \"\",\n        )\n\n        split_functions = deepcopy(function_manager.get_function_schema('subtask_split_operation'))\n\n        agent = agent_dispatcher.dispatch(\n            RequiredAbilities.plan_generation,\n            target_task=f\"生成一个完成任务的计划：{self.query.task}\",\n            # avaliable_tools_description_list=self.avaliable_tools_description_list\n        )\n\n        # TODO: 不够健壮。调度生成的提示信息可能不包含这些指定的占位符？\n        new_message , _ = agent.parse(\n            placeholders={\n                \"system\": {\n                    # \"avaliable_tool_descriptions\": json.dumps(self.avaliable_tools_description_list, indent=2, ensure_ascii=False),\n                    \"avaliable_tool_names\": str([cont[\"name\"] for cont in self.avaliable_tools_description_list]),\n                },\n                \"user\": {\n                    \"query\": self.plan.data.raw\n                }\n            },\n            arguments=deepcopy(function_manager.get_function_schema('simple_thought')['parameters']),\n            functions=[split_functions], \n        )\n        \n        subtasks = json5.loads(new_message[\"function_call\"][\"arguments\"])\n\n        for subtask_item in subtasks[\"subtasks\"]:\n            subplan = plan_function_output_parser(subtask_item)\n            Plan.make_relation(self.plan, subplan)\n\n[代码片段结束]\n相应代码如下：\n    def deal_subtask_split(self, function_input: dict, now_dealing_task: Plan) -> (str, PlanOperationStatusCode):\n        \"\"\"处理子任务拆分。\n\n        该方法处理子任务拆分。\n\n        参数：\n        - function_input (dict): 函数输入。\n        - now_dealing_task (Plan): 当前正在处理的任务。\n\n        返回值：\n        - str: 函数输出。\n        - PlanOperationStatusCode: 状态码。\n        \"\"\"\n        print(json.dumps(function_input,indent=2,ensure_ascii=False))\n\n        inorder_subtask_stack = Plan.get_inorder_travel(self.plan)\n        target_subtask_id = function_input[\"target_subtask_id\"].strip()\n        all_subtask_ids = [cont.get_subtask_id(to_str=True) for cont in inorder_subtask_stack]\n\n        can_edit = False\n        for k, subtask in enumerate(inorder_subtask_stack):\n            if subtask.get_subtask_id(to_str=True) == now_dealing_task.get_subtask_id(to_str=True):\n                \n                can_edit = True\n\n            if subtask.get_subtask_id(to_str=True) == target_subtask_id:\n                if not can_edit:\n                    return json.dumps({\"error\": f\"您只能与当前正在处理的子任务一起拆分待办子任务计划，例如 '>= {now_dealing_task.get_subtask_id(to_str=True)}'。没有发生任何操作。\"}), PlanOperationStatusCode.MODIFY_FORMER_PLAN\n                \n                # if not subtask.data.status == TaskStatusCode.FAIL:\n                #     return json.dumps({\"error\": f\"You can only split the FAIL subtask plans together. This is a '{subtask.data.status",
            "code_start_line": 18,
            "code_end_line": 30,
            "parent": null,
            "have_return": true,
            "code_content": "def plan_function_output_parser(function_output_item: dict) -> Plan:\n    \"\"\"Parses the function output item into a Plan object.\n\n    Args:\n        function_output_item (dict): The dictionary representing the function output item.\n\n    Returns:\n        Plan: The parsed Plan object.\n    \"\"\"\n    subtask_node = TaskSaveItem()\n    subtask_node.load_from_json(function_output_item=function_output_item)\n    subplan = Plan(subtask_node)\n    return subplan\n",
            "name_column": 4
        },
        "PlanRefineChain": {
            "type": "ClassDef",
            "name": "PlanRefineChain",
            "md_content": "**PlanRefineChain函数**：这个类的功能是表示一系列计划细化。\n\n这个类用于跟踪细化计划和相关的细化函数。\n\n**属性**：\n- plans（List[Plan]）：细化计划的列表。\n- functions（List[dict]）：细化函数的列表。\n\n**__init__函数**：\n- 初始化一个PlanRefineChain对象。\n- 参数：\n  - init_plan：初始计划。\n\n**register函数**：\n- 注册一个计划细化。\n- 参数：\n  - function_name（str）：细化函数的名称。\n  - function_input（dict）：细化函数的输入。\n  - function_output（str）：细化函数的输出。\n  - new_plan（Plan）：细化后的新计划。\n\n**parse_to_message_list函数**：\n- 将细化链解析为消息列表。\n- 参数：\n  - flag_changed：一个指示计划是否发生变化的标志。\n- 返回值：消息列表。\n\n**注意**：在使用这个类的代码中，需要注意以下几点：\n- 在初始化PlanAgent对象时，会创建一个PlanRefineChain对象并将其添加到refine_chains列表中。\n- 在plan_refine_mode函数中，会根据用户的建议对计划进行细化，并将细化过程添加到refine_chains列表中。\n\n**输出示例**：\n```\nPlanRefineChain对象的plans属性：[Plan对象1, Plan对象2, ...]\nPlanRefineChain对象的functions属性：[{\"name\": \"函数1\", \"input\": {...}, \"output\": \"输出1\"}, {\"name\": \"函数2\", \"input\": {...}, \"output\": \"输出2\"}, ...]\n```",
            "code_start_line": 32,
            "code_end_line": 107,
            "parent": null,
            "have_return": true,
            "code_content": "class PlanRefineChain():\n    \"\"\"Represents a chain of plan refinements.\n\n    This class keeps track of the refined plans and the associated refine functions.\n\n    Attributes:\n        plans (List[Plan]): The list of refined plans.\n        functions (List[dict]): The list of refine functions.\n    \"\"\"\n\n    def __init__(self, init_plan):\n        \"\"\"Initializes a PlanRefineChain object.\n\n        Args:\n            init_plan: The initial plan.\n        \"\"\"\n        self.plans = [deepcopy(init_plan)]\n        self.functions = []\n\n    def register(self, function_name, function_input, function_output, new_plan: Plan):\n        \"\"\"Registers a plan refinement.\n\n        This method adds the function name, input, and output, as well as the new plan to the refine chain.\n\n        Args:\n            function_name (str): The name of the refine function.\n            function_input (dict): The input of the refine function.\n            function_output (str): The output of the refine function.\n            new_plan (Plan): The new plan after refinement.\n        \"\"\"\n        self.functions.append({\n            \"name\": function_name,\n            \"input\": function_input,\n            \"output\": function_output,\n        })\n        self.plans.append(deepcopy(new_plan))\n\n        XAgentCoreComponents.global_recorder.regist_plan_modify(\n            refine_function_name = function_name,\n            refine_function_input = function_input,\n            refine_function_output = function_output,\n            plan_after = new_plan.to_json(posterior=True),\n        )\n\n    def parse_to_message_list(self, flag_changed) -> List[Message]:\n        \"\"\"Parses the refine chain to a list of messages.\n\n        This method generates a list of messages describing each refinement step in the refine chain.\n\n        Args:\n            flag_changed: A flag indicating whether the plan has changed.\n\n        Returns:\n            List[Message]: A list of messages.\n        \"\"\"\n        assert len(self.plans) == len(self.functions) + 1\n\n        if CONFIG.enable_summary:\n            init_message = summarize_plan(self.plans[0].to_json())\n        else:\n            init_message = json.dumps(self.plans[0].to_json(), indent=2, ensure_ascii=False)\n        init_message =  Message(\"user\", f\"\"\"The initial plan and the execution status is:\\n'''\\n{init_message}\\n'''\\n\\n\"\"\")\n        output_list = [init_message]\n        for k, (function, output_plan) in enumerate(zip(self.functions, self.plans[1:])):\n            operation_message = Message(\"user\", f\"\"\"For the {k+1}\\'th step, You made the following operation:\\nfunction_name: {function[\"name\"]}\\n'''\\n{json.dumps(function[\"input\"],indent=2,ensure_ascii=False)}\\n'''\\nThen get the operation result:\\n{function[\"output\"]}\\n\"\"\")\n            output_list.append(operation_message)\n        if len(self.plans) > 1:\n            if flag_changed:\n                if CONFIG.enable_summary:\n                    new_message = summarize_plan(self.plans[-1].to_json())\n                else:\n                    new_message = json.dumps(self.plans[-1].to_json(), indent=2, ensure_ascii=False)\n                output_list.append(Message(\"user\", f\"\"\"The total plan changed to follows:\\n'''\\n{new_message}\\n'''\\n\\n\"\"\"))\n            else:\n                output_list.append(Message(\"user\", f\"The total plan stay unchanged\"))\n        return output_list\n",
            "name_column": 6
        },
        "PlanAgent": {
            "type": "ClassDef",
            "name": "PlanAgent",
            "md_content": "**PlanAgent函数**: 这个类的功能是生成和细化计划。\n\n这个类是负责生成和细化计划的，它有以下属性：\n\n- config: 计划代理的配置。\n- query (BaseQuery): 用于生成计划的基本查询。\n- avaliable_tools_description_list (List[dict]): 可用工具描述的列表。\n- plan (Plan): 计划。\n- refine_chains (List[PlanRefineChain]): 细化链的列表。\n\n这个类有以下方法：\n\n- `__init__(self, config, query: BaseQuery, avaliable_tools_description_list: List[dict])`: 初始化PlanAgent对象。\n- `initial_plan_generation(self, agent_dispatcher)`: 生成初始计划。\n- `plan_iterate_based_on_memory_system(self)`: 基于内存系统迭代细化计划。\n- `latest_plan(self)`: 获取最新的计划。\n- `plan_refine_mode(self, now_dealing_task: Plan, toolserver_interface, agent_dispatcher)`: 进入计划细化模式。\n- `deal_subtask_split(self, function_input: dict, now_dealing_task: Plan) -> (str, PlanOperationStatusCode)`: 处理子任务拆分。\n- `deal_subtask_delete(self, function_input: dict, now_dealing_task: Plan) -> (str, PlanOperationStatusCode)`: 处理子任务删除。\n- `deal_subtask_modify(self, function_input: dict, now_dealing_task: Plan) -> (str, PlanOperationStatusCode)`: 处理子任务修改。\n- `deal_subtask_add(self, function_input: dict, now_dealing_task: Plan) -> (str, PlanOperationStatusCode)`: 处理子任务添加。\n\n**Note**: \n- 这个类代表了一个计划代理，负责生成和细化计划。\n- `__init__`方法用于初始化PlanAgent对象，接受配置、查询和可用工具描述列表作为参数。\n- `initial_plan_generation`方法用于生成初始计划，通过调用计划生成代理来实现。\n- `plan_iterate_based_on_memory_system`方法用于基于内存系统迭代细化计划，目前未实现。\n- `latest_plan`方法用于获取最新的计划。\n- `plan_refine_mode`方法用于进入计划细化模式，根据用户的建议进行计划细化。\n- `deal_subtask_split`方法用于处理子任务拆分，将一个子任务拆分为多个子任务。\n- `deal_subtask_delete`方法用于处理子任务删除，删除指定的子任务。\n- `deal_subtask_modify`方法用于处理子任务修改，修改指定子任务的数据。\n- `deal_subtask_add`方法用于处理子任务添加，在指定子任务后添加新的子任务。\n\n**Output Example**:\n```python\nplan_agent = PlanAgent(config, query, avaliable_tools_description_list)\nplan_agent.initial_plan_generation(agent_dispatcher)\nlatest_plan = plan_agent.latest_plan()\nplan_agent.plan_refine_mode(now_dealing_task, toolserver_interface, agent_dispatcher)\n```",
            "code_start_line": 109,
            "code_end_line": 495,
            "parent": null,
            "have_return": true,
            "code_content": "class PlanAgent():\n    \"\"\"Represents a plan agent.\n\n    This class is responsible for generating and refining plans.\n\n    Attributes:\n        config: The configuration for the plan agent.\n        query (BaseQuery): The base query for generating plans.\n        avaliable_tools_description_list (List[dict]): The list of available tool descriptions.\n        plan (Plan): The plan.\n        refine_chains (List[PlanRefineChain]): The list of refine chains.\n    \"\"\"\n    def __init__(self, config, query: BaseQuery, avaliable_tools_description_list: List[dict]):\n        \"\"\"Initializes a PlanAgent object.\n\n        Args:\n            config: The configuration for the plan agent.\n            query (BaseQuery): The base query for generating plans.\n            avaliable_tools_description_list (List[dict]): The list of available tool descriptions.\n        \"\"\"\n        self.config = config\n        self.query = query\n        self.avaliable_tools_description_list = avaliable_tools_description_list\n\n        self.plan = Plan(\n            data = TaskSaveItem(\n                name=f\"act as {query.role_name}\",\n                goal=query.task,\n                milestones=query.plan,\n                # tool_budget=100,\n            )\n        )\n\n        self.refine_chains: List[PlanRefineChain] = []\n\n    def initial_plan_generation(self, agent_dispatcher):\n        \"\"\"Generates the initial plan.\n\n        This method generates the initial plan by calling the plan generation agent.\n        \"\"\"\n        logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= GENERATE INITIAL_PLAN -=-=-=-=-=-=-=\",\n            Fore.GREEN,\n            \"\",\n        )\n\n        split_functions = deepcopy(function_manager.get_function_schema('subtask_split_operation'))\n\n        agent = agent_dispatcher.dispatch(\n            RequiredAbilities.plan_generation,\n            target_task=f\"Generate a plan to accomplish the task: {self.query.task}\",\n            # avaliable_tools_description_list=self.avaliable_tools_description_list\n        )\n\n        # TODO: not robust. dispatcher generated prompt may not contain these specified placeholders?\n        new_message , _ = agent.parse(\n            placeholders={\n                \"system\": {\n                    # \"avaliable_tool_descriptions\": json.dumps(self.avaliable_tools_description_list, indent=2, ensure_ascii=False),\n                    \"avaliable_tool_names\": str([cont[\"name\"] for cont in self.avaliable_tools_description_list]),\n                },\n                \"user\": {\n                    \"query\": self.plan.data.raw\n                }\n            },\n            arguments=deepcopy(function_manager.get_function_schema('simple_thought')['parameters']),\n            functions=[split_functions], \n        )\n        \n        subtasks = json5.loads(new_message[\"function_call\"][\"arguments\"])\n\n        for subtask_item in subtasks[\"subtasks\"]:\n            subplan = plan_function_output_parser(subtask_item)\n            Plan.make_relation(self.plan, subplan)\n\n    def plan_iterate_based_on_memory_system(self):\n        \"\"\"Iteratively refines the plan based on the memory system.\n\n        This method iteratively refines the plan based on the memory system.\n        \"\"\"\n        logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= ITERATIVELY REFINE PLAN BASED ON MEMORY SYSTEM -=-=-=-=-=-=-=\",\n            Fore.BLUE,\n        )\n        print(\"Not Implemented, skip\")\n        # TODO\n\n    @property\n    def latest_plan(self):\n        \"\"\"Gets the latest plan.\n\n        Returns:\n            The latest plan.\n        \"\"\"\n        return self.plan\n\n    def plan_refine_mode(self, now_dealing_task: Plan, toolserver_interface, agent_dispatcher):\n        \"\"\"Enters the plan refine mode.\n\n        This method enters the plan refine mode and performs plan refinements based on user suggestions.\n\n        Args:\n            now_dealing_task (Plan): The task that is currently being dealt with.\n        \"\"\"\n        logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= ITERATIVELY REFINE PLAN BASED ON TASK AGENT SUGGESTIONS -=-=-=-=-=-=-=\",\n            Fore.BLUE,\n        )\n\n        self.refine_chains.append(PlanRefineChain(self.plan)) \n\n        modify_steps = 0\n        max_step = self.config.max_plan_refine_chain_length\n\n        agent = agent_dispatcher.dispatch(\n            RequiredAbilities.plan_refinement, \n            target_task=\"Refine the given plan.\", \n            # avaliable_tools_description_list=self.avaliable_tools_description_list\n        )\n        try:\n            refine_node_message = now_dealing_task.process_node.data[\"command\"][\"properties\"][\"args\"]\n            refine_node_message = refine_node_message[\"suggestions_for_latter_subtasks_plan\"][\"reason\"]\n        except:\n            refine_node_message = \"\"\n        workspace_files = str(toolserver_interface.execute_command_client(\"FileSystemEnv_print_filesys_struture\", {\"return_root\":True}))\n        workspace_files,length = clip_text(workspace_files,1000,clip_end=True)\n                \n        while modify_steps < max_step:\n\n            logger.typewriter_log(\n                f\"-=-=-=-=-=-=-= Continually refining planning (still in the loop)-=-=-=-=-=-=-=\",\n                Fore.GREEN,\n            )\n\n            subtask_id = now_dealing_task.get_subtask_id(to_str=True)\n            flag_changed = False\n            \n            additional_message_list = self.refine_chains[-1].parse_to_message_list(flag_changed)\n\n            functions=[deepcopy(function_manager.get_function_schema('subtask_operations'))]\n            \n            new_message , _ = agent.parse(\n                placeholders={\n                    \"system\": {\n                        # \"avaliable_tool_descriptions\": json.dumps(self.avaliable_tools_description_list, indent=2, ensure_ascii=False),\n                        \"avaliable_tool_names\": str([cont[\"name\"] for cont in self.avaliable_tools_description_list]),\n                        \"max_plan_tree_width\": self.config.max_plan_tree_width,\n                        \"max_plan_tree_depth\": self.config.max_plan_tree_depth,\n                    },\n                    \"user\": {\n                        \"subtask_id\": subtask_id,\n                        \"max_step\": max_step,\n                        \"modify_steps\": modify_steps,\n                        \"max_plan_tree_depth\": self.config.max_plan_tree_depth,\n                        \"workspace_files\": workspace_files,\n                        \"refine_node_message\":refine_node_message,\n                    }\n                }, \n                arguments=deepcopy(function_manager.get_function_schema('simple_thought')['parameters']),\n                functions=functions, \n                additional_messages=additional_message_list,\n                additional_insert_index=-1,\n            )\n            function_name = new_message[\"function_call\"][\"name\"]\n            function_input = json5.loads(new_message[\"function_call\"][\"arguments\"])\n\n            if function_input['operation'] == 'split':\n                # modify function_input here\n                function_output, output_status_code = self.deal_subtask_split(function_input, now_dealing_task)\n            elif function_input['operation'] == 'add':\n                function_output, output_status_code = self.deal_subtask_add(function_input, now_dealing_task)\n            elif function_input['operation'] == 'delete':\n                function_output, output_status_code = self.deal_subtask_delete(function_input, now_dealing_task)\n            elif function_input['operation'] == 'exit':\n                output_status_code = PlanOperationStatusCode.PLAN_REFINE_EXIT\n                function_output = json.dumps({\n                    \"content\": \"exit PLAN_REFINE_MODE successfully\",\n                })\n            else:\n                logger.typewriter_log(\"Error: \", Fore.RED, f\"Operation {function_input['operation']} not found. Nothing happens\")\n                output_status_code = PlanOperationStatusCode.PLAN_OPERATION_NOT_FOUND\n                function_output = json.dumps({\n                    \"error\": f\"Operation {function_input['operation']} not found. Nothing happens\"\n                })\n            \n            if \"error\" not in function_output:\n                flag_changed = True\n\n            self.refine_chains[-1].register(function_name=function_name,\n                                            function_input=function_input,\n                                            function_output=function_output,\n                                            new_plan=self.plan)\n\n            if output_status_code == PlanOperationStatusCode.MODIFY_SUCCESS:\n                color = Fore.GREEN\n            elif output_status_code == PlanOperationStatusCode.PLAN_REFINE_EXIT:\n                color = Fore.YELLOW\n            else:\n                color = Fore.RED\n            logger.typewriter_log(\"SYSTEM: \", Fore.YELLOW, function_output)\n            logger.typewriter_log(\n                \"PLAN MODIFY STATUS CODE: \", Fore.YELLOW, f\"{color}{output_status_code.name}{Style.RESET_ALL}\"\n            )\n\n            if output_status_code == PlanOperationStatusCode.PLAN_REFINE_EXIT or output_status_code == PlanOperationStatusCode.MODIFY_SUCCESS:\n                return\n\n            modify_steps += 1\n\n    def deal_subtask_split(self, function_input: dict, now_dealing_task: Plan) -> (str, PlanOperationStatusCode):\n        \"\"\"Deals with subtask splitting.\n\n        This method handles subtask splitting.\n\n        Args:\n            function_input (dict): The function input.\n            now_dealing_task (Plan): The task that is currently being dealt with.\n\n        Returns:\n            str: The function output.\n            PlanOperationStatusCode: The status code.\n        \"\"\"\n        print(json.dumps(function_input,indent=2,ensure_ascii=False))\n\n        inorder_subtask_stack = Plan.get_inorder_travel(self.plan)\n        target_subtask_id = function_input[\"target_subtask_id\"].strip()\n        all_subtask_ids = [cont.get_subtask_id(to_str=True) for cont in inorder_subtask_stack]\n\n        can_edit = False\n        for k, subtask in enumerate(inorder_subtask_stack):\n            if subtask.get_subtask_id(to_str=True) == now_dealing_task.get_subtask_id(to_str=True):\n                \n                can_edit = True\n\n            if subtask.get_subtask_id(to_str=True) == target_subtask_id:\n                if not can_edit:\n                    return json.dumps({\"error\": f\"You can only split the TODO subtask plans together with the now_dealing_subtask, e.g. '>= {now_dealing_task.get_subtask_id(to_str=True)}'. Nothing happended\",}), PlanOperationStatusCode.MODIFY_FORMER_PLAN\n                \n                # if not subtask.data.status == TaskStatusCode.FAIL:\n                #     return json.dumps({\"error\": f\"You can only split the FAIL subtask plans together. This is a '{subtask.data.status.name}' Task. Nothing happended\"}), PlanOperationStatusCode.OTHER_ERROR\n\n                if subtask.get_depth() >= self.config.max_plan_tree_depth:\n                    return json.dumps({\"error\": f\"The plan tree has a max depth of {self.config.max_plan_tree_depth}. '{subtask.data.name}' already has a depth of {subtask.get_depth()}. Nothing happended\"}), PlanOperationStatusCode.OTHER_ERROR\n\n                for new_subtask in function_input[\"subtasks\"]:\n                    new_subplan = plan_function_output_parser(new_subtask)\n                    Plan.make_relation(subtask,new_subplan)\n                subtask.data.status = TaskStatusCode.SPLIT\n                return json.dumps({\"success\": f\"Subtask '{target_subtask_id}' has been split\",}), PlanOperationStatusCode.MODIFY_SUCCESS\n\n        return json.dumps({\"error\": f\"target_subtask_id '{target_subtask_id}' not found. Nothing happended\",}), PlanOperationStatusCode.TARGET_SUBTASK_NOT_FOUND\n\n\n    def deal_subtask_delete(self, function_input: dict, now_dealing_task: Plan) -> (str, PlanOperationStatusCode):\n        \"\"\"Deals with subtask deletion.\n\n        This method handles subtask deletion.\n\n        Args:\n            function_input (dict): The function input.\n            now_dealing_task (Plan): The task that is currently being dealt with.\n\n        Returns:\n            str: The function output.\n            PlanOperationStatusCode: The status code.\n        \"\"\"\n        print(json.dumps(function_input,indent=2,ensure_ascii=False))\n\n        inorder_subtask_stack:list[Plan] = Plan.get_inorder_travel(self.plan)\n        target_subtask_id = function_input[\"target_subtask_id\"].strip()\n\n        all_subtask_ids = [cont.get_subtask_id(to_str=True) for cont in inorder_subtask_stack]\n\n        can_edit = False\n        for k, subtask in enumerate(inorder_subtask_stack):\n            if subtask.get_subtask_id(to_str=True) == target_subtask_id:\n                if not can_edit:\n                    return json.dumps({\"error\": f\"You can only delete the TODO subtask plans, e.g., task_id>'{now_dealing_task.get_subtask_id(to_str=True)}', you are deleting {subtask.get_subtask_id(to_str=True)}. Nothing happended\"}), PlanOperationStatusCode.MODIFY_FORMER_PLAN\n                \n                \n                if subtask.data.status != TaskStatusCode.TODO :\n                    return json.dumps({\"error\": f\"You can only delete the TODO subtask plans, e.g., task_id>'{now_dealing_task.get_subtask_id(to_str=True)}', you are deleting {subtask.get_subtask_id(to_str=True)}. Nothing happended\"}), PlanOperationStatusCode.MODIFY_FORMER_PLAN\n                \n                # try to delete the subtask\n                subtask.father.children.remove(subtask)\n                subtask.father = None\n                \n                return json.dumps({\"success\": f\"Subtask '{target_subtask_id}' has been deleted\",}), PlanOperationStatusCode.MODIFY_SUCCESS\n            if subtask.get_subtask_id(to_str=True) == now_dealing_task.get_subtask_id(to_str=True):\n                \n                can_edit = True\n\n        return json.dumps({\"error\": f\"target_subtask_id '{target_subtask_id}' not found, should in {all_subtask_ids}. Nothing happended\",}), PlanOperationStatusCode.TARGET_SUBTASK_NOT_FOUND\n\n\n    def deal_subtask_modify(self, function_input: dict, now_dealing_task: Plan) -> (str, PlanOperationStatusCode):\n        \"\"\"Deals with subtask modification.\n\n        This method handles subtask modification.\n\n        Args:\n            function_input (dict): The function input.\n            now_dealing_task (Plan): The task that is currently being dealt with.\n\n        Returns:\n            str: The function output.\n            PlanOperationStatusCode: The status code.\n        \"\"\"\n        print(json.dumps(function_input,indent=2,ensure_ascii=False))\n\n        inorder_subtask_stack = Plan.get_inorder_travel(self.plan)\n        target_subtask_id = function_input[\"target_subtask_id\"].strip()\n\n        all_subtask_ids = [cont.get_subtask_id(to_str=True) for cont in inorder_subtask_stack]\n\n        can_edit = False\n        for k, subtask in enumerate(inorder_subtask_stack):\n            if subtask.get_subtask_id(to_str=True) == target_subtask_id:\n                if not can_edit:\n                    return json.dumps({\"error\": f\"You can only modify the TODO subtask plans, e.g., task_id>'{now_dealing_task.get_subtask_id(to_str=True)}', you are modifying {subtask.get_subtask_id(to_str=True)}. Nothing happended\"}), PlanOperationStatusCode.MODIFY_FORMER_PLAN\n                \n                assert subtask.data.status == TaskStatusCode.TODO\n                subtask.data.load_from_json(function_input[\"new_data\"])\n\n                return json.dumps({\"success\": f\"Subtask '{target_subtask_id}' has been modified\",}), PlanOperationStatusCode.MODIFY_SUCCESS\n            if subtask.get_subtask_id(to_str=True) == now_dealing_task.get_subtask_id(to_str=True):\n                \n                can_edit = True\n\n        return json.dumps({\"error\": f\"target_subtask_id '{target_subtask_id}' not found, should in {all_subtask_ids}. Nothing happended\",}), PlanOperationStatusCode.TARGET_SUBTASK_NOT_FOUND\n\n    def deal_subtask_add(self, function_input: dict, now_dealing_task: Plan) -> (str, PlanOperationStatusCode):\n        \"\"\"Deals with subtask addition.\n\n        This method handles subtask addition.\n\n        Args:\n            function_input (dict): The function input.\n            now_dealing_task (Plan): The task that is currently being dealt with.\n\n        Returns:\n            str: The function output.\n            PlanOperationStatusCode: The status code.\n        \"\"\"\n        print(json.dumps(function_input,indent=2,ensure_ascii=False))\n\n        inorder_subtask_stack:list[Plan] = Plan.get_inorder_travel(self.plan)\n        former_subtask_id = function_input[\"target_subtask_id\"].strip()\n\n        all_subtask_ids = [cont.get_subtask_id(to_str=True) for cont in inorder_subtask_stack]\n\n        # check whether the former_subtask_id is valid\n\n        former_subtask = None\n        for subtask in inorder_subtask_stack:\n            if subtask.get_subtask_id(to_str=True) == former_subtask_id:\n                former_subtask = subtask\n                break\n        if former_subtask is None:\n            return json.dumps({\"error\": f\"former_subtask_id '{former_subtask_id}' not found, should in {all_subtask_ids}. Nothing happended\",}), PlanOperationStatusCode.TARGET_SUBTASK_NOT_FOUND\n        \n        former_subtask_id_list = former_subtask.get_subtask_id_list()\n        now_dealing_task_id_list = now_dealing_task.get_subtask_id_list()\n        \n        if former_subtask.get_depth() <= 1:\n            return json.dumps({\"error\": f\"You are not allowed to add a subtask at root level. Nothing happended\",}), PlanOperationStatusCode.TARGET_SUBTASK_NOT_FOUND\n        \n        if len(former_subtask.father.children) + len(function_input[\"subtasks\"]) > self.config.max_plan_tree_width: # fixs bugs here: the length calculation is incorrect\n            return json.dumps({\"error\": f\"The plan tree has a max width of {self.config.max_plan_tree_width}. '{former_subtask.data.name}' already has a width of {len(former_subtask.children)}. Nothing happended\"}), PlanOperationStatusCode.OTHER_ERROR\n            \n        for i in range(min(len(former_subtask_id_list), len(now_dealing_task_id_list))):\n            if former_subtask_id_list[i]<now_dealing_task_id_list[i]:\n                return json.dumps({\"error\": f\"You can only add the subtask plans after than now_dealing task, e.g. 'former_subtask_id >= {now_dealing_task.get_subtask_id(to_str=True)}'. Nothing happended\",}), PlanOperationStatusCode.MODIFY_FORMER_PLAN\n        # pass check\n        new_subplans = [plan_function_output_parser(new_subtask) for new_subtask in function_input[\"subtasks\"]]\n\n        subtask = former_subtask\n        if subtask.father is None:\n            return json.dumps({\"error\":f\"Currently not support adding a subtask at root level!\"}), PlanOperationStatusCode.MODIFY_FORMER_PLAN\n        # assert subtask.father != None\n        index = subtask.father.children.index(subtask)\n\n        for new_subplan in new_subplans:\n            new_subplan.father = subtask.father\n        subtask.father.children[index+1:index+1] = new_subplans\n        \n        return json.dumps({\"success\": f\"A new subtask has been added after '{former_subtask_id}'\",}), PlanOperationStatusCode.MODIFY_SUCCESS",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__函数**：这个函数的作用是初始化一个PlanAgent对象。\n\n详细代码分析和描述：\n- 参数config是计划代理的配置。\n- 参数query是用于生成计划的基本查询。\n- 参数avaliable_tools_description_list是可用工具的描述列表。\n\n这个函数的主要功能是将传入的参数赋值给对象的属性。具体来说：\n- 将config赋值给self.config。\n- 将query赋值给self.query。\n- 将avaliable_tools_description_list赋值给self.avaliable_tools_description_list。\n\n接下来，函数创建了一个Plan对象，并将其赋值给self.plan属性。在创建Plan对象时，传入了一个TaskSaveItem对象作为参数。TaskSaveItem对象包含了一些任务的信息，包括任务的名称、目标、里程碑等。\n\n最后，函数创建了一个空的列表self.refine_chains，用于存储计划的细化链。\n\n**注意**：使用这段代码时需要注意以下几点：\n- 需要传入正确的参数，包括config、query和avaliable_tools_description_list。\n- 创建Plan对象时，可以根据需要设置TaskSaveItem对象的属性。",
            "code_start_line": 121,
            "code_end_line": 142,
            "parent": "PlanAgent",
            "have_return": false,
            "code_content": "    def __init__(self, config, query: BaseQuery, avaliable_tools_description_list: List[dict]):\n        \"\"\"Initializes a PlanAgent object.\n\n        Args:\n            config: The configuration for the plan agent.\n            query (BaseQuery): The base query for generating plans.\n            avaliable_tools_description_list (List[dict]): The list of available tool descriptions.\n        \"\"\"\n        self.config = config\n        self.query = query\n        self.avaliable_tools_description_list = avaliable_tools_description_list\n\n        self.plan = Plan(\n            data = TaskSaveItem(\n                name=f\"act as {query.role_name}\",\n                goal=query.task,\n                milestones=query.plan,\n                # tool_budget=100,\n            )\n        )\n\n        self.refine_chains: List[PlanRefineChain] = []\n",
            "name_column": 8
        },
        "register": {
            "type": "FunctionDef",
            "name": "register",
            "md_content": "**register函数**：该函数用于注册计划细化。\n\n该方法将函数名称、输入和输出以及新计划添加到细化链中。\n\n参数：\n- function_name (str)：细化函数的名称。\n- function_input (dict)：细化函数的输入。\n- function_output (str)：细化函数的输出。\n- new_plan (Plan)：细化后的新计划。\n\n该函数将函数名称、输入和输出添加到functions列表中，并将新计划添加到plans列表中。\n\nXAgentCoreComponents.global_recorder.regist_plan_modify函数用于注册计划修改，其中包括细化函数的名称、输入、输出以及细化后的计划。\n\n**注意**：使用该代码时需要注意以下几点：\n- 需要提供正确的函数名称、输入和输出。\n- 需要确保new_plan是Plan类型的对象。\n- 需要确保XAgentCoreComponents.global_recorder对象已正确初始化。",
            "code_start_line": 51,
            "code_end_line": 74,
            "parent": "PlanRefineChain",
            "have_return": false,
            "code_content": "    def register(self, function_name, function_input, function_output, new_plan: Plan):\n        \"\"\"Registers a plan refinement.\n\n        This method adds the function name, input, and output, as well as the new plan to the refine chain.\n\n        Args:\n            function_name (str): The name of the refine function.\n            function_input (dict): The input of the refine function.\n            function_output (str): The output of the refine function.\n            new_plan (Plan): The new plan after refinement.\n        \"\"\"\n        self.functions.append({\n            \"name\": function_name,\n            \"input\": function_input,\n            \"output\": function_output,\n        })\n        self.plans.append(deepcopy(new_plan))\n\n        XAgentCoreComponents.global_recorder.regist_plan_modify(\n            refine_function_name = function_name,\n            refine_function_input = function_input,\n            refine_function_output = function_output,\n            plan_after = new_plan.to_json(posterior=True),\n        )\n",
            "name_column": 8
        },
        "parse_to_message_list": {
            "type": "FunctionDef",
            "name": "parse_to_message_list",
            "md_content": "**parse_to_message_list函数**：该函数的功能是将细化链解析为消息列表。\n\n该方法生成一个消息列表，描述细化链中的每个细化步骤。\n\n参数：\n- flag_changed：表示计划是否发生了变化的标志。\n\n返回值：\n- List[Message]：消息列表。\n\n该函数首先断言self.plans的长度等于self.functions的长度加1。\n\n如果CONFIG.enable_summary为True，则将self.plans[0]转换为JSON格式的字符串，并通过summarize_plan函数生成初始消息init_message。否则，直接将self.plans[0]转换为JSON格式的字符串，并设置缩进和非ASCII字符。\n\n接下来，将init_message封装为Message对象，并添加到output_list中。\n\n然后，通过enumerate函数遍历self.functions和self.plans[1:]，分别获取每个函数和对应的输出计划。根据这些信息生成operation_message，描述用户在第k+1步所做的操作和操作结果，并将其添加到output_list中。\n\n如果self.plans的长度大于1，则根据flag_changed的值判断计划是否发生了变化。如果发生了变化，根据CONFIG.enable_summary的值生成新的消息new_message，并将其添加到output_list中。如果未发生变化，则添加一条消息指示计划未发生变化。\n\n最后，返回output_list作为函数的输出。\n\n**注意**：该函数依赖于其他函数summarize_plan和Message。\n\n**输出示例**：假设函数执行成功，output_list可能如下所示：\n```\n[\n    Message(\"user\", \"The initial plan and the execution status is:\\n'''\\n{init_message}\\n'''\\n\\n\"),\n    Message(\"user\", \"For the 1'th step, You made the following operation:\\nfunction_name: {function_name}\\n'''\\n{function_input}\\n'''\\nThen get the operation result:\\n{function_output}\\n\"),\n    Message(\"user\", \"The total plan changed to follows:\\n'''\\n{new_message}\\n'''\\n\\n\")\n]\n```",
            "code_start_line": 76,
            "code_end_line": 107,
            "parent": "PlanRefineChain",
            "have_return": true,
            "code_content": "    def parse_to_message_list(self, flag_changed) -> List[Message]:\n        \"\"\"Parses the refine chain to a list of messages.\n\n        This method generates a list of messages describing each refinement step in the refine chain.\n\n        Args:\n            flag_changed: A flag indicating whether the plan has changed.\n\n        Returns:\n            List[Message]: A list of messages.\n        \"\"\"\n        assert len(self.plans) == len(self.functions) + 1\n\n        if CONFIG.enable_summary:\n            init_message = summarize_plan(self.plans[0].to_json())\n        else:\n            init_message = json.dumps(self.plans[0].to_json(), indent=2, ensure_ascii=False)\n        init_message =  Message(\"user\", f\"\"\"The initial plan and the execution status is:\\n'''\\n{init_message}\\n'''\\n\\n\"\"\")\n        output_list = [init_message]\n        for k, (function, output_plan) in enumerate(zip(self.functions, self.plans[1:])):\n            operation_message = Message(\"user\", f\"\"\"For the {k+1}\\'th step, You made the following operation:\\nfunction_name: {function[\"name\"]}\\n'''\\n{json.dumps(function[\"input\"],indent=2,ensure_ascii=False)}\\n'''\\nThen get the operation result:\\n{function[\"output\"]}\\n\"\"\")\n            output_list.append(operation_message)\n        if len(self.plans) > 1:\n            if flag_changed:\n                if CONFIG.enable_summary:\n                    new_message = summarize_plan(self.plans[-1].to_json())\n                else:\n                    new_message = json.dumps(self.plans[-1].to_json(), indent=2, ensure_ascii=False)\n                output_list.append(Message(\"user\", f\"\"\"The total plan changed to follows:\\n'''\\n{new_message}\\n'''\\n\\n\"\"\"))\n            else:\n                output_list.append(Message(\"user\", f\"The total plan stay unchanged\"))\n        return output_list\n",
            "name_column": 8
        },
        "initial_plan_generation": {
            "type": "FunctionDef",
            "name": "initial_plan_generation",
            "md_content": "**initial_plan_generation函数**：该函数的功能是生成初始计划。\n\n该函数接受一个名为agent_dispatcher的参数，用于调度代理。\n\n函数内部首先打印一条日志，表示开始生成初始计划。\n\n然后，函数调用function_manager.get_function_schema('subtask_split_operation')函数获取名为'subtask_split_operation'的函数的参数。\n\n接下来，函数调用agent_dispatcher的dispatch方法，传入RequiredAbilities.plan_generation和目标任务的描述作为参数，生成一个代理对象agent。\n\n函数使用agent的parse方法，传入placeholders参数和arguments参数，解析生成新的消息new_message。\n\n函数将new_message中的subtasks解析为字典，并遍历其中的每个子任务。\n\n对于每个子任务，函数调用plan_function_output_parser方法解析子任务的输出，并使用Plan.make_relation方法将子任务与当前计划建立关联。\n\n**注意**：代码中的TODO注释表示该部分代码还不够健壮，因为dispatcher生成的提示可能不包含指定的占位符。\n\n该函数在以下文件中被调用：\n文件路径：XAgent/workflow/task_handler.py\n代码片段：\n```\nself.plan_agent.initial_plan_generation(\n    agent_dispatcher=self.agent_dispatcher)\n```\n该函数被调用时，传入了agent_dispatcher作为参数。\n\n函数调用完成后，会打印最新计划的JSON表示，并将计划的相关信息插入到interaction中。\n\n最后，函数调用plan_iterate_based_on_memory_system方法进行计划的迭代。\n\n在函数外部的outer_loop方法中，调用initial_plan_generation函数是解决查询的主要任务之一。\n\n该函数的作用是生成初始计划，通过调用plan generation agent来实现。函数内部通过调用agent_dispatcher的dispatch方法生成一个代理对象agent，并使用agent的parse方法解析生成新的消息new_message。最后，函数将子任务与当前计划建立关联。\n\n**注意**：在使用该函数时，需要注意代码中的TODO注释，以及agent生成的提示信息是否包含指定的占位符。",
            "code_start_line": 144,
            "code_end_line": 182,
            "parent": "PlanAgent",
            "have_return": false,
            "code_content": "    def initial_plan_generation(self, agent_dispatcher):\n        \"\"\"Generates the initial plan.\n\n        This method generates the initial plan by calling the plan generation agent.\n        \"\"\"\n        logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= GENERATE INITIAL_PLAN -=-=-=-=-=-=-=\",\n            Fore.GREEN,\n            \"\",\n        )\n\n        split_functions = deepcopy(function_manager.get_function_schema('subtask_split_operation'))\n\n        agent = agent_dispatcher.dispatch(\n            RequiredAbilities.plan_generation,\n            target_task=f\"Generate a plan to accomplish the task: {self.query.task}\",\n            # avaliable_tools_description_list=self.avaliable_tools_description_list\n        )\n\n        # TODO: not robust. dispatcher generated prompt may not contain these specified placeholders?\n        new_message , _ = agent.parse(\n            placeholders={\n                \"system\": {\n                    # \"avaliable_tool_descriptions\": json.dumps(self.avaliable_tools_description_list, indent=2, ensure_ascii=False),\n                    \"avaliable_tool_names\": str([cont[\"name\"] for cont in self.avaliable_tools_description_list]),\n                },\n                \"user\": {\n                    \"query\": self.plan.data.raw\n                }\n            },\n            arguments=deepcopy(function_manager.get_function_schema('simple_thought')['parameters']),\n            functions=[split_functions], \n        )\n        \n        subtasks = json5.loads(new_message[\"function_call\"][\"arguments\"])\n\n        for subtask_item in subtasks[\"subtasks\"]:\n            subplan = plan_function_output_parser(subtask_item)\n            Plan.make_relation(self.plan, subplan)\n",
            "name_column": 8
        },
        "plan_iterate_based_on_memory_system": {
            "type": "FunctionDef",
            "name": "plan_iterate_based_on_memory_system",
            "md_content": "**plan_iterate_based_on_memory_system函数**：该函数的功能是基于内存系统迭代地细化计划。\n\n该函数通过内存系统迭代地细化计划。\n\n代码分析和描述：\n- 首先，函数使用logger.typewriter_log方法打印一条带有蓝色前景色的日志信息。\n- 然后，函数打印一条\"Not Implemented, skip\"的信息，表示该函数还未实现。\n\n注意事项：\n- 该函数目前还未实现，会直接跳过执行。\n\n该函数在以下文件中被调用：\n文件路径：XAgent/workflow/task_handler.py\n代码片段：\n```\nself.plan_agent.plan_iterate_based_on_memory_system()\n```\n该函数在task_handler.py文件的outer_loop函数中被调用，用于迭代地细化计划。\n\n[代码片段结束]\n[XAgent/workflow/task_handler.py文件结束]",
            "code_start_line": 184,
            "code_end_line": 193,
            "parent": "PlanAgent",
            "have_return": false,
            "code_content": "    def plan_iterate_based_on_memory_system(self):\n        \"\"\"Iteratively refines the plan based on the memory system.\n\n        This method iteratively refines the plan based on the memory system.\n        \"\"\"\n        logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= ITERATIVELY REFINE PLAN BASED ON MEMORY SYSTEM -=-=-=-=-=-=-=\",\n            Fore.BLUE,\n        )\n        print(\"Not Implemented, skip\")\n",
            "name_column": 8
        },
        "latest_plan": {
            "type": "FunctionDef",
            "name": "latest_plan",
            "md_content": "**latest_plan函数**：此函数的功能是获取最新的计划。\n\n该函数返回最新的计划。\n\n该函数被以下文件调用：\n文件路径：XAgent/workflow/task_handler.py\n代码片段如下：\n    def outer_loop(self):\n        \"\"\"\n        执行外部循环中的主要任务序列。\n\n        Raises:\n            AssertionError: 如果在处理计划时遇到了意外的状态，则引发此异常。\n\n        Returns:\n            None\n        \"\"\"\n        self.logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= BEGIN QUERY SOVLING -=-=-=-=-=-=-=\",\n            Fore.YELLOW,\n            \"\",\n        )\n        self.query.log_self()\n\n        self.plan_agent.initial_plan_generation(\n            agent_dispatcher=self.agent_dispatcher)\n\n        print(summarize_plan(self.plan_agent.latest_plan.to_json()))\n\n        print_data = self.plan_agent.latest_plan.to_json()\n        self.interaction.insert_data(data={\n            \"task_id\": print_data.get(\"task_id\", \"\"),\n            \"name\": print_data.get(\"name\", \"\"),\n            \"goal\": print_data.get(\"goal\", \"\"),\n            \"handler\": print_data.get(\"handler\", \"\"),\n            \"tool_budget\": print_data.get(\"tool_budget\", \"\"),\n            \"subtasks\": [{**sub, \"inner\": []} for sub in print_data.get(\"subtask\", [])]\n        }, status=StatusEnum.START, current=print_data.get(\"task_id\", \"\"))\n\n        self.plan_agent.plan_iterate_based_on_memory_system()\n\n        def rewrite_input_func(old, new):\n            if new is None or not isinstance(new, dict):\n                return old, False\n            else:\n                goal = new.get(\"goal\", \"\")\n                if goal != \"\":\n                    old = goal\n                return old, True\n\n        self.now_dealing_task = self.plan_agent.latest_plan.children[0]\n        # workspace_hash_id = \"\"\n        while self.now_dealing_task:\n            task_id = self.now_dealing_task.get_subtask_id(to_str=True)\n            self.recorder.change_now_task(task_id)\n            if self.interaction.interrupt:\n                goal = self.now_dealing_task.data.goal\n                receive_data = self.interaction.receive(\n                    {\"args\": {\"goal\": goal}})\n                new_intput, flag = rewrite_input_func(\n                    self.now_dealing_task, receive_data)\n\n                if flag:\n                    self.logger.typewriter_log(\n                        \"-=-=-=-=-=-=-= USER INPUT -=-=-=-=-=-=-=\",\n                        Fore.GREEN,\n                        \"\",\n                    )\n                    self.logger.typewriter_log(\n                        \"goal: \",\n                        Fore.YELLOW,\n                        f\"{new_intput}\",\n                    )\n                    self.now_dealing_task.data.goal = new_intput\n                    self.logger.typewriter_log(\n                        \"-=-=-=-=-=-=-= USER INPUT -=-=-=-=-=-=-=\",\n                        Fore.GREEN,\n                        \"\",\n                    )\n\n            search_method = self.inner_loop(self.now_dealing_task)\n\n            self.now_dealing_task.process_node = search_method.get_finish_node()\n\n            self.posterior_process(self.now_dealing_task)\n\n            self.working_memory_agent.register_task(self.now_dealing_task)\n\n            self.xagent_core.print_task_save_items(self.now_dealing_task.data)\n\n            refinement_result = {\n                \"name\": self.now_dealing_task.data.name,\n                \"goal\": self.now_dealing_task.data.goal,\n                \"prior_plan_criticism\": self.now_dealing_task.data.prior_plan_criticism,\n                \"posterior_plan_reflection\": self.now_dealing_task.data.posterior_plan_reflection,\n                \"milestones\": self.now_dealing_task.data.milestones,\n                # \"expected_tools\": self.now_dealing_task.data.expected_tools,\n                \"tool_reflection\": self.now_dealing_task.data.tool_reflection,\n                \"action_list_summary\": self.now_dealing_task.data.action_list_summary,\n                \"task_id\": task_id,\n            }\n\n            self.interaction.insert_data(\n                data=refinement_result, status=StatusEnum.REFINEMENT, current=task_id)\n            if search_method.need_for_plan_refine:\n                self.plan_agent.plan_refine_mode(\n                    self.now_dealing_task, self.toolserver_interface, self.agent_dispatcher)\n            else:\n                self.logger.typewriter_log(\n                    \"subtask submitted as no need to refine the plan, continue\",\n                    Fore.BLUE,\n                )\n\n            self.now_dealing_task = Plan.pop_next_subtask(\n                self.now_dealing_task)\n\n            if self.now_dealing_task is None:\n                self.interaction.insert_data(\n                    data=[], status=StatusEnum.FINISHED, current=\"\")\n            else:\n                current_task_id = self.now_dealing_task.get_subtask_id(\n                    to_str=True)\n                remaining_subtask = Plan.get_remaining_subtask(\n                    self.now_dealing_task)\n                subtask_list = []\n                for todo_plan in remaining_subtask:\n                    raw_data = json.loads(todo_plan.data.raw)\n                    raw_data[\"task_id\"] = todo_plan.get_subtask_id(to_str=True)\n                    raw_data[\"inner\"] = []\n                    raw_data[\"node_id\"] = uuid.uuid4().hex\n                    subtask_list.append(raw_data)\n\n                self.interaction.insert_data(\n                    data=subtask_list, status=StatusEnum.SUBTASK, current=current_task_id)\n\n        self.logger.typewriter_log(\"ALL Tasks Done\", Fore.GREEN)\n        return\n\n[代码片段结束]\n[End of XAgent/workflow/task_handler.py]\n\n请注意：\n- 生成的内容中不应包含Markdown标题和分割线语法。\n- 主要使用中文编写。如果需要，可以在分析和描述中使用一些英文单词，以增强文档的可读性，因为您不需要将函数名或变量名翻译为目标语言。\n\n**latest_plan函数**：此函数的功能是获取最新的计划。\n\n该函数返回最新的计划。\n\n该函数被XAgent/workflow/task_handler.py文件中的outer_loop函数调用。outer_loop函数是执行外部循环中的主要任务序列的函数。在outer_loop函数中，首先进行了初始计划生成的操作，然后打印了最新计划的摘要信息，并将该计划的相关信息插入到交互系统中。接下来，根据内存系统的迭代计划进行迭代，然后进入一个循环，处理当前正在处理的任务。在处理任务的过程中，根据用户的输入进行相应的处理，然后执行内部循环任务，并进行后续处理。最后，根据需要进行计划的细化或提交子任务，直到所有任务完成。函数执行完毕后，打印所有任务完成的信息。\n\n**注意**：使用该函数时需要注意以下几点：\n- 该函数依赖于其他函数和类的支持，确保这些依赖项已正确导入。\n- 函数返回的最新计划可能是一个复杂的数据结构，需要根据具体情况进行处理。\n\n**输出示例**：假设最新计划为{\"task_id\": \"123\", \"name\": \"任务1\", \"goal\": \"完成某项任务\"}，则函数返回{\"task_id\": \"123\", \"name\": \"任务1\", \"goal\": \"完成某项任务\"}。",
            "code_start_line": 197,
            "code_end_line": 203,
            "parent": "PlanAgent",
            "have_return": true,
            "code_content": "    def latest_plan(self):\n        \"\"\"Gets the latest plan.\n\n        Returns:\n            The latest plan.\n        \"\"\"\n        return self.plan\n",
            "name_column": 8
        },
        "plan_refine_mode": {
            "type": "FunctionDef",
            "name": "plan_refine_mode",
            "md_content": "**plan_refine_mode函数**：该函数的功能是进入计划细化模式，并根据用户的建议对计划进行细化。\n\n该函数接受以下参数：\n- now_dealing_task (Plan): 当前正在处理的任务。\n\n函数内部逻辑如下：\n1. 将进入计划细化模式的提示信息打印到日志中。\n2. 将当前计划添加到计划细化链中。\n3. 初始化计划修改步数和最大步数。\n4. 根据任务调度器获取计划细化代理。\n5. 尝试从当前处理的任务中获取细化节点的信息。\n6. 获取工作空间文件的信息。\n7. 进入循环，直到达到最大步数或退出计划细化模式。\n8. 在每次循环中，获取当前子任务的ID，并设置标志位flag_changed为False。\n9. 将当前计划细化链解析为消息列表。\n10. 准备函数调用所需的参数。\n11. 调用代理的解析方法，获取新的消息和函数调用的输入。\n12. 根据函数调用的输入执行相应的操作，并获取输出结果和状态码。\n13. 根据输出结果判断是否发生了修改，并将修改信息注册到计划细化链中。\n14. 根据状态码判断操作的结果，并打印相应的日志。\n15. 如果状态码为PLAN_REFINE_EXIT或MODIFY_SUCCESS，则退出计划细化模式。\n16. 增加计划修改步数。\n17. 返回函数的执行结果。\n\n**注意**：在使用该函数时需要注意以下几点：\n- 函数的参数now_dealing_task必须是Plan类型的对象。\n- 函数的执行过程中会根据用户的建议对计划进行细化，需要确保用户的建议是合理有效的。\n\n**输出示例**：模拟函数返回值的可能外观。\n```python\n{\n    \"content\": \"exit PLAN_REFINE_MODE successfully\"\n}\n```",
            "code_start_line": 205,
            "code_end_line": 316,
            "parent": "PlanAgent",
            "have_return": true,
            "code_content": "    def plan_refine_mode(self, now_dealing_task: Plan, toolserver_interface, agent_dispatcher):\n        \"\"\"Enters the plan refine mode.\n\n        This method enters the plan refine mode and performs plan refinements based on user suggestions.\n\n        Args:\n            now_dealing_task (Plan): The task that is currently being dealt with.\n        \"\"\"\n        logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= ITERATIVELY REFINE PLAN BASED ON TASK AGENT SUGGESTIONS -=-=-=-=-=-=-=\",\n            Fore.BLUE,\n        )\n\n        self.refine_chains.append(PlanRefineChain(self.plan)) \n\n        modify_steps = 0\n        max_step = self.config.max_plan_refine_chain_length\n\n        agent = agent_dispatcher.dispatch(\n            RequiredAbilities.plan_refinement, \n            target_task=\"Refine the given plan.\", \n            # avaliable_tools_description_list=self.avaliable_tools_description_list\n        )\n        try:\n            refine_node_message = now_dealing_task.process_node.data[\"command\"][\"properties\"][\"args\"]\n            refine_node_message = refine_node_message[\"suggestions_for_latter_subtasks_plan\"][\"reason\"]\n        except:\n            refine_node_message = \"\"\n        workspace_files = str(toolserver_interface.execute_command_client(\"FileSystemEnv_print_filesys_struture\", {\"return_root\":True}))\n        workspace_files,length = clip_text(workspace_files,1000,clip_end=True)\n                \n        while modify_steps < max_step:\n\n            logger.typewriter_log(\n                f\"-=-=-=-=-=-=-= Continually refining planning (still in the loop)-=-=-=-=-=-=-=\",\n                Fore.GREEN,\n            )\n\n            subtask_id = now_dealing_task.get_subtask_id(to_str=True)\n            flag_changed = False\n            \n            additional_message_list = self.refine_chains[-1].parse_to_message_list(flag_changed)\n\n            functions=[deepcopy(function_manager.get_function_schema('subtask_operations'))]\n            \n            new_message , _ = agent.parse(\n                placeholders={\n                    \"system\": {\n                        # \"avaliable_tool_descriptions\": json.dumps(self.avaliable_tools_description_list, indent=2, ensure_ascii=False),\n                        \"avaliable_tool_names\": str([cont[\"name\"] for cont in self.avaliable_tools_description_list]),\n                        \"max_plan_tree_width\": self.config.max_plan_tree_width,\n                        \"max_plan_tree_depth\": self.config.max_plan_tree_depth,\n                    },\n                    \"user\": {\n                        \"subtask_id\": subtask_id,\n                        \"max_step\": max_step,\n                        \"modify_steps\": modify_steps,\n                        \"max_plan_tree_depth\": self.config.max_plan_tree_depth,\n                        \"workspace_files\": workspace_files,\n                        \"refine_node_message\":refine_node_message,\n                    }\n                }, \n                arguments=deepcopy(function_manager.get_function_schema('simple_thought')['parameters']),\n                functions=functions, \n                additional_messages=additional_message_list,\n                additional_insert_index=-1,\n            )\n            function_name = new_message[\"function_call\"][\"name\"]\n            function_input = json5.loads(new_message[\"function_call\"][\"arguments\"])\n\n            if function_input['operation'] == 'split':\n                # modify function_input here\n                function_output, output_status_code = self.deal_subtask_split(function_input, now_dealing_task)\n            elif function_input['operation'] == 'add':\n                function_output, output_status_code = self.deal_subtask_add(function_input, now_dealing_task)\n            elif function_input['operation'] == 'delete':\n                function_output, output_status_code = self.deal_subtask_delete(function_input, now_dealing_task)\n            elif function_input['operation'] == 'exit':\n                output_status_code = PlanOperationStatusCode.PLAN_REFINE_EXIT\n                function_output = json.dumps({\n                    \"content\": \"exit PLAN_REFINE_MODE successfully\",\n                })\n            else:\n                logger.typewriter_log(\"Error: \", Fore.RED, f\"Operation {function_input['operation']} not found. Nothing happens\")\n                output_status_code = PlanOperationStatusCode.PLAN_OPERATION_NOT_FOUND\n                function_output = json.dumps({\n                    \"error\": f\"Operation {function_input['operation']} not found. Nothing happens\"\n                })\n            \n            if \"error\" not in function_output:\n                flag_changed = True\n\n            self.refine_chains[-1].register(function_name=function_name,\n                                            function_input=function_input,\n                                            function_output=function_output,\n                                            new_plan=self.plan)\n\n            if output_status_code == PlanOperationStatusCode.MODIFY_SUCCESS:\n                color = Fore.GREEN\n            elif output_status_code == PlanOperationStatusCode.PLAN_REFINE_EXIT:\n                color = Fore.YELLOW\n            else:\n                color = Fore.RED\n            logger.typewriter_log(\"SYSTEM: \", Fore.YELLOW, function_output)\n            logger.typewriter_log(\n                \"PLAN MODIFY STATUS CODE: \", Fore.YELLOW, f\"{color}{output_status_code.name}{Style.RESET_ALL}\"\n            )\n\n            if output_status_code == PlanOperationStatusCode.PLAN_REFINE_EXIT or output_status_code == PlanOperationStatusCode.MODIFY_SUCCESS:\n                return\n\n            modify_steps += 1\n",
            "name_column": 8
        },
        "deal_subtask_split": {
            "type": "FunctionDef",
            "name": "deal_subtask_split",
            "md_content": "**deal_subtask_split函数**: 这个函数的功能是处理子任务的拆分。\n\n这个函数用于处理子任务的拆分。\n\n参数:\n- function_input (dict): 函数的输入参数。\n- now_dealing_task (Plan): 当前正在处理的任务。\n\n返回值:\n- str: 函数的输出结果。\n- PlanOperationStatusCode: 状态码。\n\n这个函数首先打印出function_input的内容，然后获取当前任务的子任务栈inorder_subtask_stack，并从function_input中获取目标子任务的ID。接下来，遍历子任务栈，判断是否可以编辑当前子任务以及是否找到了目标子任务。如果可以编辑当前子任务并且找到了目标子任务，则进行拆分操作。拆分操作包括创建新的子任务并建立与原子任务的关系。最后，将目标子任务的状态设置为SPLIT，并返回拆分成功的消息。\n\n如果没有找到目标子任务，则返回目标子任务未找到的错误消息。\n\n**注意**: 使用这段代码时需要注意以下几点:\n- function_input参数需要包含target_subtask_id和subtasks字段。\n- target_subtask_id字段表示目标子任务的ID。\n- subtasks字段是一个列表，包含了要拆分出的新子任务的信息。\n\n**输出示例**:\n```\n{\n    \"success\": \"子任务 'target_subtask_id' 已经被拆分\"\n}\n```",
            "code_start_line": 318,
            "code_end_line": 359,
            "parent": "PlanAgent",
            "have_return": true,
            "code_content": "    def deal_subtask_split(self, function_input: dict, now_dealing_task: Plan) -> (str, PlanOperationStatusCode):\n        \"\"\"Deals with subtask splitting.\n\n        This method handles subtask splitting.\n\n        Args:\n            function_input (dict): The function input.\n            now_dealing_task (Plan): The task that is currently being dealt with.\n\n        Returns:\n            str: The function output.\n            PlanOperationStatusCode: The status code.\n        \"\"\"\n        print(json.dumps(function_input,indent=2,ensure_ascii=False))\n\n        inorder_subtask_stack = Plan.get_inorder_travel(self.plan)\n        target_subtask_id = function_input[\"target_subtask_id\"].strip()\n        all_subtask_ids = [cont.get_subtask_id(to_str=True) for cont in inorder_subtask_stack]\n\n        can_edit = False\n        for k, subtask in enumerate(inorder_subtask_stack):\n            if subtask.get_subtask_id(to_str=True) == now_dealing_task.get_subtask_id(to_str=True):\n                \n                can_edit = True\n\n            if subtask.get_subtask_id(to_str=True) == target_subtask_id:\n                if not can_edit:\n                    return json.dumps({\"error\": f\"You can only split the TODO subtask plans together with the now_dealing_subtask, e.g. '>= {now_dealing_task.get_subtask_id(to_str=True)}'. Nothing happended\",}), PlanOperationStatusCode.MODIFY_FORMER_PLAN\n                \n                # if not subtask.data.status == TaskStatusCode.FAIL:\n                #     return json.dumps({\"error\": f\"You can only split the FAIL subtask plans together. This is a '{subtask.data.status.name}' Task. Nothing happended\"}), PlanOperationStatusCode.OTHER_ERROR\n\n                if subtask.get_depth() >= self.config.max_plan_tree_depth:\n                    return json.dumps({\"error\": f\"The plan tree has a max depth of {self.config.max_plan_tree_depth}. '{subtask.data.name}' already has a depth of {subtask.get_depth()}. Nothing happended\"}), PlanOperationStatusCode.OTHER_ERROR\n\n                for new_subtask in function_input[\"subtasks\"]:\n                    new_subplan = plan_function_output_parser(new_subtask)\n                    Plan.make_relation(subtask,new_subplan)\n                subtask.data.status = TaskStatusCode.SPLIT\n                return json.dumps({\"success\": f\"Subtask '{target_subtask_id}' has been split\",}), PlanOperationStatusCode.MODIFY_SUCCESS\n\n        return json.dumps({\"error\": f\"target_subtask_id '{target_subtask_id}' not found. Nothing happended\",}), PlanOperationStatusCode.TARGET_SUBTASK_NOT_FOUND\n",
            "name_column": 8
        },
        "deal_subtask_delete": {
            "type": "FunctionDef",
            "name": "deal_subtask_delete",
            "md_content": "**deal_subtask_delete函数**：这个函数的功能是处理子任务的删除。\n\n该方法用于处理子任务的删除。\n\n参数：\n- function_input（dict）：函数输入。\n- now_dealing_task（Plan）：当前正在处理的任务。\n\n返回值：\n- str：函数输出。\n- PlanOperationStatusCode：状态码。\n\n代码分析和描述：\n该函数首先打印出function_input的内容，然后获取目标子任务的ID，并将所有子任务的ID存储在all_subtask_ids列表中。\n\n接下来，函数会遍历inorder_subtask_stack列表，找到与目标子任务ID相匹配的子任务。如果找到了目标子任务，函数会进行以下操作：\n- 检查是否可以编辑该子任务，如果不可以编辑，则返回错误信息。\n- 检查子任务的状态是否为\"TODO\"，如果不是，则返回错误信息。\n- 尝试删除该子任务，并返回删除成功的信息。\n\n如果遍历完整个inorder_subtask_stack列表后仍未找到目标子任务，则返回目标子任务未找到的错误信息。\n\n注意：使用该代码时需要注意以下几点：\n- function_input参数需要包含\"target_subtask_id\"字段，表示要删除的子任务ID。\n- 函数的返回值是一个包含函数输出和状态码的元组。\n\n输出示例：\n```\n{\n  \"success\": \"Subtask 'target_subtask_id' has been deleted\"\n}\n```",
            "code_start_line": 362,
            "code_end_line": 401,
            "parent": "PlanAgent",
            "have_return": true,
            "code_content": "    def deal_subtask_delete(self, function_input: dict, now_dealing_task: Plan) -> (str, PlanOperationStatusCode):\n        \"\"\"Deals with subtask deletion.\n\n        This method handles subtask deletion.\n\n        Args:\n            function_input (dict): The function input.\n            now_dealing_task (Plan): The task that is currently being dealt with.\n\n        Returns:\n            str: The function output.\n            PlanOperationStatusCode: The status code.\n        \"\"\"\n        print(json.dumps(function_input,indent=2,ensure_ascii=False))\n\n        inorder_subtask_stack:list[Plan] = Plan.get_inorder_travel(self.plan)\n        target_subtask_id = function_input[\"target_subtask_id\"].strip()\n\n        all_subtask_ids = [cont.get_subtask_id(to_str=True) for cont in inorder_subtask_stack]\n\n        can_edit = False\n        for k, subtask in enumerate(inorder_subtask_stack):\n            if subtask.get_subtask_id(to_str=True) == target_subtask_id:\n                if not can_edit:\n                    return json.dumps({\"error\": f\"You can only delete the TODO subtask plans, e.g., task_id>'{now_dealing_task.get_subtask_id(to_str=True)}', you are deleting {subtask.get_subtask_id(to_str=True)}. Nothing happended\"}), PlanOperationStatusCode.MODIFY_FORMER_PLAN\n                \n                \n                if subtask.data.status != TaskStatusCode.TODO :\n                    return json.dumps({\"error\": f\"You can only delete the TODO subtask plans, e.g., task_id>'{now_dealing_task.get_subtask_id(to_str=True)}', you are deleting {subtask.get_subtask_id(to_str=True)}. Nothing happended\"}), PlanOperationStatusCode.MODIFY_FORMER_PLAN\n                \n                # try to delete the subtask\n                subtask.father.children.remove(subtask)\n                subtask.father = None\n                \n                return json.dumps({\"success\": f\"Subtask '{target_subtask_id}' has been deleted\",}), PlanOperationStatusCode.MODIFY_SUCCESS\n            if subtask.get_subtask_id(to_str=True) == now_dealing_task.get_subtask_id(to_str=True):\n                \n                can_edit = True\n\n        return json.dumps({\"error\": f\"target_subtask_id '{target_subtask_id}' not found, should in {all_subtask_ids}. Nothing happended\",}), PlanOperationStatusCode.TARGET_SUBTASK_NOT_FOUND\n",
            "name_column": 8
        },
        "deal_subtask_modify": {
            "type": "FunctionDef",
            "name": "deal_subtask_modify",
            "md_content": "**deal_subtask_modify函数**：该函数的功能是处理子任务的修改。\n\n该方法用于处理子任务的修改。\n\n参数：\n- function_input (dict)：函数输入。\n- now_dealing_task (Plan)：当前正在处理的任务。\n\n返回值：\n- str：函数输出。\n- PlanOperationStatusCode：状态码。\n\n代码分析和描述：\n该函数用于处理子任务的修改。首先，将函数输入以json格式打印出来。然后，获取按照顺序遍历的子任务栈。接下来，获取目标子任务的ID，并将所有子任务的ID存储在一个列表中。\n\n然后，设置一个变量can_edit为False。遍历子任务栈，如果当前子任务的ID与目标子任务的ID相同，则进行以下操作：\n- 如果can_edit为False，则返回错误信息，说明只能修改TODO状态的子任务计划，例如任务ID为'now_dealing_task.get_subtask_id(to_str=True)'，而你正在修改的是'subtask.get_subtask_id(to_str=True)'。返回的状态码为MODIFY_FORMER_PLAN。\n- 否则，断言当前子任务的状态为TODO，并将其数据从函数输入中加载。\n\n最后，返回修改成功的信息和状态码MODIFY_SUCCESS。\n\n如果当前子任务的ID与当前正在处理的任务的ID相同，则将can_edit设置为True。\n\n如果遍历完整个子任务栈后，仍未找到目标子任务的ID，则返回错误信息，说明目标子任务的ID' target_subtask_id '未找到，应该在' all_subtask_ids '中。返回的状态码为TARGET_SUBTASK_NOT_FOUND。\n\n注意：关于代码使用的注意事项\n- 函数的输入参数function_input应为一个字典类型。\n- 函数的返回值为一个字符串和一个状态码。\n\n输出示例：\n```\n{\n  \"success\": \"Subtask 'target_subtask_id' has been modified\"\n}\n```",
            "code_start_line": 404,
            "code_end_line": 438,
            "parent": "PlanAgent",
            "have_return": true,
            "code_content": "    def deal_subtask_modify(self, function_input: dict, now_dealing_task: Plan) -> (str, PlanOperationStatusCode):\n        \"\"\"Deals with subtask modification.\n\n        This method handles subtask modification.\n\n        Args:\n            function_input (dict): The function input.\n            now_dealing_task (Plan): The task that is currently being dealt with.\n\n        Returns:\n            str: The function output.\n            PlanOperationStatusCode: The status code.\n        \"\"\"\n        print(json.dumps(function_input,indent=2,ensure_ascii=False))\n\n        inorder_subtask_stack = Plan.get_inorder_travel(self.plan)\n        target_subtask_id = function_input[\"target_subtask_id\"].strip()\n\n        all_subtask_ids = [cont.get_subtask_id(to_str=True) for cont in inorder_subtask_stack]\n\n        can_edit = False\n        for k, subtask in enumerate(inorder_subtask_stack):\n            if subtask.get_subtask_id(to_str=True) == target_subtask_id:\n                if not can_edit:\n                    return json.dumps({\"error\": f\"You can only modify the TODO subtask plans, e.g., task_id>'{now_dealing_task.get_subtask_id(to_str=True)}', you are modifying {subtask.get_subtask_id(to_str=True)}. Nothing happended\"}), PlanOperationStatusCode.MODIFY_FORMER_PLAN\n                \n                assert subtask.data.status == TaskStatusCode.TODO\n                subtask.data.load_from_json(function_input[\"new_data\"])\n\n                return json.dumps({\"success\": f\"Subtask '{target_subtask_id}' has been modified\",}), PlanOperationStatusCode.MODIFY_SUCCESS\n            if subtask.get_subtask_id(to_str=True) == now_dealing_task.get_subtask_id(to_str=True):\n                \n                can_edit = True\n\n        return json.dumps({\"error\": f\"target_subtask_id '{target_subtask_id}' not found, should in {all_subtask_ids}. Nothing happended\",}), PlanOperationStatusCode.TARGET_SUBTASK_NOT_FOUND\n",
            "name_column": 8
        },
        "deal_subtask_add": {
            "type": "FunctionDef",
            "name": "deal_subtask_add",
            "md_content": "**deal_subtask_add函数**：此函数的功能是处理子任务的添加。\n\n该方法用于处理子任务的添加。\n\n参数：\n- function_input（dict）：函数输入。\n- now_dealing_task（Plan）：当前正在处理的任务。\n\n返回值：\n- str：函数输出。\n- PlanOperationStatusCode：状态码。\n\n代码分析和描述：\n- 首先，该函数打印出function_input的内容。\n- 然后，获取当前任务的中序子任务栈。\n- 获取目标子任务的ID，并将其去除首尾的空格。\n- 获取所有子任务的ID列表。\n- 检查former_subtask_id是否有效。遍历子任务栈，如果找到与former_subtask_id相等的子任务，则将其赋值给former_subtask。如果找不到，则返回错误信息和状态码TARGET_SUBTASK_NOT_FOUND。\n- 获取former_subtask和now_dealing_task的ID列表。\n- 检查former_subtask的深度是否小于等于1。如果是，则返回错误信息和状态码TARGET_SUBTASK_NOT_FOUND，表示不允许在根级别添加子任务。\n- 检查former_subtask的宽度是否超过了最大宽度。如果超过了最大宽度，则返回错误信息和状态码OTHER_ERROR。\n- 检查former_subtask_id_list和now_dealing_task_id_list的长度，并逐个比较对应位置的元素。如果former_subtask_id_list中的元素小于now_dealing_task_id_list中的元素，则返回错误信息和状态码MODIFY_FORMER_PLAN。\n- 如果通过了上述检查，将function_input中的subtasks转换为Plan对象的列表new_subplans。\n- 获取subtask的父节点，如果父节点为空，则返回错误信息和状态码MODIFY_FORMER_PLAN。\n- 获取subtask在父节点的children列表中的索引。\n- 将new_subplans插入到subtask的父节点的children列表中的index+1的位置。\n- 返回成功信息和状态码MODIFY_SUCCESS。\n\n注意：使用代码中的PlanOperationStatusCode枚举类表示状态码。\n\n输出示例：\n```\n{\n  \"success\": \"A new subtask has been added after 'former_subtask_id'\"\n}\n```",
            "code_start_line": 440,
            "code_end_line": 495,
            "parent": "PlanAgent",
            "have_return": true,
            "code_content": "    def deal_subtask_add(self, function_input: dict, now_dealing_task: Plan) -> (str, PlanOperationStatusCode):\n        \"\"\"Deals with subtask addition.\n\n        This method handles subtask addition.\n\n        Args:\n            function_input (dict): The function input.\n            now_dealing_task (Plan): The task that is currently being dealt with.\n\n        Returns:\n            str: The function output.\n            PlanOperationStatusCode: The status code.\n        \"\"\"\n        print(json.dumps(function_input,indent=2,ensure_ascii=False))\n\n        inorder_subtask_stack:list[Plan] = Plan.get_inorder_travel(self.plan)\n        former_subtask_id = function_input[\"target_subtask_id\"].strip()\n\n        all_subtask_ids = [cont.get_subtask_id(to_str=True) for cont in inorder_subtask_stack]\n\n        # check whether the former_subtask_id is valid\n\n        former_subtask = None\n        for subtask in inorder_subtask_stack:\n            if subtask.get_subtask_id(to_str=True) == former_subtask_id:\n                former_subtask = subtask\n                break\n        if former_subtask is None:\n            return json.dumps({\"error\": f\"former_subtask_id '{former_subtask_id}' not found, should in {all_subtask_ids}. Nothing happended\",}), PlanOperationStatusCode.TARGET_SUBTASK_NOT_FOUND\n        \n        former_subtask_id_list = former_subtask.get_subtask_id_list()\n        now_dealing_task_id_list = now_dealing_task.get_subtask_id_list()\n        \n        if former_subtask.get_depth() <= 1:\n            return json.dumps({\"error\": f\"You are not allowed to add a subtask at root level. Nothing happended\",}), PlanOperationStatusCode.TARGET_SUBTASK_NOT_FOUND\n        \n        if len(former_subtask.father.children) + len(function_input[\"subtasks\"]) > self.config.max_plan_tree_width: # fixs bugs here: the length calculation is incorrect\n            return json.dumps({\"error\": f\"The plan tree has a max width of {self.config.max_plan_tree_width}. '{former_subtask.data.name}' already has a width of {len(former_subtask.children)}. Nothing happended\"}), PlanOperationStatusCode.OTHER_ERROR\n            \n        for i in range(min(len(former_subtask_id_list), len(now_dealing_task_id_list))):\n            if former_subtask_id_list[i]<now_dealing_task_id_list[i]:\n                return json.dumps({\"error\": f\"You can only add the subtask plans after than now_dealing task, e.g. 'former_subtask_id >= {now_dealing_task.get_subtask_id(to_str=True)}'. Nothing happended\",}), PlanOperationStatusCode.MODIFY_FORMER_PLAN\n        # pass check\n        new_subplans = [plan_function_output_parser(new_subtask) for new_subtask in function_input[\"subtasks\"]]\n\n        subtask = former_subtask\n        if subtask.father is None:\n            return json.dumps({\"error\":f\"Currently not support adding a subtask at root level!\"}), PlanOperationStatusCode.MODIFY_FORMER_PLAN\n        # assert subtask.father != None\n        index = subtask.father.children.index(subtask)\n\n        for new_subplan in new_subplans:\n            new_subplan.father = subtask.father\n        subtask.father.children[index+1:index+1] = new_subplans\n        \n        return json.dumps({\"success\": f\"A new subtask has been added after '{former_subtask_id}'\",}), PlanOperationStatusCode.MODIFY_SUCCESS",
            "name_column": 8
        }
    },
    "XAgent/workflow/base_query.py": {
        "BaseQuery": {
            "type": "ClassDef",
            "name": "BaseQuery",
            "md_content": "**BaseQuery函数**: 这个类的功能是定义了一个查询对象的基类。任何其他在XAgent中使用的查询类都应该继承这个基类。\n\n这个类有以下属性：\n- role_name (str): 查询涉及的角色名称。\n- task (str): 正在查询的任务。\n- plan (list): 查询的计划详情列表。\n\n这个类有以下方法：\n- `__init__(self, role_name=\"\", task=\"\", plan=[])`: 构造函数，用于初始化BaseQuery对象的属性。\n- `log_self(self)`: 抽象方法，用于记录查询的详细信息。所有继承自BaseQuery的类都应该实现这个方法。\n- `to_json(self)`: 将BaseQuery对象序列化为JSON对象。\n- `from_json(cls, json_data)`: 从JSON对象构造一个新的BaseQuery对象。\n\n**注意**: \n- BaseQuery是一个抽象基类，不能直接实例化。\n- `log_self`方法是一个抽象方法，需要在子类中实现具体的逻辑。\n\n**输出示例**:\n```python\nquery = BaseQuery(role_name=\"user\", task=\"search\", plan=[\"step1\", \"step2\"])\nprint(query.to_json())\n# 输出: {'task': 'search', 'role_name': 'user', 'plan': ['step1', 'step2']}\n\njson_data = {'task': 'search', 'role_name': 'user', 'plan': ['step1', 'step2']}\nquery = BaseQuery.from_json(json_data)\nprint(query.role_name)\n# 输出: 'user'\n```",
            "code_start_line": 6,
            "code_end_line": 61,
            "parent": null,
            "have_return": true,
            "code_content": "class BaseQuery(metaclass = abc.ABCMeta):\n    \"\"\"\n    Base class for Query object. This class should be inherited by any other query class that will be used in the XAgent.\n\n    Attributes:\n        role_name (str): Name of the role involved in the query.\n        task (str): Task that is being queried.\n        plan (list): List of the plan details for the query.\n    \"\"\"\n\n    def __init__(self, role_name=\"\", task=\"\", plan=[]):\n        \"\"\"\n        Constructs all the necessary attributes for the BaseQuery object.\n\n        Args:\n            role_name (str, optional): Name of the role involved in the query.\n            task (str, optional): Task that is being queried.\n            plan (list, optional): List of the plan details for the query.\n        \"\"\"\n        self.role_name = role_name\n        self.task = task\n        self.plan = plan\n\n    @abc.abstractmethod\n    def log_self(self):\n        \"\"\"\n        Abstract method to log Query details. \n        This method should be implemented by all classes that inherit from BaseQuery.\n        \"\"\"\n        pass\n\n    def to_json(self):\n        \"\"\"\n        Serializes the BaseQuery object into a JSON object.\n\n        Returns:\n            dict: A dictionary version of the BaseQuery object.\n        \"\"\"\n        return {\n            \"task\": self.task,\n            \"role_name\": self.role_name,\n            \"plan\": self.plan,\n        }\n\n    @classmethod\n    def from_json(cls, json_data):\n        \"\"\"\n        Construct a new BaseQuery object from a JSON object.\n\n        Args:\n            json_data (dict): The JSON object that will be used to construct the BaseQuery.\n\n        Returns:\n            BaseQuery: A new BaseQuery object constructed from the values in `json_data`.\n        \"\"\"\n        return cls(**json_data)\n",
            "name_column": 6
        },
        "AutoGPTQuery": {
            "type": "ClassDef",
            "name": "AutoGPTQuery",
            "md_content": "**AutoGPTQuery函数**：这个类的功能是用于特定的GPT模型操作，它继承自BaseQuery类。\n\n构造函数`__init__(self, **args)`：通过继承BaseQuery类，构造AutoGPTQuery对象的所有必要属性。\n\n参数：\n- `**args`：可变长度的参数列表，是一个属性键值对的字典。\n\nlog_self函数：使用logger记录AutoGPTQuery的详细信息。\n\n该方法记录\"Role\"和\"Task\"，分别使用role_name和task作为参数。\n如果计划中有任何细节，它还会记录\"Plan\"以及计划中的每个细节。\n\n注意：使用代码中的logger记录AutoGPTQuery的详细信息。\n\n**注意**：关于代码使用的注意事项：\n- AutoGPTQuery是一个特定类型的查询，用于特定的GPT模型操作。\n- 构造函数`__init__`继承自BaseQuery类，用于构造AutoGPTQuery对象的属性。\n- log_self函数使用logger记录AutoGPTQuery的详细信息，包括\"Role\"、\"Task\"和计划中的细节。",
            "code_start_line": 64,
            "code_end_line": 91,
            "parent": null,
            "have_return": false,
            "code_content": "class AutoGPTQuery(BaseQuery):\n    \"\"\"\n    A specific type of query that inherits from the BaseQuery class.\n    Used for specific GPT model actions.\n    \"\"\"\n\n    def __init__(self,**args):\n        \"\"\"\n        Constructs all the necessary attributes for the AutoGPTQuery object by inheriting from BaseQuery class.\n\n        Args:\n            **args: Variable length argument list which is a dictionary of attribute key-value pairs.\n        \"\"\"\n        super().__init__(**args)\n\n    def log_self(self):\n        \"\"\"\n        Logs AutoGPTQuery details using logger.\n\n        This method logs \"Role\", \"Task\" with role_name and task respectively.\n        If there is any detail in the plan, it also logs \"Plan\" with each detail in the plan.\n        \"\"\"\n        logger.typewriter_log(\"Role\", Fore.YELLOW, self.role_name)\n        logger.typewriter_log(\"Task\", Fore.YELLOW, self.task)\n        if self.plan != []:\n            logger.typewriter_log(\"Plan\", Fore.YELLOW)\n            for k, plan in enumerate(self.plan):\n                logger.typewriter_log(f\"    {k+1}.{plan}\", Style.RESET_ALL)",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__函数**：这个函数的功能是通过从BaseQuery类继承来构建AutoGPTQuery对象的所有必要属性。\n\n这个函数接受一个可变长度的参数列表**args，它是一个包含属性键值对的字典。\n\n在函数内部，通过调用父类的__init__函数来初始化对象的属性。\n\n**注意**：使用这段代码时需要注意以下几点：\n- 这个函数是一个构造函数，用于初始化对象的属性。\n- 参数**args是一个字典，可以包含任意数量的属性键值对。\n- 调用父类的__init__函数来初始化对象的属性。",
            "code_start_line": 70,
            "code_end_line": 77,
            "parent": "AutoGPTQuery",
            "have_return": false,
            "code_content": "    def __init__(self,**args):\n        \"\"\"\n        Constructs all the necessary attributes for the AutoGPTQuery object by inheriting from BaseQuery class.\n\n        Args:\n            **args: Variable length argument list which is a dictionary of attribute key-value pairs.\n        \"\"\"\n        super().__init__(**args)\n",
            "name_column": 8
        },
        "log_self": {
            "type": "FunctionDef",
            "name": "log_self",
            "md_content": "**log_self函数**: 这个函数的功能是使用logger记录AutoGPTQuery的详细信息。\n\n这个函数会使用logger记录\"Role\"和\"Task\"，并分别使用role_name和task作为参数。如果计划中有任何细节，它还会记录\"Plan\"以及计划中的每个细节。\n\n这个函数被以下文件调用：\n文件路径：XAgent/workflow/base_query.py\n对应的代码如下：\n```python\nclass BaseQuery(metaclass = abc.ABCMeta):\n    \"\"\"\n    Base class for Query object. This class should be inherited by any other query class that will be used in the XAgent.\n\n    Attributes:\n        role_name (str): Name of the role involved in the query.\n        task (str): Task that is being queried.\n        plan (list): List of the plan details for the query.\n    \"\"\"\n\n    def __init__(self, role_name=\"\", task=\"\", plan=[]):\n        \"\"\"\n        Constructs all the necessary attributes for the BaseQuery object.\n\n        Args:\n            role_name (str, optional): Name of the role involved in the query.\n            task (str, optional): Task that is being queried.\n            plan (list, optional): List of the plan details for the query.\n        \"\"\"\n        self.role_name = role_name\n        self.task = task\n        self.plan = plan\n\n    @abc.abstractmethod\n    def log_self(self):\n        \"\"\"\n        Abstract method to log Query details. \n        This method should be implemented by all classes that inherit from BaseQuery.\n        \"\"\"\n        pass\n\n    def to_json(self):\n        \"\"\"\n        Serializes the BaseQuery object into a JSON object.\n\n        Returns:\n            dict: A dictionary version of the BaseQuery object.\n        \"\"\"\n        return {\n            \"task\": self.task,\n            \"role_name\": self.role_name,\n            \"plan\": self.plan,\n        }\n\n    @classmethod\n    def from_json(cls, json_data):\n        \"\"\"\n        Construct a new BaseQuery object from a JSON object.\n\n        Args:\n            json_data (dict): The JSON object that will be used to construct the BaseQuery.\n\n        Returns:\n            BaseQuery: A new BaseQuery object constructed from the values in `json_data`.\n        \"\"\"\n        return cls(**json_data)\n```\n[代码段结束]\n[结束于 XAgent/workflow/base_query.py]\n文件路径：XAgent/workflow/task_handler.py\n对应的代码如下：\n```python\n    def outer_loop(self):\n        \"\"\"\n        Executes the main sequence of tasks in the outer loop.\n\n        Raises:\n            AssertionError: Raised if a not expected status is encountered while handling the plan.\n\n        Returns:\n            None\n        \"\"\"\n        self.logger.typewriter_log(\n            f\"-=-=-=-=-=-=-= BEGIN QUERY SOVLING -=-=-=-=-=-=-=\",\n            Fore.YELLOW,\n            \"\",\n        )\n        self.query.log_self()\n\n        self.plan_agent.initial_plan_generation(\n            agent_dispatcher=self.agent_dispatcher)\n\n        print(summarize_plan(self.plan_agent.latest_plan.to_json()))\n\n        print_data = self.plan_agent.latest_plan.to_json()\n        self.interaction.insert_data(data={\n            \"task_id\": print_data.get(\"task_id\", \"\"),\n            \"name\": print_data.get(\"name\", \"\"),\n            \"goal\": print_data.get(\"goal\", \"\"),\n            \"handler\": print_data.get(\"handler\", \"\"),\n            \"tool_budget\": print_data.get(\"tool_budget\", \"\"),\n            \"subtasks\": [{**sub, \"inner\": []} for sub in print_data.get(\"subtask\", [])]\n        }, status=StatusEnum.START, current=print_data.get(\"task_id\", \"\"))\n\n        self.plan_agent.plan_iterate_based_on_memory_system()\n\n        def rewrite_input_func(old, new):\n            if new is None or not isinstance(new, dict):\n                return old, False\n            else:\n                goal = new.get(\"goal\", \"\")\n                if goal != \"\":\n                    old = goal\n                return old, True\n\n        self.now_dealing_task = self.plan_agent.latest_plan.children[0]\n        # workspace_hash_id = \"\"\n        while self.now_dealing_task:\n            task_id = self.now_dealing_task.get_subtask_id(to_str=True)\n            self.recorder.change_now_task(task_id)\n            if self.interaction.interrupt:\n                goal = self.now_dealing_task.data.goal\n                receive_data = self.interaction.receive(\n                    {\"args\": {\"goal\": goal}})\n                new_intput, flag = rewrite_input_func(\n                    self.now_dealing_task, receive_data)\n\n                if flag:\n                    self.logger.typewriter_log(\n                        \"-=-=-=-=-=-=-= USER INPUT -=-=-=-=-=-=-=\",\n                        Fore.GREEN,\n                        \"\",\n                    )\n                    self.logger",
            "code_start_line": 79,
            "code_end_line": 91,
            "parent": "AutoGPTQuery",
            "have_return": false,
            "code_content": "    def log_self(self):\n        \"\"\"\n        Logs AutoGPTQuery details using logger.\n\n        This method logs \"Role\", \"Task\" with role_name and task respectively.\n        If there is any detail in the plan, it also logs \"Plan\" with each detail in the plan.\n        \"\"\"\n        logger.typewriter_log(\"Role\", Fore.YELLOW, self.role_name)\n        logger.typewriter_log(\"Task\", Fore.YELLOW, self.task)\n        if self.plan != []:\n            logger.typewriter_log(\"Plan\", Fore.YELLOW)\n            for k, plan in enumerate(self.plan):\n                logger.typewriter_log(f\"    {k+1}.{plan}\", Style.RESET_ALL)",
            "name_column": 8
        },
        "to_json": {
            "type": "FunctionDef",
            "name": "to_json",
            "md_content": "**to_json函数**：该函数的功能是将BaseQuery对象序列化为JSON对象。\n\n该函数将BaseQuery对象的属性转化为一个字典对象，并返回该字典对象。\n\n**注意**：无\n\n**输出示例**：\n```\n{\n    \"task\": \"task_name\",\n    \"role_name\": \"role_name\",\n    \"plan\": \"plan_name\"\n}\n```\n\n该函数在项目中的调用情况如下：\n\n文件路径：XAgent/recorder.py\n\n代码片段：\n```python\ndef regist_query(self, query):\n    \"\"\"记录query的相关信息\n    \"\"\"\n    record = self.generate_record(\n        current=self.now_subtask_id,\n        node_id=0,\n        node_type=RecorderTypeEnum.QUERY,\n        data=query.to_json(),\n    )\n    with get_db() as db:\n        RunningRecordCRUD.insert_record(db=db, record=record)\n```\n\n该函数在regist_query函数中被调用，用于将query对象转化为JSON对象，并将其作为记录的一部分存储到数据库中。",
            "code_start_line": 37,
            "code_end_line": 48,
            "parent": "BaseQuery",
            "have_return": true,
            "code_content": "    def to_json(self):\n        \"\"\"\n        Serializes the BaseQuery object into a JSON object.\n\n        Returns:\n            dict: A dictionary version of the BaseQuery object.\n        \"\"\"\n        return {\n            \"task\": self.task,\n            \"role_name\": self.role_name,\n            \"plan\": self.plan,\n        }\n",
            "name_column": 8
        },
        "from_json": {
            "type": "FunctionDef",
            "name": "from_json",
            "md_content": "**from_json函数**：该函数的作用是根据JSON对象构建一个新的BaseQuery对象。\n\n该函数接受两个参数：\n- json_data（dict类型）：用于构建BaseQuery对象的JSON对象。\n\n该函数返回一个BaseQuery对象，该对象是根据`json_data`中的值构建而成的。\n\n该函数在以下文件中被调用：\n文件路径：XAgent/recorder.py\n对应代码如下：\n```python\ndef get_query(self):\n    \"\"\"从数据库中获取查询\"\"\"\n    with get_db() as db:\n        records = RunningRecordCRUD.get_record_by_type(\n            db=db,\n            record_id=self.record_id,\n            node_id=0,\n            node_type=RecorderTypeEnum.QUERY,\n        )\n\n    self.query = AutoGPTQuery.from_json(records[0].data)\n    return self.query\n```\n[代码片段结束]\n对应代码如下：\n```python\ndef load_from_db(self, record_id):\n    \"\"\"从本地文件夹加载record，用于后面的直接复现\n    \"\"\"\n\n    self.newly_start = False\n\n    with get_db() as db:\n        records = RunningRecordCRUD.get_record_by_type(\n            db=db,\n            record_id=record_id\n        )\n\n    for record in records:\n        if record.node_type == RecorderTypeEnum.QUERY:\n            self.query = AutoGPTQuery.from_json(record.data)\n        elif record.node_type == RecorderTypeEnum.CONFIG:\n            self.config = XAgentConfig()\n            self.config.merge_from_dict(record.data)\n        elif record.node_type == RecorderTypeEnum.LLM_INPUT_PAIR:\n            self.llm_server_cache.append(record.data)\n        elif record.node_type == RecorderTypeEnum.TOOL_SERVER_PAIR:\n            self.tool_server_cache.append(record.data)\n        elif record.node_type == RecorderTypeEnum.PLAN_REFINE:\n            self.plan_refine_cache.append(record.data)\n        elif record.node_type == RecorderTypeEnum.TOOL_CALL:\n            self.tool_call_cache.append(record.data)\n        else:\n            raise NotImplementedError\n```\n[代码片段结束]\n[文件结束]\n文件路径：XAgent/running_recorder.py\n对应代码如下：\n```python\ndef load_from_disk(self, record_dir):\n    \"\"\"\n    从磁盘中加载record。\n\n    参数：\n        - record_dir（str类型）：record的目录。\n\n    \"\"\"\n    logger.typewriter_log(\n        \"从磁盘中加载record，覆盖所有现有的配置信息\",\n        Fore.BLUE,\n        record_dir,\n    )\n    self.regist_father_info(record_dir)\n    self.newly_start = False\n\n    for dir_name in os.listdir(record_dir):\n        if dir_name == \"query.json\":\n            with open(os.path.join(record_dir, dir_name), \"r\",encoding=\"utf-8\") as reader:\n                self.query_json = json.load(reader)\n                self.query = AutoGPTQuery.from_json(self.query_json)\n        elif dir_name == \"config.yml\":\n            CONFIG.reload(os.path.join(record_dir, dir_name))\n        elif dir_name == \"LLM_inout_pair\":\n            inout_count = len(os.listdir(os.path.join(record_dir, dir_name)))\n            self.llm_server_cache = [None]*inout_count\n            for file_name in os.listdir(os.path.join(record_dir, dir_name)):\n                inout_id = int(file_name.split(\".\")[0])\n                with open(os.path.join(record_dir, dir_name, file_name), \"r\",encoding=\"utf-8\") as reader:\n                    llm_pair = json.load(reader)\n                    self.llm_server_cache[inout_id] = llm_pair\n            logger.typewriter_log(\n                f\"记录包含{inout_count}个LLM输入输出\",\n                Fore.BLUE,\n            )\n        elif dir_name == \"tool_server_pair\":\n            inout_count = len(os.listdir(os.path.join(record_dir, dir_name)))\n            self.tool_server_cache = [None]*inout_count\n            for file_name in os.listdir(os.path.join(record_dir, dir_name)):\n                inout_id = int(file_name.split(\".\")[0])\n                with open(os.path.join(record_dir, dir_name, file_name), \"r\",encoding=\"utf-8\") as reader:\n                    tool_pair = json.load(reader)\n                    self.tool_server_cache[inout_id] = tool_pair\n            logger.typewriter_log(\n                f\"记录包含{len(os.listdir(os.path.join(record_dir, dir_name)))}个工具调用\",\n                Fore.BLUE,\n            )\n        elif os.path.isdir(os.path.join(record_dir, dir_name)):\n            for file_name in os.listdir(os.path.join(record_dir, dir_name)):\n                if file_name.startswith(\"plan_refine\"):\n                    with open(os.path.join(record_dir, dir_name, file_name),encoding=\"utf-8\") as reader:\n                        plan_refine = json.load(reader)\n                        self.plan_refine_cache.append(plan_refine)\n                elif file_name.startswith(\"tool\"):\n                    with open(os.path.join(record_dir, dir_name, file_name),encoding=\"utf-8\") as reader:\n                        tool_call = json.load(reader)\n                        self.tool_call_cache.append(tool_call)\n                else:\n                    raise NotImplementedError\n```\n[代码片段结束]\n[文件结束]\n\n**注意**：使用该代码时需要注意以下几点：\n- `json_data`参数必须是一个字典类型的JSON对象。\n- `json_data`中的键必须与`BaseQuery`类的属性名相对应，否则会引发错误。\n\n**输出示例**：模拟代码返回值的可能外观。\n```python\n{\n    \"key1\": \"value1\",\n    \"key2\": \"value2\",\n    ...\n}\n```",
            "code_start_line": 51,
            "code_end_line": 61,
            "parent": "BaseQuery",
            "have_return": true,
            "code_content": "    def from_json(cls, json_data):\n        \"\"\"\n        Construct a new BaseQuery object from a JSON object.\n\n        Args:\n            json_data (dict): The JSON object that will be used to construct the BaseQuery.\n\n        Returns:\n            BaseQuery: A new BaseQuery object constructed from the values in `json_data`.\n        \"\"\"\n        return cls(**json_data)\n",
            "name_column": 8
        }
    },
    "XAgent/inner_loop_search_algorithms/ReACT.py": {
        "make_message": {
            "type": "FunctionDef",
            "name": "make_message",
            "md_content": "**make_message函数**：此函数用于为每个节点生成消息。\n\n该函数接受以下参数：\n- now_node：当前的ToolNode实例。\n- max_length：子任务链的最大长度。\n- config：配置设置。\n- now_dealing_task：当前处理的任务。\n\n该函数返回当前节点的消息序列。\n\n函数内部逻辑如下：\n1. 如果配置中启用了摘要功能（enable_summary为True），则使用summarize_plan函数对当前处理的任务进行摘要，将结果赋值给terminal_task_info变量。\n2. 否则，将当前处理的任务转换为JSON格式，并使用json.dumps函数将其格式化为字符串，设置缩进为2，确保不转义非ASCII字符，将结果赋值给terminal_task_info变量。\n3. 创建一个空的消息序列列表。\n4. 构建当前子任务的提示信息now_subtask_prompt，包含terminal_task_info的内容，并将其作为Message对象添加到消息序列中。\n5. 获取当前节点的process属性，赋值给action_process变量。\n6. 如果配置中启用了摘要功能（enable_summary为True），则使用summarize_action函数对action_process进行摘要，将结果赋值给action_process变量。\n7. 构建用户提示信息user_prompt，包含action_process的内容，并将其作为Message对象添加到消息序列中。\n8. 返回消息序列。\n\n**注意**：使用此函数时需要注意以下几点：\n- 需要传入正确的参数，包括now_node、max_length、config和now_dealing_task。\n- 如果配置中启用了摘要功能（enable_summary为True），则会对任务和动作进行摘要处理。\n- 函数返回的是一个消息序列，可以根据需要进行进一步处理或展示。\n\n**输出示例**：以下是函数返回值的示例：\n```\n[\n    Message(\"user\", \"Now you will perform the following subtask:\\n\"\"\"\\n{terminal_task_info}\\n\"\"\"\\n\"),\n    Message(\"user\", \"The following steps have been performed (you have already done the following and the current file contents are shown below):\\n\\n{action_process}\")\n]\n```",
            "code_start_line": 18,
            "code_end_line": 53,
            "parent": null,
            "have_return": true,
            "code_content": "def make_message(now_node: ToolNode, max_length, config, now_dealing_task):\n    \"\"\"\n    Function to generate messages for each node.\n\n    Args:\n        now_node: The current ToolNode instance.\n        task_handler: Handler of the tasks.\n        max_length: Maximum length of the subtask chain.\n        config: The configuration settings.\n\n    Returns:\n        The sequence of messages for the current node.\n\n    \"\"\"\n\n    if CONFIG.enable_summary:\n        terminal_task_info = summarize_plan(\n            now_dealing_task.to_json())\n    else:\n        terminal_task_info = json.dumps(\n            now_dealing_task.to_json(), indent=2, ensure_ascii=False)\n\n    message_sequence = []\n\n    now_subtask_prompt = f'''Now you will perform the following subtask:\\n\"\"\"\\n{terminal_task_info}\\n\"\"\"\\n'''\n    message_sequence.append(Message(\"user\", now_subtask_prompt))\n    action_process = now_node.process\n\n    if config.enable_summary:\n        action_process = summarize_action(\n            action_process, terminal_task_info)\n    user_prompt = f\"\"\"The following steps have been performed (you have already done the following and the current file contents are shown below):\\n\n    {action_process}\n    \"\"\"\n    message_sequence.append(Message(\"user\", user_prompt))\n    return message_sequence\n",
            "name_column": 4
        },
        "ReACTChainSearch": {
            "type": "ClassDef",
            "name": "ReACTChainSearch",
            "md_content": "**ReACTChainSearch函数**: 这个类的功能是执行ReACT链式搜索，它用于执行基于链式搜索的任务。\n\n该类继承自BaseSearchMethod类，用于实现ReACT链式搜索的功能。它通过维护一个任务树的列表来表示处理过的任务，并提供了一系列方法来操作任务树。\n\n**__init__函数**:\n- xagent_core_components: XAgentCoreComponents对象，用于初始化ReACTChainSearch对象。它维护一个任务树的列表来表示处理过的任务。\n\n**run函数**:\n- config: 搜索的配置信息。\n- agent: 负责链式搜索的基础代理。\n- arguments: 当前任务的参数。\n- functions: 可用的函数列表。\n- task_id: 当前任务的ID。\n- max_try: 最大尝试次数。\n- max_answer: 最大接收答案的数量。\n\n**get_finish_node函数**:\n- 返回任务树中的完成节点。\n\n**get_origin_data函数**:\n- data: 初始输入数据列表。\n- 返回初始输入数据的字典形式。\n\n**rewrite_input_func函数**:\n- old: 旧的输入项。\n- new: 替换旧输入项的新输入项。\n- 返回更新后的输入列表和重写状态。\n\n**generate_chain函数**:\n- config: 搜索的配置信息。\n- agent: 负责链式搜索的基础代理。\n- arguments: 当前任务的参数。\n- functions: 可用的函数列表。\n- task_id: 当前任务的ID。\n- now_dealing_task: 当前处理的任务。\n- plan_agent: 计划代理。\n- 运行链式搜索任务。\n\n**to_json函数**:\n- 将ReACTChainSearch对象转换为JSON格式。\n\n**is_include_pictures函数**:\n- 判断是否包含图片。\n\n**注意**: \n- ReACTChainSearch类用于执行基于链式搜索的任务。\n- 该类维护一个任务树的列表来表示处理过的任务。\n- run函数用于运行链式搜索任务。\n- get_finish_node函数用于获取任务树中的完成节点。\n- get_origin_data函数用于获取初始输入数据。\n- rewrite_input_func函数用于检查新输入是否有效，并更新旧输入。\n- generate_chain函数用于运行链式搜索任务。\n- to_json函数用于将对象转换为JSON格式。\n- is_include_pictures函数用于判断是否包含图片。\n\n**输出示例**:\n```python\nsearch_method = ReACTChainSearch(xagent_core_components=core_components)\nsearch_method.run(config, agent, arguments, functions, task_id, now_dealing_task, plan_agent)\nfinish_node = search_method.get_finish_node()\norigin_data = search_method.get_origin_data(data)\nupdated_input, rewrite_status = search_method.rewrite_input_func(old, new)\nsearch_method.generate_chain(config, agent, arguments, functions, task_id, now_dealing_task, plan_agent)\nsearch_method.to_json()\ninclude_pictures = search_method.is_include_pictures(using_tools)\n```",
            "code_start_line": 56,
            "code_end_line": 338,
            "parent": null,
            "have_return": true,
            "code_content": "class ReACTChainSearch(BaseSearchMethod):\n    \"\"\"\n    Class for ReACT chain search. It performs chain based searches for tasks.\n    \"\"\"\n\n    def __init__(self, xagent_core_components: XAgentCoreComponents):\n        \"\"\"\n        xagent_core_components: XAgentCoreComponents object, used to initialize ReACTChainSearch object\n        Initializes ReACTChainSearch object. It maintains a list of trees to represent \n        the processed tasks.\n        \"\"\"\n        super().__init__()\n\n        self.tree_list = []\n\n        self.finish_node = None\n\n        self.xagent_core_components = xagent_core_components\n\n    def run(self,\n            config,\n            agent: BaseAgent,\n            arguments,\n            functions,\n            task_id,\n            now_dealing_task,\n            plan_agent,\n            max_try=1,\n            max_answer=1):\n        \"\"\"\n        Runs the chain search task.\n\n        Args:\n            config: Configuration for the search.\n            agent: Base agent responsible for chain search.\n            arguments: Arguments for the current task to be handled.\n            functions: The available functions for use by agent.\n            task_id: ID of the current task.\n            max_try: Maximum number of attempts.\n            max_answer: Maximum number of answers to be received\n\n        Returns:\n            None\n        Raises:\n            None\n        \"\"\"\n\n        for _attempt_id in range(max_try):\n            self.generate_chain(config, agent, arguments,\n                                functions, task_id, now_dealing_task, plan_agent)\n\n        if self.status == SearchMethodStatusCode.HAVE_AT_LEAST_ONE_ANSWER:\n            self.status = SearchMethodStatusCode.SUCCESS\n        else:\n            self.status = SearchMethodStatusCode.FAIL\n\n    def get_finish_node(self):\n        \"\"\"\n        Function to retrieve the finished node in the task tree.\n\n        Returns:\n            The finished node.  \n        \"\"\"\n        return self.finish_node\n\n    def get_origin_data(self, data):\n        \"\"\"\n        Retrieves the initially entered data.\n\n        Args:\n            data: The initially entered data list.\n\n        Returns:\n            The initially entered data as a dictionary.:\n        \"\"\"\n        assistant_thoughts_reasoning = None\n        assistant_thoughts_plan = None\n        assistant_thoughts_speak = None\n        assistant_thoughts_criticism = None\n\n        assistant_thoughts = data.get(\"thoughts\", {})\n        assistant_thoughts = assistant_thoughts.get(\"properties\", {})\n        assistant_thoughts_text = assistant_thoughts.get(\"thought\")\n        if assistant_thoughts:\n            assistant_thoughts_reasoning = assistant_thoughts.get(\"reasoning\")\n            assistant_thoughts_plan = assistant_thoughts.get(\"plan\")\n            assistant_thoughts_criticism = assistant_thoughts.get(\"criticism\")\n\n        return {\"args\": {\n            \"thoughts\": assistant_thoughts_text,\n            \"reasoning\": assistant_thoughts_reasoning,\n            \"plan\": assistant_thoughts_plan,\n            \"criticism\": assistant_thoughts_criticism\n        }}\n\n    def rewrite_input_func(self, old, new):\n        \"\"\"\n        Checks whether the new inputs are valid and if so updates the old input\n        with the new one.\n\n        Args:\n            old: The old input entry.\n            new: The new input entry to replace the old one.\n\n        Returns:\n            The updated input list and the rewrite status.\n        \"\"\"\n        if not isinstance(new, dict):\n            pass\n        if new is None:\n            return old, False\n        else:\n            args = new.get(\"args\", {})\n            assistant_thoughts_reasoning = None\n            assistant_thoughts_plan = None\n            assistant_thoughts_speak = None\n            assistant_thoughts_criticism = None\n\n            assistant_thoughts = old.get(\"thoughts\", {})\n            assistant_thoughts = assistant_thoughts.get(\"properties\", {})\n            assistant_thoughts_text = assistant_thoughts.get(\"thought\")\n            if assistant_thoughts:\n                assistant_thoughts_reasoning = assistant_thoughts.get(\n                    \"reasoning\")\n                assistant_thoughts_plan = assistant_thoughts.get(\"plan\")\n                assistant_thoughts_criticism = assistant_thoughts.get(\n                    \"criticism\")\n\n                if \"thoughts\" in args.keys() and \"thought\" in assistant_thoughts.keys():\n                    old[\"thoughts\"][\"properties\"][\"thought\"] = args.get(\n                        \"thoughts\", assistant_thoughts_text)\n                if \"reasoning\" in args.keys() and \"reasoning\" in assistant_thoughts.keys():\n                    old[\"thoughts\"][\"properties\"][\"reasoning\"] = args.get(\n                        \"reasoning\", assistant_thoughts_reasoning)\n                if \"plan\" in args.keys() and \"plan\" in assistant_thoughts.keys():\n                    old[\"thoughts\"][\"properties\"][\"plan\"] = args.get(\n                        \"plan\", assistant_thoughts_plan)\n                if \"criticism\" in args.keys() and \"criticism\" in assistant_thoughts.keys():\n                    old[\"thoughts\"][\"properties\"][\"criticism\"] = args.get(\n                        \"criticism\", assistant_thoughts_criticism)\n\n            return old, True\n\n    def generate_chain(self, config, agent: BaseAgent, arguments, functions, task_id, now_dealing_task, plan_agent):\n        \"\"\"\n        Run the chain search task.\n\n        Args:\n            config: Configuration for the search.\n            agent: Base agent responsible for chain search.\n            arguments: Arguments for the current task to be handled.\n            functions: The available functions for use by agent.\n            task_id: ID of the current task.\n\n        Returns:\n            None.\n        Raises:\n            None.\n        \"\"\"\n\n        self.tree_list.append(TaskSearchTree())\n        now_attempt_tree = self.tree_list[-1]\n        now_node = now_attempt_tree.root\n\n        while now_node.get_depth() < config.max_subtask_chain_length:\n            self.xagent_core_components.logger.typewriter_log(\n                \"-=-=-=-=-=-=-= THOUGHTS, REASONING, PLAN AND CRITICISM WILL NOW BE VERIFIED BY AGENT -=-=-=-=-=-=-=\",\n                Fore.GREEN,\n                \"\",\n            )\n            if now_node.father != None:\n                if self.xagent_core_components.interaction.interrupt:\n                    can_modify = self.get_origin_data(now_node.data)\n                    receive_data = self.xagent_core_components.interaction.receive(\n                        can_modify)\n                    data, rewrite_flag = self.rewrite_input_func(\n                        now_node.data, receive_data)\n                    now_node.data = data\n                    if rewrite_flag:\n                        self.xagent_core_components.logger.typewriter_log(\n                            \"-=-=-=-=-=-=-= USER INPUT -=-=-=-=-=-=-=\",\n                            Fore.GREEN,\n                            \"\",\n                        )\n                        self.xagent_core_components.print_assistant_thoughts(now_node.data, False)\n                        self.xagent_core_components.logger.typewriter_log(\n                            \"-=-=-=-=-=-=-= USER INPUT -=-=-=-=-=-=-=\",\n                            Fore.GREEN,\n                            \"\",\n                        )\n\n            message_sequence = make_message(now_node=now_node,\n                                            max_length=config.max_subtask_chain_length,\n                                            config=config,\n                                            now_dealing_task=now_dealing_task)\n\n            function_call = None\n            if now_node.get_depth() == config.max_subtask_chain_length - 1:\n                function_call = {\"name\": \"subtask_submit\"}\n\n            file_archi, _, = self.xagent_core_components.toolserver_interface.execute_command_client(\n                \"FileSystemEnv_print_filesys_struture\", {\"return_root\": True})\n            file_archi, length = clip_text(file_archi, 1000, clip_end=True)\n\n            human_prompt = \"\"\n            if config.enable_ask_human_for_help:\n                human_prompt = \"- Use 'ask_human_for_help' when you need help, remember to be specific to your requirement to help user to understand your problem.\"\n            else:\n                human_prompt = \"- Human is not available for help. You are not allowed to ask human for help in any form or channel. Solve the problem by yourself. If information is not enough, try your best to use default value.\"\n\n            all_plan = plan_agent.latest_plan.to_json()\n            if config.enable_summary:\n                all_plan = summarize_plan(all_plan)\n            else:\n                all_plan = json.dumps(all_plan, indent=2, ensure_ascii=False)\n\n            new_message, tokens = agent.parse(\n                placeholders={\n                    \"system\": {\n                        \"all_plan\": all_plan\n                    },\n                    \"user\": {\n                        \"workspace_files\": file_archi,\n                        \"subtask_id\": now_dealing_task.get_subtask_id(to_str=True),\n                        \"max_length\": config.max_subtask_chain_length,\n                        \"step_num\": str(now_node.get_depth()+1),\n                        \"human_help_prompt\": human_prompt,\n                    }\n                },\n                arguments=arguments,\n                functions=functions,\n                function_call=function_call,\n                additional_messages=message_sequence,\n                additional_insert_index=-1\n            )\n\n            new_tree_node = agent.message_to_tool_node(new_message)\n\n            print_data = self.xagent_core_components.print_assistant_thoughts(\n                new_tree_node.data, False\n            )\n\n            tool_output, tool_output_status_code, need_for_plan_refine, using_tools = self.xagent_core_components.function_handler.handle_tool_call(\n                new_tree_node)\n            self.need_for_plan_refine = need_for_plan_refine\n            now_attempt_tree.make_father_relation(now_node, new_tree_node)\n            self.xagent_core_components.interaction.insert_data(\n                data={**print_data, \"using_tools\": using_tools}, status=\"inner\", current=task_id, is_include_pictures=self.is_include_pictures(using_tools))\n\n            now_node = new_tree_node\n\n            if tool_output_status_code == ToolCallStatusCode.SUBMIT_AS_SUCCESS:\n\n                self.status = SearchMethodStatusCode.HAVE_AT_LEAST_ONE_ANSWER\n                break\n            elif tool_output_status_code == ToolCallStatusCode.SUBMIT_AS_FAILED:\n                break\n\n        self.finish_node = now_node\n\n    def to_json(self):\n        \"\"\"\n        Placeholder function to convert ReACTChainSearch object to JSON.\n\n        Currently not implemented.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n\n    def is_include_pictures(self, using_tools):\n        \"\"\"判断是否包含png\n        \"\"\"\n        tool_name = using_tools.get(\"tool_name\", \"\") if isinstance(\n            using_tools, dict) else \"\"\n        tool_output = using_tools.get(\n            \"tool_output\", {}) if isinstance(using_tools, dict) else \"\"\n        if tool_name == \"PythonNotebook_execute_cell\":\n            for output in tool_output:\n                if isinstance(output, dict) and 'file_name' in output:\n                    return True\n        return False\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__函数**：该函数的功能是初始化ReACTChainSearch对象。它维护一个树的列表来表示已处理的任务。\n\n在这个函数中，我们首先调用父类的构造函数`super().__init__()`来初始化父类的属性。然后，我们定义了以下属性：\n\n- `tree_list`：表示已处理任务的树的列表。\n- `finish_node`：表示任务的结束节点。\n- `xagent_core_components`：一个XAgentCoreComponents对象，用于初始化ReACTChainSearch对象。\n\n在这个函数中，我们没有返回任何值。\n\n**注意**：在使用这段代码时需要注意以下几点：\n- 在使用该函数之前，需要先创建一个XAgentCoreComponents对象，并将其作为参数传入该函数。\n- 在初始化ReACTChainSearch对象后，可以通过访问`tree_list`属性来获取已处理任务的树的列表。\n- 可以通过访问`finish_node`属性来获取任务的结束节点。",
            "code_start_line": 61,
            "code_end_line": 73,
            "parent": "ReACTChainSearch",
            "have_return": false,
            "code_content": "    def __init__(self, xagent_core_components: XAgentCoreComponents):\n        \"\"\"\n        xagent_core_components: XAgentCoreComponents object, used to initialize ReACTChainSearch object\n        Initializes ReACTChainSearch object. It maintains a list of trees to represent \n        the processed tasks.\n        \"\"\"\n        super().__init__()\n\n        self.tree_list = []\n\n        self.finish_node = None\n\n        self.xagent_core_components = xagent_core_components\n",
            "name_column": 8
        },
        "run": {
            "type": "FunctionDef",
            "name": "run",
            "md_content": "**run函数**：此函数的功能是运行链式搜索任务。\n\n该函数接受以下参数：\n- config：搜索的配置信息。\n- agent：负责链式搜索的基础代理。\n- arguments：当前任务的参数。\n- functions：可供代理使用的可用函数。\n- task_id：当前任务的ID。\n- max_try：最大尝试次数，默认为1。\n- max_answer：最大接收答案的数量，默认为1。\n\n该函数通过循环尝试执行generate_chain函数，直到达到最大尝试次数为止。\n\n如果搜索的状态为HAVE_AT_LEAST_ONE_ANSWER，则将状态设置为SUCCESS，否则设置为FAIL。\n\n**注意**：在使用该函数时需要注意以下几点：\n- 需要提供正确的配置信息和代理对象。\n- 参数arguments需要符合函数'action_reasoning'的参数规范。\n- 函数functions需要包含代理所需的内置工具。\n- task_id需要提供正确的任务ID。\n- max_try和max_answer可以根据需要进行调整。",
            "code_start_line": 75,
            "code_end_line": 110,
            "parent": "ReACTChainSearch",
            "have_return": false,
            "code_content": "    def run(self,\n            config,\n            agent: BaseAgent,\n            arguments,\n            functions,\n            task_id,\n            now_dealing_task,\n            plan_agent,\n            max_try=1,\n            max_answer=1):\n        \"\"\"\n        Runs the chain search task.\n\n        Args:\n            config: Configuration for the search.\n            agent: Base agent responsible for chain search.\n            arguments: Arguments for the current task to be handled.\n            functions: The available functions for use by agent.\n            task_id: ID of the current task.\n            max_try: Maximum number of attempts.\n            max_answer: Maximum number of answers to be received\n\n        Returns:\n            None\n        Raises:\n            None\n        \"\"\"\n\n        for _attempt_id in range(max_try):\n            self.generate_chain(config, agent, arguments,\n                                functions, task_id, now_dealing_task, plan_agent)\n\n        if self.status == SearchMethodStatusCode.HAVE_AT_LEAST_ONE_ANSWER:\n            self.status = SearchMethodStatusCode.SUCCESS\n        else:\n            self.status = SearchMethodStatusCode.FAIL\n",
            "name_column": 8
        },
        "get_finish_node": {
            "type": "FunctionDef",
            "name": "get_finish_node",
            "md_content": "**get_finish_node函数**：该函数用于检索任务树中已完成的节点。\n\n该函数没有参数。\n\n返回值：\n- 已完成的节点。\n\n该函数用于获取任务树中已完成的节点。在任务处理过程中，当一个节点完成时，可以通过调用该函数获取已完成的节点。\n\n**注意**：无\n\n**输出示例**：假设已完成的节点为node1，则函数返回值为node1。",
            "code_start_line": 112,
            "code_end_line": 119,
            "parent": "ReACTChainSearch",
            "have_return": true,
            "code_content": "    def get_finish_node(self):\n        \"\"\"\n        Function to retrieve the finished node in the task tree.\n\n        Returns:\n            The finished node.  \n        \"\"\"\n        return self.finish_node\n",
            "name_column": 8
        },
        "get_origin_data": {
            "type": "FunctionDef",
            "name": "get_origin_data",
            "md_content": "**get_origin_data函数**：该函数的功能是检索最初输入的数据。\n\n该函数接受一个数据列表作为参数，并将最初输入的数据转换为字典形式返回。\n\n在函数内部，首先初始化了一些变量，如assistant_thoughts_reasoning、assistant_thoughts_plan、assistant_thoughts_speak和assistant_thoughts_criticism等。\n\n然后，通过获取输入数据中的\"thoughts\"字段，进一步获取\"reasoning\"、\"plan\"和\"criticism\"等属性的值。\n\n最后，将获取到的数据以字典形式返回。\n\n**注意**：该函数的参数data应为一个字典，其中包含了最初输入的数据。\n\n**输出示例**：返回一个包含最初输入数据的字典，格式如下：\n```\n{\n    \"args\": {\n        \"thoughts\": \"XXX\",\n        \"reasoning\": \"XXX\",\n        \"plan\": \"XXX\",\n        \"criticism\": \"XXX\"\n    }\n}\n```",
            "code_start_line": 121,
            "code_end_line": 149,
            "parent": "ReACTChainSearch",
            "have_return": true,
            "code_content": "    def get_origin_data(self, data):\n        \"\"\"\n        Retrieves the initially entered data.\n\n        Args:\n            data: The initially entered data list.\n\n        Returns:\n            The initially entered data as a dictionary.:\n        \"\"\"\n        assistant_thoughts_reasoning = None\n        assistant_thoughts_plan = None\n        assistant_thoughts_speak = None\n        assistant_thoughts_criticism = None\n\n        assistant_thoughts = data.get(\"thoughts\", {})\n        assistant_thoughts = assistant_thoughts.get(\"properties\", {})\n        assistant_thoughts_text = assistant_thoughts.get(\"thought\")\n        if assistant_thoughts:\n            assistant_thoughts_reasoning = assistant_thoughts.get(\"reasoning\")\n            assistant_thoughts_plan = assistant_thoughts.get(\"plan\")\n            assistant_thoughts_criticism = assistant_thoughts.get(\"criticism\")\n\n        return {\"args\": {\n            \"thoughts\": assistant_thoughts_text,\n            \"reasoning\": assistant_thoughts_reasoning,\n            \"plan\": assistant_thoughts_plan,\n            \"criticism\": assistant_thoughts_criticism\n        }}\n",
            "name_column": 8
        },
        "rewrite_input_func": {
            "type": "FunctionDef",
            "name": "rewrite_input_func",
            "md_content": "**rewrite_input_func函数**：该函数的功能是检查新输入是否有效，如果有效则用新输入更新旧输入。\n\n该函数接受两个参数：\n- old：旧的输入条目。\n- new：要替换旧输入的新输入条目。\n\n该函数的返回值为更新后的输入列表和重写状态。\n\n函数内部逻辑如下：\n1. 首先判断新输入是否为字典类型，如果不是则不进行任何操作。\n2. 如果新输入为None，则返回旧输入和False。\n3. 否则，从新输入中获取args字段的值，并初始化assistant_thoughts_reasoning、assistant_thoughts_plan、assistant_thoughts_speak和assistant_thoughts_criticism变量。\n4. 从旧输入中获取thoughts字段的值，并将其赋值给assistant_thoughts变量。\n5. 从assistant_thoughts中获取properties字段的值，并将其赋值给assistant_thoughts_text变量。\n6. 如果assistant_thoughts不为空，则从args中检查是否存在\"thoughts\"和\"thought\"字段，并将其值更新到旧输入中的thoughts字段中。\n7. 同样地，如果args中存在\"reasoning\"和\"reasoning\"字段，则将其值更新到旧输入中的thoughts字段中。\n8. 如果args中存在\"plan\"和\"plan\"字段，则将其值更新到旧输入中的thoughts字段中。\n9. 如果args中存在\"criticism\"和\"criticism\"字段，则将其值更新到旧输入中的thoughts字段中。\n10. 返回更新后的旧输入和True。\n\n**注意**：关于代码使用的注意事项\n**输出示例**：模拟代码返回值的可能外观。\n\n请注意：\n- 生成的文档内容中不要包含Markdown的标题和分隔符语法。\n- 主要使用中文进行描述，如果需要，可以在分析和描述中使用一些英文单词，以提高文档的可读性，因为不需要将函数名或变量名翻译成目标语言。",
            "code_start_line": 151,
            "code_end_line": 197,
            "parent": "ReACTChainSearch",
            "have_return": true,
            "code_content": "    def rewrite_input_func(self, old, new):\n        \"\"\"\n        Checks whether the new inputs are valid and if so updates the old input\n        with the new one.\n\n        Args:\n            old: The old input entry.\n            new: The new input entry to replace the old one.\n\n        Returns:\n            The updated input list and the rewrite status.\n        \"\"\"\n        if not isinstance(new, dict):\n            pass\n        if new is None:\n            return old, False\n        else:\n            args = new.get(\"args\", {})\n            assistant_thoughts_reasoning = None\n            assistant_thoughts_plan = None\n            assistant_thoughts_speak = None\n            assistant_thoughts_criticism = None\n\n            assistant_thoughts = old.get(\"thoughts\", {})\n            assistant_thoughts = assistant_thoughts.get(\"properties\", {})\n            assistant_thoughts_text = assistant_thoughts.get(\"thought\")\n            if assistant_thoughts:\n                assistant_thoughts_reasoning = assistant_thoughts.get(\n                    \"reasoning\")\n                assistant_thoughts_plan = assistant_thoughts.get(\"plan\")\n                assistant_thoughts_criticism = assistant_thoughts.get(\n                    \"criticism\")\n\n                if \"thoughts\" in args.keys() and \"thought\" in assistant_thoughts.keys():\n                    old[\"thoughts\"][\"properties\"][\"thought\"] = args.get(\n                        \"thoughts\", assistant_thoughts_text)\n                if \"reasoning\" in args.keys() and \"reasoning\" in assistant_thoughts.keys():\n                    old[\"thoughts\"][\"properties\"][\"reasoning\"] = args.get(\n                        \"reasoning\", assistant_thoughts_reasoning)\n                if \"plan\" in args.keys() and \"plan\" in assistant_thoughts.keys():\n                    old[\"thoughts\"][\"properties\"][\"plan\"] = args.get(\n                        \"plan\", assistant_thoughts_plan)\n                if \"criticism\" in args.keys() and \"criticism\" in assistant_thoughts.keys():\n                    old[\"thoughts\"][\"properties\"][\"criticism\"] = args.get(\n                        \"criticism\", assistant_thoughts_criticism)\n\n            return old, True\n",
            "name_column": 8
        },
        "generate_chain": {
            "type": "FunctionDef",
            "name": "generate_chain",
            "md_content": "**generate_chain函数**：此函数的功能是运行链式搜索任务。\n\n该函数接受以下参数：\n- config：搜索的配置信息。\n- agent：负责链式搜索的基础代理。\n- arguments：当前任务的参数。\n- functions：可供代理使用的可用函数。\n- task_id：当前任务的ID。\n\n该函数没有返回值。\n\n该函数的作用是运行链式搜索任务。它通过循环迭代来生成任务搜索树，并根据配置的最大子任务链长度来限制搜索的深度。在每次迭代中，函数会调用代理的parse方法，将当前节点的数据转换为消息，并将消息传递给工具节点进行处理。函数还会处理工具节点的输出，并根据输出的状态码来判断是否需要进行计划的优化。最后，函数会更新搜索树的节点，并根据工具节点的输出状态码来判断搜索任务是否完成。\n\n**注意**：在每次迭代中，函数会根据配置的enable_ask_human_for_help参数来判断是否允许用户向人类寻求帮助。如果允许，函数会在消息中添加相应的提示信息。另外，函数还会根据配置的enable_summary参数来决定是否对计划进行摘要。\n\n**输出示例**：无返回值。",
            "code_start_line": 199,
            "code_end_line": 314,
            "parent": "ReACTChainSearch",
            "have_return": true,
            "code_content": "    def generate_chain(self, config, agent: BaseAgent, arguments, functions, task_id, now_dealing_task, plan_agent):\n        \"\"\"\n        Run the chain search task.\n\n        Args:\n            config: Configuration for the search.\n            agent: Base agent responsible for chain search.\n            arguments: Arguments for the current task to be handled.\n            functions: The available functions for use by agent.\n            task_id: ID of the current task.\n\n        Returns:\n            None.\n        Raises:\n            None.\n        \"\"\"\n\n        self.tree_list.append(TaskSearchTree())\n        now_attempt_tree = self.tree_list[-1]\n        now_node = now_attempt_tree.root\n\n        while now_node.get_depth() < config.max_subtask_chain_length:\n            self.xagent_core_components.logger.typewriter_log(\n                \"-=-=-=-=-=-=-= THOUGHTS, REASONING, PLAN AND CRITICISM WILL NOW BE VERIFIED BY AGENT -=-=-=-=-=-=-=\",\n                Fore.GREEN,\n                \"\",\n            )\n            if now_node.father != None:\n                if self.xagent_core_components.interaction.interrupt:\n                    can_modify = self.get_origin_data(now_node.data)\n                    receive_data = self.xagent_core_components.interaction.receive(\n                        can_modify)\n                    data, rewrite_flag = self.rewrite_input_func(\n                        now_node.data, receive_data)\n                    now_node.data = data\n                    if rewrite_flag:\n                        self.xagent_core_components.logger.typewriter_log(\n                            \"-=-=-=-=-=-=-= USER INPUT -=-=-=-=-=-=-=\",\n                            Fore.GREEN,\n                            \"\",\n                        )\n                        self.xagent_core_components.print_assistant_thoughts(now_node.data, False)\n                        self.xagent_core_components.logger.typewriter_log(\n                            \"-=-=-=-=-=-=-= USER INPUT -=-=-=-=-=-=-=\",\n                            Fore.GREEN,\n                            \"\",\n                        )\n\n            message_sequence = make_message(now_node=now_node,\n                                            max_length=config.max_subtask_chain_length,\n                                            config=config,\n                                            now_dealing_task=now_dealing_task)\n\n            function_call = None\n            if now_node.get_depth() == config.max_subtask_chain_length - 1:\n                function_call = {\"name\": \"subtask_submit\"}\n\n            file_archi, _, = self.xagent_core_components.toolserver_interface.execute_command_client(\n                \"FileSystemEnv_print_filesys_struture\", {\"return_root\": True})\n            file_archi, length = clip_text(file_archi, 1000, clip_end=True)\n\n            human_prompt = \"\"\n            if config.enable_ask_human_for_help:\n                human_prompt = \"- Use 'ask_human_for_help' when you need help, remember to be specific to your requirement to help user to understand your problem.\"\n            else:\n                human_prompt = \"- Human is not available for help. You are not allowed to ask human for help in any form or channel. Solve the problem by yourself. If information is not enough, try your best to use default value.\"\n\n            all_plan = plan_agent.latest_plan.to_json()\n            if config.enable_summary:\n                all_plan = summarize_plan(all_plan)\n            else:\n                all_plan = json.dumps(all_plan, indent=2, ensure_ascii=False)\n\n            new_message, tokens = agent.parse(\n                placeholders={\n                    \"system\": {\n                        \"all_plan\": all_plan\n                    },\n                    \"user\": {\n                        \"workspace_files\": file_archi,\n                        \"subtask_id\": now_dealing_task.get_subtask_id(to_str=True),\n                        \"max_length\": config.max_subtask_chain_length,\n                        \"step_num\": str(now_node.get_depth()+1),\n                        \"human_help_prompt\": human_prompt,\n                    }\n                },\n                arguments=arguments,\n                functions=functions,\n                function_call=function_call,\n                additional_messages=message_sequence,\n                additional_insert_index=-1\n            )\n\n            new_tree_node = agent.message_to_tool_node(new_message)\n\n            print_data = self.xagent_core_components.print_assistant_thoughts(\n                new_tree_node.data, False\n            )\n\n            tool_output, tool_output_status_code, need_for_plan_refine, using_tools = self.xagent_core_components.function_handler.handle_tool_call(\n                new_tree_node)\n            self.need_for_plan_refine = need_for_plan_refine\n            now_attempt_tree.make_father_relation(now_node, new_tree_node)\n            self.xagent_core_components.interaction.insert_data(\n                data={**print_data, \"using_tools\": using_tools}, status=\"inner\", current=task_id, is_include_pictures=self.is_include_pictures(using_tools))\n\n            now_node = new_tree_node\n\n            if tool_output_status_code == ToolCallStatusCode.SUBMIT_AS_SUCCESS:\n\n                self.status = SearchMethodStatusCode.HAVE_AT_LEAST_ONE_ANSWER\n                break\n            elif tool_output_status_code == ToolCallStatusCode.SUBMIT_AS_FAILED:\n                break\n\n        self.finish_node = now_node\n",
            "name_column": 8
        },
        "to_json": {
            "type": "FunctionDef",
            "name": "to_json",
            "md_content": "**to_json函数**: 这个函数的功能是将ReACTChainSearch对象转换为JSON。\n\n这个函数是一个占位函数，目前没有实现具体的功能。它的返回值是None。\n\n**注意**: 目前这个函数没有实现具体的功能，所以在使用时需要注意。",
            "code_start_line": 316,
            "code_end_line": 325,
            "parent": "ReACTChainSearch",
            "have_return": false,
            "code_content": "    def to_json(self):\n        \"\"\"\n        Placeholder function to convert ReACTChainSearch object to JSON.\n\n        Currently not implemented.\n\n        Returns:\n            None\n        \"\"\"\n        pass\n",
            "name_column": 8
        },
        "is_include_pictures": {
            "type": "FunctionDef",
            "name": "is_include_pictures",
            "md_content": "**is_include_pictures函数**：该函数的功能是判断给定的工具列表中是否包含png文件。\n\n该函数接受一个参数using_tools，该参数是一个字典，包含了使用的工具的相关信息。函数首先从using_tools中获取工具的名称tool_name和工具的输出tool_output。如果using_tools不是字典类型，则将tool_name和tool_output设置为空字符串和空字典。\n\n接下来，函数判断tool_name是否为\"PythonNotebook_execute_cell\"。如果是，则遍历tool_output列表，对于每个输出output，判断其是否为字典类型且是否包含'file_name'键。如果是，则说明输出中包含了png文件，函数返回True。\n\n如果tool_name不是\"PythonNotebook_execute_cell\"，或者tool_output中没有包含png文件的输出，则函数返回False。\n\n**注意**：使用该函数时需要传入一个包含工具信息的字典using_tools。函数会判断工具列表中是否包含png文件，并返回相应的结果。\n\n**输出示例**：假设using_tools为{\"tool_name\": \"PythonNotebook_execute_cell\", \"tool_output\": [{\"file_name\": \"image1.png\"}, {\"file_name\": \"image2.jpg\"}]}，则函数返回True。",
            "code_start_line": 327,
            "code_end_line": 338,
            "parent": "ReACTChainSearch",
            "have_return": true,
            "code_content": "    def is_include_pictures(self, using_tools):\n        \"\"\"判断是否包含png\n        \"\"\"\n        tool_name = using_tools.get(\"tool_name\", \"\") if isinstance(\n            using_tools, dict) else \"\"\n        tool_output = using_tools.get(\n            \"tool_output\", {}) if isinstance(using_tools, dict) else \"\"\n        if tool_name == \"PythonNotebook_execute_cell\":\n            for output in tool_output:\n                if isinstance(output, dict) and 'file_name' in output:\n                    return True\n        return False\n",
            "name_column": 8
        }
    },
    "XAgent/inner_loop_search_algorithms/__init__.py": {},
    "XAgent/inner_loop_search_algorithms/base_search.py": {
        "BaseSearchMethod": {
            "type": "ClassDef",
            "name": "BaseSearchMethod",
            "md_content": "**BaseSearchMethod函数**：这个类的功能是定义了所有搜索方法共有的元素和操作。\n\n该类有以下属性：\n- status (SearchMethodStatusCode): 搜索方法的状态，可以是'DOING'、'SUCCESS'或'FAILED'。\n- need_for_plan_refine (bool): 一个标志，指示是否需要对计划进行细化。初始值为False。\n\n该类有以下方法：\n- \\_\\_init\\_\\_(): 初始化搜索方法实例并记录其创建。\n- run(): 运行搜索方法的占位函数，所有搜索方法的子类都应该实现这个方法。\n- to_json(): 创建搜索方法的json表示的占位函数，所有搜索方法的子类都应该实现这个方法。\n- get_finish_node(): 获取搜索方法运行的最终节点的占位函数，所有搜索方法的子类都应该实现这个方法。\n- status(): 获取搜索方法的当前状态。\n\n**注意**：该类是一个基类，不能直接实例化，只能通过继承它的子类来使用。\n\n**输出示例**：\n```\n构造一个搜索方法: BaseSearchMethod\n```",
            "code_start_line": 6,
            "code_end_line": 48,
            "parent": null,
            "have_return": true,
            "code_content": "class BaseSearchMethod:\n    \"\"\"The base class for all search methods. It defines the common elements and actions that all search \n    methods have.\n    \n    Attributes:\n        status (SearchMethodStatusCode): The status of the search method. It can be 'DOING', 'SUCCESS' or 'FAILED'.\n        need_for_plan_refine (bool): A flag that indicates if the plan needs to be refined. It starts as False.\n    \"\"\"\n    def __init__(self):\n        \"\"\"Initializes the search method instance and logs its creation.\"\"\"\n        logger.typewriter_log(\n            f\"Constructing a searching method:\",\n            Fore.YELLOW,\n            self.__class__.__name__,\n        )\n        self.status: SearchMethodStatusCode = SearchMethodStatusCode.DOING\n        self.need_for_plan_refine: bool = False\n\n    def run(self):\n        \"\"\"A Placeholder function for running the search method. \n           This should be implemented by all search method subclasses.\n        \"\"\"\n        pass\n\n    def to_json(self):\n        \"\"\"A Placeholder function for creating a json representation of the search method. \n           This should be implemented by all search method subclasses.\n        \"\"\"\n        pass\n    \n    def get_finish_node(self):\n        \"\"\"A Placeholder function for getting the final node of the search method run.\n           This should be implemented by all search method subclasses.\n        \"\"\"\n        pass\n\n    def status(self):\n        \"\"\"Gets the current status of the search method.\n\n        Returns:\n            SearchMethodStatusCode: The current status of the search method.\n        \"\"\"\n        return self.status\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__函数**：这个函数的作用是初始化搜索方法实例并记录其创建。\n\n在这个函数中，首先使用logger.typewriter_log()函数记录了搜索方法的创建过程。该函数接受三个参数，分别是字符串\"Constructing a searching method:\"、Fore.YELLOW（一个用于设置文本颜色的变量）和self.__class__.__name__（表示当前类的名称）。这样可以在日志中打印出类的名称，以便后续的调试和追踪。\n\n接下来，函数设置了两个实例变量。第一个是self.status，它的类型是SearchMethodStatusCode，表示搜索方法的状态码。这个状态码用于表示搜索方法的当前状态，可能的取值有DOING、DONE等。第二个实例变量是self.need_for_plan_refine，它的类型是bool，表示是否需要进行计划细化。这个变量用于控制是否需要对计划进行进一步的优化和改进。\n\n**注意**：在使用这个函数时，需要注意以下几点：\n- 确保在调用该函数之前已经正确设置了logger和SearchMethodStatusCode。\n- 在使用self.status和self.need_for_plan_refine时，需要根据具体的业务逻辑进行判断和处理。",
            "code_start_line": 14,
            "code_end_line": 22,
            "parent": "BaseSearchMethod",
            "have_return": false,
            "code_content": "    def __init__(self):\n        \"\"\"Initializes the search method instance and logs its creation.\"\"\"\n        logger.typewriter_log(\n            f\"Constructing a searching method:\",\n            Fore.YELLOW,\n            self.__class__.__name__,\n        )\n        self.status: SearchMethodStatusCode = SearchMethodStatusCode.DOING\n        self.need_for_plan_refine: bool = False\n",
            "name_column": 8
        },
        "run": {
            "type": "FunctionDef",
            "name": "run",
            "md_content": "**run函数**：该函数是一个占位函数，用于运行搜索方法。所有搜索方法的子类都应该实现这个函数。\n\n该函数没有具体的代码实现，只是一个占位符。在具体的搜索方法子类中，需要根据具体的搜索算法来实现该函数。\n\n**注意**：使用该代码时需要注意以下几点：\n- 该函数是一个占位函数，需要在具体的搜索方法子类中进行实现。\n- 实现该函数时，需要根据具体的搜索算法来编写代码逻辑。",
            "code_start_line": 24,
            "code_end_line": 28,
            "parent": "BaseSearchMethod",
            "have_return": false,
            "code_content": "    def run(self):\n        \"\"\"A Placeholder function for running the search method. \n           This should be implemented by all search method subclasses.\n        \"\"\"\n        pass\n",
            "name_column": 8
        },
        "to_json": {
            "type": "FunctionDef",
            "name": "to_json",
            "md_content": "**to_json函数**：该函数的功能是创建搜索方法的json表示的占位函数。所有搜索方法的子类都应该实现这个函数。\n\n该函数是一个占位函数，没有实际的代码实现。它的目的是为了提醒开发者在实现具体的搜索方法时，需要创建一个json表示。具体的实现应该根据具体的搜索方法来完成。\n\n**注意**：使用该代码时需要注意以下几点：\n- 该函数是一个占位函数，没有实际的代码实现，需要根据具体的搜索方法进行实现。\n- 实现该函数时，需要创建一个json表示来表示搜索方法的相关信息。",
            "code_start_line": 30,
            "code_end_line": 34,
            "parent": "BaseSearchMethod",
            "have_return": false,
            "code_content": "    def to_json(self):\n        \"\"\"A Placeholder function for creating a json representation of the search method. \n           This should be implemented by all search method subclasses.\n        \"\"\"\n        pass\n",
            "name_column": 8
        },
        "get_finish_node": {
            "type": "FunctionDef",
            "name": "get_finish_node",
            "md_content": "**get_finish_node函数**：这个函数的作用是获取搜索方法运行的最终节点。这个函数是一个占位函数，需要由所有搜索方法的子类来实现。\n\n在这个函数中，我们可以看到它只有一个pass语句，表示这个函数没有具体的实现代码。这是因为这个函数是一个占位函数，需要由具体的搜索方法子类来实现。这个函数的目的是为了获取搜索方法运行的最终节点，具体的实现逻辑会根据不同的搜索方法而有所不同。\n\n**注意**：在使用这个函数时需要注意以下几点：\n- 这个函数是一个占位函数，需要由具体的搜索方法子类来实现。\n- 在实现这个函数时，需要根据具体的搜索方法来确定最终节点的获取逻辑。",
            "code_start_line": 36,
            "code_end_line": 40,
            "parent": "BaseSearchMethod",
            "have_return": false,
            "code_content": "    def get_finish_node(self):\n        \"\"\"A Placeholder function for getting the final node of the search method run.\n           This should be implemented by all search method subclasses.\n        \"\"\"\n        pass\n",
            "name_column": 8
        },
        "status": {
            "type": "FunctionDef",
            "name": "status",
            "md_content": "**status函数**：该函数的功能是获取搜索方法的当前状态。\n\n该函数没有参数，通过调用该函数可以获取搜索方法的当前状态。返回值为SearchMethodStatusCode类型，表示搜索方法的当前状态。\n\n**注意**：使用该函数时需要注意以下几点：\n- 该函数没有参数，直接调用即可。\n- 返回值为SearchMethodStatusCode类型，表示搜索方法的当前状态。\n\n**输出示例**：假设搜索方法的当前状态为\"RUNNING\"，则调用该函数后的返回值为\"RUNNING\"。",
            "code_start_line": 42,
            "code_end_line": 48,
            "parent": "BaseSearchMethod",
            "have_return": true,
            "code_content": "    def status(self):\n        \"\"\"Gets the current status of the search method.\n\n        Returns:\n            SearchMethodStatusCode: The current status of the search method.\n        \"\"\"\n        return self.status\n",
            "name_column": 8
        }
    },
    "XAgentGen/app.py": {
        "ConstrainedLogitsProcessor": {
            "type": "ClassDef",
            "name": "ConstrainedLogitsProcessor",
            "md_content": "**ConstrainedLogitsProcessor函数**：该类的功能是对logits进行约束处理。\n\n该类继承自LogitsProcessor类，并具有以下方法：\n\n- `__init__(self, extra_arguments, functions, function_call, tokenizer_path, device=None)`: 构造函数，用于初始化ConstrainedLogitsProcessor对象。参数extra_arguments是额外的参数，functions是函数列表，function_call是函数调用列表，tokenizer_path是tokenizer的路径，device是设备类型。在函数内部，首先判断function_call是否为空，如果为空则将其赋值为None。然后创建FunctionParser对象dp，并使用TransformersTokenizer和XTransformers初始化模型model。接下来，调用dp的create_all_functions_model方法创建所有函数模型，并将模型转换为正则表达式列表regex_list。最后，使用generate.multi_regex方法创建生成器generator。\n\n- `__call__(self, generated_token_ids: List[int], logits: torch.Tensor) -> torch.Tensor`: 该方法用于对生成的token ids和logits进行处理，并返回处理后的logits。首先，将生成的token ids转换为torch.LongTensor类型，并将其转移到与logits相同的设备上。然后，使用generator的create_proposal方法对生成的token ids和logits进行处理，得到masked_logits。最后，返回masked_logits。\n\n**注意**：在使用该类时，需要提供额外的参数、函数列表、函数调用列表、tokenizer路径和设备类型。\n\n**输出示例**：模拟代码返回值的可能外观。\n\n```python\nmasked_logits\n```",
            "code_start_line": 68,
            "code_end_line": 84,
            "parent": null,
            "have_return": true,
            "code_content": "class ConstrainedLogitsProcessor(LogitsProcessor):\n    def __init__(self, extra_arguments, functions, function_call, tokenizer_path, device=None):\n        if function_call is not None and len(function_call) == 0:\n            function_call = None\n        self.dp = FunctionParser()\n        outline_tokenizer = TransformersTokenizer(tokenizer_path)\n        fake_model = Dict()\n        fake_model.device = device\n        model = XTransformers(fake_model, outline_tokenizer)\n        self.dp.create_all_functions_model(extra_arguments, functions, function_call)\n        regex_list = self.dp.models_to_regex()\n        self.generator = generate.multi_regex(model, regex_list)\n\n    def __call__(self, generated_token_ids: List[int], logits: torch.Tensor) -> torch.Tensor:\n        generated_token_ids = torch.LongTensor(generated_token_ids).view(1, -1).to(logits.device)\n        masked_logits = self.generator.create_proposal(generated_token_ids, logits.view(1, -1))\n        return masked_logits\n",
            "name_column": 6
        },
        "health": {
            "type": "AsyncFunctionDef",
            "name": "health",
            "md_content": "**health函数**：该函数的功能是返回字符串\"ok\"。\n\n该函数是一个异步函数，使用async关键字定义。异步函数是一种特殊的函数，可以在执行过程中暂停并允许其他代码运行，然后在某个条件满足时继续执行。在该函数中，没有使用任何参数。\n\n函数体中只有一行代码，即返回字符串\"ok\"。这意味着当调用该函数时，它将立即返回字符串\"ok\"作为结果。\n\n**注意**：该函数没有任何输入参数，也没有任何副作用。它只是简单地返回一个固定的字符串。\n\n**输出示例**：假设调用该函数后，返回值为\"ok\"。",
            "code_start_line": 87,
            "code_end_line": 88,
            "parent": null,
            "have_return": true,
            "code_content": "async def health():\n    return \"ok\"\n",
            "name_column": 10
        },
        "chat_function": {
            "type": "AsyncFunctionDef",
            "name": "chat_function",
            "md_content": "**chat_function函数**: 这个函数的功能是处理聊天请求并生成回复。\n\n在这个函数中，首先从请求中获取到模型名称，如果模型名称不是\"agentllama\"或\"xagentllm\"，则返回一个错误的模型信息。接着从请求中获取到消息、参数、函数和函数调用等信息，并将其格式化为一个任务提示。然后根据任务提示创建一个ConstrainedLogitsProcessor对象，并设置采样参数。接下来，生成一个随机的请求ID，并使用tokenizer对任务提示进行编码。然后使用engine生成回复结果，并将结果保存在final_output中。在生成回复结果的过程中，如果客户端断开连接，则中止请求并返回499状态码。最后，将回复结果进行解析，并将解析后的结果返回。\n\n如果解析结果失败，则返回一个包含错误信息的失败状态。否则，返回一个包含模型名称、使用情况和回复结果的成功状态。\n\n**注意**: 在使用这段代码时需要注意以下几点:\n- 需要传入一个Response对象和一个Request对象作为参数。\n- 需要确保传入的请求中包含正确的模型名称、消息、参数、函数和函数调用等信息。\n\n**输出示例**:\n```\n{\n    \"model\": \"agentllama\",\n    \"usage\": {\n        \"prompt_tokens\": 10,\n        \"completion_tokens\": 20,\n        \"total_tokens\": 30\n    },\n    \"choices\": [\n        {\n            \"message\": {\n                \"content\": \"这是一个回复示例\"\n            },\n            \"finish_reason\": \"stop\",\n            \"index\": 0\n        }\n    ]\n}\n```",
            "code_start_line": 92,
            "code_end_line": 170,
            "parent": null,
            "have_return": true,
            "code_content": "async def chat_function(response:Response,request: Request):\n    global engine\n    call_msg = await request.json()\n    model_name = call_msg.get(\"model\",\"\")\n    if model_name != \"agentllama\" and model_name != \"xagentllm\":\n        return {\"model\": \"\", \"choices\": [{'message': {'content': f'bad model {model_name}'}, 'finish_reason': 'error', 'index': -1}]}\n    messages = call_msg.get(\"messages\",None)\n    arguments = call_msg.get(\"arguments\",None)\n    functions = call_msg.get(\"functions\",None)\n    function_call = call_msg.get(\"function_call\",None)\n    task_prompt = format({\n        \"messages\": messages,\n        \"arguments\": arguments,\n        \"functions\": functions,\n        \"function_call\": function_call\n    }, dump_method='json')\n    processor = ConstrainedLogitsProcessor(arguments, functions, function_call, model_path, device='cuda')\n    sampling_params = SamplingParams(\n        temperature=call_msg.get(\"temperature\", 0.8),\n        top_p=call_msg.get(\"top_p\", 1.0),\n        frequency_penalty=call_msg.get(\"frequency_penalty\",0.5),\n        presence_penalty=call_msg.get(\"presence_penalty\", 0.0),\n        repetition_penalty=call_msg.get(\"repetition_penalty\",1.2),\n        max_tokens=call_msg.get(\"max_tokens\", 4000),\n        logits_processors=[processor]\n    )\n    # make request\n    request_id = random_uuid()\n    # tokenize prompt\n    input_ids = tokenizer.encode(task_prompt, return_tensors=\"pt\")\n    prompt_tokens = input_ids.shape[1]  \n    results_generator = engine.generate(task_prompt, sampling_params, request_id)\n    final_output = None\n    async for request_output in results_generator:\n        if await request.is_disconnected():\n            # Abort the request if the client disconnects.\n            await engine.abort(request_id)\n            return Response(status_code=499)\n        final_output = request_output\n    sequence = final_output.outputs[0].text\n    # tokenizer output\n    output_ids = tokenizer.encode(sequence, return_tensors=\"pt\")\n    completion_tokens = output_ids.shape[1]\n    try:\n        sequence = json.loads(sequence)\n        if \"extra_parameters\" in sequence:\n            sequence[\"arguments\"] = sequence[\"extra_parameters\"]\n            sequence.pop(\"extra_parameters\")\n    except Exception as e:\n        res = {\"status\": \"fail\",\"broken_json\":sequence,\"error_message\":str(e)}\n    else:\n        res = {\n            \"status\": \"success\",\n            \"function_res\": sequence,\n            \"usage\":{\n                \"prompt_tokens\": prompt_tokens,\n                \"completion_tokens\": completion_tokens,\n                \"total_tokens\": prompt_tokens + completion_tokens\n            }\n        }\n\n    if res[\"status\"] == \"fail\":\n        response.status_code = 400\n        return {\"model\": \"\", \"choices\": [{'message': {'content': json.dumps(res,ensure_ascii=False)}, 'finish_reason': 'error', 'index': -1}]}\n    \n    response_model = {\n        'model': model_name,\n        'usage': res[\"usage\"],\n        'choices':[\n            {\n                \"message\":{\n                    \"content\": json.dumps(res[\"function_res\"], ensure_ascii=False)\n                },\n                \"finish_reason\":\"stop\",\n                \"index\":0,\n            }\n        ]\n    }\n    return response_model\n",
            "name_column": 10
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__函数**：这个函数的作用是初始化一个Function对象。\n\n在这个函数中，首先对传入的function_call进行判断，如果function_call是一个空列表，则将其置为None。然后创建一个FunctionParser对象，并根据传入的extra_arguments、functions和function_call参数，使用create_all_functions_model方法创建所有函数的模型。接着将模型转换为正则表达式列表，并使用XTransformers模型和正则表达式列表创建一个生成器对象。\n\n**注意**：在使用这个函数时，需要传入extra_arguments、functions、function_call、tokenizer_path和device参数。其中，extra_arguments是额外的参数，functions是函数列表，function_call是函数调用列表，tokenizer_path是分词器的路径，device是设备类型。",
            "code_start_line": 69,
            "code_end_line": 79,
            "parent": "ConstrainedLogitsProcessor",
            "have_return": false,
            "code_content": "    def __init__(self, extra_arguments, functions, function_call, tokenizer_path, device=None):\n        if function_call is not None and len(function_call) == 0:\n            function_call = None\n        self.dp = FunctionParser()\n        outline_tokenizer = TransformersTokenizer(tokenizer_path)\n        fake_model = Dict()\n        fake_model.device = device\n        model = XTransformers(fake_model, outline_tokenizer)\n        self.dp.create_all_functions_model(extra_arguments, functions, function_call)\n        regex_list = self.dp.models_to_regex()\n        self.generator = generate.multi_regex(model, regex_list)\n",
            "name_column": 8
        },
        "__call__": {
            "type": "FunctionDef",
            "name": "__call__",
            "md_content": "**__call__函数**：这个函数的作用是将生成的令牌ID和logits作为输入，返回经过处理的masked_logits。\n\n该函数首先将生成的令牌ID转换为torch.LongTensor类型，并通过view函数将其形状调整为(1, -1)，然后将其移动到与logits相同的设备上。\n\n接下来，函数调用self.generator.create_proposal函数，将生成的令牌ID和调整后的logits作为参数传入。create_proposal函数的作用是根据生成的令牌ID和logits生成masked_logits。\n\n最后，函数返回masked_logits作为输出。\n\n**注意**：使用该代码时需要注意以下几点：\n- 输入的generated_token_ids应为一个整数列表。\n- logits应为torch.Tensor类型的张量。\n\n**输出示例**：模拟代码返回值的可能外观。\n```python\nmasked_logits = torch.Tensor(...)\nreturn masked_logits\n```",
            "code_start_line": 81,
            "code_end_line": 84,
            "parent": "ConstrainedLogitsProcessor",
            "have_return": true,
            "code_content": "    def __call__(self, generated_token_ids: List[int], logits: torch.Tensor) -> torch.Tensor:\n        generated_token_ids = torch.LongTensor(generated_token_ids).view(1, -1).to(logits.device)\n        masked_logits = self.generator.create_proposal(generated_token_ids, logits.view(1, -1))\n        return masked_logits\n",
            "name_column": 8
        }
    },
    "XAgentGen/xgen/server/datamodel.py": {
        "FuncReq": {
            "type": "ClassDef",
            "name": "FuncReq",
            "md_content": "**FuncReq函数**：这个类的函数是用于函数调用的请求。\n\n这个类的作用是定义了一个函数调用的请求对象，用于向系统发送函数调用的请求。该对象包含了以下属性：\n\n- `messages`：一个可选的列表，包含了一系列消息的字典。每个字典代表一条消息，可以用于函数调用的上下文信息。\n- `arguments`：一个可选的字典，包含了函数调用的参数。\n- `functions`：一个可选的列表，包含了一系列函数的字典。每个字典代表一个函数，可以用于函数调用的备选函数列表。\n- `function_call`：一个可选的字典，包含了要调用的函数的信息。\n- `temperature`：一个可选的浮点数，表示函数调用时的温度参数。\n- `max_tokens`：一个可选的整数，表示函数调用时的最大生成token数。\n- `top_p`：一个可选的浮点数，表示函数调用时的top-p参数。\n- `top_k`：一个可选的整数，表示函数调用时的top-k参数。\n- `repetition_penalty`：一个可选的浮点数，表示函数调用时的重复惩罚参数。\n- `model`：一个字符串，表示要使用的模型。\n\n**注意**：在使用该代码时需要注意以下几点：\n- `messages`、`arguments`、`functions`、`function_call`等属性都是可选的，可以根据实际需求选择性地设置。\n- `temperature`、`max_tokens`、`top_p`、`top_k`、`repetition_penalty`等参数是用于控制函数调用的生成结果的一些参数，可以根据实际需求进行调整。\n- `model`属性是必需的，需要指定要使用的模型。\n\n以上是对FuncReq类的详细解释和说明。",
            "code_start_line": 4,
            "code_end_line": 15,
            "parent": null,
            "have_return": false,
            "code_content": "class FuncReq(BaseModel):\n    \"\"\"The request for function call\"\"\"\n    messages:Optional[list[dict]]\n    arguments:Optional[dict]\n    functions:Optional[list[dict]]\n    function_call:Optional[dict]\n    temperature:Optional[float]\n    max_tokens:Optional[int]\n    top_p:Optional[float]\n    top_k:Optional[int]\n    repetition_penalty:Optional[float]\n    model:str\n",
            "name_column": 6
        },
        "Usage": {
            "type": "ClassDef",
            "name": "Usage",
            "md_content": "**Usage类的功能**：该类用于记录令牌的消耗情况。\n\nUsage类是一个数据模型类，用于表示令牌的消耗情况。它包含以下属性：\n\n- prompt_tokens：表示使用的提示令牌数量，类型为整数。\n- completion_tokens：表示使用的完成令牌数量，类型为整数。\n- total_tokens：表示总共使用的令牌数量，类型为整数。\n\n在项目中，Usage类被用作XAgentResponse类的一个可选属性。XAgentResponse类位于XAgentGen/xgen/server/datamodel.py文件中，用于表示XAgent的响应。它包含以下属性：\n\n- model：表示XAgent的模型，类型为字符串。\n- usage：表示XAgent的令牌消耗情况，类型为Usage类的实例，可选。\n- choices：表示XAgent的响应选项，类型为XAgentMessage类的列表。\n\n在使用Usage类时，需要注意以下几点：\n\n- Usage类用于记录令牌的消耗情况，可以通过访问其属性来获取具体的令牌消耗数量。\n- Usage类是一个数据模型类，用于表示数据结构，不包含具体的方法或功能。\n- Usage类通常作为其他类的属性使用，用于表示相关的数据信息。\n\n**注意**：在使用Usage类时，需要确保传入的属性值符合预期的数据类型，并且使用正确的属性名称访问相关的数据信息。",
            "code_start_line": 18,
            "code_end_line": 22,
            "parent": null,
            "have_return": false,
            "code_content": "class Usage(BaseModel):\n    \"\"\"The record for token consumption\"\"\"\n    prompt_tokens:int\n    completion_tokens:int\n    total_tokens:int\n",
            "name_column": 6
        },
        "FuncResult": {
            "type": "ClassDef",
            "name": "FuncResult",
            "md_content": "**FuncResult函数**：这个类的功能是表示函数调用的响应。\n\nFuncResult类是一个继承自BaseModel的类，它用于表示函数调用的响应。该类具有两个属性，分别是arguments和function_call。这两个属性都是可选的字典类型。\n\n- arguments属性表示函数调用时的参数，它是一个可选的字典类型。如果函数调用时有传递参数，那么arguments属性将包含这些参数的键值对。\n- function_call属性表示函数调用的相关信息，它也是一个可选的字典类型。如果函数调用时有传递相关信息，那么function_call属性将包含这些信息的键值对。\n\n使用FuncResult类可以方便地表示函数调用的响应，并且可以根据需要选择是否包含参数和函数调用信息。\n\n**注意**：在使用FuncResult类时，需要注意arguments和function_call属性都是可选的，可以根据实际情况选择是否使用它们。",
            "code_start_line": 24,
            "code_end_line": 27,
            "parent": null,
            "have_return": false,
            "code_content": "class FuncResult(BaseModel):\n    \"\"\"The response for function call\"\"\"\n    arguments:Optional[dict]\n    function_call:Optional[dict]\n",
            "name_column": 6
        },
        "Message": {
            "type": "ClassDef",
            "name": "Message",
            "md_content": "**Message功能**：这个类的功能是表示消息。\n\n该类定义了一个名为Message的数据模型，它继承自BaseModel。它只有一个属性content，类型为str，用于表示消息的内容。\n\n在项目中，该类被以下文件调用：\n文件路径：XAgentGen/xgen/server/datamodel.py\n代码片段如下：\n```python\nclass XAgentMessage(BaseModel):\n    message: Message\n    finish_reason: str\n    index: int\n```\n在这个代码片段中，XAgentMessage类使用了Message类作为其中一个属性，用于表示消息。除了message属性外，XAgentMessage还有finish_reason和index两个属性。\n\n**注意**：在使用该类时需要注意以下几点：\n- Message类的content属性必须是字符串类型。\n- 在使用XAgentMessage类时，需要先导入Message类。",
            "code_start_line": 29,
            "code_end_line": 30,
            "parent": null,
            "have_return": false,
            "code_content": "class Message(BaseModel):\n    content: str\n",
            "name_column": 6
        },
        "XAgentMessage": {
            "type": "ClassDef",
            "name": "XAgentMessage",
            "md_content": "**XAgentMessage功能**：这个类的功能是定义了XAgent的消息对象。\n\nXAgentMessage类具有以下属性：\n- message: Message类型，表示消息的内容。\n- finish_reason: str类型，表示消息的结束原因。\n- index: int类型，表示消息的索引。\n\n该类被以下文件调用：\n文件路径：XAgentGen/xgen/server/datamodel.py\n调用代码如下：\n```python\nclass XAgentResponse(BaseModel):\n    model: str\n    usage: Optional[Usage]\n    choices: list[XAgentMessage]\n```\n\n**注意**：在使用该类时需要注意以下几点：\n- XAgentMessage类用于表示XAgent的消息对象，其中包含了消息的内容、结束原因和索引信息。\n- message属性表示消息的具体内容，可以是任意类型。\n- finish_reason属性表示消息的结束原因，是一个字符串类型。\n- index属性表示消息的索引，是一个整数类型。",
            "code_start_line": 32,
            "code_end_line": 35,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentMessage(BaseModel):\n    message:Message\n    finish_reason:str\n    index:int\n",
            "name_column": 6
        },
        "XAgentResponse": {
            "type": "ClassDef",
            "name": "XAgentResponse",
            "md_content": "**XAgentResponse类的功能**：该类的功能是表示XAgent的响应对象。\n\nXAgentResponse类是一个继承自BaseModel的数据模型类。它具有以下属性：\n\n- model: 表示响应的模型名称，类型为str。\n- usage: 表示使用方式的可选属性，类型为Optional[Usage]。Usage是一个自定义的数据模型类，用于表示使用方式的详细信息。\n- choices: 表示可选的响应消息列表，类型为list[XAgentMessage]。XAgentMessage是一个自定义的数据模型类，用于表示XAgent的消息。\n\n该类用于表示XAgent的响应对象，其中包含了模型名称、使用方式和可选的响应消息列表。开发者可以使用该类来构建和解析XAgent的响应。\n\n**注意**：在使用XAgentResponse类时，需要注意以下几点：\n\n- model属性表示响应的模型名称，类型为str。开发者需要确保传入的模型名称是有效的。\n- usage属性表示使用方式的可选属性，类型为Optional[Usage]。开发者可以选择是否提供使用方式的详细信息。\n- choices属性表示可选的响应消息列表，类型为list[XAgentMessage]。开发者可以根据需要添加或解析响应消息。\n\n以上是XAgentResponse类的功能和使用说明。通过使用该类，开发者可以方便地构建和解析XAgent的响应对象。",
            "code_start_line": 37,
            "code_end_line": 40,
            "parent": null,
            "have_return": false,
            "code_content": "class XAgentResponse(BaseModel):\n    model:str\n    usage:Optional[Usage]\n    choices:list[XAgentMessage]\n",
            "name_column": 6
        }
    },
    "XAgentGen/xgen/server/__init__.py": {},
    "XAgentGen/xgen/server/message_formater.py": {
        "custom_yaml_dump": {
            "type": "FunctionDef",
            "name": "custom_yaml_dump",
            "md_content": "**custom_yaml_dump函数**：该函数的功能是将输入的item对象转换为自定义的YAML格式。\n\n该函数的代码逻辑如下：\n- 如果item为None，则直接返回item。\n- 如果item是字典类型，则遍历字典中的每个键值对，对值进行递归调用custom_yaml_dump函数，并将结果存入新的字典中。\n- 如果item是字符串类型且包含换行符，则调用literal函数将字符串转换为YAML格式。\n- 其他情况下，直接返回item。\n\n该函数在以下文件中被调用：\n文件路径：XAgentGen/xgen/server/message_formater.py\n调用代码如下：\ndef custom_yaml_dump(item):\n    if item is None:\n        return item\n    elif isinstance(item, dict):\n        data = {}\n        for key, value in item.items():\n            data[key] = custom_yaml_dump(value)\n        return data\n    elif isinstance(item, str) and '\\n' in item:\n        return literal(item)\n    else:\n        return item\n\n【代码片段结束】\n调用代码如下：\ndef yaml_dump(item):\n    f = StringIO()\n    item = custom_yaml_dump(item)\n    yaml_obj.dump(item, f)\n    f.seek(0)\n    string = f.read()\n    return string\n\n【代码片段结束】\n【XAgentGen/xgen/server/message_formater.py代码片段结束】\n\n**注意**：使用该代码时需要注意以下几点：\n- 该函数适用于将Python对象转换为自定义的YAML格式。\n- 输入的item对象可以是任意类型，包括字典、字符串等。\n- 如果item是字典类型，则会递归调用custom_yaml_dump函数对字典中的值进行转换。\n- 如果item是字符串类型且包含换行符，则会调用literal函数将字符串转换为YAML格式。\n- 其他情况下，item会被直接返回。\n\n**输出示例**：模拟该函数返回值的可能外观。\n```python\n{\n    'key1': 'value1',\n    'key2': {\n        'subkey1': 'subvalue1',\n        'subkey2': 'subvalue2'\n    },\n    'key3': None\n}\n```",
            "code_start_line": 21,
            "code_end_line": 32,
            "parent": null,
            "have_return": true,
            "code_content": "def custom_yaml_dump(item):\n    if item is None:\n        return item\n    elif isinstance(item, dict):\n        data = {}\n        for key, value in item.items():\n            data[key] = custom_yaml_dump(value)\n        return data\n    elif isinstance(item, str) and '\\n' in item:\n        return literal(item)\n    else:\n        return item\n",
            "name_column": 4
        },
        "yaml_load": {
            "type": "FunctionDef",
            "name": "yaml_load",
            "md_content": "**yaml_load函数**：该函数的功能是将字符串解析为YAML格式的数据。\n\n该函数接受一个字符串作为输入参数，然后使用StringIO将字符串转换为文件对象f。接下来，使用yaml_obj.load方法将文件对象f中的数据解析为YAML格式的数据，并将解析结果存储在变量data中。最后，将解析结果data作为函数的返回值。\n\n需要注意的是，该函数依赖于yaml_obj对象的load方法进行解析操作。在调用该函数之前，需要确保yaml_obj对象已经正确初始化，并且yaml模块已经正确导入。\n\n**注意**：在使用该函数时，需要注意以下几点：\n- 确保传入的字符串参数符合YAML格式的语法规范，否则可能会导致解析失败。\n- 确保yaml_obj对象已经正确初始化，并且yaml模块已经正确导入。\n\n**输出示例**：假设输入字符串为\"key: value\"，则函数的返回值为{'key': 'value'}。",
            "code_start_line": 35,
            "code_end_line": 38,
            "parent": null,
            "have_return": true,
            "code_content": "def yaml_load(string):\n    f = StringIO(string)\n    data = yaml_obj.load(f)\n    return data\n",
            "name_column": 4
        },
        "yaml_dump": {
            "type": "FunctionDef",
            "name": "yaml_dump",
            "md_content": "**yaml_dump函数**：该函数的功能是将输入的item对象转换为yaml格式的字符串。\n\n该函数首先创建一个StringIO对象f，用于存储转换后的字符串。然后调用custom_yaml_dump函数对item进行自定义的转换处理。接下来，使用yaml_obj.dump方法将转换后的item对象写入到f中。然后，将f的指针移动到文件开头，并读取f中的内容，将其作为字符串返回。\n\n在项目中，该函数在XAgentGen/xgen/server/message_formater.py文件中被调用。具体调用代码如下：\n\n```python\ndef my_dump(item, dump_method):\n    item = json_try(item)\n    if dump_method == 'yaml':\n        return yaml_dump(item)\n    elif dump_method == 'json':\n        return json.dumps(item, ensure_ascii=False)\n    else:\n        raise NotImplementedError\n```\n\n**注意**：使用该函数时需要注意以下几点：\n- 输入的item对象需要满足转换为yaml格式的要求。\n- dump_method参数只能为'yaml'或'json'，否则会抛出NotImplementedError异常。\n\n**输出示例**：以下是该函数可能返回的字符串的示例：\n```\nname: John\nage: 30\ncity: New York\n```",
            "code_start_line": 41,
            "code_end_line": 47,
            "parent": null,
            "have_return": true,
            "code_content": "def yaml_dump(item):\n    f = StringIO()\n    item = custom_yaml_dump(item)\n    yaml_obj.dump(item, f)\n    f.seek(0)\n    string = f.read()\n    return string\n",
            "name_column": 4
        },
        "message_format": {
            "type": "FunctionDef",
            "name": "message_format",
            "md_content": "**message_format函数**：该函数的功能是根据传入的消息格式化字符串。\n\n该函数接受一个名为msg的参数，该参数是一个字典类型的消息。函数首先判断消息的角色，如果角色是\"user\"，则将消息的内容添加到格式化字符串中，并在开头添加特定的起始标记和实例标记；如果角色是\"assistant\"，则直接将消息的内容添加到格式化字符串中，并在结尾添加特定的结束标记；否则，抛出NotImplementedError异常。最后，函数返回格式化后的字符串。\n\n该函数在以下文件中被调用：\n文件路径：XAgentGen/xgen/server/message_formater.py\n对应代码如下：\n```python\ndef format(item, dump_method='yaml'):\n    \"\"\"\n    reformat the request item\n    item: {\"messages\": ..., \"arguments\": ..., \"functions\": ..., \"function_call\": ...}\n    \"\"\"\n    if \"arguments\" in item and item['arguments'] is not None and len(item['arguments']) > 0:\n        arguments_string = \"# Global Arguments\\n\" + my_dump(item[\"arguments\"], \"yaml\")\n    else:\n        arguments_string = \"\"\n    if \"functions\" in item and item['functions'] is not None and len(item['functions']) > 0:\n        functions_string = \"# Functions\\n\" + my_dump(item[\"functions\"], \"yaml\")\n    else:\n        functions_string = \"\"\n    if \"function_call\" in item and item['function_call'] is not None and 'name' in item['function_call']:\n        function_call_string = f\"You need to use {item['function_call']['name']} function.\"\n    else:\n        function_call_string = \"\"\n    system_prefix = (\n        \"Response with following json schemas:\\n\" +\n        f\"{arguments_string}\\n{functions_string}\\n{function_call_string}\"\n    )\n    system_prefix = system_prefix.strip()\n\n    dialog = item[\"messages\"]\n    sys_msg_idx = find_system_msg(dialog)\n    if sys_msg_idx == -1:\n        dialog.insert(0, {\"role\": \"system\", \"content\": system_prefix})\n    else:\n        dialog[sys_msg_idx][\"content\"] += \"\\n\" + system_prefix\n\n    dialog = merge_messages(dialog)\n    input_string = \"\".join([message_format(msg) for msg in dialog])\n    return input_string\n```\n[此部分代码结束]\n[XAgentGen/xgen/server/message_formater.py代码结束]\n\n**注意**：使用该代码时需要注意以下几点：\n- 传入的msg参数必须是一个字典类型的消息，且必须包含\"role\"和\"content\"两个键。\n- 消息的角色只能是\"user\"或\"assistant\"，否则会抛出NotImplementedError异常。\n\n**输出示例**：模拟该代码返回值的可能外观。\n```\n# Global Arguments\n- argument1: value1\n- argument2: value2\n\n# Functions\n- function1:\n    - argument1: value1\n    - argument2: value2\n\nYou need to use function1 function.\n\nUser: [BOS] 用户消息内容 [E_INST] \nAssistant: 助手消息内容[EOS]\n```\n以上是对目标对象的详细解释文档，包括函数的功能、代码分析和描述、使用注意事项以及输出示例。",
            "code_start_line": 50,
            "code_end_line": 58,
            "parent": null,
            "have_return": true,
            "code_content": "def message_format(msg):\n    \"\"\"https://github.com/facebookresearch/llama/blob/main/llama/generation.py#L343\"\"\"\n    if msg[\"role\"] == \"user\":\n        string = f\"{BOS}{B_INST} {msg['content'].strip()} {E_INST} \"\n    elif msg[\"role\"] == \"assistant\":\n        string = f\"{msg['content'].strip()}{EOS}\"\n    else:\n        raise NotImplementedError\n    return string\n",
            "name_column": 4
        },
        "merge_messages": {
            "type": "FunctionDef",
            "name": "merge_messages",
            "md_content": "**merge_messages函数**：该函数的功能是将消息列表中的连续相同角色的消息合并为一个消息。\n\n该函数接受一个消息列表作为输入参数，然后遍历消息列表中的每个消息。如果当前消息的角色是系统消息，则将角色设置为用户，并在内容前后添加特殊标记。否则，将角色设置为当前消息的角色，并将内容设置为当前消息的内容。\n\n接下来，函数会检查当前消息的角色是否与上一个消息的角色相同。如果相同，则将当前消息的内容追加到上一个消息的内容后面，以换行符分隔。如果不同，则将当前消息添加到新的消息列表中。\n\n最后，函数返回合并后的新消息列表。\n\n**注意**：在使用该代码时需要注意以下几点：\n- 输入参数messages应为一个消息列表，其中每个消息应包含角色和内容。\n- 返回值为一个新的消息列表，其中连续相同角色的消息已合并。\n\n**输出示例**：假设输入的消息列表为：\n```\n[\n    {\"role\": \"user\", \"content\": \"Hello\"},\n    {\"role\": \"user\", \"content\": \"How are you?\"},\n    {\"role\": \"system\", \"content\": \"I'm fine, thank you.\"}\n]\n```\n则函数的返回值为：\n```\n[\n    {\"role\": \"user\", \"content\": \"Hello\\nHow are you?\"},\n    {\"role\": \"user\", \"content\": \"I'm fine, thank you.\"}\n]\n```",
            "code_start_line": 61,
            "code_end_line": 79,
            "parent": null,
            "have_return": true,
            "code_content": "def merge_messages(messages):\n    new_messages = []\n    pre_role = \"\"\n    for msg in messages:\n        # system message should be merged with user message\n        # reference: https://github.com/facebookresearch/llama/blob/main/llama/generation.py#L324\n        if msg['role'] == 'system':\n            role = 'user'\n            content = B_SYS + msg[\"content\"] + E_SYS\n        else:\n            role = msg['role']\n            content = msg['content']\n\n        if role == pre_role:\n            new_messages[-1][\"content\"] += \"\\n\" + content\n        else:\n            new_messages.append({'role': role, 'content': content})\n        pre_role = role\n    return new_messages\n",
            "name_column": 4
        },
        "find_system_msg": {
            "type": "FunctionDef",
            "name": "find_system_msg",
            "md_content": "**find_system_msg函数**: 这个函数的功能是在给定的消息列表中查找系统消息，并返回系统消息的索引。\n\n该函数接受一个消息列表作为参数，然后遍历列表中的每个消息，判断消息的\"role\"属性是否为\"system\"，如果是，则将该消息的索引赋值给变量idx。最后，函数返回变量idx，即系统消息的索引。\n\n该函数在项目中的以下文件中被调用：\n文件路径：XAgentGen/xgen/server/message_formater.py\n对应代码如下：\n```python\ndef format(item, dump_method='yaml'):\n    \"\"\"\n    重新格式化请求项\n    item: {\"messages\": ..., \"arguments\": ..., \"functions\": ..., \"function_call\": ...}\n    \"\"\"\n    if \"arguments\" in item and item['arguments'] is not None and len(item['arguments']) > 0:\n        arguments_string = \"# 全局参数\\n\" + my_dump(item[\"arguments\"], \"yaml\")\n    else:\n        arguments_string = \"\"\n    if \"functions\" in item and item['functions'] is not None and len(item['functions']) > 0:\n        functions_string = \"# 函数\\n\" + my_dump(item[\"functions\"], \"yaml\")\n    else:\n        functions_string = \"\"\n    if \"function_call\" in item and item['function_call'] is not None and 'name' in item['function_call']:\n        function_call_string = f\"你需要使用 {item['function_call']['name']} 函数。\"\n    else:\n        function_call_string = \"\"\n    system_prefix = (\n        \"响应的JSON模式如下：\\n\" +\n        f\"{arguments_string}\\n{functions_string}\\n{function_call_string}\"\n    )\n    system_prefix = system_prefix.strip()\n\n    dialog = item[\"messages\"]\n    sys_msg_idx = find_system_msg(dialog)\n    if sys_msg_idx == -1:\n        dialog.insert(0, {\"role\": \"system\", \"content\": system_prefix})\n    else:\n        dialog[sys_msg_idx][\"content\"] += \"\\n\" + system_prefix\n\n    dialog = merge_messages(dialog)\n    input_string = \"\".join([message_format(msg) for msg in dialog])\n    return input_string\n```\n[此部分代码结束]\n[XAgentGen/xgen/server/message_formater.py代码结束]\n\n**find_system_msg函数**的功能是在给定的消息列表中查找系统消息，并返回系统消息的索引。\n\n该函数通过遍历消息列表中的每个消息，判断消息的\"role\"属性是否为\"system\"来找到系统消息。如果找到了系统消息，则将该消息的索引赋值给变量idx。最后，函数返回变量idx，即系统消息的索引。\n\n**注意**：该函数的返回值为系统消息的索引，如果找不到系统消息，则返回-1。\n\n**输出示例**：假设给定的消息列表为：\n```python\nmessages = [\n    {\"role\": \"user\", \"content\": \"你好\"},\n    {\"role\": \"system\", \"content\": \"系统消息1\"},\n    {\"role\": \"user\", \"content\": \"请问有什么问题？\"},\n    {\"role\": \"system\", \"content\": \"系统消息2\"},\n    {\"role\": \"user\", \"content\": \"谢谢\"}\n]\n```\n调用find_system_msg(messages)的返回值为2，表示系统消息2的索引为2。",
            "code_start_line": 82,
            "code_end_line": 87,
            "parent": null,
            "have_return": true,
            "code_content": "def find_system_msg(messages):\n    idx = -1\n    for i, msg in enumerate(messages):\n        if msg[\"role\"] == \"system\":\n            idx = i\n    return idx\n",
            "name_column": 4
        },
        "my_dump": {
            "type": "FunctionDef",
            "name": "my_dump",
            "md_content": "**my_dump函数**：该函数的功能是根据指定的dump方法将item对象转换为字符串。\n\n该函数接受两个参数：\n- item：要转换的对象。\n- dump_method：指定的转换方法，可选值为'yaml'或'json'。\n\n函数内部首先对item对象进行了json_try操作，将其转换为JSON格式。然后根据dump_method的取值，分别使用yaml_dump和json.dumps方法将item对象转换为字符串。如果dump_method的取值不是'yaml'或'json'，则抛出NotImplementedError异常。\n\n**注意**：在使用该函数时，需要确保dump_method参数的取值为'yaml'或'json'，否则将会抛出异常。\n\n**输出示例**：假设item对象为{\"name\": \"John\", \"age\": 25}，dump_method为'json'，则函数的返回值为'{\"name\": \"John\", \"age\": 25}'。",
            "code_start_line": 90,
            "code_end_line": 97,
            "parent": null,
            "have_return": true,
            "code_content": "def my_dump(item, dump_method):\n    item = json_try(item)\n    if dump_method == 'yaml':\n        return yaml_dump(item)\n    elif dump_method == 'json':\n        return json.dumps(item, ensure_ascii=False)\n    else:\n        raise NotImplementedError\n",
            "name_column": 4
        },
        "json_try": {
            "type": "FunctionDef",
            "name": "json_try",
            "md_content": "**json_try函数**: 这个函数的功能是尝试将输入的item转换为JSON格式的数据。它会递归地检查item的类型，如果是字符串类型，则尝试将其解析为JSON对象；如果是字典类型，则递归地对字典中的每个值进行转换；如果是列表类型，则递归地对列表中的每个元素进行转换；其他类型则直接返回。最终返回转换后的JSON数据。\n\n该函数在项目中的以下文件中被调用：\n文件路径：XAgentGen/xgen/server/message_formater.py\n对应代码如下：\n```python\ndef my_dump(item, dump_method):\n    item = json_try(item)\n    if dump_method == 'yaml':\n        return yaml_dump(item)\n    elif dump_method == 'json':\n        return json.dumps(item, ensure_ascii=False)\n    else:\n        raise NotImplementedError\n```\n[代码片段结束]\n对应代码如下：\n```python\ndef json_try(item):\n    if isinstance(item, str):\n        try:\n            x = json.loads(item)\n            if not isinstance(x, str):\n                return json_try(x)\n            else:\n                return x\n        except:\n            return item\n    elif isinstance(item, dict):\n        data = {}\n        for key, value in item.items():\n            data[key] = json_try(value)\n        return data if len(data) > 0 else None\n    elif isinstance(item, list):\n        data = []\n        for x in item:\n            data.append(json_try(x))\n        return data if len(data) > 0 else None\n    else:\n        return item\n```\n[代码片段结束]\n对应代码如下：\n```python\ndef json_try(item):\n    if isinstance(item, str):\n        try:\n            x = json.loads(item)\n            if not isinstance(x, str):\n                return json_try(x)\n            else:\n                return x\n        except:\n            return item\n    elif isinstance(item, dict):\n        data = {}\n        for key, value in item.items():\n            data[key] = json_try(value)\n        return data if len(data) > 0 else None\n    elif isinstance(item, list):\n        data = []\n        for x in item:\n            data.append(json_try(x))\n        return data if len(data) > 0 else None\n    else:\n        return item\n```\n[代码片段结束]\n对应代码如下：\n```python\ndef json_try(item):\n    if isinstance(item, str):\n        try:\n            x = json.loads(item)\n            if not isinstance(x, str):\n                return json_try(x)\n            else:\n                return x\n        except:\n            return item\n    elif isinstance(item, dict):\n        data = {}\n        for key, value in item.items():\n            data[key] = json_try(value)\n        return data if len(data) > 0 else None\n    elif isinstance(item, list):\n        data = []\n        for x in item:\n            data.append(json_try(x))\n        return data if len(data) > 0 else None\n    else:\n        return item\n```\n[代码片段结束]\n[End of XAgentGen/xgen/server/message_formater.py]\n\n**注意**: 在使用该代码时需要注意以下几点：\n- 输入的item应为合法的JSON字符串、字典或列表。\n- 如果item无法解析为JSON对象，则会直接返回原始的item。\n- 返回的JSON数据可能是字典、列表或其他基本数据类型。\n\n**输出示例**: 模拟代码返回值的可能外观。\n```python\n{\n    \"key1\": \"value1\",\n    \"key2\": {\n        \"nested_key\": \"nested_value\"\n    },\n    \"key3\": [\n        \"item1\",\n        \"item2\"\n    ]\n}\n```",
            "code_start_line": 100,
            "code_end_line": 121,
            "parent": null,
            "have_return": true,
            "code_content": "def json_try(item):\n    if isinstance(item, str):\n        try:\n            x = json.loads(item)\n            if not isinstance(x, str):\n                return json_try(x)\n            else:\n                return x\n        except:\n            return item\n    elif isinstance(item, dict):\n        data = {}\n        for key, value in item.items():\n            data[key] = json_try(value)\n        return data if len(data) > 0 else None\n    elif isinstance(item, list):\n        data = []\n        for x in item:\n            data.append(json_try(x))\n        return data if len(data) > 0 else None\n    else:\n        return item\n",
            "name_column": 4
        },
        "my_load": {
            "type": "FunctionDef",
            "name": "my_load",
            "md_content": "**my_load函数**：该函数的功能是根据指定的dump方法将字符串加载为相应的数据结构。\n\n该函数接受两个参数：string（要加载的字符串）和dump_method（指定的dump方法）。根据dump_method的值，函数将使用相应的方法将字符串加载为数据结构。如果dump_method为'yaml'，则调用yaml_load函数将字符串加载为YAML格式的数据结构；如果dump_method为'json'，则调用json.loads函数将字符串加载为JSON格式的数据结构。如果dump_method的值不是'yaml'或'json'，则抛出NotImplementedError异常。\n\n**注意**：在使用该函数时需要注意以下几点：\n- 确保传入的字符串符合指定的dump方法所需的格式。\n- 确保dump_method的值为'yaml'或'json'，否则会抛出异常。\n\n**输出示例**：假设传入的字符串为'{\"name\": \"John\", \"age\": 30}'，dump_method为'json'，则函数将返回以下数据结构：\n{\n  \"name\": \"John\",\n  \"age\": 30\n}",
            "code_start_line": 124,
            "code_end_line": 130,
            "parent": null,
            "have_return": true,
            "code_content": "def my_load(string, dump_method):\n    if dump_method == 'yaml':\n        return yaml_load(string)\n    elif dump_method == 'json':\n        return json.loads(string)\n    else:\n        raise NotImplementedError\n",
            "name_column": 4
        },
        "format": {
            "type": "FunctionDef",
            "name": "format",
            "md_content": "**format函数**：这个函数的功能是重新格式化请求项。\n\n该函数接受两个参数：item和dump_method。item是一个字典，包含了请求的消息、参数、函数和函数调用等信息。dump_method是一个字符串，表示转储方法的类型，默认为'yaml'。\n\n函数首先判断item中是否存在参数（arguments）、函数（functions）和函数调用（function_call）的信息。如果存在，则将它们转储为字符串，并添加相应的注释。如果不存在，则将对应的字符串置为空。\n\n接下来，函数将系统前缀（system_prefix）设置为包含参数、函数和函数调用信息的字符串。然后，函数将对话（dialog）中的系统消息（system message）与系统前缀进行合并。\n\n之后，函数将对话中的消息进行合并，并将每个消息转换为字符串。最后，将所有转换后的字符串拼接在一起，并返回结果。\n\n**注意**：在使用该函数时需要注意以下几点：\n- item参数必须是一个字典，包含了请求的消息、参数、函数和函数调用等信息。\n- dump_method参数是一个字符串，表示转储方法的类型，默认为'yaml'。\n\n**输出示例**：假设item参数为{\"messages\": [{\"role\": \"user\", \"content\": \"Hello\"}, {\"role\": \"assistant\", \"content\": \"How can I help you?\"}], \"arguments\": {\"arg1\": \"value1\", \"arg2\": \"value2\"}, \"functions\": {\"func1\": \"value1\", \"func2\": \"value2\"}, \"function_call\": {\"name\": \"my_function\"}}，则函数的返回值为以下字符串：\n```\nHello\nHow can I help you?\n# Global Arguments\narg1: value1\narg2: value2\n# Functions\nfunc1: value1\nfunc2: value2\nYou need to use my_function function.\n```",
            "code_start_line": 133,
            "code_end_line": 165,
            "parent": null,
            "have_return": true,
            "code_content": "def format(item, dump_method='yaml'):\n    \"\"\"\n    reformat the request item\n    item: {\"messages\": ..., \"arguments\": ..., \"functions\": ..., \"function_call\": ...}\n    \"\"\"\n    if \"arguments\" in item and item['arguments'] is not None and len(item['arguments']) > 0:\n        arguments_string = \"# Global Arguments\\n\" + my_dump(item[\"arguments\"], \"yaml\")\n    else:\n        arguments_string = \"\"\n    if \"functions\" in item and item['functions'] is not None and len(item['functions']) > 0:\n        functions_string = \"# Functions\\n\" + my_dump(item[\"functions\"], \"yaml\")\n    else:\n        functions_string = \"\"\n    if \"function_call\" in item and item['function_call'] is not None and 'name' in item['function_call']:\n        function_call_string = f\"You need to use {item['function_call']['name']} function.\"\n    else:\n        function_call_string = \"\"\n    system_prefix = (\n        \"Response with following json schemas:\\n\" +\n        f\"{arguments_string}\\n{functions_string}\\n{function_call_string}\"\n    )\n    system_prefix = system_prefix.strip()\n\n    dialog = item[\"messages\"]\n    sys_msg_idx = find_system_msg(dialog)\n    if sys_msg_idx == -1:\n        dialog.insert(0, {\"role\": \"system\", \"content\": system_prefix})\n    else:\n        dialog[sys_msg_idx][\"content\"] += \"\\n\" + system_prefix\n\n    dialog = merge_messages(dialog)\n    input_string = \"\".join([message_format(msg) for msg in dialog])\n    return input_string\n",
            "name_column": 4
        }
    },
    "XAgentGen/xgen/models/transformers.py": {
        "prepare_logits_processor": {
            "type": "FunctionDef",
            "name": "prepare_logits_processor",
            "md_content": "**prepare_logits_processor函数**：该函数的功能是根据给定的参数生成logits处理器。\n\n该函数接受四个参数：\n- temperature（温度）：控制生成文本的多样性，值越高生成的文本越随机。\n- repetition_penalty（重复惩罚）：控制生成文本中重复词语的惩罚程度，值越高生成的文本越不会重复。\n- top_p（前p个词）：控制生成文本时从概率最高的词中选择的范围，值越小生成的文本越保守。\n- top_k（前k个词）：控制生成文本时从概率最高的词中选择的数量，值越小生成的文本越保守。\n\n函数内部首先创建了一个LogitsProcessorList对象，用于存储logits处理器。然后根据参数的取值情况，依次判断是否需要添加对应的logits处理器到列表中。\n\n- 如果temperature大于等于1e-5且不等于1.0，则添加TemperatureLogitsWarper处理器到列表中。\n- 如果repetition_penalty大于1.0，则添加RepetitionPenaltyLogitsProcessor处理器到列表中。\n- 如果top_p在1e-8到1.0之间，则添加TopPLogitsWarper处理器到列表中。\n- 如果top_k大于0，则添加TopKLogitsWarper处理器到列表中。\n\n最后将处理器列表作为函数的返回值。\n\n**注意**：在使用该函数时需要注意以下几点：\n- temperature的取值应大于等于1e-5且不等于1.0。\n- repetition_penalty的取值应大于1.0。\n- top_p的取值应在1e-8到1.0之间。\n- top_k的取值应大于0。\n\n**输出示例**：模拟代码返回值的可能外观。\n\n```python\nprocessor_list = LogitsProcessorList()\nif temperature >= 1e-5 and temperature != 1.0:\n    processor_list.append(TemperatureLogitsWarper(temperature))\nif repetition_penalty > 1.0:\n    processor_list.append(RepetitionPenaltyLogitsProcessor(repetition_penalty))\nif 1e-8 <= top_p < 1.0:\n    processor_list.append(TopPLogitsWarper(top_p))\nif top_k > 0:\n    processor_list.append(TopKLogitsWarper(top_k))\nreturn processor_list\n```",
            "code_start_line": 17,
            "code_end_line": 31,
            "parent": null,
            "have_return": true,
            "code_content": "def prepare_logits_processor(\n    temperature: float, repetition_penalty: float, top_p: float, top_k: int\n) -> LogitsProcessorList:\n    \"\"\"generate the logits processor with params\"\"\"\n    processor_list = LogitsProcessorList()\n    # TemperatureLogitsWarper doesn't accept 0.0, 1.0 makes it a no-op so we skip two cases.\n    if temperature >= 1e-5 and temperature != 1.0:\n        processor_list.append(TemperatureLogitsWarper(temperature))\n    if repetition_penalty > 1.0:\n        processor_list.append(RepetitionPenaltyLogitsProcessor(repetition_penalty))\n    if 1e-8 <= top_p < 1.0:\n        processor_list.append(TopPLogitsWarper(top_p))\n    if top_k > 0:\n        processor_list.append(TopKLogitsWarper(top_k))\n    return processor_list\n",
            "name_column": 4
        },
        "XTransformers": {
            "type": "ClassDef",
            "name": "XTransformers",
            "md_content": "**XTransformers函数**: 这个类的功能是为了处理基于Transformers模型的文本生成任务。\n\n该类继承自Transformers类，它接受一个预训练模型和一个预训练分词器作为参数，并提供了一些方法来处理文本生成任务。\n\n- **\\_\\_init\\_\\_方法**: 初始化XTransformers类的实例。它接受一个预训练模型和一个预训练分词器作为参数，并调用父类的\\_\\_init\\_\\_方法进行初始化。它还初始化了logits_processor属性为None。\n\n- **reset方法**: 重置分词器的prompt_tokens和completion_tokens属性为0，以便重新开始生成文本的过程。\n\n- **add_logits_processor方法**: 添加logits处理器。它接受一个generate_kwargs参数，该参数是一个包含生成文本时的一些参数的字典。根据generate_kwargs中的参数值，创建一个logits_processor对象，并将其赋值给logits_processor属性。\n\n- **forward方法**: 前向传播方法。它接受输入的input_ids和attention_mask张量作为参数，并可选地接受过去的键值对。它调用父类的forward方法来获取下一个token的logits和输出的过去的键值对。如果logits_processor存在，则将输入的input_ids和下一个token的logits传递给logits_processor进行处理。最后返回处理后的下一个token的logits和输出的过去的键值对。\n\n**注意**: 在使用XTransformers类时，可以通过调用reset方法来重置分词器的状态，通过调用add_logits_processor方法来添加logits处理器，以及通过调用forward方法来生成文本。\n\n**输出示例**:\n```\n下一个token的logits: tensor([[ 0.1234, -0.5678,  0.9876, ...]])\n输出的过去的键值对: (tensor([[...]]), tensor([[...]]), ...)\n```",
            "code_start_line": 33,
            "code_end_line": 71,
            "parent": null,
            "have_return": true,
            "code_content": "class XTransformers(Transformers):\n    def __init__(\n        self,\n        model: \"PreTrainedModel\",\n        tokenizer: \"PreTrainedTokenizer\",\n    ):\n        super().__init__(model,tokenizer)\n        self.logits_processor=None\n    \n    def reset(self):\n        self.tokenizer.prompt_tokens = 0\n        self.tokenizer.completion_tokens = 0\n\n    def add_logits_processor(self,generate_kwargs:dict={}):\n\n        temperature = float(generate_kwargs.get(\"temperature\", 1.0))\n        repetition_penalty = float(generate_kwargs.get(\"repetition_penalty\", 1.0))\n        top_p = float(generate_kwargs.get(\"top_p\", 1.0))\n        top_k = int(generate_kwargs.get(\"top_k\", -1))  # -1 means disable\n\n        logits_processor = prepare_logits_processor(\n            temperature, repetition_penalty, top_p, top_k\n        )\n\n        self.logits_processor = logits_processor\n\n    def forward(\n        self,\n        input_ids: torch.LongTensor,\n        attention_mask: torch.LongTensor,\n        past_key_values: Optional[Tuple] = None,\n    ) -> Tuple[torch.FloatTensor, Optional[KVCacheType]]:\n        \n        next_token_logits, output_past_key_values = super().forward(input_ids,attention_mask,past_key_values)\n        \n        if self.logits_processor:\n            next_token_logits = self.logits_processor(input_ids,next_token_logits)\n       \n        return next_token_logits, output_past_key_values\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__函数**：这个函数的作用是初始化一个Function对象。\n\n在这个函数中，有两个参数：\n- model: \"PreTrainedModel\"类型，表示一个预训练模型。\n- tokenizer: \"PreTrainedTokenizer\"类型，表示一个预训练分词器。\n\n在函数的内部，调用了父类的__init__函数，将model和tokenizer作为参数传递给父类的构造函数。\n\n此外，还初始化了一个logits_processor变量，初始值为None。\n\n**注意**：在使用这段代码时需要注意以下几点：\n- model参数必须是一个预训练模型对象。\n- tokenizer参数必须是一个预训练分词器对象。",
            "code_start_line": 34,
            "code_end_line": 40,
            "parent": "XTransformers",
            "have_return": false,
            "code_content": "    def __init__(\n        self,\n        model: \"PreTrainedModel\",\n        tokenizer: \"PreTrainedTokenizer\",\n    ):\n        super().__init__(model,tokenizer)\n        self.logits_processor=None\n",
            "name_column": 8
        },
        "reset": {
            "type": "FunctionDef",
            "name": "reset",
            "md_content": "**reset函数**：该函数的功能是重置tokenizer的prompt_tokens和completion_tokens为0。\n\n该函数用于重置tokenizer对象的prompt_tokens和completion_tokens属性为0。tokenizer是一个用于处理文本的工具，prompt_tokens属性表示在生成文本时前置的token数量，completion_tokens属性表示在生成文本时后置的token数量。通过将这两个属性重置为0，可以确保在生成新的文本时不会受到之前生成文本的影响。\n\n**注意**：在使用该函数时需要注意以下几点：\n- 确保已经创建了tokenizer对象。\n- 重置prompt_tokens和completion_tokens属性后，生成的文本将不再受之前生成文本的影响。",
            "code_start_line": 42,
            "code_end_line": 44,
            "parent": "XTransformers",
            "have_return": false,
            "code_content": "    def reset(self):\n        self.tokenizer.prompt_tokens = 0\n        self.tokenizer.completion_tokens = 0\n",
            "name_column": 8
        },
        "add_logits_processor": {
            "type": "FunctionDef",
            "name": "add_logits_processor",
            "md_content": "**add_logits_processor函数**：该函数的作用是为模型添加logits处理器。\n\n在该函数中，首先从generate_kwargs参数中获取temperature、repetition_penalty、top_p和top_k等参数的值。然后，调用prepare_logits_processor函数，根据获取的参数值创建logits处理器。最后，将创建的logits处理器赋值给self.logits_processor属性。\n\n在项目中，该函数被以下文件调用：\n文件路径：XAgentGen/xgen/parser/function_parser.py\n调用代码如下：\n```\ndef create_generator(self,model:models.XTransformers,function_info:Dict[str,Any],generate_params:Dict = {}):\n    \"\"\"\n    @param: model: transformer模型\n    @param: functions: 函数列表\n    @param: extra_argument: 额外参数的json\n    @param: function_call: 函数调用名称的json\n    @param: generate_params: 推理约束参数的字典\n    @return: 创建一个用于引导生成的生成器\n    \"\"\"    \n    extra_arguments = function_info.get(\"arguments\",None)\n    functions = function_info.get(\"functions\",None)\n    function_call = function_info.get(\"function_call\",None)\n    self.create_all_functions_model(extra_arguments,functions,function_call) \n    regex_list = self.models_to_regex()\n    self.model = model\n    # temperature and so on\n    self.model.add_logits_processor(generate_params)\n    self.generator = generate.multi_regex(self.model, regex_list,generate_params.get(\"max_tokens\"))\n    return self.generator\n```\n[此处为代码片段结束]\n[此处为XAgentGen/xgen/parser/function_parser.py文件结束]\n\n**注意**：在使用该代码时需要注意以下几点：\n- generate_kwargs参数中的temperature、repetition_penalty、top_p和top_k等参数需要根据实际情况进行设置。\n- 通过调用add_logits_processor函数，可以为模型添加logits处理器，从而对生成的结果进行处理。",
            "code_start_line": 46,
            "code_end_line": 57,
            "parent": "XTransformers",
            "have_return": false,
            "code_content": "    def add_logits_processor(self,generate_kwargs:dict={}):\n\n        temperature = float(generate_kwargs.get(\"temperature\", 1.0))\n        repetition_penalty = float(generate_kwargs.get(\"repetition_penalty\", 1.0))\n        top_p = float(generate_kwargs.get(\"top_p\", 1.0))\n        top_k = int(generate_kwargs.get(\"top_k\", -1))  # -1 means disable\n\n        logits_processor = prepare_logits_processor(\n            temperature, repetition_penalty, top_p, top_k\n        )\n\n        self.logits_processor = logits_processor\n",
            "name_column": 8
        },
        "forward": {
            "type": "FunctionDef",
            "name": "forward",
            "md_content": "**forward函数**：该函数的功能是对输入进行前向传播计算。\n\n该函数接受以下参数：\n- input_ids: torch.LongTensor类型的输入张量，表示输入的token序列。\n- attention_mask: torch.LongTensor类型的输入张量，表示输入的attention mask。\n- past_key_values: 可选参数，表示过去的键值对。默认为None。\n\n该函数的返回值是一个元组，包含两个元素：\n- next_token_logits: torch.FloatTensor类型的输出张量，表示下一个token的logits。\n- output_past_key_values: 可选参数，表示输出的过去的键值对。默认为None。\n\n在函数内部，首先调用了父类的forward函数，传入输入参数input_ids、attention_mask和past_key_values，得到next_token_logits和output_past_key_values。\n\n接下来，如果存在logits_processor，则调用logits_processor对next_token_logits进行处理。\n\n最后，返回next_token_logits和output_past_key_values。\n\n**注意**：关于代码使用的注意事项\n\n**输出示例**：模拟代码返回值的可能外观。\n\n请注意：\n- 生成的内容中不应包含Markdown的标题和分隔符语法。\n- 主要使用中文编写。如果需要，可以在分析和描述中使用一些英文单词，以提高文档的可读性，因为不需要将函数名或变量名翻译为目标语言。",
            "code_start_line": 59,
            "code_end_line": 71,
            "parent": "XTransformers",
            "have_return": true,
            "code_content": "    def forward(\n        self,\n        input_ids: torch.LongTensor,\n        attention_mask: torch.LongTensor,\n        past_key_values: Optional[Tuple] = None,\n    ) -> Tuple[torch.FloatTensor, Optional[KVCacheType]]:\n        \n        next_token_logits, output_past_key_values = super().forward(input_ids,attention_mask,past_key_values)\n        \n        if self.logits_processor:\n            next_token_logits = self.logits_processor(input_ids,next_token_logits)\n       \n        return next_token_logits, output_past_key_values\n",
            "name_column": 8
        }
    },
    "XAgentGen/xgen/models/__init__.py": {},
    "XAgentGen/xgen/parser/function_parser.py": {
        "FunctionParser": {
            "type": "ClassDef",
            "name": "FunctionParser",
            "md_content": "**FunctionParser类的功能**：FunctionParser类用于解析函数的参数和生成相应的Pydantic模型。\n\nFunctionParser类包含以下方法：\n\n- `__init__(self) -> None`：初始化函数，创建一个空的functionCallModels列表和regex_strs列表。\n\n- `create_total_model(cls)`：创建一个总模型TotalModel的类方法，返回TotalModel类。\n\n- `create_function_call_model(cls)`：创建一个函数调用模型FunctionCallModel的类方法，返回FunctionCallModel类。\n\n- `add_property(cls, model, prop_name, prop_type, required, default=None, constrain=None, multi_type=False)`：为模型添加属性的类方法，将属性信息添加到模型的fields中，并设置相应的验证规则。\n\n- `pre_process(cls, prop: Dict[str, Any])`：预处理属性的类方法，根据属性的类型和约束条件，将属性的类型转换为相应的字符串。\n\n- `create_list_item_model(cls, prop_json: Dict[str, Any], property_name: str) -> Union[BaseModel, str]`：创建列表项模型的类方法，根据属性的类型和约束条件，生成相应的Pydantic模型。\n\n- `create_multi_types(cls, property_name: str, type_list: List[Any]) -> List[Any]`：创建多类型模型的类方法，根据属性的类型列表，生成可用于union的类型列表。\n\n- `create_object_model(cls, object_item: Dict[str, Any], object_name: str, object_model: BaseModel = None) -> BaseModel`：创建对象模型的类方法，根据对象的属性信息，生成相应的Pydantic模型。\n\n- `add_function_model(cls, extra_arguments_json: Dict[str, Any], function_json: Dict[str, Any] = None)`：添加函数模型的类方法，根据函数的参数信息，生成相应的Pydantic模型。\n\n- `create_all_functions_model(self, extra_arguments: Dict[str, Any] = None, functions: list = None, function_call: Dict[str, Any] = None)`：创建所有函数模型的方法，根据额外参数、函数列表和函数调用信息，生成相应的Pydantic模型。\n\n- `models_to_regex(self)`：将模型转换为正则表达式的方法，将所有函数模型转换为对应的正则表达式字符串。\n\n- `context_ids_next_ids(self, context_ids: List[int])`：获取下一个有效标记的方法，根据当前生成的标记列表，返回下一个有效标记的索引列表。\n\n- `post_process(self, schema)`：后处理模式的方法，对模式进行一些额外的处理。\n\n- `create_generator(self, model: models.XTransformers, function_info: Dict[str, Any], generate_params: Dict = {})`：创建生成器的方法，根据模型、函数信息和生成参数，创建一个用于生成文本的生成器。\n\n- `check(self, call_info: str)`：检查函数调用信息的方法，验证函数调用信息的有效性。\n\n**注意**：在使用FunctionParser类时，需要注意以下几点：\n- 需要先调用`create_all_functions_model`方法来创建所有函数模型。\n- 在调用`create_generator`方法之前，需要先创建一个模型对象。\n- 在调用`check`方法之前，需要将函数调用信息转换为字符串格式。\n\n**输出示例**：\n```python\n# 示例代码\ndp = FunctionParser()\ndp.create_all_functions_model(extra_arguments, functions, function_call)\nregex_list = dp.models_to_regex()\nmodel = XTransformers(fake_model, outline_tokenizer)\ngenerator = generate.multi_regex(model, regex_list)\n```\n",
            "code_start_line": 36,
            "code_end_line": 370,
            "parent": null,
            "have_return": true,
            "code_content": "class FunctionParser:\n\n        def __init__(self) -> None:\n                self.functionCallModels = []\n                self.regex_strs = []\n        \n        @classmethod\n        def create_total_model(cls):\n                class TotalModel(BaseModel):\n                        pass\n                return TotalModel\n\n        @classmethod\n        def create_function_call_model(cls):\n                class FunctionCallModel(BaseModel):\n                        name:str\n                return FunctionCallModel\n        \n        @classmethod\n        def add_property(cls,model, prop_name, prop_type, required, default=None, constrain=None,multi_type = False):\n                field_info = model.__fields__\n                field_info[prop_name] = ModelField(name=prop_name,type_=prop_type,class_validators={},model_config=model.__config__,required=required,default=default)\n                if constrain is not None:\n                        field_info[prop_name].field_info.ge = constrain.get('minimum',None)\n                        field_info[prop_name].field_info.le = constrain.get('maximum',None)\n                        field_info[prop_name].field_info.min_length = constrain.get('minLength',None)\n                        field_info[prop_name].field_info.max_length = constrain.get('maxLength',None)\n                        field_info[prop_name].field_info.regex = constrain.get('regex',None)\n                \n                setattr(model, prop_name, field_info)\n\n                if required:\n                        setattr(model, f\"validate_{prop_name}\", validator(prop_name, pre=True, allow_reuse=True)(lambda v: v))\n                \n                model.__fields__ = field_info\n\n                return model\n        \n        @classmethod\n        def pre_process(cls,prop:Dict[str,Any]):\n                new_prop = prop\n                if type2type.get(prop[\"type\"],\"other type\") == list:\n                        item_type = type2type[prop[\"items\"][\"type\"]]\n                        if item_type == int:\n                                new_prop[\"type\"] = \"List[int]\"\n                        elif item_type == str:\n                                new_prop[\"type\"] = \"List[str]\"\n                        elif item_type == bool:\n                                new_prop[\"type\"] = \"List[bool]\"\n                        elif item_type == None:\n                                new_prop[\"type\"] = \"List[null]\"\n\n                return new_prop\n        \n        @classmethod\n        def create_list_item_model(cls,prop_json:Dict[str,Any],property_name:str)->Union[BaseModel,str]:\n                \"\"\"\n                @param: prop: the property which is a array\n                @param: prop_name: the name of array property\n                @param: object_model: do the inplace replace for pydantic model\n                @return: the pydantic model inherited from BaseModel or a str which describe the List[type]\n                \"\"\"\n                item = None\n                property_json = cls.pre_process(prop_json)\n                if property_json[\"items\"].get(\"type\",\"no type\") == \"object\":\n                        item = cls.create_object_model(property_json[\"items\"],property_name+\"_item\")\n                elif property_json[\"items\"].get(\"type\",\"no type\") == \"array\":\n                        item = cls.create_list_item_model(property_json[\"items\"],property_name+\"_arrayItem\")\n                        item = List[item]\n                else:\n                        item = type2type.get(property_json[\"items\"][\"type\"],str)\n                return item\n        @classmethod\n        def create_multi_types(cls,property_name:str,type_list:List[Any])->List[Any]:\n                \"\"\"\n                @param: type_list: a list of types of prop\n                @return: the list of available type(to be union later)\n                \"\"\"\n                new_type_list = []\n                for i,tp in enumerate(type_list):\n                        if not isinstance(tp,dict):\n                                new_type_list.append(type2type.get(tp,str))\n                        elif \"type\" not in tp.keys():\n                                continue\n                        elif tp[\"type\"] == \"object\":\n                                object_type = cls.create_object_model(tp,property_name + f\"_{i}_type_object\") \n                                new_type_list.append(object_type)\n                        elif tp[\"type\"] == \"array\":\n                                array_type = cls.create_list_item_model(tp,property_name + f\"_{i}_type_array\")\n                                new_type_list.append(List[array_type])\n\n                return new_type_list        \n\n\n        @classmethod\n        def create_object_model(cls,object_item:Dict[str,Any],object_name:str,object_model:BaseModel=None)->BaseModel:\n                \"\"\"\n                @param: object_item: the item which is a object(function[parameters]、property、extra_argument[parameters])\n                @param: object_name: the name of object item(for property loc)\n                @return: the object model inherited from BaseModel\n                \"\"\"\n                if object_model is None:\n                        object_model = create_model(object_name,__base__=BaseModel)\n                assert \"properties\" in object_item.keys()\n\n                properties = object_item[\"properties\"]\n                for property_name in properties.keys():\n                        property_json = properties[property_name]\n\n                        if isinstance(property_json[\"type\"],list):\n                                multi_type = cls.create_multi_types(property_name,property_json[\"type\"])\n                                if len(multi_type) > 1:\n                                        multi_type = Union[tuple(multi_type)] # type: ignore\n                                if \"required\" in object_item.keys():                          \n                                        if property_name not in object_item[\"required\"]:\n                                                if \"default\" in property_json.keys():\n                                                        object_model = cls.add_property(object_model,property_name,multi_type,required=False,default=property_json[\"default\"])\n                                                else: \n                                                        object_model = cls.add_property(object_model,property_name,multi_type,required=False)\n                                        else:\n                                                object_model = cls.add_property(object_model,property_name,multi_type,required=True,default=None)\n\n                                else:\n                                        if \"default\" in properties[property_name].keys():\n                                                object_model = cls.add_property(object_model,property_name,multi_type,required=False,default=property_json[\"default\"])\n                                        else:\n                                                object_model=  cls.add_property(object_model,property_name,multi_type,required=True)\n                        elif \"enum\" in property_json.keys():\n                                enum_name = property_name\n                                enum_values = {value: value for value in property_json['enum']}\n                                enumModel = Enum(enum_name, enum_values)\n                                if \"required\" in object_item.keys():\n                                        if property_name not in object_item[\"required\"]:\n                                                if \"default\" in property_json.keys():\n                                                        object_model = cls.add_property(object_model,enum_name,enumModel,required=False,default=property_json[\"default\"])\n                                                else:\n                                                        object_model = cls.add_property(object_model,enum_name,enumModel,required=False)\n\n                                        else:\n                                                object_model = cls.add_property(object_model,enum_name,enumModel,required=True)\n\n                                else:\n                                        if \"default\" in property_json.keys():\n                                                object_model = cls.add_property(object_model,enum_name,enumModel,required=False,default=property_json[\"default\"])\n                                        else:\n                                                object_model = cls.add_property(object_model,enum_name,enumModel,required=True)\n                        elif property_json[\"type\"] == \"array\":\n                                item = cls.create_list_item_model(property_json,property_name)\n                                if item is not None:\n                                        if \"required\" in object_item.keys():\n                                                if property_name not in object_item[\"required\"]:\n                                                        if \"default\" in property_json.keys():\n                                                                object_model = cls.add_property(object_model,property_name,List[item],required=False,default=property_json[\"default\"])\n                                                        else:\n                                                                object_model = cls.add_property(object_model,property_name,List[item],required=False)\n                                                else:\n                                                        object_model = cls.add_property(object_model,property_name,List[item],required=True)\n                                        else:\n                                                if \"default\" in property_json.keys():\n                                                        object_model = cls.add_property(object_model,property_name,List[item],required=False,default=property_json[\"default\"])\n                                                else:\n                                                        object_model = cls.add_property(object_model,property_name,List[item],required=True)\n\n                        elif property_json[\"type\"] == \"object\" and \"properties\" in property_json.keys():\n                                object_property_model = cls.create_object_model(property_json,property_name)\n                                if \"required\" in object_item.keys():\n                                        if property_name not in object_item[\"required\"]:\n                                                if \"default\" in property_json.keys():\n                                                        object_model = cls.add_property(object_model,property_name,object_property_model,required=False,default=property_json[\"default\"])\n                                                else:\n                                                        object_model = cls.add_property(object_model,property_name,object_property_model,required=False)\n                                        else:\n                                                object_model = cls.add_property(object_model,property_name,object_property_model,required=True)\n                                else:\n                                        if \"default\" in property_json.keys():\n                                                object_model = cls.add_property(object_model,property_name,object_property_model,required=False,default=property_json[\"default\"])\n                                        else:\n                                                object_model = cls.add_property(object_model,property_name,object_property_model,required=True)\n\n                        else:   \n                                constrain = \\\n                                {\n                                        \"maxLength\":property_json.get(\"maxLength\",None),\n                                        \"minLength\":property_json.get(\"minLength\",None),\n                                        \"maximum\":property_json.get(\"maximum\",None),\n                                        \"minimum\":property_json.get(\"minimum\",None)        \n                                }\n                                if \"required\" in object_item.keys():                          \n                                        if property_name not in object_item[\"required\"]:\n                                                if \"default\" in property_json.keys():\n                                                        object_model = cls.add_property(object_model,property_name,type2type.get(property_json[\"type\"],str),required=False,default=property_json[\"default\"],constrain=constrain)\n                                                else:\n                                                        object_model = cls.add_property(object_model,property_name,type2type.get(property_json[\"type\"],str),required=False,constrain=constrain)\n                                        else:\n                                                object_model = cls.add_property(object_model,property_name,type2type.get(property_json[\"type\"],str),required=True,default=None,constrain=constrain)\n\n                                else:\n                                        if \"default\" in properties[property_name].keys():\n                                                object_model = cls.add_property(object_model,property_name,type2type.get(property_json[\"type\"],str),required=False,default=property_json[\"default\"],constrain=constrain)\n                                        else:\n                                                object_model=  cls.add_property(object_model,property_name,type2type.get(property_json[\"type\"],str),required=True,constrain=constrain)\n\n                return object_model\n\n        @classmethod\n        def add_function_model(cls,extra_arguments_json:Dict[str,Any],function_json:Dict[str,Any]=None):\n                \"\"\"\n                @param: function: the single function to generate a pydantic model\n                @param: extra_arguments: the extra arguments\n                \"\"\"\n                extra_arguments = copy.deepcopy(extra_arguments_json)\n                extra_argumentModel = None\n                if extra_arguments is not None and \"properties\" in extra_arguments.keys():  \n                        extra_argumentModel = cls.create_object_model(extra_arguments,\"ExtraArgumentModel\",extra_argumentModel)\n                \n                functionCallModel = None\n                if function_json is not None:\n                        function = copy.deepcopy(function_json)\n                        parameters = function[\"parameters\"]\n                        if \"properties\" in parameters.keys():\n                                argumentModel = cls.create_object_model(parameters,\"ArgumentModel\") \n\n                        functionCallModel = cls.create_function_call_model()\n                        functionCallModel = cls.add_property(functionCallModel,\"name\",str,required=True,constrain={\"regex\":function[\"name\"]})\n                        if argumentModel is not None:\n                                functionCallModel = cls.add_property(functionCallModel,\"arguments\",argumentModel,required=True)\n                totalModel = cls.create_total_model()\n                if extra_argumentModel is not None:\n                        totalModel = cls.add_property(totalModel,\"arguments\",extra_argumentModel,required=True)\n                if functionCallModel is not None:\n                        totalModel = cls.add_property(totalModel,\"function_call\",functionCallModel,required=True)\n                return totalModel      \n          \n        \n        def create_all_functions_model(self,extra_arguments:Dict[str,Any]=None,functions:list=None,function_call:Dict[str,Any]=None):\n                \"\"\"\n                @param: functions: a list of functions\n                @param: extra_argument: a json of extra_arguments\n                @param: function_call: a json of function call\n                \"\"\" \n                self.functionCallModels = []\n                if  functions is None or len(functions)==0:\n                        self.functionCallModels.append(self.add_function_model(extra_arguments))\n                        return\n                for function in functions:\n                        if function_call is not None and \"name\" in function_call.keys():\n                                if  function_call[\"name\"] == function[\"name\"]:\n                                        self.functionCallModels.append(self.add_function_model(extra_arguments,function))\n                                        return\n                        else:\n                                self.functionCallModels.append(self.add_function_model(extra_arguments,function))\n\n\n        def models_to_regex(self):\n                self.regex_strs = []\n                for function in self.functionCallModels:\n                    if hasattr(function, \"model_json_schema\"):\n                        json_schema = function.model_json_schema()\n                    else: \n                        json_schema = function.schema()\n\n                    json_schema = self.post_process(json_schema)\n                    schema = json.dumps(json_schema)\n                    self.regex_strs.append(build_regex_from_object(schema))\n                return self.regex_strs\n\n\n        def context_ids_next_ids(self,context_ids:List[int]):\n                \"\"\"\n                @param: context_ids: the ids of generated tokens (list[list[int]])\n                @return: valid_ids: the valid ids of next token (list[list[int]])\n                \"\"\"\n                # you should empty the pstates every times except you input all context in order)\n                self.generator.pstates = []\n                import traceback\n                logits = torch.ones(len(self.model.tokenizer.vocabulary)).to(self.model.device)\n                # masked_logits \n                try:\n                        masked_logits = self.generator.create_proposal(torch.tensor([context_ids]).to(self.model.device), logits)\n                        # valid indexes\n                        non_inf_indices = torch.nonzero(masked_logits != -math.inf).squeeze(dim=1)\n                        non_inf_indices = non_inf_indices[:,1]\n                        non_inf_indices = non_inf_indices.tolist()\n                except Exception as e:\n                        print(\"no available path\")\n                        non_inf_indices = []\n                return non_inf_indices\n\n\n        def post_process(self,schema):   \n                com_schema = schema\n                if \"definitions\" in com_schema.keys():\n                        for prop in com_schema[\"definitions\"].keys():\n                                if \"type\" not in com_schema[\"definitions\"][prop].keys():\n                                        com_schema[\"definitions\"][prop][\"type\"]=\"string\"\n                \n                return com_schema\n\n        def create_generator(self,model:models.XTransformers,function_info:Dict[str,Any],generate_params:Dict = {}):\n                \"\"\"\n                @param: model: the transformer model\n                @param: functions: a list of functions\n                @param: extra_argument: a json of extra_arguments\n                @param: function_call: a json of function call name\n                @param: generate_params: a dict of inference constraint arguments\n                @return: create a generator for guided generate\n                \"\"\"    \n                extra_arguments = function_info.get(\"arguments\",None)\n                functions = function_info.get(\"functions\",None)\n                function_call = function_info.get(\"function_call\",None)\n                self.create_all_functions_model(extra_arguments,functions,function_call) \n                regex_list = self.models_to_regex()\n                self.model = model\n                # temperature and so on\n                self.model.add_logits_processor(generate_params)\n                self.generator = generate.multi_regex(self.model, regex_list,generate_params.get(\"max_tokens\"))\n                return self.generator\n        \n        def check(self,call_info:str):\n                \"\"\"\n                @param: function: the dynamic BaseModel generated for specified function\n                \"\"\"\n                try:\n                        call_info_json = json.loads(call_info)\n                except Exception:\n                        return False\n                if \"name\" not in call_info_json.keys():\n                        return False\n                if \"arguments\" not in call_info_json.keys():\n                        return False\n                try:\n                        self.functionCallModel.model_validate_json(call_info)\n                except Exception:\n                        return False\n                return True\n",
            "name_column": 6
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__函数**：这个函数的功能是初始化一个Function对象。\n\n在这个函数中，有两个实例变量：\n- functionCallModels：一个空列表，用于存储函数调用模型。\n- regex_strs：一个空列表，用于存储正则表达式字符串。\n\n这个函数没有参数，也没有返回值。\n\n**注意**：在使用这段代码时需要注意以下几点：\n- 这个函数只是用来初始化一个Function对象，没有其他具体的功能。\n- 在使用这个对象之前，需要先调用其他函数来添加函数调用模型和正则表达式字符串。",
            "code_start_line": 38,
            "code_end_line": 40,
            "parent": "FunctionParser",
            "have_return": false,
            "code_content": "        def __init__(self) -> None:\n                self.functionCallModels = []\n                self.regex_strs = []\n",
            "name_column": 12
        },
        "create_total_model": {
            "type": "FunctionDef",
            "name": "create_total_model",
            "md_content": "**create_total_model函数**：这个函数的作用是创建一个TotalModel对象。\n\n在代码中，create_total_model函数定义了一个内部类TotalModel，它继承自BaseModel。然后，函数返回了TotalModel的一个实例。\n\n**注意**：这个函数没有参数，它只是简单地创建并返回一个TotalModel对象。\n\n**输出示例**：假设代码的返回值如下所示：\n\n```\nclass TotalModel(BaseModel):\n    pass\n```\n\n这个示例展示了一个TotalModel对象的定义，它继承自BaseModel。",
            "code_start_line": 43,
            "code_end_line": 46,
            "parent": "FunctionParser",
            "have_return": true,
            "code_content": "        def create_total_model(cls):\n                class TotalModel(BaseModel):\n                        pass\n                return TotalModel\n",
            "name_column": 12
        },
        "create_function_call_model": {
            "type": "FunctionDef",
            "name": "create_function_call_model",
            "md_content": "**create_function_call_model函数**：这个函数的作用是创建一个FunctionCallModel对象。\n\n在XAgentGen/xgen/parser/function_parser.py文件中，create_function_call_model函数定义如下：\n```python\ndef create_function_call_model(cls):\n    class FunctionCallModel(BaseModel):\n        name:str\n    return FunctionCallModel\n```\n\n**代码分析和描述**：\ncreate_function_call_model函数是一个类方法，它接受一个参数cls。这个函数的目的是创建一个名为FunctionCallModel的类，并返回该类的实例。\n\n在函数内部，我们定义了一个继承自BaseModel的类FunctionCallModel。这个类只有一个属性name，它的类型是str。\n\n最后，函数返回了FunctionCallModel类的实例。\n\n**注意**：这个函数的返回值是一个FunctionCallModel对象。\n\n**输出示例**：下面是一个可能的返回值的示例：\n```python\nclass FunctionCallModel(BaseModel):\n    name: str\n```\n这个示例展示了一个FunctionCallModel对象的结构，它只有一个name属性，类型为str。",
            "code_start_line": 49,
            "code_end_line": 52,
            "parent": "FunctionParser",
            "have_return": true,
            "code_content": "        def create_function_call_model(cls):\n                class FunctionCallModel(BaseModel):\n                        name:str\n                return FunctionCallModel\n",
            "name_column": 12
        },
        "add_property": {
            "type": "FunctionDef",
            "name": "add_property",
            "md_content": "**add_property函数**：该函数的功能是向模型中添加属性。\n\n该函数接受以下参数：\n- cls：类对象\n- model：模型对象\n- prop_name：属性名称\n- prop_type：属性类型\n- required：属性是否必需\n- default：属性的默认值（可选）\n- constrain：属性的约束条件（可选）\n- multi_type：属性是否允许多种类型（可选）\n\n该函数的作用是向模型中添加一个新的属性。首先，通过访问模型的__fields__属性，获取模型的字段信息。然后，创建一个新的ModelField对象，并将其添加到字段信息中。ModelField对象包含属性的名称、类型、验证器等信息。如果约束条件不为空，则将约束条件中的最小值、最大值、最小长度、最大长度和正则表达式分别赋值给ModelField对象的相应属性。\n\n接下来，使用setattr函数将属性添加到模型中。如果属性是必需的，则还会添加一个名为validate_{prop_name}的验证器函数，该函数用于验证属性的值。最后，将更新后的字段信息重新赋值给模型的__fields__属性。\n\n该函数的返回值是更新后的模型对象。\n\n**注意**：使用该函数时需要注意以下几点：\n- 需要确保传入的模型对象具有__fields__属性。\n- 如果属性是必需的，需要确保传入的模型对象具有validate_{prop_name}的验证器函数。\n\n**输出示例**：假设我们有一个模型对象model，我们可以使用add_property函数向该模型中添加一个名为prop_name的属性。调用add_property函数后，模型对象model的__fields__属性将被更新，新的属性将被添加到模型中。",
            "code_start_line": 55,
            "code_end_line": 72,
            "parent": "FunctionParser",
            "have_return": true,
            "code_content": "        def add_property(cls,model, prop_name, prop_type, required, default=None, constrain=None,multi_type = False):\n                field_info = model.__fields__\n                field_info[prop_name] = ModelField(name=prop_name,type_=prop_type,class_validators={},model_config=model.__config__,required=required,default=default)\n                if constrain is not None:\n                        field_info[prop_name].field_info.ge = constrain.get('minimum',None)\n                        field_info[prop_name].field_info.le = constrain.get('maximum',None)\n                        field_info[prop_name].field_info.min_length = constrain.get('minLength',None)\n                        field_info[prop_name].field_info.max_length = constrain.get('maxLength',None)\n                        field_info[prop_name].field_info.regex = constrain.get('regex',None)\n                \n                setattr(model, prop_name, field_info)\n\n                if required:\n                        setattr(model, f\"validate_{prop_name}\", validator(prop_name, pre=True, allow_reuse=True)(lambda v: v))\n                \n                model.__fields__ = field_info\n\n                return model\n",
            "name_column": 12
        },
        "pre_process": {
            "type": "FunctionDef",
            "name": "pre_process",
            "md_content": "**pre_process函数**：这个函数的功能是对传入的属性进行预处理。\n\n在这个函数中，首先将传入的属性赋值给新的属性new_prop。然后判断属性的类型是否为列表，如果是列表类型，则进一步判断列表中元素的类型，并将属性的类型进行相应的替换。如果元素类型是int，则将属性的类型替换为\"List[int]\"；如果元素类型是str，则将属性的类型替换为\"List[str]\"；如果元素类型是bool，则将属性的类型替换为\"List[bool]\"；如果元素类型是None，则将属性的类型替换为\"List[null]\"。最后返回处理后的属性new_prop。\n\n**注意**：在使用这段代码时需要注意以下几点：\n- 传入的属性prop必须是一个字典类型。\n- 属性的类型必须是列表类型，且列表中的元素类型必须在type2type字典中有对应的映射关系。\n\n**输出示例**：假设传入的属性prop为{\"type\": \"array\", \"items\": {\"type\": \"int\"}}，经过pre_process函数处理后，返回的属性new_prop为{\"type\": \"List[int]\"}。",
            "code_start_line": 75,
            "code_end_line": 88,
            "parent": "FunctionParser",
            "have_return": true,
            "code_content": "        def pre_process(cls,prop:Dict[str,Any]):\n                new_prop = prop\n                if type2type.get(prop[\"type\"],\"other type\") == list:\n                        item_type = type2type[prop[\"items\"][\"type\"]]\n                        if item_type == int:\n                                new_prop[\"type\"] = \"List[int]\"\n                        elif item_type == str:\n                                new_prop[\"type\"] = \"List[str]\"\n                        elif item_type == bool:\n                                new_prop[\"type\"] = \"List[bool]\"\n                        elif item_type == None:\n                                new_prop[\"type\"] = \"List[null]\"\n\n                return new_prop\n",
            "name_column": 12
        },
        "create_list_item_model": {
            "type": "FunctionDef",
            "name": "create_list_item_model",
            "md_content": "**create_list_item_model函数**：这个函数的功能是根据给定的属性JSON和属性名称创建一个列表项模型。\n\n该函数接受三个参数：\n- prop_json：属性的JSON表示，包含属性的类型和其他信息。\n- property_name：属性的名称。\n- object_model：用于进行原地替换的Pydantic模型。\n\n该函数的返回值可以是继承自BaseModel的Pydantic模型，也可以是描述List[type]的字符串。\n\n函数的详细分析和描述如下：\n- 首先，对属性的JSON进行预处理，以确保属性的一致性和完整性。\n- 然后，根据属性的类型进行判断：\n  - 如果属性的类型是\"object\"，则调用create_object_model函数创建一个对象模型，并将其命名为property_name+\"_item\"。\n  - 如果属性的类型是\"array\"，则递归调用create_list_item_model函数创建一个列表项模型，并将其命名为property_name+\"_arrayItem\"。然后，将列表项模型包装在List中。\n  - 如果属性的类型不是\"object\"或\"array\"，则根据type2type字典将属性的类型转换为相应的Python类型。\n- 最后，返回创建的模型。\n\n**注意**：在使用该函数时需要注意以下几点：\n- 传入的属性JSON应包含\"type\"字段，用于判断属性的类型。\n- 如果属性的类型是\"array\"，则属性的JSON应包含\"items\"字段，用于描述列表项的类型。\n\n**输出示例**：模拟代码返回值的可能外观。\n- 如果属性的类型是\"object\"，则返回一个继承自BaseModel的对象模型。\n- 如果属性的类型是\"array\"，则返回一个描述List[type]的字符串。\n- 如果属性的类型不是\"object\"或\"array\"，则返回一个Python类型。\n\n请注意：\n- 生成的文档内容中不应包含Markdown的标题和分隔符语法。\n- 文档主要使用中文编写，如果需要，可以在分析和描述中使用一些英文单词以增强文档的可读性，因为不需要将函数名或变量名翻译为目标语言。",
            "code_start_line": 91,
            "code_end_line": 107,
            "parent": "FunctionParser",
            "have_return": true,
            "code_content": "        def create_list_item_model(cls,prop_json:Dict[str,Any],property_name:str)->Union[BaseModel,str]:\n                \"\"\"\n                @param: prop: the property which is a array\n                @param: prop_name: the name of array property\n                @param: object_model: do the inplace replace for pydantic model\n                @return: the pydantic model inherited from BaseModel or a str which describe the List[type]\n                \"\"\"\n                item = None\n                property_json = cls.pre_process(prop_json)\n                if property_json[\"items\"].get(\"type\",\"no type\") == \"object\":\n                        item = cls.create_object_model(property_json[\"items\"],property_name+\"_item\")\n                elif property_json[\"items\"].get(\"type\",\"no type\") == \"array\":\n                        item = cls.create_list_item_model(property_json[\"items\"],property_name+\"_arrayItem\")\n                        item = List[item]\n                else:\n                        item = type2type.get(property_json[\"items\"][\"type\"],str)\n                return item\n",
            "name_column": 12
        },
        "create_multi_types": {
            "type": "FunctionDef",
            "name": "create_multi_types",
            "md_content": "**create_multi_types函数**：这个函数的作用是根据给定的类型列表创建多个类型，并返回可用的类型列表（稍后将进行合并）。\n\n该函数接受两个参数：\n- property_name：属性的名称，字符串类型。\n- type_list：属性的类型列表，List[Any]类型。\n\n该函数的返回值是一个列表，包含了所有可用的类型。\n\n该函数的具体实现如下：\n1. 创建一个空的新类型列表new_type_list。\n2. 使用enumerate函数遍历type_list中的每个元素，其中i是元素的索引，tp是元素的值。\n3. 判断tp的类型是否为字典，如果不是，则将tp转换为对应的类型并添加到new_type_list中。\n4. 如果tp是字典，并且字典中包含\"type\"键，则根据\"type\"的值进行不同的处理：\n   - 如果\"type\"的值是\"object\"，则调用create_object_model函数创建一个对象类型，并将其添加到new_type_list中。\n   - 如果\"type\"的值是\"array\"，则调用create_list_item_model函数创建一个数组类型的元素，并将其添加到new_type_list中。\n5. 返回new_type_list作为函数的结果。\n\n**注意**：在处理type_list中的每个元素时，根据元素的类型进行不同的处理，可以创建不同的类型，并将其添加到new_type_list中。\n\n**输出示例**：\n假设type_list为[\"int\", {\"type\": \"object\"}, {\"type\": \"array\"}]，则函数的返回值为[int, object, List]。",
            "code_start_line": 109,
            "code_end_line": 127,
            "parent": "FunctionParser",
            "have_return": true,
            "code_content": "        def create_multi_types(cls,property_name:str,type_list:List[Any])->List[Any]:\n                \"\"\"\n                @param: type_list: a list of types of prop\n                @return: the list of available type(to be union later)\n                \"\"\"\n                new_type_list = []\n                for i,tp in enumerate(type_list):\n                        if not isinstance(tp,dict):\n                                new_type_list.append(type2type.get(tp,str))\n                        elif \"type\" not in tp.keys():\n                                continue\n                        elif tp[\"type\"] == \"object\":\n                                object_type = cls.create_object_model(tp,property_name + f\"_{i}_type_object\") \n                                new_type_list.append(object_type)\n                        elif tp[\"type\"] == \"array\":\n                                array_type = cls.create_list_item_model(tp,property_name + f\"_{i}_type_array\")\n                                new_type_list.append(List[array_type])\n\n                return new_type_list        \n",
            "name_column": 12
        },
        "create_object_model": {
            "type": "FunctionDef",
            "name": "create_object_model",
            "md_content": "**create_object_model函数**：这个函数的作用是根据给定的对象信息，创建一个继承自BaseModel的对象模型。\n\n该函数接受以下参数：\n- object_item: 对象的信息，可以是函数的参数、属性或额外参数的参数。\n- object_name: 对象的名称，用于属性定位。\n- object_model: 可选参数，已存在的对象模型。\n\n该函数的返回值是一个继承自BaseModel的对象模型。\n\n该函数的详细分析和描述如下：\n- 首先，如果object_model参数为空，则创建一个以object_name为名称、继承自BaseModel的对象模型。\n- 然后，检查object_item中是否包含\"properties\"键，如果不包含则抛出异常。\n- 遍历object_item中的每个属性，获取属性的名称和属性的JSON信息。\n- 对于属性的类型为列表的情况，调用create_multi_types函数创建多个可选类型，并将它们合并为Union类型。根据object_item中是否包含\"required\"键，决定是否将属性设置为必需属性，并根据是否存在\"default\"键来设置默认值。\n- 对于属性的类型为枚举的情况，根据枚举值创建一个Enum模型，并根据object_item中是否包含\"required\"键来设置是否为必需属性。\n- 对于属性的类型为数组的情况，调用create_list_item_model函数创建数组元素的模型，并根据object_item中是否包含\"required\"键来设置是否为必需属性。\n- 对于属性的类型为对象的情况，递归调用create_object_model函数创建对象的模型，并根据object_item中是否包含\"required\"键来设置是否为必需属性。\n- 对于其他类型的属性，根据属性的JSON信息中的约束条件，如最大长度、最小长度、最大值、最小值等，创建属性的模型，并根据object_item中是否包含\"required\"键来设置是否为必需属性。\n- 最后，返回创建的对象模型。\n\n**注意**：使用该代码时需要注意以下几点：\n- object_item参数必须包含\"properties\"键，否则会抛出异常。\n- object_item中的属性类型可以是单个类型，也可以是多个类型的列表。\n- 对象模型的属性可以是基本类型、枚举类型、数组类型或对象类型。\n- 对象模型的属性可以设置为必需属性，并可以设置默认值。\n- 对象模型的属性可以设置约束条件，如最大长度、最小长度、最大值、最小值等。\n\n**输出示例**：模拟代码返回值的可能外观。\n```python\nobject_model = create_object_model(object_item, object_name, object_model)\n```",
            "code_start_line": 131,
            "code_end_line": 238,
            "parent": "FunctionParser",
            "have_return": true,
            "code_content": "        def create_object_model(cls,object_item:Dict[str,Any],object_name:str,object_model:BaseModel=None)->BaseModel:\n                \"\"\"\n                @param: object_item: the item which is a object(function[parameters]、property、extra_argument[parameters])\n                @param: object_name: the name of object item(for property loc)\n                @return: the object model inherited from BaseModel\n                \"\"\"\n                if object_model is None:\n                        object_model = create_model(object_name,__base__=BaseModel)\n                assert \"properties\" in object_item.keys()\n\n                properties = object_item[\"properties\"]\n                for property_name in properties.keys():\n                        property_json = properties[property_name]\n\n                        if isinstance(property_json[\"type\"],list):\n                                multi_type = cls.create_multi_types(property_name,property_json[\"type\"])\n                                if len(multi_type) > 1:\n                                        multi_type = Union[tuple(multi_type)] # type: ignore\n                                if \"required\" in object_item.keys():                          \n                                        if property_name not in object_item[\"required\"]:\n                                                if \"default\" in property_json.keys():\n                                                        object_model = cls.add_property(object_model,property_name,multi_type,required=False,default=property_json[\"default\"])\n                                                else: \n                                                        object_model = cls.add_property(object_model,property_name,multi_type,required=False)\n                                        else:\n                                                object_model = cls.add_property(object_model,property_name,multi_type,required=True,default=None)\n\n                                else:\n                                        if \"default\" in properties[property_name].keys():\n                                                object_model = cls.add_property(object_model,property_name,multi_type,required=False,default=property_json[\"default\"])\n                                        else:\n                                                object_model=  cls.add_property(object_model,property_name,multi_type,required=True)\n                        elif \"enum\" in property_json.keys():\n                                enum_name = property_name\n                                enum_values = {value: value for value in property_json['enum']}\n                                enumModel = Enum(enum_name, enum_values)\n                                if \"required\" in object_item.keys():\n                                        if property_name not in object_item[\"required\"]:\n                                                if \"default\" in property_json.keys():\n                                                        object_model = cls.add_property(object_model,enum_name,enumModel,required=False,default=property_json[\"default\"])\n                                                else:\n                                                        object_model = cls.add_property(object_model,enum_name,enumModel,required=False)\n\n                                        else:\n                                                object_model = cls.add_property(object_model,enum_name,enumModel,required=True)\n\n                                else:\n                                        if \"default\" in property_json.keys():\n                                                object_model = cls.add_property(object_model,enum_name,enumModel,required=False,default=property_json[\"default\"])\n                                        else:\n                                                object_model = cls.add_property(object_model,enum_name,enumModel,required=True)\n                        elif property_json[\"type\"] == \"array\":\n                                item = cls.create_list_item_model(property_json,property_name)\n                                if item is not None:\n                                        if \"required\" in object_item.keys():\n                                                if property_name not in object_item[\"required\"]:\n                                                        if \"default\" in property_json.keys():\n                                                                object_model = cls.add_property(object_model,property_name,List[item],required=False,default=property_json[\"default\"])\n                                                        else:\n                                                                object_model = cls.add_property(object_model,property_name,List[item],required=False)\n                                                else:\n                                                        object_model = cls.add_property(object_model,property_name,List[item],required=True)\n                                        else:\n                                                if \"default\" in property_json.keys():\n                                                        object_model = cls.add_property(object_model,property_name,List[item],required=False,default=property_json[\"default\"])\n                                                else:\n                                                        object_model = cls.add_property(object_model,property_name,List[item],required=True)\n\n                        elif property_json[\"type\"] == \"object\" and \"properties\" in property_json.keys():\n                                object_property_model = cls.create_object_model(property_json,property_name)\n                                if \"required\" in object_item.keys():\n                                        if property_name not in object_item[\"required\"]:\n                                                if \"default\" in property_json.keys():\n                                                        object_model = cls.add_property(object_model,property_name,object_property_model,required=False,default=property_json[\"default\"])\n                                                else:\n                                                        object_model = cls.add_property(object_model,property_name,object_property_model,required=False)\n                                        else:\n                                                object_model = cls.add_property(object_model,property_name,object_property_model,required=True)\n                                else:\n                                        if \"default\" in property_json.keys():\n                                                object_model = cls.add_property(object_model,property_name,object_property_model,required=False,default=property_json[\"default\"])\n                                        else:\n                                                object_model = cls.add_property(object_model,property_name,object_property_model,required=True)\n\n                        else:   \n                                constrain = \\\n                                {\n                                        \"maxLength\":property_json.get(\"maxLength\",None),\n                                        \"minLength\":property_json.get(\"minLength\",None),\n                                        \"maximum\":property_json.get(\"maximum\",None),\n                                        \"minimum\":property_json.get(\"minimum\",None)        \n                                }\n                                if \"required\" in object_item.keys():                          \n                                        if property_name not in object_item[\"required\"]:\n                                                if \"default\" in property_json.keys():\n                                                        object_model = cls.add_property(object_model,property_name,type2type.get(property_json[\"type\"],str),required=False,default=property_json[\"default\"],constrain=constrain)\n                                                else:\n                                                        object_model = cls.add_property(object_model,property_name,type2type.get(property_json[\"type\"],str),required=False,constrain=constrain)\n                                        else:\n                                                object_model = cls.add_property(object_model,property_name,type2type.get(property_json[\"type\"],str),required=True,default=None,constrain=constrain)\n\n                                else:\n                                        if \"default\" in properties[property_name].keys():\n                                                object_model = cls.add_property(object_model,property_name,type2type.get(property_json[\"type\"],str),required=False,default=property_json[\"default\"],constrain=constrain)\n                                        else:\n                                                object_model=  cls.add_property(object_model,property_name,type2type.get(property_json[\"type\"],str),required=True,constrain=constrain)\n\n                return object_model\n",
            "name_column": 12
        },
        "add_function_model": {
            "type": "FunctionDef",
            "name": "add_function_model",
            "md_content": "**add_function_model函数**：此函数的功能是生成一个pydantic模型。\n\n该函数接受两个参数：\n- extra_arguments_json：额外的参数，为字典类型。\n- function_json：函数的json表示，为字典类型，默认为None。\n\n函数内部逻辑如下：\n1. 首先，将extra_arguments_json进行深拷贝，得到extra_arguments变量。\n2. 判断extra_arguments是否为None，并且判断extra_arguments中是否包含\"properties\"键。如果是，则调用create_object_model函数生成ExtraArgumentModel模型，并将其赋值给extra_argumentModel变量。\n3. 判断function_json是否为None。如果不是，则进行以下操作：\n   - 深拷贝function_json，得到function变量。\n   - 获取function中的parameters字段，并判断其中是否包含\"properties\"键。如果是，则调用create_object_model函数生成ArgumentModel模型，并将其赋值给argumentModel变量。\n   - 调用create_function_call_model函数生成functionCallModel模型。\n   - 调用add_property函数，为functionCallModel添加\"name\"属性，属性类型为str，必填项，约束为{\"regex\":function[\"name\"]}。\n   - 如果argumentModel不为None，则调用add_property函数，为functionCallModel添加\"arguments\"属性，属性类型为argumentModel，必填项。\n4. 调用create_total_model函数生成totalModel模型。\n5. 如果extra_argumentModel不为None，则调用add_property函数，为totalModel添加\"arguments\"属性，属性类型为extra_argumentModel，必填项。\n6. 如果functionCallModel不为None，则调用add_property函数，为totalModel添加\"function_call\"属性，属性类型为functionCallModel，必填项。\n7. 返回totalModel。\n\n**注意**：使用此代码时需要注意以下几点：\n- extra_arguments_json和function_json参数的格式必须符合要求。\n- 在调用add_function_model函数之前，需要先调用create_object_model、create_function_call_model、add_property和create_total_model等函数。\n\n**输出示例**：模拟代码返回值的可能外观。",
            "code_start_line": 241,
            "code_end_line": 267,
            "parent": "FunctionParser",
            "have_return": true,
            "code_content": "        def add_function_model(cls,extra_arguments_json:Dict[str,Any],function_json:Dict[str,Any]=None):\n                \"\"\"\n                @param: function: the single function to generate a pydantic model\n                @param: extra_arguments: the extra arguments\n                \"\"\"\n                extra_arguments = copy.deepcopy(extra_arguments_json)\n                extra_argumentModel = None\n                if extra_arguments is not None and \"properties\" in extra_arguments.keys():  \n                        extra_argumentModel = cls.create_object_model(extra_arguments,\"ExtraArgumentModel\",extra_argumentModel)\n                \n                functionCallModel = None\n                if function_json is not None:\n                        function = copy.deepcopy(function_json)\n                        parameters = function[\"parameters\"]\n                        if \"properties\" in parameters.keys():\n                                argumentModel = cls.create_object_model(parameters,\"ArgumentModel\") \n\n                        functionCallModel = cls.create_function_call_model()\n                        functionCallModel = cls.add_property(functionCallModel,\"name\",str,required=True,constrain={\"regex\":function[\"name\"]})\n                        if argumentModel is not None:\n                                functionCallModel = cls.add_property(functionCallModel,\"arguments\",argumentModel,required=True)\n                totalModel = cls.create_total_model()\n                if extra_argumentModel is not None:\n                        totalModel = cls.add_property(totalModel,\"arguments\",extra_argumentModel,required=True)\n                if functionCallModel is not None:\n                        totalModel = cls.add_property(totalModel,\"function_call\",functionCallModel,required=True)\n                return totalModel      \n",
            "name_column": 12
        },
        "create_all_functions_model": {
            "type": "FunctionDef",
            "name": "create_all_functions_model",
            "md_content": "**create_all_functions_model函数**：该函数的功能是根据传入的参数创建所有函数模型。\n\n该函数接受以下参数：\n- extra_arguments（可选）：额外参数的字典形式的JSON。\n- functions（可选）：函数列表。\n- function_call（可选）：函数调用的字典形式的JSON。\n\n该函数的作用是根据传入的参数创建所有函数模型，并将其存储在self.functionCallModels中。\n\n如果functions为空或长度为0，则会调用add_function_model函数创建一个函数模型，并将其添加到self.functionCallModels中。\n\n如果function_call不为空且包含\"name\"键，且该键的值与函数列表中的某个函数的\"name\"键的值相等，则会调用add_function_model函数创建一个函数模型，并将其添加到self.functionCallModels中。\n\n如果以上条件都不满足，则会遍历函数列表，对每个函数调用add_function_model函数创建一个函数模型，并将其添加到self.functionCallModels中。\n\n**注意**：在使用该函数时需要注意以下几点：\n- 该函数需要在FunctionParser类的实例上调用。\n- 需要提供额外参数、函数列表和函数调用的信息作为参数。\n\n**输出示例**：以下是该函数可能的返回值的示例：\n```\n[\n    {\n        \"name\": \"function1\",\n        \"arguments\": {\n            \"arg1\": \"value1\",\n            \"arg2\": \"value2\"\n        }\n    },\n    {\n        \"name\": \"function2\",\n        \"arguments\": {\n            \"arg3\": \"value3\",\n            \"arg4\": \"value4\"\n        }\n    }\n]\n```",
            "code_start_line": 270,
            "code_end_line": 286,
            "parent": "FunctionParser",
            "have_return": true,
            "code_content": "        def create_all_functions_model(self,extra_arguments:Dict[str,Any]=None,functions:list=None,function_call:Dict[str,Any]=None):\n                \"\"\"\n                @param: functions: a list of functions\n                @param: extra_argument: a json of extra_arguments\n                @param: function_call: a json of function call\n                \"\"\" \n                self.functionCallModels = []\n                if  functions is None or len(functions)==0:\n                        self.functionCallModels.append(self.add_function_model(extra_arguments))\n                        return\n                for function in functions:\n                        if function_call is not None and \"name\" in function_call.keys():\n                                if  function_call[\"name\"] == function[\"name\"]:\n                                        self.functionCallModels.append(self.add_function_model(extra_arguments,function))\n                                        return\n                        else:\n                                self.functionCallModels.append(self.add_function_model(extra_arguments,function))\n",
            "name_column": 12
        },
        "models_to_regex": {
            "type": "FunctionDef",
            "name": "models_to_regex",
            "md_content": "**models_to_regex函数**：此函数的功能是将模型转换为正则表达式。\n\n该函数接受一个FunctionParser对象的实例作为参数，并遍历其中的functionCallModels列表。对于列表中的每个function对象，函数首先检查该对象是否具有model_json_schema属性，如果有，则调用该属性的方法获取模型的JSON模式。如果没有model_json_schema属性，则调用schema方法获取模型的模式。\n\n接下来，函数对获取到的JSON模式进行后处理，将其转换为字符串形式，并将其添加到regex_strs列表中。最后，函数返回regex_strs列表，其中包含了所有模型转换为正则表达式后的结果。\n\n**注意**：在调用此函数之前，需要确保FunctionParser对象的functionCallModels属性已经被正确设置。\n\n**输出示例**：假设functionCallModels列表中有两个function对象，分别对应两个模型的JSON模式。经过模型转换为正则表达式的处理后，regex_strs列表的内容如下所示：\n```\n['{\"type\": \"object\", \"properties\": {\"name\": {\"type\": \"string\"}, \"age\": {\"type\": \"number\"}}}', '{\"type\": \"object\", \"properties\": {\"title\": {\"type\": \"string\"}, \"content\": {\"type\": \"string\"}}}']\n```",
            "code_start_line": 289,
            "code_end_line": 300,
            "parent": "FunctionParser",
            "have_return": true,
            "code_content": "        def models_to_regex(self):\n                self.regex_strs = []\n                for function in self.functionCallModels:\n                    if hasattr(function, \"model_json_schema\"):\n                        json_schema = function.model_json_schema()\n                    else: \n                        json_schema = function.schema()\n\n                    json_schema = self.post_process(json_schema)\n                    schema = json.dumps(json_schema)\n                    self.regex_strs.append(build_regex_from_object(schema))\n                return self.regex_strs\n",
            "name_column": 12
        },
        "context_ids_next_ids": {
            "type": "FunctionDef",
            "name": "context_ids_next_ids",
            "md_content": "**context_ids_next_ids函数**：这个函数的功能是根据给定的上下文id列表，返回下一个token的有效id列表。\n\n这个函数的具体实现如下：\n- 首先，将生成器的pstates清空，以便每次调用函数时都是一个新的状态（除非按顺序输入所有上下文）。\n- 然后，导入traceback模块，用于处理异常情况。\n- 接下来，创建一个长度为词汇表大小的张量logits，其中每个元素的值都为1，并将其移动到模型所在的设备上。\n- 然后，尝试使用生成器的create_proposal方法生成掩码后的logits。该方法接受一个上下文id列表的张量作为输入，并返回一个掩码后的logits张量。\n- 接着，找到非负无穷值的索引，即找到非负无穷值的位置。将这些索引提取出来，并转换为Python列表。\n- 如果在生成掩码后的logits时出现异常，打印\"no available path\"，并将非负无穷值的索引列表设置为空列表。\n- 最后，返回非负无穷值的索引列表作为函数的输出。\n\n**注意**：关于代码使用的一些注意事项：\n- 在调用函数之前，需要确保生成器的pstates为空，以便每次调用函数时都是一个新的状态。\n- 函数的输入参数context_ids是一个包含上下文id列表的列表。\n- 函数的输出是一个包含下一个token的有效id列表的列表。\n\n**输出示例**：模拟代码返回值的可能外观。\n```python\n[1, 3, 5, 7]\n```",
            "code_start_line": 303,
            "code_end_line": 322,
            "parent": "FunctionParser",
            "have_return": true,
            "code_content": "        def context_ids_next_ids(self,context_ids:List[int]):\n                \"\"\"\n                @param: context_ids: the ids of generated tokens (list[list[int]])\n                @return: valid_ids: the valid ids of next token (list[list[int]])\n                \"\"\"\n                # you should empty the pstates every times except you input all context in order)\n                self.generator.pstates = []\n                import traceback\n                logits = torch.ones(len(self.model.tokenizer.vocabulary)).to(self.model.device)\n                # masked_logits \n                try:\n                        masked_logits = self.generator.create_proposal(torch.tensor([context_ids]).to(self.model.device), logits)\n                        # valid indexes\n                        non_inf_indices = torch.nonzero(masked_logits != -math.inf).squeeze(dim=1)\n                        non_inf_indices = non_inf_indices[:,1]\n                        non_inf_indices = non_inf_indices.tolist()\n                except Exception as e:\n                        print(\"no available path\")\n                        non_inf_indices = []\n                return non_inf_indices\n",
            "name_column": 12
        },
        "post_process": {
            "type": "FunctionDef",
            "name": "post_process",
            "md_content": "**post_process函数**：该函数的功能是对给定的schema进行后处理。\n\n在函数内部，首先将传入的schema赋值给com_schema变量。然后，通过判断com_schema中是否存在\"definitions\"字段，如果存在，则遍历该字段下的所有属性。对于每个属性，如果其\"type\"字段不存在，则将其设置为\"string\"类型。\n\n最后，返回经过后处理的com_schema。\n\n**注意**：在使用该代码时需要注意以下几点：\n- 该函数接受一个schema作为参数，并对其进行后处理。\n- 后处理的目的是确保schema中的每个属性都有\"type\"字段，如果缺少则设置为\"string\"类型。\n\n**输出示例**：假设传入的schema为：\n```json\n{\n  \"definitions\": {\n    \"prop1\": {},\n    \"prop2\": {}\n  }\n}\n```\n经过后处理后的schema为：\n```json\n{\n  \"definitions\": {\n    \"prop1\": {\n      \"type\": \"string\"\n    },\n    \"prop2\": {\n      \"type\": \"string\"\n    }\n  }\n}\n```",
            "code_start_line": 325,
            "code_end_line": 332,
            "parent": "FunctionParser",
            "have_return": true,
            "code_content": "        def post_process(self,schema):   \n                com_schema = schema\n                if \"definitions\" in com_schema.keys():\n                        for prop in com_schema[\"definitions\"].keys():\n                                if \"type\" not in com_schema[\"definitions\"][prop].keys():\n                                        com_schema[\"definitions\"][prop][\"type\"]=\"string\"\n                \n                return com_schema\n",
            "name_column": 12
        },
        "create_generator": {
            "type": "FunctionDef",
            "name": "create_generator",
            "md_content": "**create_generator函数**：这个函数的作用是创建一个生成器用于引导生成。\n\n该函数接受以下参数：\n- model: transformer模型\n- function_info: 包含函数信息的字典，包括函数的参数、函数列表和函数调用名称\n- generate_params: 推理约束参数的字典，默认为空字典\n\n该函数的返回值是一个生成器。\n\n在函数内部，首先从function_info中获取额外的参数、函数列表和函数调用名称。然后调用create_all_functions_model函数，将额外参数、函数列表和函数调用名称传递给它。接下来，将模型转换为正则表达式列表，并将其赋值给regex_list。然后将传入的模型赋值给self.model。接着，将生成参数中的温度等参数添加到模型中。最后，调用generate.multi_regex函数，传入模型、正则表达式列表和最大token数，创建一个生成器，并将其赋值给self.generator。最后，返回生成器。\n\n**注意**：在使用该函数时需要注意以下几点：\n- 参数model必须是一个transformer模型\n- 参数function_info必须是一个包含函数信息的字典，包括函数的参数、函数列表和函数调用名称\n- 参数generate_params是一个字典，用于设置推理约束参数，可以为空字典\n\n**输出示例**：模拟代码返回值的可能外观。",
            "code_start_line": 334,
            "code_end_line": 352,
            "parent": "FunctionParser",
            "have_return": true,
            "code_content": "        def create_generator(self,model:models.XTransformers,function_info:Dict[str,Any],generate_params:Dict = {}):\n                \"\"\"\n                @param: model: the transformer model\n                @param: functions: a list of functions\n                @param: extra_argument: a json of extra_arguments\n                @param: function_call: a json of function call name\n                @param: generate_params: a dict of inference constraint arguments\n                @return: create a generator for guided generate\n                \"\"\"    \n                extra_arguments = function_info.get(\"arguments\",None)\n                functions = function_info.get(\"functions\",None)\n                function_call = function_info.get(\"function_call\",None)\n                self.create_all_functions_model(extra_arguments,functions,function_call) \n                regex_list = self.models_to_regex()\n                self.model = model\n                # temperature and so on\n                self.model.add_logits_processor(generate_params)\n                self.generator = generate.multi_regex(self.model, regex_list,generate_params.get(\"max_tokens\"))\n                return self.generator\n",
            "name_column": 12
        },
        "check": {
            "type": "FunctionDef",
            "name": "check",
            "md_content": "**check函数**：这个函数的功能是检查传入的call_info字符串是否符合指定的格式。\n\n该函数接受一个名为call_info的字符串参数，该参数表示一个函数调用的信息。函数首先尝试将call_info字符串解析为JSON格式，如果解析失败则返回False。接着，函数检查解析后的JSON对象中是否包含\"name\"和\"arguments\"两个键，如果不包含则返回False。然后，函数调用self.functionCallModel.model_validate_json方法，该方法用于验证call_info是否符合指定的格式，如果验证失败则返回False。最后，如果所有的检查都通过，则返回True。\n\n**注意**：在使用该函数时需要注意传入的call_info参数必须是一个符合指定格式的JSON字符串。\n\n**输出示例**：False",
            "code_start_line": 354,
            "code_end_line": 370,
            "parent": "FunctionParser",
            "have_return": true,
            "code_content": "        def check(self,call_info:str):\n                \"\"\"\n                @param: function: the dynamic BaseModel generated for specified function\n                \"\"\"\n                try:\n                        call_info_json = json.loads(call_info)\n                except Exception:\n                        return False\n                if \"name\" not in call_info_json.keys():\n                        return False\n                if \"arguments\" not in call_info_json.keys():\n                        return False\n                try:\n                        self.functionCallModel.model_validate_json(call_info)\n                except Exception:\n                        return False\n                return True\n",
            "name_column": 12
        },
        "TotalModel": {
            "type": "ClassDef",
            "name": "TotalModel",
            "md_content": "**TotalModel类的功能**：该类的功能是XXX。\n\n该类是XAgentGen/xgen/parser/function_parser.py文件中的create_total_model函数中创建的一个子类。该函数的代码如下：\n\n```python\ndef create_total_model(cls):\n    class TotalModel(BaseModel):\n        pass\n    return TotalModel\n```\n\n**注意**：目前该类没有定义任何属性或方法，只是一个空的类。它继承自BaseModel类。\n\n在项目中，该类被调用的情况如下：\n- XAgentGen/xgen/parser/function_parser.py文件中的create_total_model函数中创建了TotalModel类。\n\n请注意：\n- 该类目前没有实际的功能，只是一个空的类定义。\n- 可以根据需要在该类中添加属性和方法来实现具体的功能。",
            "code_start_line": 44,
            "code_end_line": 45,
            "parent": "create_total_model",
            "have_return": false,
            "code_content": "                class TotalModel(BaseModel):\n                        pass\n",
            "name_column": 22
        },
        "FunctionCallModel": {
            "type": "ClassDef",
            "name": "FunctionCallModel",
            "md_content": "**FunctionCallModel函数**：这个类的功能是定义一个函数调用模型，其中包含一个名为name的字符串属性。\n\n该类的作用是定义一个函数调用模型，用于表示函数的调用信息。在该类中，只有一个属性name，用于存储函数的名称。\n\n**注意**：在使用该类时，需要注意以下几点：\n- name属性是一个字符串类型，用于存储函数的名称。",
            "code_start_line": 50,
            "code_end_line": 51,
            "parent": "create_function_call_model",
            "have_return": false,
            "code_content": "                class FunctionCallModel(BaseModel):\n                        name:str\n",
            "name_column": 22
        }
    },
    "XAgentGen/xgen/parser/__init__.py": {},
    "XAgentGen/xgen/text/generate/__init__.py": {},
    "XAgentGen/xgen/text/generate/regex.py": {
        "to_hash": {
            "type": "FunctionDef",
            "name": "to_hash",
            "md_content": "**to_hash函数**：该函数的功能是将给定的vocabulary、regex_str和eos_token拼接成一个字符串，并返回该字符串的哈希值。\n\n该函数接受三个参数：\n- vocabulary：表示词汇表，是一个列表，包含了所有的词汇。\n- regex_str：表示正则表达式的字符串。\n- eos_token：表示结束标记。\n\n函数内部首先使用f-string将vocabulary、regex_str和eos_token拼接成一个字符串。然后使用hash函数计算该字符串的哈希值，并将结果返回。\n\n需要注意的是，该函数的返回值是一个整数。\n\n**注意**：在使用该函数时，需要确保传入的参数类型正确，并且vocabulary和regex_str的取值符合预期。\n\n**输出示例**：假设传入的参数分别为[\"apple\", \"banana\", \"orange\"], \"[a-z]+\", \"<eos>\"，则函数的返回值可能为-123456789。",
            "code_start_line": 15,
            "code_end_line": 17,
            "parent": null,
            "have_return": true,
            "code_content": "def to_hash(vocabulary, regex_str, eos_token):\n    string = f\"vocabulary:{''.join(vocabulary)}, regex: {regex_str}, eos_token: {eos_token}\"\n    return hash(string)\n",
            "name_column": 4
        },
        "XRegex": {
            "type": "ClassDef",
            "name": "XRegex",
            "md_content": "**XRegex函数**：这个类的功能是创建一个正则表达式的有限状态机。\n\n这个类继承自`Regex`类，它有以下参数：\n- `model`：一个模型对象，用于生成文本。\n- `regex_string`：一个字符串，表示正则表达式的模式。\n- `max_tokens`：一个可选的整数，表示生成的文本的最大长度。\n- `sampler`：一个可选的`sampler`对象，用于控制生成文本的采样方式。\n- `stop`：一个字符串或字符串列表，表示生成文本时的停止条件。\n- `allow_empty_tokens`：一个布尔值，表示是否允许生成空的token。\n- `initial_state`：一个可选的整数，表示有限状态机的初始状态。\n- `final_states`：一个可选的整数集合，表示有限状态机的终止状态。\n- `states_to_token_maps`：一个可选的字典，表示状态到token的映射关系。\n- `empty_token_ids`：一个可选的整数集合，表示空token的id。\n\n在初始化函数中，首先通过`model.tokenizer.vocabulary`获取模型的词汇表，并将词汇表按照词汇表中的索引进行排序。然后使用`to_hash`函数生成一个哈希键，该键由排序后的词汇表、正则表达式模式和模型的结束标记组成。\n\n接下来，通过检查哈希键是否存在于`pstate_to_vocab_path_cache`缓存中，如果存在，则从缓存中获取有限状态机、状态到token的映射关系和空token的id。如果不存在，则使用`interegular.parse_pattern`函数解析正则表达式模式，并将其转换为有限状态机。然后使用`make_deterministic_fsm`函数将有限状态机转换为确定性有限状态机，并使用`reduce`方法对其进行优化。接着，使用`create_fsm_index_tokenizer`函数生成状态到token的映射关系和空token的id。最后，将有限状态机的初始状态、终止状态、状态到token的映射关系和空token的id保存到`pstate_to_vocab_path_cache`缓存中。\n\n最后，调用父类`Regex`的初始化函数，传入相应的参数，完成对象的初始化。\n\n**注意**：在使用`XRegex`类时，需要传入一个模型对象和一个正则表达式模式。可以通过调用`multi_regex`函数来创建一个包含多个正则表达式模式的有限状态机。",
            "code_start_line": 19,
            "code_end_line": 61,
            "parent": null,
            "have_return": false,
            "code_content": "class XRegex(Regex):\n    def __init__(\n        self,\n        model,\n        regex_string: str,\n        max_tokens: Optional[int] = None,\n        *,\n        sampler: Optional[\"Sampler\"] = None,\n        stop: Union[str, List[str]] = [],\n        allow_empty_tokens: bool = True,\n        initial_state: Optional[int] = None,\n        final_states: Optional[Set[int]] = None,\n        states_to_token_maps: Optional[Dict[int, Dict[int, int]]] = None,\n        empty_token_ids: Optional[Set[int]] = None,\n    ):\n        \n        vocab = model.tokenizer.vocabulary\n        sorted_vocabulary = [\n            model.tokenizer.convert_token_to_string(k)\n            for k, v in sorted(vocab.items(), key=lambda kv: kv[1])\n        ]\n        hash_key = to_hash(list(sorted_vocabulary), regex_string, model.tokenizer.eos_token)\n\n        if hash_key in pstate_to_vocab_path_cache:\n            regex_fsm,states_to_token_maps,empty_token_ids = pstate_to_vocab_path_cache[hash_key]\n            initial_state = regex_fsm.initial\n            final_states = regex_fsm.finals\n        else:\n            regex_pattern = interegular.parse_pattern(regex_string)\n            regex_fsm, _ = make_deterministic_fsm(regex_pattern.to_fsm().reduce())\n            (\n                states_to_token_maps,\n                empty_token_ids,\n            ) = create_fsm_index_tokenizer(regex_fsm, model.tokenizer)\n            initial_state = regex_fsm.initial\n            final_states = regex_fsm.finals\n            \n            pstate_to_vocab_path_cache[hash_key] = (regex_fsm,states_to_token_maps,empty_token_ids)\n\n        super().__init__(\n            model, regex_string, max_tokens, sampler=sampler,stop=stop,\n            allow_empty_tokens=allow_empty_tokens,initial_state=initial_state,final_states=final_states,\n            states_to_token_maps=states_to_token_maps,empty_token_ids=empty_token_ids)\n",
            "name_column": 6
        },
        "multi_regex": {
            "type": "FunctionDef",
            "name": "multi_regex",
            "md_content": "**multi_regex函数**：该函数的功能是根据给定的选择列表，生成一个正则表达式匹配模式。\n\n该函数接受以下参数：\n- model: 一个模型对象，用于生成正则表达式匹配模式。\n- choices: 一个字符串列表，包含了多个选择项，用于构建正则表达式的匹配模式。\n- max_tokens: 可选参数，用于限制生成的正则表达式的最大长度。\n- sampler: 可选参数，一个采样器对象，用于生成正则表达式的匹配模式。\n- allow_empty_tokens: 可选参数，一个布尔值，指示是否允许生成的正则表达式中包含空的匹配模式。\n\n该函数首先将选择项列表转换为一个正则表达式字符串，然后使用该字符串和其他参数创建一个XRegex对象，并将其作为结果返回。\n\n**注意**：在使用该函数时需要注意以下几点：\n- 参数model必须是一个有效的模型对象。\n- 参数choices不能为空列表。\n- 参数max_tokens必须是一个正整数。\n- 参数sampler必须是一个有效的采样器对象。\n\n**输出示例**：假设choices列表为[\"abc\", \"def\", \"ghi\"]，max_tokens为10，返回的XRegex对象将具有以下属性：\n- model: 传入的模型对象。\n- regex_str: 生成的正则表达式字符串为\"(abc|def|ghi)\"。\n- max_tokens: 传入的max_tokens值。\n- sampler: 传入的采样器对象。\n- allow_empty_tokens: 传入的allow_empty_tokens值。",
            "code_start_line": 63,
            "code_end_line": 78,
            "parent": null,
            "have_return": true,
            "code_content": "def multi_regex(\n    model,\n    choices: List[str],\n    max_tokens: Optional[int] = None,\n    *,\n    sampler: Optional[\"Sampler\"] = None,\n    allow_empty_tokens: bool = True,\n):\n    regex_str = r\"(\" + r\"|\".join(choices) + r\")\"\n    return XRegex(\n        model,\n        regex_str,\n        max_tokens,\n        sampler=sampler,\n        allow_empty_tokens=allow_empty_tokens,\n    )\n",
            "name_column": 4
        },
        "__init__": {
            "type": "FunctionDef",
            "name": "__init__",
            "md_content": "**__init__函数**：这个函数的功能是初始化一个对象。\n\n在这个函数中，我们首先获取了模型的词汇表，并对其进行排序。然后，我们使用排序后的词汇表、正则表达式字符串和模型的结束标记来生成一个哈希键。如果这个哈希键在缓存中已经存在，我们就从缓存中获取对应的正则有限状态机、状态到标记的映射和空标记的ID。否则，我们使用正则表达式字符串解析出正则模式，并将其转换为确定性有限状态机。然后，我们创建状态到标记的映射和空标记的ID，并将初始状态和终止状态设置为正则有限状态机的初始状态和终止状态。最后，我们将正则有限状态机、状态到标记的映射和空标记的ID存储到缓存中。\n\n在初始化对象时，我们调用了父类的__init__函数，并传入了模型、正则表达式字符串、最大标记数、采样器、停止标记、是否允许空标记、初始状态、终止状态、状态到标记的映射和空标记的ID。\n\n**注意**：使用这段代码时需要注意以下几点：\n- 需要提供一个模型对象和一个正则表达式字符串作为参数。\n- 可以选择性地提供最大标记数、采样器、停止标记、是否允许空标记、初始状态、终止状态、状态到标记的映射和空标记的ID作为参数。\n- 如果缓存中已经存在相同的哈希键，将直接使用缓存中的正则有限状态机、状态到标记的映射和空标记的ID，而不会重新生成。\n- 如果缓存中不存在相同的哈希键，将根据正则表达式字符串生成正则有限状态机，并将其存储到缓存中供以后使用。",
            "code_start_line": 20,
            "code_end_line": 61,
            "parent": "XRegex",
            "have_return": false,
            "code_content": "    def __init__(\n        self,\n        model,\n        regex_string: str,\n        max_tokens: Optional[int] = None,\n        *,\n        sampler: Optional[\"Sampler\"] = None,\n        stop: Union[str, List[str]] = [],\n        allow_empty_tokens: bool = True,\n        initial_state: Optional[int] = None,\n        final_states: Optional[Set[int]] = None,\n        states_to_token_maps: Optional[Dict[int, Dict[int, int]]] = None,\n        empty_token_ids: Optional[Set[int]] = None,\n    ):\n        \n        vocab = model.tokenizer.vocabulary\n        sorted_vocabulary = [\n            model.tokenizer.convert_token_to_string(k)\n            for k, v in sorted(vocab.items(), key=lambda kv: kv[1])\n        ]\n        hash_key = to_hash(list(sorted_vocabulary), regex_string, model.tokenizer.eos_token)\n\n        if hash_key in pstate_to_vocab_path_cache:\n            regex_fsm,states_to_token_maps,empty_token_ids = pstate_to_vocab_path_cache[hash_key]\n            initial_state = regex_fsm.initial\n            final_states = regex_fsm.finals\n        else:\n            regex_pattern = interegular.parse_pattern(regex_string)\n            regex_fsm, _ = make_deterministic_fsm(regex_pattern.to_fsm().reduce())\n            (\n                states_to_token_maps,\n                empty_token_ids,\n            ) = create_fsm_index_tokenizer(regex_fsm, model.tokenizer)\n            initial_state = regex_fsm.initial\n            final_states = regex_fsm.finals\n            \n            pstate_to_vocab_path_cache[hash_key] = (regex_fsm,states_to_token_maps,empty_token_ids)\n\n        super().__init__(\n            model, regex_string, max_tokens, sampler=sampler,stop=stop,\n            allow_empty_tokens=allow_empty_tokens,initial_state=initial_state,final_states=final_states,\n            states_to_token_maps=states_to_token_maps,empty_token_ids=empty_token_ids)\n",
            "name_column": 8
        }
    }
}